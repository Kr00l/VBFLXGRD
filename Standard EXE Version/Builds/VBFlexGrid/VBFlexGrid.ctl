VERSION 5.00
Begin VB.UserControl VBFlexGrid 
   Alignable       =   -1  'True
   ClientHeight    =   1800
   ClientLeft      =   0
   ClientTop       =   0
   ClientWidth     =   2400
   DataBindingBehavior=   2  'vbComplexBound
   DrawStyle       =   5  'Transparent
   HasDC           =   0   'False
   PropertyPages   =   "VBFlexGrid.ctx":0000
   ScaleHeight     =   120
   ScaleMode       =   3  'Pixel
   ScaleWidth      =   160
   ToolboxBitmap   =   "VBFlexGrid.ctx":0072
   Begin VB.Timer TimerIncrementalSearch 
      Enabled         =   0   'False
      Left            =   0
      Top             =   0
   End
End
Attribute VB_Name = "VBFlexGrid"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Option Explicit
#If (VBA7 = 0) Then
Private Enum LongPtr
[_]
End Enum
#End If
#If Win64 Then
Private Const NULL_PTR As LongPtr = 0
Private Const PTR_SIZE As Long = 8
#Else
Private Const NULL_PTR As Long = 0
Private Const PTR_SIZE As Long = 4
#End If

#Const ImplementThemedControls = True
#Const ImplementDataSource = True ' True = Required: msdatsrc.tlb
#Const ImplementFlexDataSource = True ' True = Required: IVBFlexDataSource.cls
#Const ImplementPreTranslateMsg = (VBFLXGRD_OCX <> 0)

#If False Then
Private FlexOLEDropModeNone, FlexOLEDropModeManual
Private FlexMousePointerDefault, FlexMousePointerArrow, FlexMousePointerCrosshair, FlexMousePointerIbeam, FlexMousePointerHand, FlexMousePointerSizePointer, FlexMousePointerSizeNESW, FlexMousePointerSizeNS, FlexMousePointerSizeNWSE, FlexMousePointerSizeWE, FlexMousePointerUpArrow, FlexMousePointerHourglass, FlexMousePointerNoDrop, FlexMousePointerArrowHourglass, FlexMousePointerArrowQuestion, FlexMousePointerSizeAll, FlexMousePointerArrowCD, FlexMousePointerPin, FlexMousePointerPerson, FlexMousePointerPen, FlexMousePointerScrollN, FlexMousePointerScrollS, FlexMousePointerScrollE, FlexMousePointerScrollW, FlexMousePointerScrollNS, FlexMousePointerScrollWE, FlexMousePointerScrollNW, FlexMousePointerScrollNE, FlexMousePointerScrollSW, FlexMousePointerScrollSE, FlexMousePointerScrollAll, FlexMousePointerCustom
Private FlexRightToLeftModeNoControl, FlexRightToLeftModeVBAME, FlexRightToLeftModeSystemLocale, FlexRightToLeftModeUserLocale, FlexRightToLeftModeOSLanguage
Private FlexBorderStyleNone, FlexBorderStyleSingle, FlexBorderStyleThin, FlexBorderStyleSunken, FlexBorderStyleRaised
Private FlexLeftRightAlignmentLeft, FlexLeftRightAlignmentRight
Private FlexScrollOrientationHorizontal, FlexScrollOrientationVertical, FlexScrollOrientationBoth
Private FlexAllowUserFreezingNone, FlexAllowUserFreezingColumns, FlexAllowUserFreezingRows, FlexAllowUserFreezingBoth
Private FlexAllowUserResizingNone, FlexAllowUserResizingColumns, FlexAllowUserResizingRows, FlexAllowUserResizingBoth
Private FlexSelectionModeFree, FlexSelectionModeByRow, FlexSelectionModeByColumn, FlexSelectionModeFreeByRow, FlexSelectionModeFreeByColumn
Private FlexFillStyleSingle, FlexFillStyleRepeat
Private FlexHighLightNever, FlexHighLightAlways, FlexHighLightWithFocus, FlexHighLightAlwaysFocusRect
Private FlexFocusRectNone, FlexFocusRectLight, FlexFocusRectHeavy, FlexFocusRectFlat
Private FlexGridLineNone, FlexGridLineFlat, FlexGridLineInset, FlexGridLineRaised, FlexGridLineDashes, FlexGridLineDots, FlexGridLineFlatHorz, FlexGridLineInsetHorz, FlexGridLineRaisedHorz, FlexGridLineDashesHorz, FlexGridLineDotsHorz, FlexGridLineFlatVert, FlexGridLineInsetVert, FlexGridLineRaisedVert, FlexGridLineDashesVert, FlexGridLineDotsVert
Private FlexTextStyleFlat, FlexTextStyleRaised, FlexTextStyleInset, FlexTextStyleRaisedLight, FlexTextStyleInsetLight
Private FlexHitResultNoWhere, FlexHitResultCell, FlexHitResultDividerRowTop, FlexHitResultDividerRowBottom, FlexHitResultDividerColumnLeft, FlexHitResultDividerColumnRight, FlexHitResultDividerFrozenRowTop, FlexHitResultDividerFrozenRowBottom, FlexHitResultDividerFrozenColumnLeft, FlexHitResultDividerFrozenColumnRight, FlexHitResultComboCue, FlexHitResultComboCueDisabled, FlexHitResultCheckBox, FlexHitResultCheckBoxDisabled
Private FlexDropTargetModeByRow, FlexDropTargetModeByColumn
Private FlexAlignmentLeftTop, FlexAlignmentLeftCenter, FlexAlignmentLeftBottom, FlexAlignmentCenterTop, FlexAlignmentCenterCenter, FlexAlignmentCenterBottom, FlexAlignmentRightTop, FlexAlignmentRightCenter, FlexAlignmentRightBottom, FlexAlignmentGeneral, FlexAlignmentGeneralTop, FlexAlignmentGeneralCenter, FlexAlignmentGeneralBottom
Private FlexPictureAlignmentLeftTop, FlexPictureAlignmentLeftCenter, FlexPictureAlignmentLeftBottom, FlexPictureAlignmentCenterTop, FlexPictureAlignmentCenterCenter, FlexPictureAlignmentCenterBottom, FlexPictureAlignmentRightTop, FlexPictureAlignmentRightCenter, FlexPictureAlignmentRightBottom, FlexPictureAlignmentStretch, FlexPictureAlignmentTile, FlexPictureAlignmentLeftTopNoOverlap, FlexPictureAlignmentLeftCenterNoOverlap, FlexPictureAlignmentLeftBottomNoOverlap, FlexPictureAlignmentRightTopNoOverlap, FlexPictureAlignmentRightCenterNoOverlap, FlexPictureAlignmentRightBottomNoOverlap
Private FlexRowSizingModeIndividual, FlexRowSizingModeAll, FlexRowSizingModeUniform
Private FlexMergeCellsNever, FlexMergeCellsFree, FlexMergeCellsRestrictRows, FlexMergeCellsRestrictColumns, FlexMergeCellsRestrictAll, FlexMergeCellsFixedOnly
Private FlexSortNone, FlexSortGenericAscending, FlexSortGenericDescending, FlexSortNumericAscending, FlexSortNumericDescending, FlexSortStringNoCaseAscending, FlexSortStringNoCaseDescending, FlexSortStringAscending, FlexSortStringDescending, FlexSortCustom, FlexSortUseColSort, FlexSortCurrencyAscending, FlexSortCurrencyDescending, FlexSortDateAscending, FlexSortDateDescending, FlexSortCustomText
Private FlexSortModeNormal, FlexSortModeTextDisplay
Private FlexVisibilityPartialOK, FlexVisibilityCompleteOnly
Private FlexPictureTypeColor, FlexPictureTypeMonochrome, FlexPictureTypeEnhMetafile
Private FlexEllipsisFormatNone, FlexEllipsisFormatEnd, FlexEllipsisFormatPath, FlexEllipsisFormatWord
Private FlexWordWrapNone, FlexWordBreak, FlexSingleLine, FlexEndEllipsis, FlexPathEllipsis, FlexWordEllipsis, FlexWordBreakEndEllipsis, FlexWordBreakPathEllipsis, FlexWordBreakWordEllipsis, FlexSingleLineEndEllipsis, FlexSingleLinePathEllipsis, FlexSingleLineWordEllipsis
Private FlexMimicTextBoxOn, FlexMimicTextBoxOff
Private FlexClearEverywhere, FlexClearFixed, FlexClearScrollable, FlexClearMovable, FlexClearFrozen, FlexClearSelection, FlexClearClip
Private FlexClearEverything, FlexClearText, FlexClearFormatting, FlexClearTag
Private FlexTabControls, FlexTabCells, FlexTabNext
Private FlexDirectionAfterReturnNone, FlexDirectionAfterReturnUp, FlexDirectionAfterReturnDown, FlexDirectionAfterReturnLeft, FlexDirectionAfterReturnRight, FlexDirectionAfterReturnEdit
Private FlexWrapNone, FlexWrapRow, FlexWrapGrid
Private FlexCellText, FlexCellClip, FlexCellTextStyle, FlexCellAlignment, FlexCellPicture, FlexCellPictureAlignment, FlexCellBackColor, FlexCellForeColor, FlexCellToolTipText, FlexCellComboCue, FlexCellChecked, FlexCellFloodPercent, FlexCellFloodColor, FlexCellFontName, FlexCellFontSize, FlexCellFontBold, FlexCellFontItalic, FlexCellFontStrikeThrough, FlexCellFontUnderline, FlexCellFontCharset, FlexCellLeft, FlexCellTop, FlexCellWidth, FlexCellHeight, FlexCellSort, FlexCellTextDisplay, FlexCellTextHidden, FlexCellHasCustomFormatting, FlexCellHasTag, FlexCellTag
Private FlexAutoSizeModeColWidth, FlexAutoSizeModeRowHeight
Private FlexAutoSizeScopeAll, FlexAutoSizeScopeFixed, FlexAutoSizeScopeScrollable, FlexAutoSizeScopeMovable, FlexAutoSizeScopeFrozen
Private FlexClipModeNormal, FlexClipModeExcludeHidden, FlexClipModeLookupConv, FlexClipModeLookupConvExcludeHidden
Private FlexClipCopyModeNormal, FlexClipCopyModeIncludeFixedRows, FlexClipCopyModeIncludeFixedColumns, FlexClipCopyModeIncludeFixedAll, FlexClipCopyModeExtended, FlexClipCopyModeExtendedFixedRows, FlexClipCopyModeExtendedFixedColumns, FlexClipCopyModeExtendedFixedAll
Private FlexClipPasteModeNormal, FlexClipPasteModeAutoSelection, FlexClipPasteModeExtended, FlexClipPasteModeExtendedAutoSelection
Private FlexClipboardActionCopy, FlexClipboardActionCut, FlexClipboardActionPaste, FlexClipboardActionDelete
Private FlexFindMatchExact, FlexFindMatchPartial, FlexFindMatchStartsWith, FlexFindMatchEndsWith
Private FlexFindDirectionDown, FlexFindDirectionUp, FlexFindDirectionRight, FlexFindDirectionLeft
Private FlexLookupConvValue, FlexLookupConvKey
Private FlexIMEModeNoControl, FlexIMEModeOn, FlexIMEModeOff, FlexIMEModeDisable, FlexIMEModeHiragana, FlexIMEModeKatakana, FlexIMEModeKatakanaHalf, FlexIMEModeAlphaFull, FlexIMEModeAlpha, FlexIMEModeHangulFull, FlexIMEModeHangul
Private FlexEditReasonCode, FlexEditReasonF2, FlexEditReasonSpace, FlexEditReasonKeyPress, FlexEditReasonDblClick, FlexEditReasonBackSpace, FlexEditReasonReturn, FlexEditReasonComboCueClick, FlexEditReasonComboCueDblClick, FlexEditReasonComboCueF4, FlexEditReasonComboCueAltUpDown
Private FlexEditCloseModeCode, FlexEditCloseModeLostFocus, FlexEditCloseModeEscape, FlexEditCloseModeReturn, FlexEditCloseModeTab, FlexEditCloseModeShiftTab, FlexEditCloseModeNavigationKey
Private FlexComboCueHidden, FlexComboCueNone, FlexComboCueDropDown, FlexComboCueButton, FlexComboCueDisabledDropDown, FlexComboCueDisabledButton
Private FlexComboModeNone, FlexComboModeDropDown, FlexComboModeEditable, FlexComboModeButton, FlexComboModeCalendar
Private FlexComboDropDownReasonCode, FlexComboDropDownReasonInitialize, FlexComboDropDownReasonMouse, FlexComboDropDownReasonKeyboard
Private FlexComboButtonValueUnpressed, FlexComboButtonValuePressed, FlexComboButtonValueDisabled
Private FlexComboButtonDrawModeNormal, FlexComboButtonDrawModeOwnerDraw
Private FlexSortArrowNone, FlexSortArrowAscending, FlexSortArrowDescending
Private FlexNoCheckBoxEver, FlexNoCheckBox, FlexUnchecked, FlexChecked, FlexGrayed, FlexTextAsCheckBox, FlexDisabledUnchecked, FlexDisabledChecked, FlexDisabledGrayed, FlexDisabledTextAsCheckBox
Private FlexCellCheckReasonMouse, FlexCellCheckReasonKeyboard
Private FlexCheckBoxAlignmentLeftTop, FlexCheckBoxAlignmentLeftCenter, FlexCheckBoxAlignmentLeftBottom, FlexCheckBoxAlignmentCenterTop, FlexCheckBoxAlignmentCenterCenter, FlexCheckBoxAlignmentCenterBottom, FlexCheckBoxAlignmentRightTop, FlexCheckBoxAlignmentRightCenter, FlexCheckBoxAlignmentRightBottom, FlexCheckBoxAlignmentUsePictureAlignment
Private FlexCheckBoxDrawModeNormal, FlexCheckBoxDrawModeOwnerDraw
Private FlexBestFitModeTextOnly, FlexBestFitModeFull, FlexBestFitModeSortArrowText, FlexBestFitModeOtherText
Private FlexWallPaperAlignmentLeftTop, FlexWallPaperAlignmentLeftCenter, FlexWallPaperAlignmentLeftBottom, FlexWallPaperAlignmentCenterTop, FlexWallPaperAlignmentCenterCenter, FlexWallPaperAlignmentCenterBottom, FlexWallPaperAlignmentRightTop, FlexWallPaperAlignmentRightCenter, FlexWallPaperAlignmentRightBottom, FlexWallPaperAlignmentStretch, FlexWallPaperAlignmentTile
Private FlexFontQualityDefault, FlexFontQualityDraft, FlexFontQualityProof, FlexFontQualityNonAntiAliased, FlexFontQualityAntiAliased, FlexFontQualityClearType, FlexFontQualityClearTypeNatural
Private FlexMetricDividerSpacing, FlexMetricTextPadding, FlexMetricCellSpacing, FlexMetricScrollBarSize, FlexMetricCheckBoxSize
Private FlexDataSourceUnboundFixedColumns, FlexDataSourceNoData, FlexDataSourceNoFieldNames, FlexDataSourceToolTipText, FlexDataSourceChecked
#End If
Public Enum FlexOLEDropModeConstants
FlexOLEDropModeNone = vbOLEDropNone
FlexOLEDropModeManual = vbOLEDropManual
End Enum
Public Enum FlexMousePointerConstants
FlexMousePointerDefault = 0
FlexMousePointerArrow = 1
FlexMousePointerCrosshair = 2
FlexMousePointerIbeam = 3
FlexMousePointerHand = 4
FlexMousePointerSizePointer = 5
FlexMousePointerSizeNESW = 6
FlexMousePointerSizeNS = 7
FlexMousePointerSizeNWSE = 8
FlexMousePointerSizeWE = 9
FlexMousePointerUpArrow = 10
FlexMousePointerHourglass = 11
FlexMousePointerNoDrop = 12
FlexMousePointerArrowHourglass = 13
FlexMousePointerArrowQuestion = 14
FlexMousePointerSizeAll = 15
FlexMousePointerArrowCD = 16
FlexMousePointerPin = 17
FlexMousePointerPerson = 18
FlexMousePointerPen = 19
FlexMousePointerScrollN = 20
FlexMousePointerScrollS = 21
FlexMousePointerScrollE = 22
FlexMousePointerScrollW = 23
FlexMousePointerScrollNS = 24
FlexMousePointerScrollWE = 25
FlexMousePointerScrollNW = 26
FlexMousePointerScrollNE = 27
FlexMousePointerScrollSW = 28
FlexMousePointerScrollSE = 29
FlexMousePointerScrollAll = 30
FlexMousePointerCustom = 99
End Enum
Public Enum FlexRightToLeftModeConstants
FlexRightToLeftModeNoControl = 0
FlexRightToLeftModeVBAME = 1
FlexRightToLeftModeSystemLocale = 2
FlexRightToLeftModeUserLocale = 3
FlexRightToLeftModeOSLanguage = 4
End Enum
Public Enum FlexBorderStyleConstants
FlexBorderStyleNone = 0
FlexBorderStyleSingle = 1
FlexBorderStyleThin = 2
FlexBorderStyleSunken = 3
FlexBorderStyleRaised = 4
End Enum
Public Enum FlexLeftRightAlignmentConstants
FlexLeftRightAlignmentLeft = 0
FlexLeftRightAlignmentRight = 1
End Enum
Public Enum FlexScrollOrientationConstants
FlexScrollOrientationHorizontal = 0
FlexScrollOrientationVertical = 1
FlexScrollOrientationBoth = 2
End Enum
Public Enum FlexAllowUserFreezingConstants
FlexAllowUserFreezingNone = 0
FlexAllowUserFreezingColumns = 1
FlexAllowUserFreezingRows = 2
FlexAllowUserFreezingBoth = 3
End Enum
Public Enum FlexAllowUserResizingConstants
FlexAllowUserResizingNone = 0
FlexAllowUserResizingColumns = 1
FlexAllowUserResizingRows = 2
FlexAllowUserResizingBoth = 3
End Enum
Public Enum FlexSelectionModeConstants
FlexSelectionModeFree = 0
FlexSelectionModeByRow = 1
FlexSelectionModeByColumn = 2
FlexSelectionModeFreeByRow = 3
FlexSelectionModeFreeByColumn = 4
End Enum
Public Enum FlexFillStyleConstants
FlexFillStyleSingle = 0
FlexFillStyleRepeat = 1
End Enum
Public Enum FlexHighLightConstants
FlexHighLightNever = 0
FlexHighLightAlways = 1
FlexHighLightWithFocus = 2
FlexHighLightAlwaysFocusRect = 3
End Enum
Public Enum FlexFocusRectConstants
FlexFocusRectNone = 0
FlexFocusRectLight = 1
FlexFocusRectHeavy = 2
FlexFocusRectFlat = 3
End Enum
Public Enum FlexGridLineConstants
FlexGridLineNone = 0
FlexGridLineFlat = 1
FlexGridLineInset = 2
FlexGridLineRaised = 3
FlexGridLineDashes = 4
FlexGridLineDots = 5
FlexGridLineFlatHorz = 6
FlexGridLineInsetHorz = 7
FlexGridLineRaisedHorz = 8
FlexGridLineDashesHorz = 9
FlexGridLineDotsHorz = 10
FlexGridLineFlatVert = 11
FlexGridLineInsetVert = 12
FlexGridLineRaisedVert = 13
FlexGridLineDashesVert = 14
FlexGridLineDotsVert = 15
End Enum
Public Enum FlexTextStyleConstants
FlexTextStyleFlat = 0
FlexTextStyleRaised = 1
FlexTextStyleInset = 2
FlexTextStyleRaisedLight = 3
FlexTextStyleInsetLight = 4
End Enum
Public Enum FlexHitResultConstants
FlexHitResultNoWhere = 0
FlexHitResultCell = 1
FlexHitResultDividerRowTop = 2
FlexHitResultDividerRowBottom = 3
FlexHitResultDividerColumnLeft = 4
FlexHitResultDividerColumnRight = 5
FlexHitResultDividerFrozenRowTop = 6
FlexHitResultDividerFrozenRowBottom = 7
FlexHitResultDividerFrozenColumnLeft = 8
FlexHitResultDividerFrozenColumnRight = 9
FlexHitResultComboCue = 10
FlexHitResultComboCueDisabled = 11
FlexHitResultCheckBox = 12
FlexHitResultCheckBoxDisabled = 13
End Enum
Public Enum FlexDropTargetModeConstants
FlexDropTargetModeByRow = 0
FlexDropTargetModeByColumn = 1
End Enum
Public Enum FlexAlignmentConstants
FlexAlignmentLeftTop = 0
FlexAlignmentLeftCenter = 1
FlexAlignmentLeftBottom = 2
FlexAlignmentCenterTop = 3
FlexAlignmentCenterCenter = 4
FlexAlignmentCenterBottom = 5
FlexAlignmentRightTop = 6
FlexAlignmentRightCenter = 7
FlexAlignmentRightBottom = 8
FlexAlignmentGeneral = 9
FlexAlignmentGeneralTop = 10
FlexAlignmentGeneralCenter = 11
FlexAlignmentGeneralBottom = 12
End Enum
Public Enum FlexPictureAlignmentConstants
FlexPictureAlignmentLeftTop = 0
FlexPictureAlignmentLeftCenter = 1
FlexPictureAlignmentLeftBottom = 2
FlexPictureAlignmentCenterTop = 3
FlexPictureAlignmentCenterCenter = 4
FlexPictureAlignmentCenterBottom = 5
FlexPictureAlignmentRightTop = 6
FlexPictureAlignmentRightCenter = 7
FlexPictureAlignmentRightBottom = 8
FlexPictureAlignmentStretch = 9
FlexPictureAlignmentTile = 10
FlexPictureAlignmentLeftTopNoOverlap = 20
FlexPictureAlignmentLeftCenterNoOverlap = 21
FlexPictureAlignmentLeftBottomNoOverlap = 22
FlexPictureAlignmentRightTopNoOverlap = 26
FlexPictureAlignmentRightCenterNoOverlap = 27
FlexPictureAlignmentRightBottomNoOverlap = 28
End Enum
Public Enum FlexRowSizingModeConstants
FlexRowSizingModeIndividual = 0
FlexRowSizingModeAll = 1
FlexRowSizingModeUniform = 2
End Enum
Public Enum FlexMergeCellsConstants
FlexMergeCellsNever = 0
FlexMergeCellsFree = 1
FlexMergeCellsRestrictRows = 2
FlexMergeCellsRestrictColumns = 3
FlexMergeCellsRestrictAll = 4
FlexMergeCellsFixedOnly = 5
End Enum
Public Enum FlexSortConstants
FlexSortNone = 0
FlexSortGenericAscending = 1
FlexSortGenericDescending = 2
FlexSortNumericAscending = 3
FlexSortNumericDescending = 4
FlexSortStringNoCaseAscending = 5
FlexSortStringNoCaseDescending = 6
FlexSortStringAscending = 7
FlexSortStringDescending = 8
FlexSortCustom = 9
FlexSortUseColSort = 10
FlexSortCurrencyAscending = 11
FlexSortCurrencyDescending = 12
FlexSortDateAscending = 13
FlexSortDateDescending = 14
FlexSortCustomText = 15
End Enum
Public Enum FlexSortModeConstants
FlexSortModeNormal = 0
FlexSortModeTextDisplay = 1
End Enum
Public Enum FlexVisibilityConstants
FlexVisibilityPartialOK = 0
FlexVisibilityCompleteOnly = 1
End Enum
Public Enum FlexPictureTypeConstants
FlexPictureTypeColor = 0
FlexPictureTypeMonochrome = 1
FlexPictureTypeEnhMetafile = 2
End Enum
Public Enum FlexEllipsisFormatConstants
FlexEllipsisFormatNone = 0
FlexEllipsisFormatEnd = 1
FlexEllipsisFormatPath = 2
FlexEllipsisFormatWord = 3
End Enum
Public Enum FlexWordWrapOptions
FlexWordWrapNone = 0
FlexWordBreak = 1
FlexSingleLine = 2
FlexEndEllipsis = 3
FlexPathEllipsis = 4
FlexWordEllipsis = 5
FlexWordBreakEndEllipsis = 6
FlexWordBreakPathEllipsis = 7
FlexWordBreakWordEllipsis = 8
FlexSingleLineEndEllipsis = 9
FlexSingleLinePathEllipsis = 10
FlexSingleLineWordEllipsis = 11
End Enum
Public Enum FlexMimicTextBoxConstants
FlexMimicTextBoxOn = 0
FlexMimicTextBoxOff = 1
End Enum
Public Enum FlexClearWhereConstants
FlexClearEverywhere = 0
FlexClearFixed = 1
FlexClearScrollable = 2
FlexClearMovable = 3
FlexClearFrozen = 4
FlexClearSelection = 5
FlexClearClip = 6
End Enum
Public Enum FlexClearWhatConstants
FlexClearEverything = 0
FlexClearText = 1
FlexClearFormatting = 2
FlexClearTag = 3
End Enum
Public Enum FlexTabBehaviorConstants
FlexTabControls = 0
FlexTabCells = 1
FlexTabNext = 2
End Enum
Public Enum FlexDirectionAfterReturnConstants
FlexDirectionAfterReturnNone = 0
FlexDirectionAfterReturnUp = 1
FlexDirectionAfterReturnDown = 2
FlexDirectionAfterReturnLeft = 3
FlexDirectionAfterReturnRight = 4
FlexDirectionAfterReturnEdit = 5
End Enum
Public Enum FlexWrapCellBehaviorConstants
FlexWrapNone = 0
FlexWrapRow = 1
FlexWrapGrid = 2
End Enum
Public Enum FlexCellSettings
FlexCellText = 0
FlexCellClip = 1
FlexCellTextStyle = 2
FlexCellAlignment = 3
FlexCellPicture = 4
FlexCellPictureAlignment = 5
FlexCellBackColor = 6
FlexCellForeColor = 7
FlexCellToolTipText = 8
FlexCellComboCue = 9
FlexCellChecked = 10
FlexCellFloodPercent = 11
FlexCellFloodColor = 12
FlexCellFontName = 13
FlexCellFontSize = 14
FlexCellFontBold = 15
FlexCellFontItalic = 16
FlexCellFontStrikeThrough = 17
FlexCellFontUnderline = 18
FlexCellFontCharset = 19
FlexCellLeft = 20
FlexCellTop = 21
FlexCellWidth = 22
FlexCellHeight = 23
FlexCellSort = 24
FlexCellTextDisplay = 25
FlexCellTextHidden = 26
FlexCellHasCustomFormatting = 27
FlexCellHasTag = 28
FlexCellTag = 29
End Enum
Public Enum FlexAutoSizeModeConstants
FlexAutoSizeModeColWidth = 0
FlexAutoSizeModeRowHeight = 1
End Enum
Public Enum FlexAutoSizeScopeConstants
FlexAutoSizeScopeAll = 0
FlexAutoSizeScopeFixed = 1
FlexAutoSizeScopeScrollable = 2
FlexAutoSizeScopeMovable = 3
FlexAutoSizeScopeFrozen = 4
End Enum
Public Enum FlexClipModeConstants
FlexClipModeNormal = 0
FlexClipModeExcludeHidden = 1
FlexClipModeLookupConv = 2
FlexClipModeLookupConvExcludeHidden = 3
End Enum
Public Enum FlexClipCopyModeConstants
FlexClipCopyModeNormal = 0
FlexClipCopyModeIncludeFixedRows = 1
FlexClipCopyModeIncludeFixedColumns = 2
FlexClipCopyModeIncludeFixedAll = 3
FlexClipCopyModeExtended = 4
FlexClipCopyModeExtendedFixedRows = 5
FlexClipCopyModeExtendedFixedColumns = 6
FlexClipCopyModeExtendedFixedAll = 7
End Enum
Public Enum FlexClipPasteModeConstants
FlexClipPasteModeNormal = 0
FlexClipPasteModeAutoSelection = 1
FlexClipPasteModeExtended = 2
FlexClipPasteModeExtendedAutoSelection = 3
End Enum
Public Enum FlexClipboardActionConstants
FlexClipboardActionCopy = 0
FlexClipboardActionCut = 1
FlexClipboardActionPaste = 2
FlexClipboardActionDelete = 3
End Enum
Public Enum FlexFindMatchConstants
FlexFindMatchExact = 0
FlexFindMatchPartial = 1
FlexFindMatchStartsWith = 2
FlexFindMatchEndsWith = 3
End Enum
Public Enum FlexFindDirectionConstants
FlexFindDirectionDown = 0
FlexFindDirectionUp = 1
FlexFindDirectionRight = 2
FlexFindDirectionLeft = 3
End Enum
Public Enum FlexLookupConvConstants
FlexLookupConvValue = 0
FlexLookupConvKey = 1
End Enum
Public Enum FlexIMEModeConstants
FlexIMEModeNoControl = 0
FlexIMEModeOn = 1
FlexIMEModeOff = 2
FlexIMEModeDisable = 3
FlexIMEModeHiragana = 4
FlexIMEModeKatakana = 5
FlexIMEModeKatakanaHalf = 6
FlexIMEModeAlphaFull = 7
FlexIMEModeAlpha = 8
FlexIMEModeHangulFull = 9
FlexIMEModeHangul = 10
End Enum
Public Enum FlexEditReasonConstants
FlexEditReasonCode = 0
FlexEditReasonF2 = 1
FlexEditReasonSpace = 2
FlexEditReasonKeyPress = 3
FlexEditReasonDblClick = 4
FlexEditReasonBackSpace = 5
FlexEditReasonReturn = 6
FlexEditReasonComboCueClick = 10
FlexEditReasonComboCueDblClick = 11
FlexEditReasonComboCueF4 = 12
FlexEditReasonComboCueAltUpDown = 13
End Enum
Public Enum FlexEditCloseModeConstants
FlexEditCloseModeCode = 0
FlexEditCloseModeLostFocus = 1
FlexEditCloseModeEscape = 2
FlexEditCloseModeReturn = 3
FlexEditCloseModeTab = 4
FlexEditCloseModeShiftTab = 5
FlexEditCloseModeNavigationKey = 6
End Enum
Public Enum FlexComboCueConstants
FlexComboCueHidden = -1
FlexComboCueNone = 0
FlexComboCueDropDown = 1
FlexComboCueButton = 2
FlexComboCueDisabledDropDown = 3
FlexComboCueDisabledButton = 4
End Enum
Public Enum FlexComboModeConstants
FlexComboModeNone = 0
FlexComboModeDropDown = 1
FlexComboModeEditable = 2
FlexComboModeButton = 3
FlexComboModeCalendar = 4
End Enum
Public Enum FlexComboDropDownReasonConstants
FlexComboDropDownReasonCode = 0
FlexComboDropDownReasonInitialize = 1
FlexComboDropDownReasonMouse = 2
FlexComboDropDownReasonKeyboard = 3
End Enum
Public Enum FlexComboButtonValueConstants
FlexComboButtonValueUnpressed = 0
FlexComboButtonValuePressed = 1
FlexComboButtonValueDisabled = 2
End Enum
Public Enum FlexComboButtonDrawModeConstants
FlexComboButtonDrawModeNormal = 0
FlexComboButtonDrawModeOwnerDraw = 1
End Enum
Public Enum FlexSortArrowConstants
FlexSortArrowNone = 0
FlexSortArrowAscending = 1
FlexSortArrowDescending = 2
End Enum
Public Enum FlexCheckBoxConstants
FlexNoCheckBoxEver = -2
FlexNoCheckBox = -1
FlexUnchecked = 0
FlexChecked = 1
FlexGrayed = 2
FlexTextAsCheckBox = 3
FlexDisabledUnchecked = 4
FlexDisabledChecked = 5
FlexDisabledGrayed = 6
FlexDisabledTextAsCheckBox = 7
End Enum
Public Enum FlexCellCheckReasonConstants
FlexCellCheckReasonMouse = 0
FlexCellCheckReasonKeyboard = 1
End Enum
Public Enum FlexCheckBoxAlignmentConstants
FlexCheckBoxAlignmentLeftTop = 0
FlexCheckBoxAlignmentLeftCenter = 1
FlexCheckBoxAlignmentLeftBottom = 2
FlexCheckBoxAlignmentCenterTop = 3
FlexCheckBoxAlignmentCenterCenter = 4
FlexCheckBoxAlignmentCenterBottom = 5
FlexCheckBoxAlignmentRightTop = 6
FlexCheckBoxAlignmentRightCenter = 7
FlexCheckBoxAlignmentRightBottom = 8
FlexCheckBoxAlignmentUsePictureAlignment = 9
End Enum
Public Enum FlexCheckBoxDrawModeConstants
FlexCheckBoxDrawModeNormal = 0
FlexCheckBoxDrawModeOwnerDraw = 1
End Enum
Public Enum FlexBestFitModeConstants
FlexBestFitModeTextOnly = 0
FlexBestFitModeFull = 1
FlexBestFitModeSortArrowText = 2
FlexBestFitModeOtherText = 3
End Enum
Public Enum FlexWallPaperAlignmentConstants
FlexWallPaperAlignmentLeftTop = 0
FlexWallPaperAlignmentLeftCenter = 1
FlexWallPaperAlignmentLeftBottom = 2
FlexWallPaperAlignmentCenterTop = 3
FlexWallPaperAlignmentCenterCenter = 4
FlexWallPaperAlignmentCenterBottom = 5
FlexWallPaperAlignmentRightTop = 6
FlexWallPaperAlignmentRightCenter = 7
FlexWallPaperAlignmentRightBottom = 8
FlexWallPaperAlignmentStretch = 9
FlexWallPaperAlignmentTile = 10
End Enum
Public Enum FlexFontQualityConstants
FlexFontQualityDefault = 0
FlexFontQualityDraft = 1
FlexFontQualityProof = 2
FlexFontQualityNonAntiAliased = 3
FlexFontQualityAntiAliased = 4
FlexFontQualityClearType = 5
FlexFontQualityClearTypeNatural = 6
End Enum
Public Enum FlexMetricConstants
FlexMetricDividerSpacing = 0
FlexMetricTextPadding = 1
FlexMetricCellSpacing = 2
FlexMetricScrollBarSize = 3
FlexMetricCheckBoxSize = 4
End Enum
Public Enum FlexDataSourceFlags
FlexDataSourceUnboundFixedColumns = 1
FlexDataSourceNoData = 2
FlexDataSourceNoFieldNames = 4
FlexDataSourceToolTipText = 8
FlexDataSourceChecked = 16
End Enum
Private Type RECT
Left As Long
Top As Long
Right As Long
Bottom As Long
End Type
Private Type POINTAPI
X As Long
Y As Long
End Type
Private Type SIZEAPI
CX As Long
CY As Long
End Type
Private Type BITMAPINFOHEADER
BISize As Long
BIWidth As Long
BIHeight As Long
BIPlanes As Integer
BIBitCount As Integer
BICompression As Long
BISizeImage As Long
BIXPelsPerMeter As Long
BIYPelsPerMeter As Long
BIClrUsed As Long
BIClrImportant As Long
End Type
Private Type BITMAPINFO
BMIHeader As BITMAPINFOHEADER
BMIColors(0 To 255) As Long
End Type
Private Type TRACKMOUSEEVENTSTRUCT
cbSize As Long
dwFlags As Long
hWndTrack As LongPtr
dwHoverTime As Long
End Type
Private Type TMSG
hWnd As LongPtr
Message As Long
wParam As LongPtr
lParam As LongPtr
Time As Long
PT As POINTAPI
End Type
Private Type TEXTMETRIC
TMHeight As Long
TMAscent As Long
TMDescent As Long
TMInternalLeading As Long
TMExternalLeading As Long
TMAveCharWidth As Long
TMMaxCharWidth As Long
TMWeight As Long
TMOverhang As Long
TMDigitizedAspectX As Long
TMDigitizedAspectY As Long
TMFirstChar As Integer
TMLastChar As Integer
TMDefaultChar As Integer
TMBreakChar As Integer
TMItalic As Byte
TMUnderlined As Byte
TMStruckOut As Byte
TMPitchAndFamily As Byte
TMCharset As Byte
End Type
Private Type DRAWTEXTPARAMS
cbSize As Long
iTabLength As Long
iLeftMargin As Long
iRightMargin As Long
uiLengthDrawn As Long
End Type
Private Type PAINTSTRUCT
hDC As LongPtr
fErase As Long
RCPaint As RECT
fRestore As Long
fIncUpdate As Long
RGBReserved(0 To 31) As Byte
End Type
Private Type DRAWITEMSTRUCT
CtlType As Long
CtlID As Long
ItemID As Long
ItemAction As Long
ItemState As Long
hWndItem As LongPtr
hDC As LongPtr
RCItem As RECT
ItemData As LongPtr
End Type
Private Type SCROLLINFO
cbSize As Long
fMask As Long
nMin As Long
nMax As Long
nPage As Long
nPos As Long
nTrackPos As Long
End Type
Private Type SYSTEMTIME
wYear As Integer
wMonth As Integer
wDayOfWeek As Integer
wDay As Integer
wHour As Integer
wMinute As Integer
wSecond As Integer
wMilliseconds As Integer
End Type
Private Type MONITORINFO
cbSize As Long
RCMonitor As RECT
RCWork As RECT
dwFlags As Long
End Type
Private Type TLOCALESIGNATURE
lsUsb(0 To 15) As Byte
lsCsbDefault(0 To 1) As Long
lsCsbSupported(0 To 1) As Long
End Type
Private Type TOOLINFO
cbSize As Long
uFlags As Long
hWnd As LongPtr
uId As LongPtr
RC As RECT
hInst As LongPtr
lpszText As LongPtr
lParam As LongPtr
End Type
Private Type NMHDR
hWndFrom As LongPtr
IDFrom As LongPtr
Code As Long
End Type
Private Const CDDS_PREPAINT As Long = &H1
Private Type NMCUSTOMDRAW
hdr As NMHDR
dwDrawStage As Long
hDC As LongPtr
RC As RECT
dwItemSpec As LongPtr
uItemState As Long
lItemlParam As LongPtr
End Type
Private Type NMTTCUSTOMDRAW
NMCD As NMCUSTOMDRAW
uDrawFlags As Long
End Type
Private Type NMTTDISPINFO
hdr As NMHDR
lpszText As LongPtr
szText(0 To ((80 * 2) - 1)) As Byte
hInst As LongPtr
uFlags As Long
lParam As LongPtr
End Type
Private Type NMSELCHANGE
hdr As NMHDR
STSelStart As SYSTEMTIME
STSelEnd As SYSTEMTIME
End Type
Private Const RCPM_ROW As Long = &H1, RCPM_COL As Long = &H2
Private Const RCPM_ROWSEL As Long = &H4, RCPM_COLSEL As Long = &H8
Private Const RCPM_TOPROW As Long = &H10, RCPM_LEFTCOL As Long = &H20
Private Const RCPF_CHECKTOPROW As Long = &H10, RCPF_CHECKLEFTCOL As Long = &H20
Private Const RCPF_FORCETOPROWMASK As Long = &H40, RCPF_FORCELEFTCOLMASK As Long = &H80
Private Const RCPF_SETSCROLLBARS As Long = &H100
Private Const RCPF_FORCEREDRAW As Long = &H200
Private Const RCPF_SHIFT As Long = &H400, RCPF_CTRL As Long = &H800
Private Type TROWCOLPARAMS
Mask As Long
Flags As Long
Message As Long
Row As Long
Col As Long
RowSel As Long
ColSel As Long
TopRow As Long
LeftCol As Long
End Type
Private Type TINDIRECTCELLREF
InProc As Boolean
SetRCP As Boolean
RCP As TROWCOLPARAMS
End Type
Private Type TCELLRANGE
LeftCol As Long
TopRow As Long
RightCol As Long
BottomRow As Long
End Type
Private Type TGRIDLINEOFFSETS
LeftTop As SIZEAPI
RightBottom As SIZEAPI
End Type
Private Type TTEXTINDENT
Left As Long
Right As Long
End Type
Private Const DIVIDER_SPACING_DIP As Long = 2
Private Type THITTESTINFO
PT As POINTAPI
HitRow As Long
HitCol As Long
HitRowDivider As Long
HitColDivider As Long
HitResult As FlexHitResultConstants
MouseRow As Long
MouseCol As Long
End Type
Private Const LBLI_VALID As Long = &H1
Private Const LBLI_UNFOLDED As Long = &H2
Private Const LBLI_HIDDEN As Long = &H4
Private Type TLABELINFO
Flags As Long
RC As RECT
DrawFlags As Long
End Type
Private Const DRAWINFO_FLAG_WALLPAPER As Long = &H1
Private Type TDRAWINFO
SelRange As TCELLRANGE
GridLinePoints(0 To 5) As POINTAPI
GridLineOffsets As TGRIDLINEOFFSETS
Flags As Long
End Type
Private Type TMERGEDRAWCOLINFO
RowOffset As Long
Height As Long
End Type
Private Type TMERGEDRAWROWINFO
ColOffset As Long
Width As Long
Cols() As TMERGEDRAWCOLINFO
End Type
Private Type TMERGEDRAWINFO
Row As TMERGEDRAWROWINFO
End Type
Private Const CFM_TEXTSTYLE As Long = &H1
Private Const CFM_ALIGNMENT As Long = &H2
Private Const CFM_PICTURE As Long = &H4
Private Const CFM_PICTURERENDERFLAG As Long = &H8
Private Const CFM_PICTUREALIGNMENT As Long = &H10
Private Const CFM_BACKCOLOR As Long = &H20
Private Const CFM_FORECOLOR As Long = &H40
Private Const CFM_TOOLTIPTEXT As Long = &H80
Private Const CFM_COMBOCUE As Long = &H100
Private Const CFM_CHECKED As Long = &H200
Private Const CFM_FLOODPERCENT As Long = &H400
Private Const CFM_FLOODCOLOR As Long = &H800
Private Const CFM_FONT As Long = &H1000
Private Const FS_BOLD As Integer = &H1, FS_ITALIC As Integer = &H2, FS_UNDERLINE As Integer = &H4, FS_STRIKEOUT As Integer = &H8
Private Type TCELLFMTG
TextStyle As Integer ' As FlexTextStyleConstants
Alignment As Integer ' As FlexAlignmentConstants
Picture As IPictureDisp
PictureRenderFlag As Integer
PictureAlignment As Integer ' As FlexPictureAlignmentConstants
BackColor As Long
ForeColor As Long
ToolTipText As String
ComboCue As Long ' As FlexComboCueConstants
Checked As Integer
FloodPercent As Integer
FloodColor As Long
FontName As String
FontSize As Single
FontStyle As Integer
FontCharset As Integer
End Type
Private Type TLPCELLFMTG
TextStyle As Integer ' As FlexTextStyleConstants
Alignment As Integer ' As FlexAlignmentConstants
lpPicture As LongPtr
PictureRenderFlag As Integer
PictureAlignment As Integer ' As FlexPictureAlignmentConstants
BackColor As Long
ForeColor As Long
lpToolTipText As LongPtr
ComboCue As Long ' As FlexComboCueConstants
Checked As Integer
FloodPercent As Integer
FloodColor As Long
lpFontName As LongPtr
FontSize As Single
FontStyle As Integer
FontCharset As Integer
End Type
Private Const CELL_TEXT_WIDTH_PADDING_DIP As Long = 3
Private Const CELL_TEXT_HEIGHT_PADDING_DIP As Long = 1
Private Type TCELL
Text As String
lpFmtg As LongPtr
lpTag As LongPtr
End Type
Private Const RATIO_OF_ROWINFO_HEIGHT_TO_COLINFO_WIDTH As Long = 4
Private Const ROWINFO_HEIGHT_SPACING_DIP As Long = 3
Private Const RWIS_HIDDEN As Long = &H1
Private Const RWIS_MERGE As Long = &H2
Private Const RWIS_SELECTED As Long = &H4
Private Const RWIS_NOSIZING As Long = &H8
Private Type TROWINFO
Height As Long
Data As LongPtr
State As Long
ID As Long
End Type
Private Type TIMAGELIST
ObjectPointer As LongPtr
Handle As LongPtr
Size As SIZEAPI
End Type
Private Type TSORTARROWMETRICS
CalcSize As SIZEAPI
DrawSize As SIZEAPI
ClientSize As SIZEAPI
End Type
Private Type TLOOKUPITEM
Key As String
Value As String
Hash As Long
End Type
Private Type TLOOKUP
Property As String
Count As Long
Items() As TLOOKUPITEM
End Type
Private Const COLINFO_WIDTH_SPACING_DIP As Long = 6
Private Const CLIS_HIDDEN As Long = &H1
Private Const CLIS_MERGE As Long = &H2
Private Const CLIS_NULLABLE As Long = &H4
Private Const CLIS_NOSIZING As Long = &H8
Private Const CLIS_CHECKBOXES As Long = &H10
Private Const CLIS_CHECKBOXESHITTESTINVISIBLE As Long = &H20
Private Const CLIS_CHECKBOXESHITTESTINVISIBLEDISABLEDONLY As Long = &H40
Private Const CLIS_CHECKBOXESHITTESTINVISIBLEFIXED As Long = &H80
Private Const CLIS_CHECKBOXESHITTESTINVISIBLEFIXEDDISABLEDONLY As Long = &H100
Private Const CLIS_TEXTINDENT As Long = &H200
Private Type TCOLINFO
Width As Long
Data As LongPtr
State As Long
Key As String
Alignment As FlexAlignmentConstants
FixedAlignment As FlexAlignmentConstants
ImageList As TIMAGELIST
WordWrapOption As FlexWordWrapOptions
WordWrapOptionFixed As FlexWordWrapOptions
MimicTextBox As FlexMimicTextBoxConstants
MimicTextBoxFixed As FlexMimicTextBoxConstants
Sort As FlexSortConstants
SortMode As FlexSortModeConstants
SortArrow As FlexSortArrowConstants
SortArrowAlignment As FlexLeftRightAlignmentConstants
SortArrowColor As Long
ComboCue As FlexComboCueConstants
ComboMode As FlexComboModeConstants
ComboButtonPicture As IPictureDisp
ComboButtonPictureRenderFlag As Integer
ComboButtonAlignment As Integer ' As FlexLeftRightAlignmentConstants
ComboButtonWidth As Long
ComboItems As String
ComboHeader As String
ComboBoundColumn As Long
CheckBoxAlignment As FlexCheckBoxAlignmentConstants
FixedCheckBoxAlignment As FlexCheckBoxAlignmentConstants
Lookup As TLOOKUP
Format As String
FixedFormat As String
DataType As Integer
NumericPrecision As Byte
NumericScale As Byte
DataCapacity As Long
End Type
Private Type TCOLS
Cols() As TCELL
RowInfo As TROWINFO
End Type
Private Type TROWS
Rows() As TCOLS
End Type
Private Type TINDIRECTMERGESORTDATA
Row As Long
TextDisplay As String
Swap As TCOLS
End Type
Private Type TPIXELMETRICS
DividerSpacing As SIZEAPI
TextPadding As SIZEAPI
CellSpacing As SIZEAPI
ScrollBarSize As Long
CheckBoxSize As Long
End Type
Private Type TINCREMENTALSEARCH
SearchString As String
Row As Long
Col As Long
CaseSensitive As Boolean
NoWrap As Boolean
Direction As FlexFindDirectionConstants
CancellationPending As Boolean
NoLostFocus As Boolean
Time As Long
End Type
Private Type TCOMBOMULTICOLUMNITEM
Count As Long
Column() As String
End Type
Private Type TCOMBOMULTICOLUMN
MaxCount As Long
MaxWidths() As Long
Items() As TCOMBOMULTICOLUMNITEM
Header As TCOMBOMULTICOLUMNITEM
BoundColumn As Long
End Type
Private Type TUNDOREDOENTRY
OldString As String
NewString As String
Clip As Boolean
ClearClip As Boolean
Row As Long
Col As Long
RowSel As Long
ColSel As Long
MergedRange As TCELLRANGE
End Type
Private Type TFORMATRANGE
hDC As LongPtr
hDCTarget As LongPtr
RC As RECT
RCPage As RECT
End Type
Public Event Click()
Attribute Click.VB_Description = "Occurs when the user presses and then releases a mouse button over an object."
Attribute Click.VB_UserMemId = -600
Public Event DblClick()
Attribute DblClick.VB_Description = "Occurs when the user presses and releases a mouse button and then presses and releases it again over an object."
Attribute DblClick.VB_UserMemId = -601
Public Event DropFiles(ByRef FileList As Variant, ByVal X As Single, ByVal Y As Single)
Attribute DropFiles.VB_Description = "Occurs when the user drops files on the control. Only applicable when there is no OLE drop target available and the allow drop files property is set to true."
Public Event Scroll()
Attribute Scroll.VB_Description = "Occurs when you reposition the scroll box on a control."
Public Event ScrollTip(ByVal Row As Long, ByVal Col As Long)
Attribute ScrollTip.VB_Description = "Occurs when the control is about to display a scroll tip."
Public Event ContextMenu(ByVal X As Single, ByVal Y As Single)
Attribute ContextMenu.VB_Description = "Occurs when the user clicked the right mouse button or types SHIFT + F10."
Public Event BeginIncrementalSearch(ByRef Row As Long, ByRef Col As Long, ByRef CaseSensitive As Boolean, ByRef NoWrap As Boolean, ByRef Direction As FlexFindDirectionConstants, ByRef Cancel As Boolean)
Attribute BeginIncrementalSearch.VB_Description = "Occurs when the user is about to begin an incremental search."
Public Event IncrementalSearch(ByVal Row As Long, ByVal Col As Long, ByVal CharCode As Long, ByVal CaseSensitive As Boolean, ByVal NoWrap As Boolean, ByVal Direction As FlexFindDirectionConstants, ByVal FoundIndex As Long)
Attribute IncrementalSearch.VB_Description = "Occurs when an incremental search has started."
Public Event EndIncrementalSearch(ByVal Row As Long, ByVal Col As Long)
Attribute EndIncrementalSearch.VB_Description = "Occurs when an incremental search has elapsed or ended."
Public Event BeforeClipboardAction(ByVal Action As FlexClipboardActionConstants, ByRef Text As String, ByRef Cancel As Boolean)
Attribute BeforeClipboardAction.VB_Description = "Occurs when a clipboard action is about to be performed."
Public Event AfterClipboardAction(ByVal Action As FlexClipboardActionConstants)
Attribute AfterClipboardAction.VB_Description = "Occurs when a clipboard action was performed."
Public Event AfterUserFreeze()
Attribute AfterUserFreeze.VB_Description = "Occurs after the user freezes a row or a column."
Public Event BeforeUserResize(ByVal Row As Long, ByVal Col As Long, ByRef Cancel As Boolean)
Attribute BeforeUserResize.VB_Description = "Occurs when the user has begun dragging a divider on a row or a column."
Public Event AfterUserResize(ByVal Row As Long, ByVal Col As Long, ByRef NewSize As Long)
Attribute AfterUserResize.VB_Description = "Occurs when the user has finished dragging a divider on a row or a column."
Public Event AfterUserResizeEnd(ByVal Row As Long, ByVal Col As Long)
Attribute AfterUserResizeEnd.VB_Description = "Occurs after the user resizes a row or a column."
Public Event LeaveCell()
Attribute LeaveCell.VB_Description = "Occurs after the cursor leaves a cell."
Public Event EnterCell()
Attribute EnterCell.VB_Description = "Occurs before the cursor enters a cell."
Public Event BeforeRowColChange(ByVal NewRow As Long, ByVal NewCol As Long, ByRef Cancel As Boolean)
Attribute BeforeRowColChange.VB_Description = "Occurs before the current cell changes."
Public Event RowColChange()
Attribute RowColChange.VB_Description = "Occurs when the current cell changes."
Public Event BeforeSelChange(ByVal NewRowSel As Long, ByVal NewColSel As Long, ByRef Cancel As Boolean)
Attribute BeforeSelChange.VB_Description = "Occurs before the selected range of cells changes."
Public Event SelChange()
Attribute SelChange.VB_Description = "Occurs when the selected range of cells changes."
Public Event MultiSelChange()
Attribute MultiSelChange.VB_Description = "Occurs when the selection of multiple (non-contiguous) ranges of cells changes."
Public Event Compare(ByVal Row1 As Long, ByVal Row2 As Long, ByVal Col As Long, ByRef Cmp As Long)
Attribute Compare.VB_Description = "Occurs during custom sorts to compare two rows."
Public Event CompareText(ByVal Text1 As String, ByVal Text2 As String, ByVal Col As Long, ByRef Cmp As Long)
Attribute CompareText.VB_Description = "Occurs during custom sorts to compare the text contents of two cells."
Public Event BeforeEdit(ByRef Row As Long, ByRef Col As Long, ByVal Reason As FlexEditReasonConstants, ByRef Cancel As Boolean)
Attribute BeforeEdit.VB_Description = "Occurs when a user attempts to edit the text of a cell."
Public Event AfterEdit(ByVal Row As Long, ByVal Col As Long, ByVal Changed As Boolean)
Attribute AfterEdit.VB_Description = "Occurs after a user edits the text of a cell."
Public Event LeaveEdit()
Attribute LeaveEdit.VB_Description = "Occurs when a user leaves edit mode."
Public Event EnterEdit()
Attribute EnterEdit.VB_Description = "Occurs when a user enters edit mode."
Public Event ValidateEdit(ByRef Cancel As Boolean)
Attribute ValidateEdit.VB_Description = "Occurs before any changes made by a user are committed to a cell. If the validation fails the changes will be discarded and the control will remain in edit mode."
Public Event EditSetupStyle(ByRef dwStyle As Long, ByRef dwExStyle As Long)
Attribute EditSetupStyle.VB_Description = "Occurs before the edit control is created. This is a request to perform additional customizations."
Public Event EditSetupWindow(ByRef BackColor As OLE_COLOR, ByRef ForeColor As OLE_COLOR)
Attribute EditSetupWindow.VB_Description = "Occurs after the edit control has been created and before it is displayed. This is a request to perform additional customizations."
Public Event EditQueryClose(ByVal CloseMode As FlexEditCloseModeConstants, ByRef Cancel As Boolean)
Attribute EditQueryClose.VB_Description = "Occurs whenever the edit mode is about to be closed, except when the edit control loses the focus."
Public Event EditChange()
Attribute EditChange.VB_Description = "Occurs when the contents of a control have changed."
Public Event EditContextMenu(ByRef Handled As Boolean, ByVal X As Single, ByVal Y As Single)
Attribute EditContextMenu.VB_Description = "Occurs when the user clicked the right mouse button or types SHIFT + F10."
Public Event EditKeyDown(KeyCode As Integer, Shift As Integer)
Attribute EditKeyDown.VB_Description = "Occurs when the user presses a key while an object has the focus."
Public Event EditKeyUp(KeyCode As Integer, Shift As Integer)
Attribute EditKeyUp.VB_Description = "Occurs when the user releases a key while an object has the focus."
Public Event EditKeyPress(KeyChar As Integer)
Attribute EditKeyPress.VB_Description = "Occurs when the user presses and releases an character key."
Public Event ComboBeforeDropDown(ByVal Reason As FlexComboDropDownReasonConstants, ByRef Cancel As Boolean)
Attribute ComboBeforeDropDown.VB_Description = "Occurs before the drop-down list is about to drop down."
Public Event ComboDropDown()
Attribute ComboDropDown.VB_Description = "Occurs when the drop-down list is about to drop down."
Public Event ComboCloseUp()
Attribute ComboCloseUp.VB_Description = "Occurs when the drop-down list has been closed."
Public Event ComboButtonClick()
Attribute ComboButtonClick.VB_Description = "Occurs when the user clicks on a combo button. Only applicable if the combo mode property is set to button."
Public Event ComboButtonOwnerDraw(ByVal Row As Long, ByVal Col As Long, ByRef Cancel As Boolean, ByVal CtlType As Long, ByVal ItemAction As Long, ByVal ItemState As Long, ByVal hDC As Long, ByVal Left As Long, ByVal Top As Long, ByVal Right As Long, ByVal Bottom As Long)
Attribute ComboButtonOwnerDraw.VB_Description = "Occurs when a visual aspect of an owner-drawn combo button has changed."
Public Event ComboButtonCustomDraw(ByVal Row As Long, ByVal Col As Long, ByRef Handled As Boolean, ByVal CtlType As Long, ByVal ItemAction As Long, ByVal ItemState As Long, ByVal hDC As Long, ByVal Left As Long, ByVal Top As Long, ByVal Right As Long, ByVal Bottom As Long, ByVal ContentLeft As Long, ByVal ContentTop As Long, ByVal ContentRight As Long, ByVal ContentBottom As Long)
Attribute ComboButtonCustomDraw.VB_Description = "Occurs after the background of an combo button has been drawn and before the content is drawn. Only applicable if the combo button draw mode property is set to normal and the combo mode property is set to button."
Public Event ComboButtonMeasure(ByVal Row As Long, ByVal Col As Long, ByRef Width As Long)
Attribute ComboButtonMeasure.VB_Description = "Occurs when an combo button's width needs to be determined in preparation of drawing it. Only applicable if the combo mode property is set to button."
Public Event ComboCueClick(ByVal Row As Long, ByVal Col As Long, ByVal Reason As FlexEditReasonConstants)
Attribute ComboCueClick.VB_Description = "Occurs when the user clicks on a combo cue and the attempt to edit has been canceled. Only applicable if the always allow combo cues property is set to true."
Public Event DividerDblClick(ByVal Row As Long, ByVal Col As Long)
Attribute DividerDblClick.VB_Description = "Occurs when the user double-clicked the divider on a row or a column."
Public Event CellClick(ByVal Row As Long, ByVal Col As Long, ByVal Button As Integer)
Attribute CellClick.VB_Description = "Occurs when a cell is clicked."
Public Event CellDblClick(ByVal Row As Long, ByVal Col As Long, ByVal Button As Integer)
Attribute CellDblClick.VB_Description = "Occurs when a cell is double clicked."
Public Event CellImageCallback(ByVal Row As Long, ByVal Col As Long, ByRef Image As Variant, ByRef Handled As Boolean)
Attribute CellImageCallback.VB_Description = "Occurs when an image list control or handle requests for a cell image."
Public Event CellBeforeCheck(ByVal Row As Long, ByVal Col As Long, ByVal Reason As FlexCellCheckReasonConstants, ByRef Cancel As Boolean)
Attribute CellBeforeCheck.VB_Description = "Occurs before a cell is about to be checked."
Public Event CellCheck(ByVal Row As Long, ByVal Col As Long)
Attribute CellCheck.VB_Description = "Occurs when a cell is checked."
Public Event CellTextIndent(ByVal Row As Long, ByVal Col As Long, ByRef Left As Long, ByRef Right As Long)
Attribute CellTextIndent.VB_Description = "Occurs when a cell requests for the amount of space, in twips, to indent text. Only applicable if the column's text indent property is set to true."
Public Event CheckBoxOwnerDraw(ByVal Row As Long, ByVal Col As Long, ByRef Cancel As Boolean, ByVal ItemState As Long, ByVal hDC As Long, ByVal Left As Long, ByVal Top As Long, ByVal Right As Long, ByVal Bottom As Long)
Attribute CheckBoxOwnerDraw.VB_Description = "Occurs when a visual aspect of an owner-drawn check box has changed."
Public Event PreviewKeyDown(ByVal KeyCode As Integer, ByRef IsInputKey As Boolean)
Attribute PreviewKeyDown.VB_Description = "Occurs before the KeyDown event."
Public Event PreviewKeyUp(ByVal KeyCode As Integer, ByRef IsInputKey As Boolean)
Attribute PreviewKeyUp.VB_Description = "Occurs before the KeyUp event."
Public Event KeyDown(KeyCode As Integer, Shift As Integer)
Attribute KeyDown.VB_Description = "Occurs when the user presses a key while an object has the focus."
Attribute KeyDown.VB_UserMemId = -602
Public Event KeyUp(KeyCode As Integer, Shift As Integer)
Attribute KeyUp.VB_Description = "Occurs when the user releases a key while an object has the focus."
Attribute KeyUp.VB_UserMemId = -604
Public Event KeyPress(KeyChar As Integer)
Attribute KeyPress.VB_Description = "Occurs when the user presses and releases an character key."
Attribute KeyPress.VB_UserMemId = -603
Public Event BeforeMouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single, ByRef Cancel As Boolean)
Attribute BeforeMouseDown.VB_Description = "Occurs before the control processes the MouseDown event."
Public Event MouseDown(Button As Integer, Shift As Integer, X As Single, Y As Single)
Attribute MouseDown.VB_Description = "Occurs when the user presses the mouse button while an object has the focus."
Attribute MouseDown.VB_UserMemId = -605
Public Event MouseMove(Button As Integer, Shift As Integer, X As Single, Y As Single)
Attribute MouseMove.VB_Description = "Occurs when the user moves the mouse."
Attribute MouseMove.VB_UserMemId = -606
Public Event MouseUp(Button As Integer, Shift As Integer, X As Single, Y As Single)
Attribute MouseUp.VB_Description = "Occurs when the user releases the mouse button while an object has the focus."
Attribute MouseUp.VB_UserMemId = -607
Public Event MouseEnter()
Attribute MouseEnter.VB_Description = "Occurs when the user moves the mouse into the control."
Public Event MouseLeave()
Attribute MouseLeave.VB_Description = "Occurs when the user moves the mouse out of the control."
Public Event OLECompleteDrag(Effect As Long)
Attribute OLECompleteDrag.VB_Description = "Occurs at the OLE drag/drop source control after a manual or automatic drag/drop has been completed or canceled."
Public Event OLEDragDrop(Data As DataObject, Effect As Long, Button As Integer, Shift As Integer, X As Single, Y As Single)
Attribute OLEDragDrop.VB_Description = "Occurs when data is dropped onto the control via an OLE drag/drop operation, and OLEDropMode is set to manual."
Public Event OLEDragOver(Data As DataObject, Effect As Long, Button As Integer, Shift As Integer, X As Single, Y As Single, State As Integer)
Attribute OLEDragOver.VB_Description = "Occurs when the mouse is moved over the control during an OLE drag/drop operation, if its OLEDropMode property is set to manual."
Public Event OLEGiveFeedback(Effect As Long, DefaultCursors As Boolean)
Attribute OLEGiveFeedback.VB_Description = "Occurs at the source control of an OLE drag/drop operation when the mouse cursor needs to be changed."
Public Event OLESetData(Data As DataObject, DataFormat As Integer)
Attribute OLESetData.VB_Description = "Occurs at the OLE drag/drop source control when the drop target requests data that was not provided to the DataObject during the OLEDragStart event."
Public Event OLEStartDrag(Data As DataObject, AllowedEffects As Long)
Attribute OLEStartDrag.VB_Description = "Occurs when an OLE drag/drop operation is initiated either manually or automatically."
#If VBA7 Then
Private Declare PtrSafe Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (ByRef Destination As Any, ByRef Source As Any, ByVal Length As Long)
Private Declare PtrSafe Sub ZeroMemory Lib "kernel32" Alias "RtlZeroMemory" (ByRef Destination As Any, ByVal Length As Long)
Private Declare PtrSafe Sub PostQuitMessage Lib "user32" (ByVal nExitCode As Long)
Private Declare PtrSafe Sub DragAcceptFiles Lib "shell32" (ByVal hWnd As LongPtr, ByVal fAccept As Long)
Private Declare PtrSafe Sub DragFinish Lib "shell32" (ByVal hDrop As LongPtr)
Private Declare PtrSafe Sub VariantInit Lib "oleaut32" (ByRef pvarg As Any)
Private Declare PtrSafe Function VariantClear Lib "oleaut32" (ByRef pvarg As Any) As Long
Private Declare PtrSafe Function VariantCopy Lib "oleaut32" (ByRef pvargDest As Any, ByRef pvargSrc As Any) As Long
Private Declare PtrSafe Function CreateWindowEx Lib "user32" Alias "CreateWindowExW" (ByVal dwExStyle As Long, ByVal lpClassName As LongPtr, ByVal lpWindowName As LongPtr, ByVal dwStyle As Long, ByVal X As Long, ByVal Y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal hWndParent As LongPtr, ByVal hMenu As LongPtr, ByVal hInstance As LongPtr, ByRef lpParam As Any) As LongPtr
Private Declare PtrSafe Function HeapAlloc Lib "kernel32" (ByVal hHeap As LongPtr, ByVal dwFlags As Long, ByVal dwBytes As LongPtr) As LongPtr
Private Declare PtrSafe Function HeapFree Lib "kernel32" (ByVal hHeap As LongPtr, ByVal dwFlags As Long, ByVal lpMem As LongPtr) As Long
Private Declare PtrSafe Function GetProcessHeap Lib "kernel32" () As LongPtr
Private Declare PtrSafe Function SysAllocString Lib "oleaut32" (ByVal lpString As LongPtr) As LongPtr
Private Declare PtrSafe Function SysFreeString Lib "oleaut32" (ByVal lpString As LongPtr) As Long
Private Declare PtrSafe Function SysReAllocString Lib "oleaut32" (ByVal pbString As LongPtr, ByVal pszStrPtr As LongPtr) As Long
Private Declare PtrSafe Function LCMapString Lib "kernel32" Alias "LCMapStringW" (ByVal LCID As Long, ByVal dwMapFlags As Long, ByVal lpSrcStr As LongPtr, ByVal cchSrcStr As Long, ByVal lpDestStr As LongPtr, ByVal cchDestStr As Long) As Long
Private Declare PtrSafe Function lstrcmp Lib "kernel32" Alias "lstrcmpW" (ByVal lpString1 As LongPtr, ByVal lpString2 As LongPtr) As Long
Private Declare PtrSafe Function lstrcmpi Lib "kernel32" Alias "lstrcmpiW" (ByVal lpString1 As LongPtr, ByVal lpString2 As LongPtr) As Long
Private Declare PtrSafe Function DispatchMessage Lib "user32" Alias "DispatchMessageW" (ByRef lpMsg As TMSG) As LongPtr
Private Declare PtrSafe Function WaitMessage Lib "user32" () As Long
Private Declare PtrSafe Function SendMessage Lib "user32" Alias "SendMessageW" (ByVal hWnd As LongPtr, ByVal wMsg As Long, ByVal wParam As LongPtr, ByRef lParam As Any) As LongPtr
Private Declare PtrSafe Function PeekMessage Lib "user32" Alias "PeekMessageW" (ByRef lpMsg As TMSG, ByVal hWnd As LongPtr, ByVal wMsgFilterMin As Long, ByVal wMsgFilterMax As Long, ByVal wRemoveMsg As Long) As Long
Private Declare PtrSafe Function PostMessage Lib "user32" Alias "PostMessageW" (ByVal hWnd As LongPtr, ByVal wMsg As Long, ByVal wParam As LongPtr, ByRef lParam As Any) As LongPtr
Private Declare PtrSafe Function DestroyWindow Lib "user32" (ByVal hWnd As LongPtr) As Long
Private Declare PtrSafe Function DefWindowProc Lib "user32" Alias "DefWindowProcW" (ByVal hWnd As LongPtr, ByVal wMsg As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr) As LongPtr
Private Declare PtrSafe Function SetParent Lib "user32" (ByVal hWndChild As LongPtr, ByVal hWndNewParent As LongPtr) As LongPtr
Private Declare PtrSafe Function ShowWindow Lib "user32" (ByVal hWnd As LongPtr, ByVal nCmdShow As Long) As Long
Private Declare PtrSafe Function MoveWindow Lib "user32" (ByVal hWnd As LongPtr, ByVal X As Long, ByVal Y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal bRepaint As Long) As Long
Private Declare PtrSafe Function EnableWindow Lib "user32" (ByVal hWnd As LongPtr, ByVal fEnable As Long) As Long
Private Declare PtrSafe Function IsWindowEnabled Lib "user32" (ByVal hWnd As LongPtr) As Long
Private Declare PtrSafe Function IsWindowVisible Lib "user32" (ByVal hWnd As LongPtr) As Long
Private Declare PtrSafe Function MonitorFromWindow Lib "user32" (ByVal hWnd As LongPtr, ByVal dwFlags As Long) As LongPtr
Private Declare PtrSafe Function GetMonitorInfo Lib "user32" Alias "GetMonitorInfoW" (ByVal hMonitor As LongPtr, ByRef lpMI As MONITORINFO) As Long
Private Declare PtrSafe Function LBItemFromPt Lib "comctl32" (ByVal hLB As LongPtr, ByVal XY As Currency, ByVal bAutoScroll As Long) As Long
Private Declare PtrSafe Function SetFocusAPI Lib "user32" Alias "SetFocus" (ByVal hWnd As LongPtr) As LongPtr
Private Declare PtrSafe Function GetFocus Lib "user32" () As LongPtr
Private Declare PtrSafe Function BeginPaint Lib "user32" (ByVal hWnd As LongPtr, ByRef lpPaint As PAINTSTRUCT) As LongPtr
Private Declare PtrSafe Function EndPaint Lib "user32" (ByVal hWnd As LongPtr, ByRef lpPaint As PAINTSTRUCT) As Long
Private Declare PtrSafe Function CreateRectRgn Lib "gdi32" (ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long) As LongPtr
Private Declare PtrSafe Function ExtSelectClipRgn Lib "gdi32" (ByVal hDC As LongPtr, ByVal hRgn As LongPtr, ByVal fnMode As Long) As Long
Private Declare PtrSafe Function GetClipRgn Lib "gdi32" (ByVal hDC As LongPtr, ByVal hRgn As LongPtr) As Long
Private Declare PtrSafe Function IntersectClipRect Lib "gdi32" (ByVal hDC As LongPtr, ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long) As Long
Private Declare PtrSafe Function RedrawWindow Lib "user32" (ByVal hWnd As LongPtr, ByVal lprcUpdate As LongPtr, ByVal hrgnUpdate As LongPtr, ByVal fuRedraw As Long) As Long
Private Declare PtrSafe Function InvalidateRect Lib "user32" (ByVal hWnd As LongPtr, ByRef lpRect As Any, ByVal bErase As Long) As Long
Private Declare PtrSafe Function UpdateWindow Lib "user32" (ByVal hWnd As LongPtr) As Long
Private Declare PtrSafe Function TrackMouseEvent Lib "user32" (ByRef lpEventTrack As TRACKMOUSEEVENTSTRUCT) As Long
Private Declare PtrSafe Function GetKeyboardLayout Lib "user32" (ByVal dwThreadID As Long) As LongPtr
Private Declare PtrSafe Function ImmIsIME Lib "imm32" (ByVal hKL As LongPtr) As Long
Private Declare PtrSafe Function ImmCreateContext Lib "imm32" () As LongPtr
Private Declare PtrSafe Function ImmDestroyContext Lib "imm32" (ByVal hIMC As LongPtr) As Long
Private Declare PtrSafe Function ImmGetContext Lib "imm32" (ByVal hWnd As LongPtr) As LongPtr
Private Declare PtrSafe Function ImmReleaseContext Lib "imm32" (ByVal hWnd As LongPtr, ByVal hIMC As LongPtr) As Long
Private Declare PtrSafe Function ImmGetOpenStatus Lib "imm32" (ByVal hIMC As LongPtr) As Long
Private Declare PtrSafe Function ImmSetOpenStatus Lib "imm32" (ByVal hIMC As LongPtr, ByVal fOpen As Long) As Long
Private Declare PtrSafe Function ImmAssociateContext Lib "imm32" (ByVal hWnd As LongPtr, ByVal hIMC As LongPtr) As LongPtr
Private Declare PtrSafe Function ImmGetConversionStatus Lib "imm32" (ByVal hIMC As LongPtr, ByVal lpfdwConversion As LongPtr, ByVal lpfdwSentence As LongPtr) As Long
Private Declare PtrSafe Function ImmSetConversionStatus Lib "imm32" (ByVal hIMC As LongPtr, ByVal fdwConversion As Long, ByVal fdwSentence As Long) As Long
Private Declare PtrSafe Function GetSystemDefaultLangID Lib "kernel32" () As Integer
Private Declare PtrSafe Function GetUserDefaultLangID Lib "kernel32" () As Integer
Private Declare PtrSafe Function GetUserDefaultUILanguage Lib "kernel32" () As Integer
Private Declare PtrSafe Function GetUserDefaultLCID Lib "kernel32" () As Long
Private Declare PtrSafe Function GetLocaleInfo Lib "kernel32" Alias "GetLocaleInfoW" (ByVal LCID As Long, ByVal LCType As Long, ByVal lpLCData As LongPtr, ByVal cchData As Long) As Long
Private Declare PtrSafe Function GetMessagePos Lib "user32" () As Long
Private Declare PtrSafe Function GetClientRect Lib "user32" (ByVal hWnd As LongPtr, ByRef lpRect As RECT) As Long
Private Declare PtrSafe Function GetWindowRect Lib "user32" (ByVal hWnd As LongPtr, ByRef lpRect As RECT) As Long
Private Declare PtrSafe Function MapWindowPoints Lib "user32" (ByVal hWndFrom As LongPtr, ByVal hWndTo As LongPtr, ByRef lppt As Any, ByVal cPoints As Long) As Long
Private Declare PtrSafe Function SetViewportOrgEx Lib "gdi32" (ByVal hDC As LongPtr, ByVal X As Long, ByVal Y As Long, ByRef lpPoint As POINTAPI) As Long
Private Declare PtrSafe Function SetRect Lib "user32" (ByRef lpRect As RECT, ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long) As Long
Private Declare PtrSafe Function CreateSolidBrush Lib "gdi32" (ByVal crColor As Long) As LongPtr
Private Declare PtrSafe Function CreatePen Lib "gdi32" (ByVal nPenStyle As Long, ByVal nWidth As Long, ByVal crColor As Long) As LongPtr
Private Declare PtrSafe Function Polyline Lib "gdi32" (ByVal hDC As LongPtr, ByRef lpPoint As POINTAPI, ByVal nCount As Long) As Long
Private Declare PtrSafe Function Polygon Lib "gdi32" (ByVal hDC As LongPtr, ByRef lpPoint As POINTAPI, ByVal nCount As Long) As Long
Private Declare PtrSafe Function Rectangle Lib "gdi32" (ByVal hDC As LongPtr, ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long) As Long
Private Declare PtrSafe Function FillRect Lib "user32" (ByVal hDC As LongPtr, ByRef lpRect As RECT, ByVal hBrush As LongPtr) As Long
Private Declare PtrSafe Function InvertRect Lib "user32" (ByVal hDC As LongPtr, ByRef lpRect As RECT) As Long
Private Declare PtrSafe Function DrawState Lib "user32" Alias "DrawStateW" (ByVal hDC As LongPtr, ByVal hBrush As LongPtr, ByVal lpDrawStateProc As LongPtr, ByVal lData As LongPtr, ByVal wData As LongPtr, ByVal X As Long, ByVal Y As Long, ByVal CX As Long, ByVal CY As Long, ByVal fFlags As Long) As Long
Private Declare PtrSafe Function DrawFocusRect Lib "user32" (ByVal hDC As LongPtr, ByRef lpRect As RECT) As Long
Private Declare PtrSafe Function DrawFrameControl Lib "user32" (ByVal hDC As LongPtr, ByRef lpRect As RECT, ByVal nCtlType As Long, ByVal nFlags As Long) As Long
Private Declare PtrSafe Function DrawText Lib "user32" Alias "DrawTextW" (ByVal hDC As LongPtr, ByVal lpchText As LongPtr, ByVal nCount As Long, ByRef lpRect As RECT, ByVal uFormat As Long) As Long
Private Declare PtrSafe Function DrawTextEx Lib "user32" Alias "DrawTextExW" (ByVal hDC As LongPtr, ByVal lpchText As LongPtr, ByVal nCount As Long, ByRef lpRect As RECT, ByVal uFormat As Long, ByRef lpDrawTextParams As Any) As Long
Private Declare PtrSafe Function TextOut Lib "gdi32" Alias "TextOutW" (ByVal hDC As LongPtr, ByVal X As Long, ByVal Y As Long, ByVal lpString As LongPtr, ByVal nCount As Long) As Long
Private Declare PtrSafe Function ExtTextOut Lib "gdi32" Alias "ExtTextOutW" (ByVal hDC As LongPtr, ByVal X As Long, ByVal Y As Long, ByVal wOptions As Long, ByRef lpRect As Any, ByVal lpString As LongPtr, ByVal nCount As Long, ByVal lpDX As LongPtr) As Long
Private Declare PtrSafe Function DeleteObject Lib "gdi32" (ByVal hObject As LongPtr) As Long
Private Declare PtrSafe Function SelectObject Lib "gdi32" (ByVal hDC As LongPtr, ByVal hObject As LongPtr) As LongPtr
Private Declare PtrSafe Function SetWindowLong Lib "user32" Alias "SetWindowLongW" (ByVal hWnd As LongPtr, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Private Declare PtrSafe Function GetWindowLong Lib "user32" Alias "GetWindowLongW" (ByVal hWnd As LongPtr, ByVal nIndex As Long) As Long
#If Win64 Then
Private Declare PtrSafe Function SetWindowLongPtr Lib "user32" Alias "SetWindowLongPtrW" (ByVal hWnd As LongPtr, ByVal nIndex As Long, ByVal dwNewLong As LongPtr) As LongPtr
Private Declare PtrSafe Function GetWindowLongPtr Lib "user32" Alias "GetWindowLongPtrW" (ByVal hWnd As LongPtr, ByVal nIndex As Long) As LongPtr
#Else
Private Declare PtrSafe Function SetWindowLongPtr Lib "user32" Alias "SetWindowLongW" (ByVal hWnd As LongPtr, ByVal nIndex As Long, ByVal dwNewLong As LongPtr) As LongPtr
Private Declare PtrSafe Function GetWindowLongPtr Lib "user32" Alias "GetWindowLongW" (ByVal hWnd As LongPtr, ByVal nIndex As Long) As LongPtr
#End If
Private Declare PtrSafe Function SetWindowPos Lib "user32" (ByVal hWnd As LongPtr, ByVal hWndInsertAfter As LongPtr, ByVal X As Long, ByVal Y As Long, ByVal CX As Long, ByVal CY As Long, ByVal wFlags As Long) As Long
Private Declare PtrSafe Function SetTextColor Lib "gdi32" (ByVal hDC As LongPtr, ByVal crColor As Long) As Long
Private Declare PtrSafe Function GetTextColor Lib "gdi32" (ByVal hDC As LongPtr) As Long
Private Declare PtrSafe Function SetBkColor Lib "gdi32" (ByVal hDC As LongPtr, ByVal crColor As Long) As Long
Private Declare PtrSafe Function GetTextExtentPoint32 Lib "gdi32" Alias "GetTextExtentPoint32W" (ByVal hDC As LongPtr, ByVal lpsz As LongPtr, ByVal cbString As Long, ByRef lpSize As SIZEAPI) As Long
Private Declare PtrSafe Function GetDC Lib "user32" (ByVal hWnd As LongPtr) As LongPtr
Private Declare PtrSafe Function GetDeviceCaps Lib "gdi32" (ByVal hDC As LongPtr, ByVal nIndex As Long) As Long
Private Declare PtrSafe Function GetWindowDC Lib "user32" (ByVal hWnd As LongPtr) As LongPtr
Private Declare PtrSafe Function GetDCEx Lib "user32" (ByVal hWnd As LongPtr, ByVal hRgnClip As LongPtr, ByVal fdwOptions As Long) As LongPtr
Private Declare PtrSafe Function ReleaseDC Lib "user32" (ByVal hWnd As LongPtr, ByVal hDC As LongPtr) As Long
Private Declare PtrSafe Function GetTextMetrics Lib "gdi32" Alias "GetTextMetricsW" (ByVal hDC As LongPtr, ByRef lpMetrics As TEXTMETRIC) As Long
Private Declare PtrSafe Function GetDoubleClickTime Lib "user32" () As Long
Private Declare PtrSafe Function GetSystemMetrics Lib "user32" (ByVal nIndex As Long) As Long
Private Declare PtrSafe Function GetSysColorBrush Lib "user32" (ByVal nIndex As Long) As LongPtr
Private Declare PtrSafe Function GetSysColor Lib "user32" (ByVal nIndex As Long) As Long
Private Declare PtrSafe Function GetStockObject Lib "gdi32" (ByVal nIndex As Long) As LongPtr
Private Declare PtrSafe Function SystemParametersInfo Lib "user32" Alias "SystemParametersInfoW" (ByVal uAction As Long, ByVal uiParam As Long, ByVal lpvParam As LongPtr, ByVal fWinIni As Long) As Long
Private Declare PtrSafe Function SetBkMode Lib "gdi32" (ByVal hDC As LongPtr, ByVal nBkMode As Long) As Long
Private Declare PtrSafe Function SetTextAlign Lib "gdi32" (ByVal hDC As LongPtr, ByVal fMode As Long) As Long
Private Declare PtrSafe Function SetLayout Lib "gdi32" (ByVal hDC As LongPtr, ByVal dwLayout As Long) As Long
Private Declare PtrSafe Function BitBlt Lib "gdi32" (ByVal hDestDC As LongPtr, ByVal X As Long, ByVal Y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal hSrcDC As LongPtr, ByVal XSrc As Long, ByVal YSrc As Long, ByVal dwRop As Long) As Long
Private Declare PtrSafe Function PatBlt Lib "gdi32" (ByVal hDC As LongPtr, ByVal X As Long, ByVal Y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal dwRop As Long) As Long
Private Declare PtrSafe Function SetStretchBltMode Lib "gdi32" (ByVal hDC As LongPtr, ByVal nStretchMode As Long) As Long
Private Declare PtrSafe Function SetBrushOrgEx Lib "gdi32" (ByVal hDC As LongPtr, ByVal nXOrg As Long, ByVal nYOrg As Long, ByRef lpPoint As Any) As Long
Private Declare PtrSafe Function StretchBlt Lib "gdi32" (ByVal hDC As LongPtr, ByVal X As Long, ByVal Y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal hSrcDC As LongPtr, ByVal XSrc As Long, ByVal YSrc As Long, ByVal nSrcWidth As Long, ByVal nSrcHeight As Long, ByVal dwRop As Long) As Long
Private Declare PtrSafe Function GetDIBits Lib "gdi32" (ByVal hDC As LongPtr, ByVal hBmp As LongPtr, ByVal nStartScan As Long, ByVal nNumScans As Long, ByVal lpBits As LongPtr, ByRef pBitmapInfo As BITMAPINFO, ByVal wUsage As Long) As Long
Private Declare PtrSafe Function StretchDIBits Lib "gdi32" (ByVal hDC As LongPtr, ByVal X As Long, ByVal Y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal XSrc As Long, ByVal YSrc As Long, ByVal nSrcWidth As Long, ByVal nSrcHeight As Long, ByVal lpBits As LongPtr, ByRef pBitmapInfo As BITMAPINFO, ByVal wUsage As Long, ByVal dwRop As Long) As Long
Private Declare PtrSafe Function CreateCompatibleDC Lib "gdi32" (ByVal hDC As LongPtr) As LongPtr
Private Declare PtrSafe Function CreateCompatibleBitmap Lib "gdi32" (ByVal hDC As LongPtr, ByVal nWidth As Long, ByVal nHeight As Long) As LongPtr
Private Declare PtrSafe Function DeleteDC Lib "gdi32" (ByVal hDC As LongPtr) As Long
Private Declare PtrSafe Function ScreenToClient Lib "user32" (ByVal hWnd As LongPtr, ByRef lpPoint As POINTAPI) As Long
Private Declare PtrSafe Function ClientToScreen Lib "user32" (ByVal hWnd As LongPtr, ByRef lpPoint As POINTAPI) As Long
Private Declare PtrSafe Function SetScrollInfo Lib "user32" (ByVal hWnd As LongPtr, ByVal wBar As Long, ByRef lpScrollInfo As SCROLLINFO, ByVal fRedraw As Long) As Long
Private Declare PtrSafe Function GetScrollInfo Lib "user32" (ByVal hWnd As LongPtr, ByVal wBar As Long, ByRef lpScrollInfo As SCROLLINFO) As Long
Private Declare PtrSafe Function WindowFromPoint Lib "user32" (ByVal XY As Currency) As LongPtr
Private Declare PtrSafe Function ChildWindowFromPoint Lib "user32" (ByVal hWndParent As LongPtr, ByVal XY As Currency) As LongPtr
Private Declare PtrSafe Function LoadCursor Lib "user32" Alias "LoadCursorW" (ByVal hInstance As LongPtr, ByVal lpCursorName As Any) As LongPtr
Private Declare PtrSafe Function SetCursor Lib "user32" (ByVal hCursor As LongPtr) As LongPtr
Private Declare PtrSafe Function GetCursorPos Lib "user32" (ByRef lpPoint As POINTAPI) As Long
Private Declare PtrSafe Function GetCursor Lib "user32" () As LongPtr
Private Declare PtrSafe Function ClipCursor Lib "user32" (ByRef lpRect As Any) As Long
Private Declare PtrSafe Function GetCapture Lib "user32" () As LongPtr
Private Declare PtrSafe Function SetCapture Lib "user32" (ByVal hWnd As LongPtr) As LongPtr
Private Declare PtrSafe Function ReleaseCapture Lib "user32" () As Long
Private Declare PtrSafe Function ImageList_GetIconSize Lib "comctl32" (ByVal hImageList As LongPtr, ByRef CX As Long, ByRef CY As Long) As Long
Private Declare PtrSafe Function ImageList_GetImageCount Lib "comctl32" (ByVal hImageList As LongPtr) As Long
Private Declare PtrSafe Function ImageList_Draw Lib "comctl32" (ByVal hImageList As LongPtr, ByVal ImgIndex As Long, ByVal hDC As LongPtr, ByVal X As Long, ByVal Y As Long, ByVal fStyle As Long) As Long
Private Declare PtrSafe Function SetTimer Lib "user32" (ByVal hWnd As LongPtr, ByVal nIDEvent As LongPtr, ByVal uElapse As Long, ByVal lpTimerFunc As LongPtr) As LongPtr
Private Declare PtrSafe Function KillTimer Lib "user32" (ByVal hWnd As LongPtr, ByVal nIDEvent As LongPtr) As Long
Private Declare PtrSafe Function DragQueryFile Lib "shell32" Alias "DragQueryFileW" (ByVal hDrop As LongPtr, ByVal iFile As Long, ByVal lpszFile As LongPtr, ByVal cch As Long) As Long
Private Declare PtrSafe Function DragQueryPoint Lib "shell32" (ByVal hDrop As LongPtr, ByRef lpPoint As POINTAPI) As Long
Private Declare PtrSafe Function CreateEnhMetaFile Lib "gdi32" Alias "CreateEnhMetaFileW" (ByVal hDC As LongPtr, ByVal lpFileName As LongPtr, ByRef lpRect As RECT, ByVal lpDescription As LongPtr) As LongPtr
Private Declare PtrSafe Function CloseEnhMetaFile Lib "gdi32" (ByVal hDC As LongPtr) As LongPtr
Private Declare PtrSafe Function PlayEnhMetaFile Lib "gdi32" (ByVal hDC As LongPtr, ByVal hEMF As LongPtr, ByRef lpRect As RECT) As Long
Private Declare PtrSafe Function DeleteEnhMetaFile Lib "gdi32" (ByVal hEMF As LongPtr) As Long
#Else
Private Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (ByRef Destination As Any, ByRef Source As Any, ByVal Length As Long)
Private Declare Sub ZeroMemory Lib "kernel32" Alias "RtlZeroMemory" (ByRef Destination As Any, ByVal Length As Long)
Private Declare Sub PostQuitMessage Lib "user32" (ByVal nExitCode As Long)
Private Declare Sub DragAcceptFiles Lib "shell32" (ByVal hWnd As Long, ByVal fAccept As Long)
Private Declare Sub DragFinish Lib "shell32" (ByVal hDrop As Long)
Private Declare Sub VariantInit Lib "oleaut32" (ByRef pvarg As Any)
Private Declare Function VariantClear Lib "oleaut32" (ByRef pvarg As Any) As Long
Private Declare Function VariantCopy Lib "oleaut32" (ByRef pvargDest As Any, ByRef pvargSrc As Any) As Long
Private Declare Function CreateWindowEx Lib "user32" Alias "CreateWindowExW" (ByVal dwExStyle As Long, ByVal lpClassName As Long, ByVal lpWindowName As Long, ByVal dwStyle As Long, ByVal X As Long, ByVal Y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal hWndParent As Long, ByVal hMenu As Long, ByVal hInstance As Long, ByRef lpParam As Any) As Long
Private Declare Function HeapAlloc Lib "kernel32" (ByVal hHeap As Long, ByVal dwFlags As Long, ByVal dwBytes As Long) As Long
Private Declare Function HeapFree Lib "kernel32" (ByVal hHeap As Long, ByVal dwFlags As Long, ByVal lpMem As Long) As Long
Private Declare Function GetProcessHeap Lib "kernel32" () As Long
Private Declare Function SysAllocString Lib "oleaut32" (ByVal lpString As Long) As Long
Private Declare Function SysFreeString Lib "oleaut32" (ByVal lpString As Long) As Long
Private Declare Function SysReAllocString Lib "oleaut32" (ByVal pbString As Long, ByVal pszStrPtr As Long) As Long
Private Declare Function LCMapString Lib "kernel32" Alias "LCMapStringW" (ByVal LCID As Long, ByVal dwMapFlags As Long, ByVal lpSrcStr As Long, ByVal cchSrcStr As Long, ByVal lpDestStr As Long, ByVal cchDestStr As Long) As Long
Private Declare Function lstrcmp Lib "kernel32" Alias "lstrcmpW" (ByVal lpString1 As Long, ByVal lpString2 As Long) As Long
Private Declare Function lstrcmpi Lib "kernel32" Alias "lstrcmpiW" (ByVal lpString1 As Long, ByVal lpString2 As Long) As Long
Private Declare Function DispatchMessage Lib "user32" Alias "DispatchMessageW" (ByRef lpMsg As TMSG) As Long
Private Declare Function WaitMessage Lib "user32" () As Long
Private Declare Function SendMessage Lib "user32" Alias "SendMessageW" (ByVal hWnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByRef lParam As Any) As Long
Private Declare Function PeekMessage Lib "user32" Alias "PeekMessageW" (ByRef lpMsg As TMSG, ByVal hWnd As Long, ByVal wMsgFilterMin As Long, ByVal wMsgFilterMax As Long, ByVal wRemoveMsg As Long) As Long
Private Declare Function PostMessage Lib "user32" Alias "PostMessageW" (ByVal hWnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByRef lParam As Any) As Long
Private Declare Function DestroyWindow Lib "user32" (ByVal hWnd As Long) As Long
Private Declare Function DefWindowProc Lib "user32" Alias "DefWindowProcW" (ByVal hWnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
Private Declare Function SetParent Lib "user32" (ByVal hWndChild As Long, ByVal hWndNewParent As Long) As Long
Private Declare Function ShowWindow Lib "user32" (ByVal hWnd As Long, ByVal nCmdShow As Long) As Long
Private Declare Function MoveWindow Lib "user32" (ByVal hWnd As Long, ByVal X As Long, ByVal Y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal bRepaint As Long) As Long
Private Declare Function EnableWindow Lib "user32" (ByVal hWnd As Long, ByVal fEnable As Long) As Long
Private Declare Function IsWindowEnabled Lib "user32" (ByVal hWnd As Long) As Long
Private Declare Function IsWindowVisible Lib "user32" (ByVal hWnd As Long) As Long
Private Declare Function MonitorFromWindow Lib "user32" (ByVal hWnd As Long, ByVal dwFlags As Long) As Long
Private Declare Function GetMonitorInfo Lib "user32" Alias "GetMonitorInfoW" (ByVal hMonitor As Long, ByRef lpMI As MONITORINFO) As Long
Private Declare Function LBItemFromPt Lib "comctl32" (ByVal hLB As Long, ByVal XY As Currency, ByVal bAutoScroll As Long) As Long
Private Declare Function SetFocusAPI Lib "user32" Alias "SetFocus" (ByVal hWnd As Long) As Long
Private Declare Function GetFocus Lib "user32" () As Long
Private Declare Function BeginPaint Lib "user32" (ByVal hWnd As Long, ByRef lpPaint As PAINTSTRUCT) As Long
Private Declare Function EndPaint Lib "user32" (ByVal hWnd As Long, ByRef lpPaint As PAINTSTRUCT) As Long
Private Declare Function CreateRectRgn Lib "gdi32" (ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long) As Long
Private Declare Function ExtSelectClipRgn Lib "gdi32" (ByVal hDC As Long, ByVal hRgn As Long, ByVal fnMode As Long) As Long
Private Declare Function GetClipRgn Lib "gdi32" (ByVal hDC As Long, ByVal hRgn As Long) As Long
Private Declare Function IntersectClipRect Lib "gdi32" (ByVal hDC As Long, ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long) As Long
Private Declare Function RedrawWindow Lib "user32" (ByVal hWnd As Long, ByVal lprcUpdate As Long, ByVal hrgnUpdate As Long, ByVal fuRedraw As Long) As Long
Private Declare Function InvalidateRect Lib "user32" (ByVal hWnd As Long, ByRef lpRect As Any, ByVal bErase As Long) As Long
Private Declare Function UpdateWindow Lib "user32" (ByVal hWnd As Long) As Long
Private Declare Function TrackMouseEvent Lib "user32" (ByRef lpEventTrack As TRACKMOUSEEVENTSTRUCT) As Long
Private Declare Function GetKeyboardLayout Lib "user32" (ByVal dwThreadID As Long) As Long
Private Declare Function ImmIsIME Lib "imm32" (ByVal hKL As Long) As Long
Private Declare Function ImmCreateContext Lib "imm32" () As Long
Private Declare Function ImmDestroyContext Lib "imm32" (ByVal hIMC As Long) As Long
Private Declare Function ImmGetContext Lib "imm32" (ByVal hWnd As Long) As Long
Private Declare Function ImmReleaseContext Lib "imm32" (ByVal hWnd As Long, ByVal hIMC As Long) As Long
Private Declare Function ImmGetOpenStatus Lib "imm32" (ByVal hIMC As Long) As Long
Private Declare Function ImmSetOpenStatus Lib "imm32" (ByVal hIMC As Long, ByVal fOpen As Long) As Long
Private Declare Function ImmAssociateContext Lib "imm32" (ByVal hWnd As Long, ByVal hIMC As Long) As Long
Private Declare Function ImmGetConversionStatus Lib "imm32" (ByVal hIMC As Long, ByVal lpfdwConversion As Long, ByVal lpfdwSentence As Long) As Long
Private Declare Function ImmSetConversionStatus Lib "imm32" (ByVal hIMC As Long, ByVal fdwConversion As Long, ByVal fdwSentence As Long) As Long
Private Declare Function GetSystemDefaultLangID Lib "kernel32" () As Integer
Private Declare Function GetUserDefaultLangID Lib "kernel32" () As Integer
Private Declare Function GetUserDefaultUILanguage Lib "kernel32" () As Integer
Private Declare Function GetUserDefaultLCID Lib "kernel32" () As Long
Private Declare Function GetLocaleInfo Lib "kernel32" Alias "GetLocaleInfoW" (ByVal LCID As Long, ByVal LCType As Long, ByVal lpLCData As Long, ByVal cchData As Long) As Long
Private Declare Function GetMessagePos Lib "user32" () As Long
Private Declare Function GetClientRect Lib "user32" (ByVal hWnd As Long, ByRef lpRect As RECT) As Long
Private Declare Function GetWindowRect Lib "user32" (ByVal hWnd As Long, ByRef lpRect As RECT) As Long
Private Declare Function MapWindowPoints Lib "user32" (ByVal hWndFrom As Long, ByVal hWndTo As Long, ByRef lppt As Any, ByVal cPoints As Long) As Long
Private Declare Function SetViewportOrgEx Lib "gdi32" (ByVal hDC As Long, ByVal X As Long, ByVal Y As Long, ByRef lpPoint As POINTAPI) As Long
Private Declare Function SetRect Lib "user32" (ByRef lpRect As RECT, ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long) As Long
Private Declare Function CreateSolidBrush Lib "gdi32" (ByVal crColor As Long) As Long
Private Declare Function CreatePen Lib "gdi32" (ByVal nPenStyle As Long, ByVal nWidth As Long, ByVal crColor As Long) As Long
Private Declare Function Polyline Lib "gdi32" (ByVal hDC As Long, ByRef lpPoint As POINTAPI, ByVal nCount As Long) As Long
Private Declare Function Polygon Lib "gdi32" (ByVal hDC As Long, ByRef lpPoint As POINTAPI, ByVal nCount As Long) As Long
Private Declare Function Rectangle Lib "gdi32" (ByVal hDC As Long, ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long) As Long
Private Declare Function FillRect Lib "user32" (ByVal hDC As Long, ByRef lpRect As RECT, ByVal hBrush As Long) As Long
Private Declare Function InvertRect Lib "user32" (ByVal hDC As Long, ByRef lpRect As RECT) As Long
Private Declare Function DrawState Lib "user32" Alias "DrawStateW" (ByVal hDC As Long, ByVal hBrush As Long, ByVal lpDrawStateProc As Long, ByVal lData As Long, ByVal wData As Long, ByVal X As Long, ByVal Y As Long, ByVal CX As Long, ByVal CY As Long, ByVal fFlags As Long) As Long
Private Declare Function DrawFocusRect Lib "user32" (ByVal hDC As Long, ByRef lpRect As RECT) As Long
Private Declare Function DrawFrameControl Lib "user32" (ByVal hDC As Long, ByRef lpRect As RECT, ByVal nCtlType As Long, ByVal nFlags As Long) As Long
Private Declare Function DrawText Lib "user32" Alias "DrawTextW" (ByVal hDC As Long, ByVal lpchText As Long, ByVal nCount As Long, ByRef lpRect As RECT, ByVal uFormat As Long) As Long
Private Declare Function DrawTextEx Lib "user32" Alias "DrawTextExW" (ByVal hDC As Long, ByVal lpchText As Long, ByVal nCount As Long, ByRef lpRect As RECT, ByVal uFormat As Long, ByRef lpDrawTextParams As Any) As Long
Private Declare Function TextOut Lib "gdi32" Alias "TextOutW" (ByVal hDC As Long, ByVal X As Long, ByVal Y As Long, ByVal lpString As Long, ByVal nCount As Long) As Long
Private Declare Function ExtTextOut Lib "gdi32" Alias "ExtTextOutW" (ByVal hDC As Long, ByVal X As Long, ByVal Y As Long, ByVal wOptions As Long, ByRef lpRect As Any, ByVal lpString As Long, ByVal nCount As Long, ByVal lpDX As Long) As Long
Private Declare Function DeleteObject Lib "gdi32" (ByVal hObject As Long) As Long
Private Declare Function SelectObject Lib "gdi32" (ByVal hDC As Long, ByVal hObject As Long) As Long
Private Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongW" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Private Declare Function GetWindowLong Lib "user32" Alias "GetWindowLongW" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
Private Declare Function SetWindowLongPtr Lib "user32" Alias "SetWindowLongW" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Private Declare Function GetWindowLongPtr Lib "user32" Alias "GetWindowLongW" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
Private Declare Function SetWindowPos Lib "user32" (ByVal hWnd As Long, ByVal hWndInsertAfter As Long, ByVal X As Long, ByVal Y As Long, ByVal CX As Long, ByVal CY As Long, ByVal wFlags As Long) As Long
Private Declare Function SetTextColor Lib "gdi32" (ByVal hDC As Long, ByVal crColor As Long) As Long
Private Declare Function GetTextColor Lib "gdi32" (ByVal hDC As Long) As Long
Private Declare Function SetBkColor Lib "gdi32" (ByVal hDC As Long, ByVal crColor As Long) As Long
Private Declare Function GetTextExtentPoint32 Lib "gdi32" Alias "GetTextExtentPoint32W" (ByVal hDC As Long, ByVal lpsz As Long, ByVal cbString As Long, ByRef lpSize As SIZEAPI) As Long
Private Declare Function GetDC Lib "user32" (ByVal hWnd As Long) As Long
Private Declare Function GetDeviceCaps Lib "gdi32" (ByVal hDC As Long, ByVal nIndex As Long) As Long
Private Declare Function GetWindowDC Lib "user32" (ByVal hWnd As Long) As Long
Private Declare Function GetDCEx Lib "user32" (ByVal hWnd As Long, ByVal hRgnClip As Long, ByVal fdwOptions As Long) As Long
Private Declare Function ReleaseDC Lib "user32" (ByVal hWnd As Long, ByVal hDC As Long) As Long
Private Declare Function GetTextMetrics Lib "gdi32" Alias "GetTextMetricsW" (ByVal hDC As Long, ByRef lpMetrics As TEXTMETRIC) As Long
Private Declare Function GetDoubleClickTime Lib "user32" () As Long
Private Declare Function GetSystemMetrics Lib "user32" (ByVal nIndex As Long) As Long
Private Declare Function GetSysColorBrush Lib "user32" (ByVal nIndex As Long) As Long
Private Declare Function GetSysColor Lib "user32" (ByVal nIndex As Long) As Long
Private Declare Function GetStockObject Lib "gdi32" (ByVal nIndex As Long) As Long
Private Declare Function SystemParametersInfo Lib "user32" Alias "SystemParametersInfoW" (ByVal uAction As Long, ByVal uiParam As Long, ByVal lpvParam As Long, ByVal fWinIni As Long) As Long
Private Declare Function SetBkMode Lib "gdi32" (ByVal hDC As Long, ByVal nBkMode As Long) As Long
Private Declare Function SetTextAlign Lib "gdi32" (ByVal hDC As Long, ByVal fMode As Long) As Long
Private Declare Function SetLayout Lib "gdi32" (ByVal hDC As Long, ByVal dwLayout As Long) As Long
Private Declare Function BitBlt Lib "gdi32" (ByVal hDestDC As Long, ByVal X As Long, ByVal Y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal hSrcDC As Long, ByVal XSrc As Long, ByVal YSrc As Long, ByVal dwRop As Long) As Long
Private Declare Function PatBlt Lib "gdi32" (ByVal hDC As Long, ByVal X As Long, ByVal Y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal dwRop As Long) As Long
Private Declare Function SetStretchBltMode Lib "gdi32" (ByVal hDC As Long, ByVal nStretchMode As Long) As Long
Private Declare Function SetBrushOrgEx Lib "gdi32" (ByVal hDC As Long, ByVal nXOrg As Long, ByVal nYOrg As Long, ByRef lpPoint As Any) As Long
Private Declare Function StretchBlt Lib "gdi32" (ByVal hDC As Long, ByVal X As Long, ByVal Y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal hSrcDC As Long, ByVal XSrc As Long, ByVal YSrc As Long, ByVal nSrcWidth As Long, ByVal nSrcHeight As Long, ByVal dwRop As Long) As Long
Private Declare Function GetDIBits Lib "gdi32" (ByVal hDC As Long, ByVal hBmp As Long, ByVal nStartScan As Long, ByVal nNumScans As Long, ByVal lpBits As Long, ByRef pBitmapInfo As BITMAPINFO, ByVal wUsage As Long) As Long
Private Declare Function StretchDIBits Lib "gdi32" (ByVal hDC As Long, ByVal X As Long, ByVal Y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal XSrc As Long, ByVal YSrc As Long, ByVal nSrcWidth As Long, ByVal nSrcHeight As Long, ByVal lpBits As Long, ByRef pBitmapInfo As BITMAPINFO, ByVal wUsage As Long, ByVal dwRop As Long) As Long
Private Declare Function CreateCompatibleDC Lib "gdi32" (ByVal hDC As Long) As Long
Private Declare Function CreateCompatibleBitmap Lib "gdi32" (ByVal hDC As Long, ByVal nWidth As Long, ByVal nHeight As Long) As Long
Private Declare Function DeleteDC Lib "gdi32" (ByVal hDC As Long) As Long
Private Declare Function ScreenToClient Lib "user32" (ByVal hWnd As Long, ByRef lpPoint As POINTAPI) As Long
Private Declare Function ClientToScreen Lib "user32" (ByVal hWnd As Long, ByRef lpPoint As POINTAPI) As Long
Private Declare Function SetScrollInfo Lib "user32" (ByVal hWnd As Long, ByVal wBar As Long, ByRef lpScrollInfo As SCROLLINFO, ByVal fRedraw As Long) As Long
Private Declare Function GetScrollInfo Lib "user32" (ByVal hWnd As Long, ByVal wBar As Long, ByRef lpScrollInfo As SCROLLINFO) As Long
Private Declare Function WindowFromPoint Lib "user32" (ByVal XY As Currency) As Long
Private Declare Function ChildWindowFromPoint Lib "user32" (ByVal hWndParent As Long, ByVal XY As Currency) As Long
Private Declare Function LoadCursor Lib "user32" Alias "LoadCursorW" (ByVal hInstance As Long, ByVal lpCursorName As Any) As Long
Private Declare Function SetCursor Lib "user32" (ByVal hCursor As Long) As Long
Private Declare Function GetCursorPos Lib "user32" (ByRef lpPoint As POINTAPI) As Long
Private Declare Function GetCursor Lib "user32" () As Long
Private Declare Function ClipCursor Lib "user32" (ByRef lpRect As Any) As Long
Private Declare Function GetCapture Lib "user32" () As Long
Private Declare Function SetCapture Lib "user32" (ByVal hWnd As Long) As Long
Private Declare Function ReleaseCapture Lib "user32" () As Long
Private Declare Function ImageList_GetIconSize Lib "comctl32" (ByVal hImageList As Long, ByRef CX As Long, ByRef CY As Long) As Long
Private Declare Function ImageList_GetImageCount Lib "comctl32" (ByVal hImageList As Long) As Long
Private Declare Function ImageList_Draw Lib "comctl32" (ByVal hImageList As Long, ByVal ImgIndex As Long, ByVal hDC As Long, ByVal X As Long, ByVal Y As Long, ByVal fStyle As Long) As Long
Private Declare Function SetTimer Lib "user32" (ByVal hWnd As Long, ByVal nIDEvent As Long, ByVal uElapse As Long, ByVal lpTimerFunc As Long) As Long
Private Declare Function KillTimer Lib "user32" (ByVal hWnd As Long, ByVal nIDEvent As Long) As Long
Private Declare Function DragQueryFile Lib "shell32" Alias "DragQueryFileW" (ByVal hDrop As Long, ByVal iFile As Long, ByVal lpszFile As Long, ByVal cch As Long) As Long
Private Declare Function DragQueryPoint Lib "shell32" (ByVal hDrop As Long, ByRef lpPoint As POINTAPI) As Long
Private Declare Function CreateEnhMetaFile Lib "gdi32" Alias "CreateEnhMetaFileW" (ByVal hDC As Long, ByVal lpFileName As Long, ByRef lpRect As RECT, ByVal lpDescription As Long) As Long
Private Declare Function CloseEnhMetaFile Lib "gdi32" (ByVal hDC As Long) As Long
Private Declare Function PlayEnhMetaFile Lib "gdi32" (ByVal hDC As Long, ByVal hEMF As Long, ByRef lpRect As RECT) As Long
Private Declare Function DeleteEnhMetaFile Lib "gdi32" (ByVal hEMF As Long) As Long
#End If

#If ImplementThemedControls = True Then

Private Enum UxThemeComboBoxParts
CP_DROPDOWNBUTTON = 1
End Enum
Private Enum UxThemeButtonParts
BP_PUSHBUTTON = 1
BP_CHECKBOX = 3
End Enum
Private Enum UxThemeComboBoxStates
CBXS_NORMAL = 1
CBXS_HOT = 2
CBXS_PRESSED = 3
CBXS_DISABLED = 4
End Enum
Private Enum UxThemeButtonStates
PBS_NORMAL = 1
PBS_HOT = 2
PBS_PRESSED = 3
PBS_DISABLED = 4
End Enum
Private Enum UxThemeCheckBoxStates
CBS_UNCHECKEDNORMAL = 1
CBS_UNCHECKEDHOT = 2
CBS_UNCHECKEDPRESSED = 3
CBS_UNCHECKEDDISABLED = 4
CBS_CHECKEDNORMAL = 5
CBS_CHECKEDHOT = 6
CBS_CHECKEDPRESSED = 7
CBS_CHECKEDDISABLED = 8
CBS_MIXEDNORMAL = 9
CBS_MIXEDHOT = 10
CBS_MIXEDPRESSED = 11
CBS_MIXEDDISABLED = 12
End Enum
#If VBA7 Then
Private Declare PtrSafe Function IsThemeBackgroundPartiallyTransparent Lib "uxtheme" (ByVal Theme As LongPtr, ByVal iPartId As Long, ByVal iStateId As Long) As Long
Private Declare PtrSafe Function DrawThemeParentBackground Lib "uxtheme" (ByVal hWnd As LongPtr, ByVal hDC As LongPtr, ByRef pRect As RECT) As Long
Private Declare PtrSafe Function DrawThemeBackground Lib "uxtheme" (ByVal Theme As LongPtr, ByVal hDC As LongPtr, ByVal iPartId As Long, ByVal iStateId As Long, ByRef pRect As RECT, ByRef pClipRect As Any) As Long
Private Declare PtrSafe Function GetThemeBackgroundContentRect Lib "uxtheme" (ByVal Theme As LongPtr, ByVal hDC As LongPtr, ByVal iPartId As Long, ByVal iStateId As Long, ByRef pBoundingRect As RECT, ByRef pContentRect As RECT) As Long
Private Declare PtrSafe Function OpenThemeData Lib "uxtheme" (ByVal hWnd As LongPtr, ByVal lpszClassList As LongPtr) As LongPtr
Private Declare PtrSafe Function CloseThemeData Lib "uxtheme" (ByVal Theme As LongPtr) As Long
#Else
Private Declare Function IsThemeBackgroundPartiallyTransparent Lib "uxtheme" (ByVal Theme As Long, ByVal iPartId As Long, ByVal iStateId As Long) As Long
Private Declare Function DrawThemeParentBackground Lib "uxtheme" (ByVal hWnd As Long, ByVal hDC As Long, ByRef pRect As RECT) As Long
Private Declare Function DrawThemeBackground Lib "uxtheme" (ByVal Theme As Long, ByVal hDC As Long, ByVal iPartId As Long, ByVal iStateId As Long, ByRef pRect As RECT, ByRef pClipRect As Any) As Long
Private Declare Function GetThemeBackgroundContentRect Lib "uxtheme" (ByVal Theme As Long, ByVal hDC As Long, ByVal iPartId As Long, ByVal iStateId As Long, ByRef pBoundingRect As RECT, ByRef pContentRect As RECT) As Long
Private Declare Function OpenThemeData Lib "uxtheme" (ByVal hWnd As Long, ByVal lpszClassList As Long) As Long
Private Declare Function CloseThemeData Lib "uxtheme" (ByVal Theme As Long) As Long
#End If

#End If

Private Const ICC_STANDARD_CLASSES As Long = &H4000
Private Const ICC_TAB_CLASSES As Long = &H8
Private Const ICC_DATE_CLASSES As Long = &H100
Private Const ID_EDITCHILD As Long = 100, ID_COMBOBUTTONCHILD As Long = 101
#If VBA7 Then
Const IDT_MULTISELCHANGE As LongPtr = 100
#Else
Const IDT_MULTISELCHANGE As Long = 100
#End If
Private Const RDW_UPDATENOW As Long = &H100, RDW_INVALIDATE As Long = &H1, RDW_ERASE As Long = &H4, RDW_ALLCHILDREN As Long = &H80, RDW_FRAME As Long = &H400
Private Const SWP_FRAMECHANGED As Long = &H20
Private Const SWP_DRAWFRAME As Long = SWP_FRAMECHANGED
Private Const SWP_NOMOVE As Long = &H2
Private Const SWP_NOOWNERZORDER As Long = &H200
Private Const SWP_NOSIZE As Long = &H1
Private Const SWP_NOZORDER As Long = &H4
Private Const SWP_NOACTIVATE As Long = &H10
Private Const SWP_SHOWWINDOW As Long = &H40
Private Const SWP_NOCOPYBITS As Long = &H100
Private Const PAGE_READWRITE As Long = 4
Private Const MEM_COMMIT As Long = &H1000
Private Const MEM_RELEASE As Long = &H8000&
#If VBA7 Then
Private Const HWND_DESKTOP As LongPtr = &H0
#Else
Private Const HWND_DESKTOP As Long = &H0
#End If
Private Const COLOR_WINDOW As Long = 5
Private Const COLOR_WINDOWTEXT As Long = 8
Private Const COLOR_HIGHLIGHT As Long = 13
Private Const COLOR_HIGHLIGHTTEXT As Long = 14
Private Const COLOR_BTNFACE As Long = 15
Private Const COLOR_GRAYTEXT As Long = 17
Private Const COLOR_BTNTEXT As Long = 18
Private Const COLOR_HOTLIGHT As Long = 26
Private Const SYSTEM_FONT As Long = 13
Private Const MONITOR_DEFAULTTOPRIMARY As Long = &H1
Private Const DCX_WINDOW As Long = &H1
Private Const DCX_INTERSECTRGN As Long = &H80
Private Const DCX_USESTYLE As Long = &H10000
Private Const MK_SHIFT As Long = &H4
Private Const MK_CONTROL As Long = &H8
Private Const TME_LEAVE As Long = &H2
Private Const TME_NONCLIENT As Long = &H10
Private Const ODA_DRAWENTIRE As Long = &H1
Private Const ODS_SELECTED As Long = &H1
Private Const ODS_GRAYED As Long = &H2
Private Const ODS_DISABLED As Long = &H4
Private Const ODS_CHECKED As Long = &H8
Private Const ODS_FOCUS As Long = &H10
Private Const ODS_HOTLIGHT As Long = &H40
Private Const ODS_NOFOCUSRECT As Long = &H200
Private Const PS_SOLID As Long = 0
Private Const PS_DASH As Long = 1
Private Const PS_DOT As Long = 2
Private Const PS_INSIDEFRAME As Long = 6
Private Const NULL_BRUSH As Long = 5
Private Const STRETCH_HALFTONE As Long = 4
Private Const DIB_RGB_COLORS As Long = 0
Private Const HORZSIZE As Long = 4
Private Const VERTSIZE As Long = 6
Private Const HORZRES As Long = 8
Private Const VERTRES As Long = 10
Private Const LOGPIXELSX As Long = 88
Private Const LOGPIXELSY As Long = 90
Private Const RASTERCAPS As Long = 38, RC_STRETCHBLT As Long = &H800
Private Const SB_HORZ As Long = 0
Private Const SB_VERT As Long = 1
Private Const SB_LINELEFT As Long = 0
Private Const SB_LINEUP As Long = 0
Private Const SB_LINERIGHT As Long = 1
Private Const SB_LINEDOWN As Long = 1
Private Const SB_PAGELEFT As Long = 2
Private Const SB_PAGEUP As Long = 2
Private Const SB_PAGERIGHT As Long = 3
Private Const SB_PAGEDOWN As Long = 3
Private Const SB_THUMBPOSITION As Long = 4
Private Const SB_THUMBTRACK As Long = 5
Private Const SB_TOP As Long = 6
Private Const SB_BOTTOM As Long = 7
Private Const SM_CXVSCROLL As Long = 2
Private Const SM_CYHSCROLL As Long = 3
Private Const SM_CYVSCROLL As Long = 20
Private Const SM_CXHSCROLL As Long = 21
Private Const SM_CXBORDER As Long = 5
Private Const SM_CYBORDER As Long = 6
Private Const SM_CXEDGE As Long = 45
Private Const SM_CYEDGE As Long = 46
Private Const SM_CXDRAG As Long = 68
Private Const SM_CYDRAG As Long = 69
Private Const SM_XVIRTUALSCREEN As Long = 76
Private Const SM_YVIRTUALSCREEN As Long = 77
Private Const SM_CXVIRTUALSCREEN As Long = 78
Private Const SM_CYVIRTUALSCREEN As Long = 79
Private Const SIF_RANGE As Long = &H1
Private Const SIF_PAGE As Long = &H2
Private Const SIF_POS As Long = &H4
Private Const SIF_DISABLENOSCROLL As Long = &H8
Private Const SIF_TRACKPOS As Long = &H10
Private Const SIF_ALL As Long = (SIF_RANGE Or SIF_PAGE Or SIF_POS Or SIF_TRACKPOS)
Private Const SPI_GETWHEELSCROLLLINES As Long = &H68
Private Const SPI_GETFOCUSBORDERHEIGHT As Long = &H2010
Private Const SPI_GETFOCUSBORDERWIDTH As Long = &H200E
Private Const RGN_DIFF As Long = 4
Private Const RGN_COPY As Long = 5
Private Const DST_ICON As Long = &H3
Private Const DST_BITMAP As Long = &H4
Private Const DSS_DISABLED As Long = &H20
Private Const DT_NOPREFIX As Long = &H800
Private Const DT_RTLREADING As Long = &H20000
Private Const DT_LEFT As Long = &H0
Private Const DT_CENTER As Long = &H1
Private Const DT_RIGHT As Long = &H2
Private Const DT_VCENTER As Long = &H4
Private Const DT_BOTTOM As Long = &H8
Private Const DT_WORDBREAK As Long = &H10
Private Const DT_SINGLELINE As Long = &H20
Private Const DT_EDITCONTROL As Long = &H2000
Private Const DT_PATH_ELLIPSIS As Long = &H4000
Private Const DT_END_ELLIPSIS As Long = &H8000&
Private Const DT_WORD_ELLIPSIS As Long = &H40000
Private Const DT_CALCRECT As Long = &H400
Private Const ETO_OPAQUE As Long = 2
Private Const ETO_CLIPPED As Long = 4
Private Const TA_RTLREADING As Long = &H100
Private Const TA_RIGHT As Long = &H2
Private Const TA_CENTER As Long = &H6
Private Const TA_BASELINE As Long = &H18
Private Const GWL_STYLE As Long = (-16)
Private Const GWL_EXSTYLE As Long = (-20)
Private Const GWL_USERDATA As Long = (-21)
Private Const LAYOUT_RTL As Long = &H1
Private Const EM_SETREADONLY As Long = &HCF, ES_READONLY As Long = &H800
Private Const EM_GETSEL As Long = &HB0
Private Const EM_SETSEL As Long = &HB1
Private Const EM_REPLACESEL As Long = &HC2
Private Const EM_GETLIMITTEXT As Long = &HD5
Private Const EM_LIMITTEXT As Long = &HC5
Private Const EM_SETLIMITTEXT As Long = EM_LIMITTEXT
Private Const EM_LINEINDEX As Long = &HBB
Private Const EM_LINELENGTH As Long = &HC1
Private Const EM_LINEFROMCHAR As Long = &HC9
Private Const EM_GETLINECOUNT As Long = &HBA
Private Const EM_GETMARGINS As Long = &HD4
Private Const EM_SETMARGINS As Long = &HD3
Private Const EN_CHANGE As Long = &H300
Private Const ES_LEFT As Long = &H0
Private Const ES_CENTER As Long = &H1
Private Const ES_RIGHT As Long = &H2
Private Const ES_MULTILINE As Long = &H4
Private Const ES_AUTOVSCROLL As Long = &H40
Private Const ES_AUTOHSCROLL As Long = &H80
Private Const EC_LEFTMARGIN As Long = &H1
Private Const EC_RIGHTMARGIN As Long = &H2
Private Const SS_OWNERDRAW As Long = &HD
Private Const SS_NOTIFY As Long = &H100
Private Const STN_CLICKED As Long = &H0
Private Const STN_DBLCLK As Long = &H1
Private Const STN_ENABLE As Long = &H2
Private Const STN_DISABLE As Long = &H3
Private Const LB_ERR As Long = (-1)
Private Const LB_ADDSTRING As Long = &H180
Private Const LB_INSERTSTRING As Long = &H181
Private Const LB_SETCURSEL As Long = &H186
Private Const LB_GETCURSEL As Long = &H188
Private Const LB_GETTEXT As Long = &H189
Private Const LB_GETTEXTLEN As Long = &H18A
Private Const LB_GETCOUNT As Long = &H18B
Private Const LB_SETITEMHEIGHT As Long = &H1A0
Private Const LB_GETITEMHEIGHT As Long = &H1A1
Private Const LB_FINDSTRINGEXACT As Long = &H1A2
Private Const LB_CARETON As Long = &H1A3 ' Undocumented
Private Const LBS_NOTIFY As Long = &H1
Private Const LBS_SORT As Long = &H2
Private Const LBS_OWNERDRAWFIXED As Long = &H10
Private Const LBS_HASSTRINGS As Long = &H40
Private Const LBS_NOINTEGRALHEIGHT As Long = &H100
Private Const LBN_SELCHANGE As Long = 1
Private Const MCM_FIRST As Long = &H1000
Private Const MCM_GETCURSEL As Long = (MCM_FIRST + 1)
Private Const MCM_SETCURSEL As Long = (MCM_FIRST + 2)
Private Const MCM_GETMINREQRECT As Long = (MCM_FIRST + 9)
Private Const MCM_GETRANGE As Long = (MCM_FIRST + 17)
Private Const MCM_SETRANGE As Long = (MCM_FIRST + 18)
Private Const MCM_GETMAXTODAYWIDTH As Long = (MCM_FIRST + 21)
Private Const MCM_SETCALENDARBORDER As Long = (MCM_FIRST + 30)
Private Const MCN_FIRST As Long = (-750)
Private Const MCN_SELECT As Long = (MCN_FIRST + 4)
Private Const GDTR_MIN As Long = 1
Private Const GDTR_MAX As Long = 2
Private Const DFC_SCROLL As Long = &H3, DFCS_SCROLLCOMBOBOX As Long = &H5
Private Const DFC_BUTTON As Long = &H4, DFCS_BUTTONCHECK As Long = &H0, DFCS_BUTTONPUSH As Long = &H10
Private Const DFCS_INACTIVE As Long = &H100
Private Const DFCS_PUSHED As Long = &H200
Private Const DFCS_CHECKED As Long = &H400
Private Const DFCS_HOT As Long = &H1000
Private Const DFCS_ADJUSTRECT As Long = &H2000
Private Const DFCS_FLAT As Long = &H4000
Private Const ILD_TRANSPARENT As Long = &H1
Private Const WS_BORDER As Long = &H800000
Private Const WS_DLGFRAME As Long = &H400000
Private Const WS_EX_TRANSPARENT As Long = &H20
Private Const WS_EX_CLIENTEDGE As Long = &H200
Private Const WS_EX_STATICEDGE As Long = &H20000
Private Const WS_EX_WINDOWEDGE As Long = &H100
Private Const WS_EX_NOINHERITLAYOUT As Long = &H100000
Private Const WS_VISIBLE As Long = &H10000000
Private Const WS_CHILD As Long = &H40000000
Private Const WS_CLIPCHILDREN As Long = &H2000000
Private Const WS_CLIPSIBLINGS As Long = &H4000000
Private Const WS_POPUP As Long = &H80000000
Private Const WS_EX_TOOLWINDOW As Long = &H80
Private Const WS_EX_TOPMOST As Long = &H8
Private Const WS_EX_ACCEPTFILES As Long = &H10
Private Const WS_EX_LAYOUTRTL As Long = &H400000, WS_EX_RTLREADING As Long = &H2000, WS_EX_RIGHT As Long = &H1000, WS_EX_LEFTSCROLLBAR As Long = &H4000
Private Const WS_HSCROLL As Long = &H100000
Private Const WS_VSCROLL As Long = &H200000
Private Const WM_NOTIFY As Long = &H4E
Private Const WM_NOTIFYFORMAT As Long = &H55
Private Const WM_MOUSEACTIVATE As Long = &H21, MA_ACTIVATE As Long = &H1, MA_ACTIVATEANDEAT As Long = &H2, MA_NOACTIVATE As Long = &H3, MA_NOACTIVATEANDEAT As Long = &H4
Private Const WM_SETTINGCHANGE As Long = &H1A
Private Const WM_MOUSEWHEEL As Long = &H20A
Private Const WM_MOUSEHWHEEL As Long = &H20E
Private Const SW_HIDE As Long = &H0
Private Const SW_SHOW As Long = &H5
Private Const SW_SHOWNA As Long = &H8
Private Const WM_SETFOCUS As Long = &H7
Private Const WM_KILLFOCUS As Long = &H8
Private Const WM_SHOWWINDOW As Long = &H18
Private Const WM_COMMAND As Long = &H111
Private Const WM_THEMECHANGED As Long = &H31A
Private Const WM_KEYDOWN As Long = &H100
Private Const WM_KEYUP As Long = &H101
Private Const WM_CHAR As Long = &H102
Private Const WM_SYSKEYDOWN As Long = &H104
Private Const WM_SYSKEYUP As Long = &H105
Private Const WM_UNICHAR As Long = &H109, UNICODE_NOCHAR As Long = &HFFFF&
Private Const WM_INPUTLANGCHANGE As Long = &H51
Private Const WM_IME_SETCONTEXT As Long = &H281
Private Const WM_IME_CHAR As Long = &H286
Private Const WM_NCLBUTTONDOWN As Long = &HA1
Private Const WM_LBUTTONDOWN As Long = &H201
Private Const WM_LBUTTONUP As Long = &H202
Private Const WM_MBUTTONDOWN As Long = &H207
Private Const WM_MBUTTONUP As Long = &H208
Private Const WM_RBUTTONDOWN As Long = &H204
Private Const WM_RBUTTONUP As Long = &H205
Private Const WM_LBUTTONDBLCLK As Long = &H203
Private Const WM_MBUTTONDBLCLK As Long = &H209
Private Const WM_RBUTTONDBLCLK As Long = &H206
Private Const WM_MOUSEMOVE As Long = &H200
Private Const WM_MOUSELEAVE As Long = &H2A3
Private Const WM_CANCELMODE As Long = &H1F
Private Const WM_CAPTURECHANGED As Long = &H215
Private Const WM_DROPFILES As Long = &H233
Private Const WM_HSCROLL As Long = &H114
Private Const WM_VSCROLL As Long = &H115
Private Const WM_CONTEXTMENU As Long = &H7B
Private Const WM_STYLECHANGED As Long = &H7D
Private Const WM_SETFONT As Long = &H30
Private Const WM_GETFONT As Long = &H31
Private Const WM_SETREDRAW As Long = &HB
Private Const WM_SIZE As Long = &H5
Private Const WM_QUIT As Long = &H12
Private Const WM_TIMER As Long = &H113
Private Const WM_SETCURSOR As Long = &H20
Private Const WM_CTLCOLOREDIT As Long = &H133
Private Const WM_CTLCOLORSTATIC As Long = &H138
Private Const WM_GETTEXTLENGTH As Long = &HE
Private Const WM_GETTEXT As Long = &HD
Private Const WM_SETTEXT As Long = &HC
Private Const WM_ERASEBKGND As Long = &H14
Private Const WM_PAINT As Long = &HF
Private Const WM_PRINTCLIENT As Long = &H318
Private Const WM_NCCALCSIZE As Long = &H83
Private Const WM_NCHITTEST As Long = &H84, HTCLIENT As Long = 1, HTHSCROLL As Long = 6, HTVSCROLL As Long = 7, HTBORDER As Long = 18
Private Const WM_NCPAINT As Long = &H85
Private Const WM_NCMOUSEMOVE As Long = &HA0
Private Const WM_NCMOUSELEAVE As Long = &H2A2
Private Const WM_DRAWITEM As Long = &H2B, ODT_LISTBOX As Long = &H2, ODT_COMBOBOX As Long = &H3, ODT_BUTTON As Long = &H4, ODT_STATIC As Long = &H5
Private Const WM_USER As Long = &H400
Private Const VP_FORMATRANGE As Long = (WM_USER + 125), VP_YES As Long = 456654
Private Const UM_CAPTURECHANGED As Long = (WM_USER + 1000)
Private Const UM_ENDINCREMENTALSEARCH As Long = (WM_USER + 1001)
Private Const TTM_ADDTOOLA As Long = (WM_USER + 4)
Private Const TTM_ADDTOOLW As Long = (WM_USER + 50)
Private Const TTM_ADDTOOL As Long = TTM_ADDTOOLW
Private Const TTM_NEWTOOLRECTA As Long = (WM_USER + 6)
Private Const TTM_NEWTOOLRECTW As Long = (WM_USER + 52)
Private Const TTM_NEWTOOLRECT As Long = TTM_NEWTOOLRECTW
Private Const TTM_GETTOOLINFOA As Long = (WM_USER + 8)
Private Const TTM_GETTOOLINFOW As Long = (WM_USER + 53)
Private Const TTM_GETTOOLINFO As Long = TTM_GETTOOLINFOW
Private Const TTM_SETTOOLINFOA As Long = (WM_USER + 9)
Private Const TTM_SETTOOLINFOW As Long = (WM_USER + 54)
Private Const TTM_SETTOOLINFO As Long = TTM_SETTOOLINFOW
Private Const TTM_GETTEXTA As Long = (WM_USER + 11)
Private Const TTM_GETTEXTW As Long = (WM_USER + 56)
Private Const TTM_GETTEXT As Long = TTM_GETTEXTW
Private Const TTM_UPDATETIPTEXTA As Long = (WM_USER + 12)
Private Const TTM_UPDATETIPTEXTW As Long = (WM_USER + 57)
Private Const TTM_UPDATETIPTEXT As Long = TTM_UPDATETIPTEXTW
Private Const TTM_GETTOOLCOUNT As Long = (WM_USER + 13)
Private Const TTM_ENUMTOOLSA As Long = (WM_USER + 14)
Private Const TTM_ENUMTOOLSW As Long = (WM_USER + 58)
Private Const TTM_ENUMTOOLS As Long = TTM_ENUMTOOLSW
Private Const TTM_TRACKACTIVATE As Long = (WM_USER + 17)
Private Const TTM_TRACKPOSITION As Long = (WM_USER + 18)
Private Const TTM_SETMAXTIPWIDTH As Long = (WM_USER + 24)
Private Const TTM_POP As Long = (WM_USER + 28)
Private Const TTM_UPDATE As Long = (WM_USER + 29)
Private Const TTM_ADJUSTRECT As Long = (WM_USER + 31)
#If VBA7 Then
Private Const LPSTR_TEXTCALLBACK As LongPtr = (-1)
#Else
Private Const LPSTR_TEXTCALLBACK As Long = (-1)
#End If
Private Const INFOTIPSIZE As Long = 1024
Private Const NM_FIRST As Long = 0
Private Const NM_CUSTOMDRAW As Long = (NM_FIRST - 12)
Private Const TTF_RTLREADING As Long = &H4
Private Const TTF_SUBCLASS As Long = &H10
Private Const TTF_TRACK As Long = &H20
Private Const TTF_TRANSPARENT As Long = &H100
Private Const TTF_PARSELINKS As Long = &H1000
Private Const TTS_ALWAYSTIP As Long = &H1
Private Const TTS_NOPREFIX As Long = &H2
Private Const TTN_FIRST As Long = (-520)
Private Const TTN_GETDISPINFOA As Long = (TTN_FIRST - 0)
Private Const TTN_GETDISPINFOW As Long = (TTN_FIRST - 10)
Private Const TTN_GETDISPINFO As Long = TTN_GETDISPINFOW
Private Const TTN_SHOW As Long = (TTN_FIRST - 1)
Implements OLEGuids.IObjectSafety
Implements OLEGuids.IOleInPlaceActiveObjectVB
Implements OLEGuids.IOleControlVB
Private VBFlexGridHandle As LongPtr, VBFlexGridToolTipHandle As LongPtr, VBFlexGridScrollTipHandle As LongPtr
Private VBFlexGridEditHandle As LongPtr, VBFlexGridComboButtonHandle As LongPtr, VBFlexGridComboListHandle As LongPtr, VBFlexGridComboCalendarHandle As LongPtr
Private VBFlexGridDoubleBufferDC As LongPtr, VBFlexGridDoubleBufferBmp As LongPtr, VBFlexGridDoubleBufferBmpOld As LongPtr
Private VBFlexGridFontHandle As LongPtr, VBFlexGridFontFixedHandle As LongPtr, VBFlexGridFontToolTipHandle As LongPtr
Private VBFlexGridClientRect As RECT
Private VBFlexGridIMCHandle As LongPtr
Private VBFlexGridBackColorBrush As LongPtr
Private VBFlexGridBackColorAltBrush As LongPtr
Private VBFlexGridBackColorBkgBrush As LongPtr
Private VBFlexGridBackColorFixedBrush As LongPtr
Private VBFlexGridBackColorSelBrush As LongPtr
Private VBFlexGridFocusRectPen As LongPtr
Private VBFlexGridGridLinePen As LongPtr, VBFlexGridPenStyle As Long
Private VBFlexGridGridLineFixedPen As LongPtr, VBFlexGridFixedPenStyle As Long
Private VBFlexGridGridLineFrozenPen As LongPtr, VBFlexGridFrozenPenStyle As Long
Private VBFlexGridGridLineWhitePen As LongPtr, VBFlexGridGridLineBlackPen As LongPtr
Private VBFlexGridIndirectCellRef As TINDIRECTCELLREF
Private VBFlexGridCells As TROWS, VBFlexGridCellsInit As Boolean
Private VBFlexGridColsInfo() As TCOLINFO
Private VBFlexGridPixelMetrics As TPIXELMETRICS
Private VBFlexGridDrawInfo As TDRAWINFO
Private VBFlexGridMergeDrawInfo As TMERGEDRAWINFO
Private VBFlexGridDefaultCell As TCELL
Private VBFlexGridDefaultCellFmtg As TCELLFMTG, VBFlexGridDefaultLpCellFmtg As TLPCELLFMTG
Private VBFlexGridDefaultRowInfo As TROWINFO
Private VBFlexGridDefaultColInfo As TCOLINFO
Private VBFlexGridDefaultCols As TCOLS
Private VBFlexGridDefaultRowHeight As Long
Private VBFlexGridDefaultColWidth As Long
Private VBFlexGridDefaultFixedRowHeight As Long
Private VBFlexGridDefaultFixedColWidth As Long
Private VBFlexGridUniformRowHeight As Long
Private VBFlexGridRow As Long, VBFlexGridCol As Long
Private VBFlexGridRowSel As Long, VBFlexGridColSel As Long
Private VBFlexGridTopRow As Long, VBFlexGridLeftCol As Long
Private VBFlexGridDoDragRow As Long, VBFlexGridDoDragCol As Long
Private VBFlexGridDoDragRowCol As Boolean
Private VBFlexGridCapturePoint As POINTAPI
Private VBFlexGridCaptureRow As Long, VBFlexGridCaptureCol As Long
Private VBFlexGridCaptureHitResult As FlexHitResultConstants
Private VBFlexGridCaptureDividerRow As Long, VBFlexGridCaptureDividerCol As Long
Private VBFlexGridCaptureDividerDrag As Boolean
Private VBFlexGridCaptureDividerMoved As Boolean
Private VBFlexGridToolTipRow As Long, VBFlexGridToolTipCol As Long
Private VBFlexGridToolTipHitResult As FlexHitResultConstants
Private VBFlexGridScrollTipTrack As Boolean
Private VBFlexGridMouseMoveRow As Long, VBFlexGridMouseMoveCol As Long
Private VBFlexGridMouseMoveChanged As Boolean
Private VBFlexGridDividerDragSplitterRect As RECT
Private VBFlexGridDividerDragOffset As POINTAPI
Private VBFlexGridDividerDragDirty As Boolean
Private VBFlexGridHitRow As Long, VBFlexGridHitCol As Long
Private VBFlexGridHitRowDivider As Long, VBFlexGridHitColDivider As Long
Private VBFlexGridHitResult As FlexHitResultConstants
Private VBFlexGridDropHighlight As Long
Private VBFlexGridDropHighlightMode As FlexDropTargetModeConstants
Private VBFlexGridInsertMark As Long
Private VBFlexGridInsertMarkAfter As Boolean
Private VBFlexGridInsertMarkMode As FlexDropTargetModeConstants
Private VBFlexGridInsertMarkBrush As LongPtr
Private VBFlexGridCellClickRow As Long, VBFlexGridCellClickCol As Long
Private VBFlexGridEditRow As Long, VBFlexGridEditCol As Long
Private VBFlexGridEditMergedRange As TCELLRANGE
Private VBFlexGridEditGridLineOffsets As TGRIDLINEOFFSETS
Private VBFlexGridEditReason As FlexEditReasonConstants
Private VBFlexGridEditCloseMode As FlexEditCloseModeConstants
Private VBFlexGridEditChangeFrozen As Boolean
Private VBFlexGridEditOnValidate As Boolean
Private VBFlexGridEditTextChanged As Boolean
Private VBFlexGridEditAlreadyValidated As Boolean
Private VBFlexGridEditRectChanged As Boolean
Private VBFlexGridEditRectChangedFrozen As Boolean
Private VBFlexGridEditTempFontHandle As LongPtr
Private VBFlexGridEditBackColor As OLE_COLOR, VBFlexGridEditForeColor As OLE_COLOR
Private VBFlexGridEditBackColorBrush As LongPtr
Private VBFlexGridEditNoLostFocus As Boolean
Private VBFlexGridComboCue As FlexComboCueConstants
Private VBFlexGridComboCueRow As Long, VBFlexGridComboCueCol As Long
Private VBFlexGridComboCueClickRow As Long, VBFlexGridComboCueClickCol As Long
Private VBFlexGridComboMode As FlexComboModeConstants, VBFlexGridComboModeActive As FlexComboModeConstants
Private VBFlexGridComboButtonPicture As IPictureDisp, VBFlexGridComboButtonPictureRenderFlag As Integer
Private VBFlexGridComboButtonAlignment As FlexRightToLeftModeConstants
Private VBFlexGridComboButtonDrawMode As FlexComboButtonDrawModeConstants
Private VBFlexGridComboButtonWidth As Long
Private VBFlexGridComboItems As String
Private VBFlexGridComboHeader As String
Private VBFlexGridComboBoundColumn As Long
Private VBFlexGridComboBoxRect As RECT
Private VBFlexGridComboMultiColumn As TCOMBOMULTICOLUMN
Private VBFlexGridComboCalendarRegistered As Boolean
Private VBFlexGridCheckBoxDrawMode As FlexCheckBoxDrawModeConstants
Private VBFlexGridWheelScrollLines As Long
Private VBFlexGridFocusBorder As SIZEAPI
Private VBFlexGridFocused As Boolean
Private VBFlexGridNoRedraw As Boolean
Private VBFlexGridCharCodeCache As Long
Private VBFlexGridIsClick As Boolean
Private VBFlexGridMouseOver As Boolean
Private VBFlexGridDesignMode As Boolean
Private VBFlexGridRTLLayout As Boolean, VBFlexGridRTLReading As Boolean
Private VBFlexGridAlignable As Boolean
Private VBFlexGridEnabledVisualStyles As Boolean
Private VBFlexGridExtendLastCol As Long
Private VBFlexGridInvertSelection As Boolean
Private VBFlexGridExpandSelectedRows As Boolean
Private VBFlexGridMultiSelChangeTimer As Boolean
Private VBFlexGridSelectedRows As Long
Private VBFlexGridSelectedRowIndices() As Long
Private VBFlexGridClipSeparatorCol As String, VBFlexGridClipSeparatorRow As String
Private VBFlexGridHotRow As Long, VBFlexGridHotCol As Long
Private VBFlexGridHotHitResult As FlexHitResultConstants
Private VBFlexGridWallPaperRenderFlag As Integer
Private VBFlexGridIncrementalSearch As TINCREMENTALSEARCH
Private VBFlexGridReaderModeAnchorRegistered As Boolean
Private VBFlexGridReaderModeScroll As SIZEAPI
Private VBFlexGridUndoQueueIndex As Long
Private VBFlexGridUndoQueue() As TUNDOREDOENTRY
Private VBFlexGridRedoQueueIndex As Long
Private VBFlexGridRedoQueue() As TUNDOREDOENTRY

#If ImplementFlexDataSource = True Then

Private VBFlexGridFlexDataSource As IVBFlexDataSource, VBFlexGridFlexDataSource2 As IVBFlexDataSource2, VBFlexGridFlexDataSourceFlags As Long

#End If

Private UCNoSetFocusFwd As Boolean

#If ImplementDataSource = True Then

Private PropDataSource As MSDATASRC.DataSource, PropDataMember As MSDATASRC.DataMember, PropRecordset As Object

#End If

#If ImplementPreTranslateMsg = True Then

Private Const UM_PRETRANSLATEMSG As Long = (WM_USER + 1100)
Private UsePreTranslateMsg As Boolean

#End If

Private WithEvents PropFont As StdFont
Attribute PropFont.VB_VarHelpID = -1
Private WithEvents PropFontFixed As StdFont
Attribute PropFontFixed.VB_VarHelpID = -1
Private PropVisualStyles As Boolean
Private PropBackColor As OLE_COLOR
Private PropBackColorAlt As OLE_COLOR
Private PropBackColorBkg As OLE_COLOR
Private PropBackColorFixed As OLE_COLOR
Private PropBackColorSel As OLE_COLOR
Private PropForeColor As OLE_COLOR
Private PropForeColorFixed As OLE_COLOR
Private PropForeColorSel As OLE_COLOR
Private PropGridColor As OLE_COLOR
Private PropGridColorFixed As OLE_COLOR
Private PropGridColorFrozen As OLE_COLOR
Private PropSortArrowColor As OLE_COLOR
Private PropFloodColor As OLE_COLOR
Private PropInsertMarkColor As OLE_COLOR
Private PropAllowDropFiles As Boolean
Private PropOLEDragDropScroll As Boolean
Private PropOLEDragDropScrollOrientation As FlexScrollOrientationConstants
Private PropMousePointer As Integer, PropMouseIcon As IPictureDisp
Private PropMouseTrack As Boolean
Private PropRightToLeft As Boolean
Private PropRightToLeftLayout As Boolean
Private PropRightToLeftMode As FlexRightToLeftModeConstants
Private PropBorderStyle As FlexBorderStyleConstants
Private PropFixedRows As Long, PropFixedCols As Long
Private PropFrozenRows As Long, PropFrozenCols As Long
Private PropRows As Long, PropCols As Long
Private PropAllowBigSelection As Boolean
Private PropAllowMultiSelection As Boolean
Private PropAllowSelection As Boolean
Private PropAllowUserEditing As Boolean
Private PropAllowUserFreezing As FlexAllowUserFreezingConstants
Private PropAllowUserResizing As FlexAllowUserResizingConstants
Private PropRowSizingMode As FlexRowSizingModeConstants
Private PropMergeCells As FlexMergeCellsConstants
Private PropFillStyle As FlexFillStyleConstants
Private PropSelectionMode As FlexSelectionModeConstants
Private PropScrollBars As VBRUN.ScrollBarConstants
Private PropScrollTrack As Boolean
Private PropScrollTipFollowThumb As Boolean
Private PropDisableNoScroll As Boolean
Private PropHighLight As FlexHighLightConstants
Private PropFocusRect As FlexFocusRectConstants
Private PropFocusRectWidth As Integer
Private PropRowHeightMin As Long
Private PropRowHeightMax As Long
Private PropColWidthMin As Long
Private PropColWidthMax As Long
Private PropGridLines As FlexGridLineConstants
Private PropGridLinesFixed As FlexGridLineConstants
Private PropGridLinesFrozen As FlexGridLineConstants
Private PropGridLineWidth As Integer
Private PropGridLineWidthFixed As Integer
Private PropGridLineWidthFrozen As Integer
Private PropTextStyle As FlexTextStyleConstants
Private PropTextStyleFixed As FlexTextStyleConstants
Private PropPictureType As FlexPictureTypeConstants
Private PropFixGridLineOffsets As Boolean
Private PropMirrorAlignGeneral As Boolean
Private PropWordWrap As Boolean
Private PropSingleLine As Boolean
Private PropEllipsisFormat As FlexEllipsisFormatConstants
Private PropEllipsisFormatFixed As FlexEllipsisFormatConstants
Private PropMimicTextBox As Boolean
Private PropRedraw As Boolean
Private PropDoubleBuffer As Boolean
Private PropTabBehavior As FlexTabBehaviorConstants
Private PropDirectionAfterReturn As FlexDirectionAfterReturnConstants
Private PropWrapCellBehavior As FlexWrapCellBehaviorConstants
Private PropShowInfoTips As Boolean
Private PropShowLabelTips As Boolean
Private PropShowScrollTips As Boolean
Private PropClipSeparators As String
Private PropClipMode As FlexClipModeConstants
Private PropClipCopyMode As FlexClipCopyModeConstants
Private PropClipPasteMode As FlexClipPasteModeConstants
Private PropFormatString As String
Private PropIMEMode As FlexIMEModeConstants
Private PropWantReturn As Boolean
Private PropExtendLastCol As Boolean
Private PropRowSortArrows As Long
Private PropAllowScrollLock As Boolean
Private PropSheetBorder As Boolean
Private PropAutoClipboard As Boolean
Private PropBestFitMode As FlexBestFitModeConstants
Private PropWallPaper As IPictureDisp
Private PropWallPaperAlignment As FlexWallPaperAlignmentConstants
Private PropAllowIncrementalSearch As Boolean
Private PropAllowReaderMode As Boolean
Private PropAlwaysAllowComboCues As Boolean
Private PropUndoLimit As Long
Private PropFontQuality As FlexFontQualityConstants
Private PropMultiSelChangeTime As Long

Private Sub IObjectSafety_GetInterfaceSafetyOptions(ByRef riid As OLEGuids.OLECLSID, ByRef pdwSupportedOptions As Long, ByRef pdwEnabledOptions As Long)
Const INTERFACESAFE_FOR_UNTRUSTED_CALLER As Long = &H1, INTERFACESAFE_FOR_UNTRUSTED_DATA As Long = &H2
pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER Or INTERFACESAFE_FOR_UNTRUSTED_DATA
pdwEnabledOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER Or INTERFACESAFE_FOR_UNTRUSTED_DATA
End Sub

Private Sub IObjectSafety_SetInterfaceSafetyOptions(ByRef riid As OLEGuids.OLECLSID, ByVal dwOptionsSetMask As Long, ByVal dwEnabledOptions As Long)
End Sub

#If VBA7 Then
Private Sub IOleInPlaceActiveObjectVB_TranslateAccelerator(ByRef Handled As Boolean, ByRef RetVal As Long, ByVal hWnd As LongPtr, ByVal wMsg As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr, ByVal Shift As Long)
#Else
Private Sub IOleInPlaceActiveObjectVB_TranslateAccelerator(ByRef Handled As Boolean, ByRef RetVal As Long, ByVal hWnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByVal lParam As Long, ByVal Shift As Long)
#End If
If wMsg = WM_KEYDOWN Or wMsg = WM_KEYUP Then
    Dim KeyCode As Integer, IsInputKey As Boolean
    KeyCode = CLng(wParam) And &HFF&
    If wMsg = WM_KEYDOWN Then
        RaiseEvent PreviewKeyDown(KeyCode, IsInputKey)
    ElseIf wMsg = WM_KEYUP Then
        RaiseEvent PreviewKeyUp(KeyCode, IsInputKey)
    End If
    Select Case KeyCode
        Case vbKeyUp, vbKeyDown, vbKeyLeft, vbKeyRight, vbKeyPageDown, vbKeyPageUp, vbKeyHome, vbKeyEnd
            SendMessage hWnd, wMsg, wParam, ByVal lParam
            Handled = True
        Case vbKeyTab
            Select Case PropTabBehavior
                Case FlexTabCells
                    IsInputKey = True
                Case FlexTabNext
                    Select Case PropWrapCellBehavior
                        Case FlexWrapNone
                            Select Case PropSelectionMode
                                Case FlexSelectionModeFree, FlexSelectionModeFreeByRow, FlexSelectionModeFreeByColumn
                                    If (Shift And vbShiftMask) = 0 Then
                                        If VBFlexGridCol < GetLastMovableCol() Then IsInputKey = True
                                    Else
                                        If VBFlexGridCol > GetFirstMovableCol() Then IsInputKey = True
                                    End If
                            End Select
                        Case FlexWrapRow
                            Select Case PropSelectionMode
                                Case FlexSelectionModeFree, FlexSelectionModeFreeByRow, FlexSelectionModeFreeByColumn
                                    If (Shift And vbShiftMask) = 0 Then
                                        If VBFlexGridRow < GetLastMovableRow() Or VBFlexGridCol < GetLastMovableCol() Then IsInputKey = True
                                    Else
                                        If VBFlexGridRow > GetFirstMovableRow() Or VBFlexGridCol > GetFirstMovableCol() Then IsInputKey = True
                                    End If
                                Case FlexSelectionModeByRow
                                    If (Shift And vbShiftMask) = 0 Then
                                        If VBFlexGridRow < GetLastMovableRow() Then IsInputKey = True
                                    Else
                                        If VBFlexGridRow > GetFirstMovableRow() Then IsInputKey = True
                                    End If
                                Case FlexSelectionModeByColumn
                                    If (Shift And vbShiftMask) = 0 Then
                                        If VBFlexGridCol < GetLastMovableCol() Then IsInputKey = True
                                    Else
                                        If VBFlexGridCol > GetFirstMovableCol() Then IsInputKey = True
                                    End If
                            End Select
                        Case FlexWrapGrid
                            IsInputKey = True
                    End Select
            End Select
            If IsInputKey = True Then
                SendMessage hWnd, wMsg, wParam, ByVal lParam
                Handled = True
            End If
        Case vbKeyReturn, vbKeyEscape
            If VBFlexGridEditHandle = NULL_PTR Then
                If VBFlexGridCaptureDividerDrag = True And KeyCode = vbKeyEscape Then
                    ReleaseCapture
                    Handled = True
                End If
                If IsInputKey = True Then
                    SendMessage hWnd, wMsg, wParam, ByVal lParam
                    Handled = True
                End If
            Else
                SendMessage hWnd, wMsg, wParam, ByVal lParam
                Handled = True
            End If
    End Select
End If
End Sub

#If VBA7 Then
Private Sub IOleControlVB_GetControlInfo(ByRef Handled As Boolean, ByRef AccelCount As Integer, ByRef AccelTable As LongPtr, ByRef Flags As Long)
#Else
Private Sub IOleControlVB_GetControlInfo(ByRef Handled As Boolean, ByRef AccelCount As Integer, ByRef AccelTable As Long, ByRef Flags As Long)
#End If
If PropWantReturn = True Then
    Flags = CTRLINFO_EATS_RETURN
    Handled = True
End If
End Sub

#If VBA7 Then
Private Sub IOleControlVB_OnMnemonic(ByRef Handled As Boolean, ByVal hWnd As LongPtr, ByVal wMsg As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr, ByVal Shift As Long)
#Else
Private Sub IOleControlVB_OnMnemonic(ByRef Handled As Boolean, ByVal hWnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByVal lParam As Long, ByVal Shift As Long)
#End If
End Sub

Private Sub UserControl_Initialize()
Call FlexLoadShellMod
Call FlexInitCC(ICC_STANDARD_CLASSES)
Call FlexWndRegisterClass

#If ImplementPreTranslateMsg = True Then

If SetVTableHandling(Me, VTableInterfaceInPlaceActiveObject) = False Then UsePreTranslateMsg = True

#Else

Call SetVTableHandling(Me, VTableInterfaceInPlaceActiveObject)

#End If

Call SetVTableHandling(Me, VTableInterfaceControl)
With VBFlexGridPixelMetrics
.DividerSpacing.CX = DIVIDER_SPACING_DIP * PixelsPerDIP_X()
.DividerSpacing.CY = DIVIDER_SPACING_DIP * PixelsPerDIP_Y()
.TextPadding.CX = CELL_TEXT_WIDTH_PADDING_DIP * PixelsPerDIP_X()
.TextPadding.CY = CELL_TEXT_HEIGHT_PADDING_DIP * PixelsPerDIP_Y()
.CellSpacing.CX = COLINFO_WIDTH_SPACING_DIP * PixelsPerDIP_X()
.CellSpacing.CY = ROWINFO_HEIGHT_SPACING_DIP * PixelsPerDIP_Y()
.ScrollBarSize = GetSystemMetrics(SM_CXVSCROLL)
.CheckBoxSize = (13 * PixelsPerDIP_X())
End With
With VBFlexGridDefaultCellFmtg
.TextStyle = -1
.Alignment = -1
.BackColor = -1
.ForeColor = -1
.Checked = -1
.FloodColor = -1
End With
With VBFlexGridDefaultLpCellFmtg
.TextStyle = -1
.Alignment = -1
.BackColor = -1
.ForeColor = -1
.Checked = -1
.FloodColor = -1
End With
With VBFlexGridDefaultRowInfo
.Height = -1
End With
With VBFlexGridDefaultColInfo
.Width = -1
.Alignment = FlexAlignmentGeneral
.FixedAlignment = -1
.WordWrapOption = -1
.WordWrapOptionFixed = -1
.MimicTextBox = -1
.MimicTextBoxFixed = -1
.SortArrowAlignment = FlexLeftRightAlignmentRight
.SortArrowColor = -1
.ComboButtonAlignment = -1
.ComboButtonWidth = -1
.CheckBoxAlignment = FlexCheckBoxAlignmentUsePictureAlignment
.FixedCheckBoxAlignment = -1
End With
VBFlexGridUniformRowHeight = -1
VBFlexGridDoDragRow = -1
VBFlexGridDoDragCol = -1
VBFlexGridDoDragRowCol = False
VBFlexGridCaptureRow = -1
VBFlexGridCaptureCol = -1
VBFlexGridCaptureHitResult = FlexHitResultNoWhere
VBFlexGridCaptureDividerRow = -1
VBFlexGridCaptureDividerCol = -1
VBFlexGridCaptureDividerDrag = False
VBFlexGridCaptureDividerMoved = False
VBFlexGridToolTipRow = -1
VBFlexGridToolTipCol = -1
VBFlexGridToolTipHitResult = FlexHitResultNoWhere
VBFlexGridMouseMoveRow = -1
VBFlexGridMouseMoveCol = -1
VBFlexGridMouseMoveChanged = False
VBFlexGridDividerDragDirty = False
VBFlexGridHitRow = -1
VBFlexGridHitCol = -1
VBFlexGridHitRowDivider = -1
VBFlexGridHitColDivider = -1
VBFlexGridHitResult = FlexHitResultNoWhere
VBFlexGridDropHighlight = -1
VBFlexGridDropHighlightMode = FlexDropTargetModeByRow
VBFlexGridInsertMark = -1
VBFlexGridInsertMarkAfter = False
VBFlexGridInsertMarkMode = FlexDropTargetModeByRow
VBFlexGridCellClickRow = -1
VBFlexGridCellClickCol = -1
VBFlexGridEditRow = -1
VBFlexGridEditCol = -1
VBFlexGridEditReason = -1
VBFlexGridEditCloseMode = -1
VBFlexGridComboCue = FlexComboCueNone
VBFlexGridComboCueRow = -1
VBFlexGridComboCueCol = -1
VBFlexGridComboCueClickRow = -1
VBFlexGridComboCueClickCol = -1
VBFlexGridComboMode = FlexComboModeNone
VBFlexGridComboModeActive = FlexComboModeNone
VBFlexGridComboButtonAlignment = FlexLeftRightAlignmentRight
VBFlexGridComboButtonDrawMode = FlexComboButtonDrawModeNormal
VBFlexGridComboButtonWidth = -1
VBFlexGridCheckBoxDrawMode = FlexCheckBoxDrawModeNormal
SystemParametersInfo SPI_GETWHEELSCROLLLINES, 0, VarPtr(VBFlexGridWheelScrollLines), 0
If SystemParametersInfo(SPI_GETFOCUSBORDERWIDTH, 0, VarPtr(VBFlexGridFocusBorder.CX), 0) = 0 Then VBFlexGridFocusBorder.CX = 1
If SystemParametersInfo(SPI_GETFOCUSBORDERHEIGHT, 0, VarPtr(VBFlexGridFocusBorder.CY), 0) = 0 Then VBFlexGridFocusBorder.CY = 1
VBFlexGridExtendLastCol = -1
VBFlexGridClipSeparatorCol = vbTab
VBFlexGridClipSeparatorRow = vbCr
VBFlexGridHotRow = -1
VBFlexGridHotCol = -1
VBFlexGridHotHitResult = FlexHitResultNoWhere
VBFlexGridIncrementalSearch.Row = -1
VBFlexGridIncrementalSearch.Col = -1
VBFlexGridIncrementalSearch.Time = -1
VBFlexGridUndoQueueIndex = -1
VBFlexGridRedoQueueIndex = -1
End Sub

Private Sub UserControl_InitProperties()
On Error Resume Next
If UserControl.ParentControls.Count = 0 Then VBFlexGridAlignable = False Else VBFlexGridAlignable = True
VBFlexGridDesignMode = Not Ambient.UserMode
On Error GoTo 0

#If ImplementDataSource = True Then

PropDataMember = vbNullString

#End If

Set PropFont = Ambient.Font
Set PropFontFixed = Nothing
PropVisualStyles = True
PropBackColor = vbWindowBackground
PropBackColorAlt = vbWindowBackground
PropBackColorBkg = &H808080
PropBackColorFixed = vbButtonFace
PropBackColorSel = vbHighlight
PropForeColor = vbWindowText
PropForeColorFixed = vbButtonText
PropForeColorSel = vbHighlightText
PropGridColor = &HC0C0C0
PropGridColorFixed = vbBlack
PropGridColorFrozen = vbBlack
PropSortArrowColor = vbGrayText
PropFloodColor = &HC0&
PropInsertMarkColor = vbBlack
PropAllowDropFiles = False
PropOLEDragDropScroll = True
PropOLEDragDropScrollOrientation = FlexScrollOrientationBoth
Me.OLEDropMode = vbOLEDropNone
PropMousePointer = 0: Set PropMouseIcon = Nothing
PropMouseTrack = False
PropRightToLeft = Ambient.RightToLeft
PropRightToLeftLayout = False
PropRightToLeftMode = FlexRightToLeftModeVBAME
If PropRightToLeft = True Then Me.RightToLeft = True
PropBorderStyle = FlexBorderStyleSunken
PropFixedRows = 1
PropFixedCols = 1
PropFrozenRows = 0
PropFrozenCols = 0
PropRows = 2
PropCols = 2
PropAllowBigSelection = True
PropAllowMultiSelection = False
PropAllowSelection = True
PropAllowUserEditing = False
PropAllowUserFreezing = FlexAllowUserFreezingNone
PropAllowUserResizing = FlexAllowUserResizingNone
PropRowSizingMode = FlexRowSizingModeIndividual
PropMergeCells = FlexMergeCellsNever
PropFillStyle = FlexFillStyleSingle
PropSelectionMode = FlexSelectionModeFree
PropScrollBars = vbBoth
PropScrollTrack = False
PropScrollTipFollowThumb = False
PropDisableNoScroll = False
PropHighLight = FlexHighLightAlways
PropFocusRect = FlexFocusRectLight
PropFocusRectWidth = -1
PropRowHeightMin = 0
PropRowHeightMax = 0
PropColWidthMin = 0
PropColWidthMax = 0
PropGridLines = FlexGridLineFlat
PropGridLinesFixed = FlexGridLineInset
PropGridLinesFrozen = FlexGridLineFlat
PropGridLineWidth = 1
PropGridLineWidthFixed = -1
PropGridLineWidthFrozen = -1
PropTextStyle = FlexTextStyleFlat
PropTextStyleFixed = FlexTextStyleFlat
PropPictureType = FlexPictureTypeColor
PropFixGridLineOffsets = False
PropMirrorAlignGeneral = False
PropWordWrap = False
PropSingleLine = False
PropEllipsisFormat = FlexEllipsisFormatNone
PropEllipsisFormatFixed = FlexEllipsisFormatNone
PropMimicTextBox = False
PropRedraw = True
PropDoubleBuffer = True
PropTabBehavior = FlexTabControls
PropDirectionAfterReturn = FlexDirectionAfterReturnNone
PropWrapCellBehavior = FlexWrapNone
PropShowInfoTips = False
PropShowLabelTips = False
PropShowScrollTips = False
PropClipSeparators = vbNullString
PropClipMode = FlexClipModeNormal
PropClipCopyMode = FlexClipCopyModeNormal
PropClipPasteMode = FlexClipPasteModeNormal
PropFormatString = vbNullString
PropIMEMode = FlexIMEModeNoControl
PropWantReturn = False
PropExtendLastCol = False
PropRowSortArrows = 0
PropAllowScrollLock = False
PropSheetBorder = True
PropAutoClipboard = False
PropBestFitMode = FlexBestFitModeTextOnly
Set PropWallPaper = Nothing
PropWallPaperAlignment = FlexWallPaperAlignmentStretch
PropAllowIncrementalSearch = False
PropAllowReaderMode = False
PropAlwaysAllowComboCues = False
PropUndoLimit = 0
PropFontQuality = FlexFontQualityDefault
PropMultiSelChangeTime = 0
Call CreateVBFlexGrid
End Sub

Private Sub UserControl_ReadProperties(PropBag As PropertyBag)
On Error Resume Next
If UserControl.ParentControls.Count = 0 Then VBFlexGridAlignable = False Else VBFlexGridAlignable = True
VBFlexGridDesignMode = Not Ambient.UserMode
On Error GoTo 0
With PropBag

#If ImplementDataSource = True Then

PropDataMember = .ReadProperty("DataMember", vbNullString)

#End If

Set PropFont = .ReadProperty("Font", Nothing)
Set PropFontFixed = .ReadProperty("FontFixed", Nothing)
PropVisualStyles = .ReadProperty("VisualStyles", True)
PropBackColor = .ReadProperty("BackColor", vbWindowBackground)
PropBackColorAlt = .ReadProperty("BackColorAlt", vbWindowBackground)
PropBackColorBkg = .ReadProperty("BackColorBkg", &H808080)
PropBackColorFixed = .ReadProperty("BackColorFixed", vbButtonFace)
PropBackColorSel = .ReadProperty("BackColorSel", vbHighlight)
PropForeColor = .ReadProperty("ForeColor", vbWindowText)
PropForeColorFixed = .ReadProperty("ForeColorFixed", vbButtonText)
PropForeColorSel = .ReadProperty("ForeColorSel", vbHighlightText)
PropGridColor = .ReadProperty("GridColor", &HC0C0C0)
PropGridColorFixed = .ReadProperty("GridColorFixed", vbBlack)
PropGridColorFrozen = .ReadProperty("GridColorFrozen", vbBlack)
PropSortArrowColor = .ReadProperty("SortArrowColor", vbGrayText)
PropFloodColor = .ReadProperty("FloodColor", &HC0&)
PropInsertMarkColor = .ReadProperty("InsertMarkColor", vbBlack)
Me.Enabled = .ReadProperty("Enabled", True)
PropAllowDropFiles = .ReadProperty("AllowDropFiles", False)
PropOLEDragDropScroll = .ReadProperty("OLEDragDropScroll", True)
PropOLEDragDropScrollOrientation = .ReadProperty("OLEDragDropScrollOrientation", FlexScrollOrientationBoth)
Me.OLEDropMode = .ReadProperty("OLEDropMode", vbOLEDropNone)
PropMousePointer = .ReadProperty("MousePointer", 0)
Set PropMouseIcon = .ReadProperty("MouseIcon", Nothing)
PropMouseTrack = .ReadProperty("MouseTrack", False)
PropRightToLeft = .ReadProperty("RightToLeft", False)
PropRightToLeftLayout = .ReadProperty("RightToLeftLayout", False)
PropRightToLeftMode = .ReadProperty("RightToLeftMode", FlexRightToLeftModeVBAME)
If PropRightToLeft = True Then Me.RightToLeft = True
PropBorderStyle = .ReadProperty("BorderStyle", FlexBorderStyleSunken)
PropFixedRows = .ReadProperty("FixedRows", 1)
PropFixedCols = .ReadProperty("FixedCols", 1)
PropFrozenRows = .ReadProperty("FrozenRows", 0)
PropFrozenCols = .ReadProperty("FrozenCols", 0)
PropRows = .ReadProperty("Rows", 2)
PropCols = .ReadProperty("Cols", 2)
PropAllowBigSelection = .ReadProperty("AllowBigSelection", True)
PropAllowMultiSelection = .ReadProperty("AllowMultiSelection", False)
PropAllowSelection = .ReadProperty("AllowSelection", True)
PropAllowUserEditing = .ReadProperty("AllowUserEditing", False)
PropAllowUserFreezing = .ReadProperty("AllowUserFreezing", FlexAllowUserFreezingNone)
PropAllowUserResizing = .ReadProperty("AllowUserResizing", FlexAllowUserResizingNone)
PropRowSizingMode = .ReadProperty("RowSizingMode", FlexRowSizingModeIndividual)
PropMergeCells = .ReadProperty("MergeCells", FlexMergeCellsNever)
PropFillStyle = .ReadProperty("FillStyle", FlexFillStyleSingle)
PropSelectionMode = .ReadProperty("SelectionMode", FlexSelectionModeFree)
PropScrollBars = .ReadProperty("ScrollBars", vbBoth)
PropScrollTrack = .ReadProperty("ScrollTrack", False)
PropScrollTipFollowThumb = .ReadProperty("ScrollTipFollowThumb", False)
PropDisableNoScroll = .ReadProperty("DisableNoScroll", False)
PropHighLight = .ReadProperty("HighLight", FlexHighLightAlways)
PropFocusRect = .ReadProperty("FocusRect", FlexFocusRectLight)
PropFocusRectWidth = .ReadProperty("FocusRectWidth", -1)
PropRowHeightMin = (.ReadProperty("RowHeightMin", 0) * PixelsPerDIP_Y())
PropRowHeightMax = (.ReadProperty("RowHeightMax", 0) * PixelsPerDIP_Y())
PropColWidthMin = (.ReadProperty("ColWidthMin", 0) * PixelsPerDIP_X())
PropColWidthMax = (.ReadProperty("ColWidthMax", 0) * PixelsPerDIP_X())
PropGridLines = .ReadProperty("GridLines", FlexGridLineFlat)
PropGridLinesFixed = .ReadProperty("GridLinesFixed", FlexGridLineInset)
PropGridLinesFrozen = .ReadProperty("GridLinesFrozen", FlexGridLineFlat)
PropGridLineWidth = .ReadProperty("GridLineWidth", 1)
PropGridLineWidthFixed = .ReadProperty("GridLineWidthFixed", -1)
PropGridLineWidthFrozen = .ReadProperty("GridLineWidthFrozen", -1)
PropTextStyle = .ReadProperty("TextStyle", FlexTextStyleFlat)
PropTextStyleFixed = .ReadProperty("TextStyleFixed", FlexTextStyleFlat)
PropPictureType = .ReadProperty("PictureType", FlexPictureTypeColor)
PropFixGridLineOffsets = .ReadProperty("FixGridLineOffsets", PropFixGridLineOffsets)
PropMirrorAlignGeneral = .ReadProperty("MirrorAlignGeneral", PropMirrorAlignGeneral)
PropWordWrap = .ReadProperty("WordWrap", False)
PropSingleLine = .ReadProperty("SingleLine", False)
PropEllipsisFormat = .ReadProperty("EllipsisFormat", FlexEllipsisFormatNone)
PropEllipsisFormatFixed = .ReadProperty("EllipsisFormatFixed", FlexEllipsisFormatNone)
PropMimicTextBox = .ReadProperty("MimicTextBox", False)
PropRedraw = .ReadProperty("Redraw", True)
PropDoubleBuffer = .ReadProperty("DoubleBuffer", True)
PropTabBehavior = .ReadProperty("TabBehavior", FlexTabControls)
PropDirectionAfterReturn = .ReadProperty("DirectionAfterReturn", FlexDirectionAfterReturnNone)
PropWrapCellBehavior = .ReadProperty("WrapCellBehavior", FlexWrapNone)
PropShowInfoTips = .ReadProperty("ShowInfoTips", False)
PropShowLabelTips = .ReadProperty("ShowLabelTips", False)
PropShowScrollTips = .ReadProperty("ShowScrollTips", False)
PropClipSeparators = VarToStr(.ReadProperty("ClipSeparators", vbNullString))
PropClipMode = .ReadProperty("ClipMode", FlexClipModeNormal)
PropClipCopyMode = .ReadProperty("ClipCopyMode", FlexClipCopyModeNormal)
PropClipPasteMode = .ReadProperty("ClipPasteMode", FlexClipPasteModeNormal)
PropFormatString = VarToStr(.ReadProperty("FormatString", vbNullString))
PropIMEMode = .ReadProperty("IMEMode", FlexIMEModeNoControl)
PropWantReturn = .ReadProperty("WantReturn", False)
PropExtendLastCol = .ReadProperty("ExtendLastCol", False)
PropRowSortArrows = .ReadProperty("RowSortArrows", 0)
PropAllowScrollLock = .ReadProperty("AllowScrollLock", False)
PropSheetBorder = .ReadProperty("SheetBorder", True)
PropAutoClipboard = .ReadProperty("AutoClipboard", False)
PropBestFitMode = .ReadProperty("BestFitMode", FlexBestFitModeTextOnly)
Set PropWallPaper = .ReadProperty("WallPaper", Nothing)
PropWallPaperAlignment = .ReadProperty("WallPaperAlignment", FlexWallPaperAlignmentStretch)
PropAllowIncrementalSearch = .ReadProperty("AllowIncrementalSearch", False)
PropAllowReaderMode = .ReadProperty("AllowReaderMode", False)
PropAlwaysAllowComboCues = .ReadProperty("AlwaysAllowComboCues", False)
PropUndoLimit = .ReadProperty("UndoLimit", 0)
PropFontQuality = .ReadProperty("FontQuality", FlexFontQualityDefault)
PropMultiSelChangeTime = .ReadProperty("MultiSelChangeTime", 0)
End With
Call CreateVBFlexGrid
End Sub

Private Sub UserControl_WriteProperties(PropBag As PropertyBag)
With PropBag

#If ImplementDataSource = True Then

.WriteProperty "DataMember", PropDataMember, vbNullString

#End If

.WriteProperty "Font", IIf(OLEFontIsEqual(PropFont, Ambient.Font) = False, PropFont, Nothing), Nothing
.WriteProperty "FontFixed", PropFontFixed, Nothing
.WriteProperty "VisualStyles", PropVisualStyles, True
.WriteProperty "BackColor", PropBackColor, vbWindowBackground
.WriteProperty "BackColorAlt", PropBackColorAlt, vbWindowBackground
.WriteProperty "BackColorBkg", PropBackColorBkg, &H808080
.WriteProperty "BackColorFixed", PropBackColorFixed, vbButtonFace
.WriteProperty "BackColorSel", PropBackColorSel, vbHighlight
.WriteProperty "ForeColor", PropForeColor, vbWindowText
.WriteProperty "ForeColorFixed", PropForeColorFixed, vbButtonText
.WriteProperty "ForeColorSel", PropForeColorSel, vbHighlightText
.WriteProperty "GridColor", PropGridColor, &HC0C0C0
.WriteProperty "GridColorFixed", PropGridColorFixed, vbBlack
.WriteProperty "GridColorFrozen", PropGridColorFrozen, vbBlack
.WriteProperty "SortArrowColor", PropSortArrowColor, vbGrayText
.WriteProperty "FloodColor", PropFloodColor, &HC0&
.WriteProperty "InsertMarkColor", PropInsertMarkColor, vbBlack
.WriteProperty "Enabled", Me.Enabled, True
.WriteProperty "AllowDropFiles", PropAllowDropFiles, False
.WriteProperty "OLEDragDropScroll", PropOLEDragDropScroll, True
.WriteProperty "OLEDragDropScrollOrientation", PropOLEDragDropScrollOrientation, FlexScrollOrientationBoth
.WriteProperty "OLEDropMode", Me.OLEDropMode, vbOLEDropNone
.WriteProperty "MousePointer", PropMousePointer, 0
.WriteProperty "MouseIcon", PropMouseIcon, Nothing
.WriteProperty "MouseTrack", PropMouseTrack, False
.WriteProperty "RightToLeft", PropRightToLeft, False
.WriteProperty "RightToLeftLayout", PropRightToLeftLayout, False
.WriteProperty "RightToLeftMode", PropRightToLeftMode, FlexRightToLeftModeVBAME
.WriteProperty "BorderStyle", PropBorderStyle, FlexBorderStyleSunken
.WriteProperty "FixedRows", PropFixedRows, 1
.WriteProperty "FixedCols", PropFixedCols, 1
.WriteProperty "FrozenRows", PropFrozenRows, 0
.WriteProperty "FrozenCols", PropFrozenCols, 0
.WriteProperty "Rows", PropRows, 2
.WriteProperty "Cols", PropCols, 2
.WriteProperty "AllowBigSelection", PropAllowBigSelection, True
.WriteProperty "AllowMultiSelection", PropAllowMultiSelection, False
.WriteProperty "AllowSelection", PropAllowSelection, True
.WriteProperty "AllowUserEditing", PropAllowUserEditing, False
.WriteProperty "AllowUserFreezing", PropAllowUserFreezing, FlexAllowUserFreezingNone
.WriteProperty "AllowUserResizing", PropAllowUserResizing, FlexAllowUserResizingNone
.WriteProperty "RowSizingMode", PropRowSizingMode, FlexRowSizingModeIndividual
.WriteProperty "MergeCells", PropMergeCells, FlexMergeCellsNever
.WriteProperty "FillStyle", PropFillStyle, FlexFillStyleSingle
.WriteProperty "SelectionMode", PropSelectionMode, FlexSelectionModeFree
.WriteProperty "ScrollBars", PropScrollBars, vbBoth
.WriteProperty "ScrollTrack", PropScrollTrack, False
.WriteProperty "ScrollTipFollowThumb", PropScrollTipFollowThumb, False
.WriteProperty "DisableNoScroll", PropDisableNoScroll, False
.WriteProperty "HighLight", PropHighLight, FlexHighLightAlways
.WriteProperty "FocusRect", PropFocusRect, FlexFocusRectLight
.WriteProperty "FocusRectWidth", PropFocusRectWidth, -1
.WriteProperty "RowHeightMin", (PropRowHeightMin / PixelsPerDIP_Y()), 0
.WriteProperty "RowHeightMax", (PropRowHeightMax / PixelsPerDIP_Y()), 0
.WriteProperty "ColWidthMin", (PropColWidthMin / PixelsPerDIP_X()), 0
.WriteProperty "ColWidthMax", (PropColWidthMax / PixelsPerDIP_X()), 0
.WriteProperty "GridLines", PropGridLines, FlexGridLineFlat
.WriteProperty "GridLinesFixed", PropGridLinesFixed, FlexGridLineInset
.WriteProperty "GridLinesFrozen", PropGridLinesFrozen, FlexGridLineFlat
.WriteProperty "GridLineWidth", PropGridLineWidth, 1
.WriteProperty "GridLineWidthFixed", PropGridLineWidthFixed, -1
.WriteProperty "GridLineWidthFrozen", PropGridLineWidthFrozen, -1
.WriteProperty "TextStyle", PropTextStyle, FlexTextStyleFlat
.WriteProperty "TextStyleFixed", PropTextStyleFixed, FlexTextStyleFlat
.WriteProperty "PictureType", PropPictureType, FlexPictureTypeColor
.WriteProperty "FixGridLineOffsets", PropFixGridLineOffsets, False
.WriteProperty "MirrorAlignGeneral", PropMirrorAlignGeneral, False
.WriteProperty "WordWrap", PropWordWrap, False
.WriteProperty "SingleLine", PropSingleLine, False
.WriteProperty "EllipsisFormat", PropEllipsisFormat, FlexEllipsisFormatNone
.WriteProperty "EllipsisFormatFixed", PropEllipsisFormatFixed, FlexEllipsisFormatNone
.WriteProperty "MimicTextBox", PropMimicTextBox, False
.WriteProperty "Redraw", PropRedraw, True
.WriteProperty "DoubleBuffer", PropDoubleBuffer, True
.WriteProperty "TabBehavior", PropTabBehavior, FlexTabControls
.WriteProperty "DirectionAfterReturn", PropDirectionAfterReturn, FlexDirectionAfterReturnNone
.WriteProperty "WrapCellBehavior", PropWrapCellBehavior, FlexWrapNone
.WriteProperty "ShowInfoTips", PropShowInfoTips, False
.WriteProperty "ShowLabelTips", PropShowLabelTips, False
.WriteProperty "ShowScrollTips", PropShowScrollTips, False
.WriteProperty "ClipSeparators", StrToVar(PropClipSeparators), vbNullString
.WriteProperty "ClipMode", PropClipMode, FlexClipModeNormal
.WriteProperty "ClipCopyMode", PropClipCopyMode, FlexClipCopyModeNormal
.WriteProperty "ClipPasteMode", PropClipPasteMode, FlexClipPasteModeNormal
.WriteProperty "FormatString", StrToVar(PropFormatString), vbNullString
.WriteProperty "IMEMode", PropIMEMode, FlexIMEModeNoControl
.WriteProperty "WantReturn", PropWantReturn, False
.WriteProperty "ExtendLastCol", PropExtendLastCol, False
.WriteProperty "RowSortArrows", PropRowSortArrows, 0
.WriteProperty "AllowScrollLock", PropAllowScrollLock, False
.WriteProperty "SheetBorder", PropSheetBorder, True
.WriteProperty "AutoClipboard", PropAutoClipboard, False
.WriteProperty "BestFitMode", PropBestFitMode, FlexBestFitModeTextOnly
.WriteProperty "WallPaper", PropWallPaper, Nothing
.WriteProperty "WallPaperAlignment", PropWallPaperAlignment, FlexWallPaperAlignmentStretch
.WriteProperty "AllowIncrementalSearch", PropAllowIncrementalSearch, False
.WriteProperty "AllowReaderMode", PropAllowReaderMode, False
.WriteProperty "AlwaysAllowComboCues", PropAlwaysAllowComboCues, False
.WriteProperty "UndoLimit", PropUndoLimit, 0
.WriteProperty "FontQuality", PropFontQuality, FlexFontQualityDefault
.WriteProperty "MultiSelChangeTime", PropMultiSelChangeTime, 0
End With
End Sub

Private Sub UserControl_Paint()
If VBFlexGridHandle = NULL_PTR Or VBFlexGridDesignMode = False Then Exit Sub
Dim OldLayout As Long, hRgn As LongPtr
If PropRightToLeft = True And PropRightToLeftLayout = True Then OldLayout = SetLayout(UserControl.hDC, LAYOUT_RTL)
If PropDoubleBuffer = True Then
    If VBFlexGridDoubleBufferDC = NULL_PTR Then
        VBFlexGridDoubleBufferDC = CreateCompatibleDC(UserControl.hDC)
        If VBFlexGridDoubleBufferDC <> NULL_PTR Then
            VBFlexGridDoubleBufferBmp = CreateCompatibleBitmap(UserControl.hDC, UserControl.ScaleWidth, UserControl.ScaleHeight)
            If VBFlexGridDoubleBufferBmp <> NULL_PTR Then VBFlexGridDoubleBufferBmpOld = SelectObject(VBFlexGridDoubleBufferDC, VBFlexGridDoubleBufferBmp)
        End If
    End If
    If VBFlexGridDoubleBufferDC <> NULL_PTR And VBFlexGridDoubleBufferBmp <> NULL_PTR Then
        If VBFlexGridCellsInit = False Then
            If VBFlexGridBackColorBkgBrush <> NULL_PTR Then
                Dim Brush As LongPtr
                Brush = SelectObject(VBFlexGridDoubleBufferDC, VBFlexGridBackColorBkgBrush)
                PatBlt VBFlexGridDoubleBufferDC, 0, 0, UserControl.ScaleWidth, UserControl.ScaleHeight, vbPatCopy
                SelectObject VBFlexGridDoubleBufferDC, Brush
            End If
            Call DrawGrid(VBFlexGridDoubleBufferDC, NULL_PTR, True)
        Else
            Call DrawGrid(VBFlexGridDoubleBufferDC, hRgn, False)
            If hRgn <> NULL_PTR Then ExtSelectClipRgn UserControl.hDC, hRgn, RGN_COPY
        End If
        BitBlt UserControl.hDC, 0, 0, UserControl.ScaleWidth, UserControl.ScaleHeight, VBFlexGridDoubleBufferDC, 0, 0, vbSrcCopy
        If hRgn <> NULL_PTR Then
            ExtSelectClipRgn UserControl.hDC, NULL_PTR, RGN_COPY
            DeleteObject hRgn
        End If
    End If
Else
    Call DrawGrid(UserControl.hDC, NULL_PTR, True)
End If
If PropRightToLeft = True And PropRightToLeftLayout = True Then SetLayout UserControl.hDC, OldLayout
End Sub

Private Sub UserControl_OLECompleteDrag(Effect As Long)
RaiseEvent OLECompleteDrag(Effect)
End Sub

Private Sub UserControl_OLEDragDrop(Data As DataObject, Effect As Long, Button As Integer, Shift As Integer, X As Single, Y As Single)
Dim P As POINTAPI
P.X = X
P.Y = Y
If VBFlexGridHandle <> NULL_PTR Then MapWindowPoints UserControl.hWnd, VBFlexGridHandle, P, 1
RaiseEvent OLEDragDrop(Data, Effect, Button, Shift, UserControl.ScaleX(P.X, vbPixels, vbContainerPosition), UserControl.ScaleY(P.Y, vbPixels, vbContainerPosition))
End Sub

Private Sub UserControl_OLEDragOver(Data As DataObject, Effect As Long, Button As Integer, Shift As Integer, X As Single, Y As Single, State As Integer)
Dim P As POINTAPI
P.X = X
P.Y = Y
If VBFlexGridHandle <> NULL_PTR Then MapWindowPoints UserControl.hWnd, VBFlexGridHandle, P, 1
RaiseEvent OLEDragOver(Data, Effect, Button, Shift, UserControl.ScaleX(P.X, vbPixels, vbContainerPosition), UserControl.ScaleY(P.Y, vbPixels, vbContainerPosition), State)
If VBFlexGridHandle <> NULL_PTR Then
    If State = vbOver And Not Effect = vbDropEffectNone Then
        If PropOLEDragDropScroll = True And (X >= 0 And X <= UserControl.ScaleWidth) And (Y >= 0 And Y <= UserControl.ScaleHeight) Then
            Dim dwStyle As Long, dwExStyle As Long
            dwStyle = GetWindowLong(VBFlexGridHandle, GWL_STYLE)
            dwExStyle = GetWindowLong(VBFlexGridHandle, GWL_EXSTYLE)
            If PropOLEDragDropScrollOrientation = FlexScrollOrientationHorizontal Or PropOLEDragDropScrollOrientation = FlexScrollOrientationBoth Then
                If (dwStyle And WS_HSCROLL) = WS_HSCROLL Then
                    Dim iCol As Long, CX1 As Long, CX2 As Long
                    For iCol = 0 To ((PropFixedCols + PropFrozenCols) - 1)
                        CX1 = CX1 + GetColWidth(iCol)
                    Next iCol
                    If (dwStyle And WS_VSCROLL) = WS_VSCROLL Then
                        If (dwExStyle And WS_EX_LEFTSCROLLBAR) = WS_EX_LEFTSCROLLBAR Then
                            CX1 = CX1 + GetSystemMetrics(SM_CXVSCROLL)
                        Else
                            CX2 = GetSystemMetrics(SM_CXVSCROLL)
                        End If
                    End If
                    If X < ((16 * PixelsPerDIP_X()) + CX1) Then
                        SendMessage VBFlexGridHandle, WM_HSCROLL, SB_LINELEFT, ByVal 0&
                    ElseIf (UserControl.ScaleWidth - X) < ((16 * PixelsPerDIP_X()) + CX2) Then
                        SendMessage VBFlexGridHandle, WM_HSCROLL, SB_LINERIGHT, ByVal 0&
                    End If
                End If
            End If
            If PropOLEDragDropScrollOrientation = FlexScrollOrientationVertical Or PropOLEDragDropScrollOrientation = FlexScrollOrientationBoth Then
                If (dwStyle And WS_VSCROLL) = WS_VSCROLL Then
                    Dim iRow As Long, CY1 As Long, CY2 As Long
                    For iRow = 0 To ((PropFixedRows + PropFrozenRows) - 1)
                        CY1 = CY1 + GetRowHeight(iRow)
                    Next iRow
                    If (dwStyle And WS_HSCROLL) = WS_HSCROLL Then CY2 = GetSystemMetrics(SM_CYHSCROLL)
                    If Y < ((16 * PixelsPerDIP_Y()) + CY1) Then
                        SendMessage VBFlexGridHandle, WM_VSCROLL, SB_LINEUP, ByVal 0&
                    ElseIf (UserControl.ScaleHeight - Y) < ((16 * PixelsPerDIP_Y()) + CY2) Then
                        SendMessage VBFlexGridHandle, WM_VSCROLL, SB_LINEDOWN, ByVal 0&
                    End If
                End If
            End If
        End If
    End If
End If
End Sub

Private Sub UserControl_OLEGiveFeedback(Effect As Long, DefaultCursors As Boolean)
RaiseEvent OLEGiveFeedback(Effect, DefaultCursors)
End Sub

Private Sub UserControl_OLESetData(Data As DataObject, DataFormat As Integer)
RaiseEvent OLESetData(Data, DataFormat)
End Sub

Private Sub UserControl_OLEStartDrag(Data As DataObject, AllowedEffects As Long)
RaiseEvent OLEStartDrag(Data, AllowedEffects)
End Sub

Public Sub OLEDrag()
Attribute OLEDrag.VB_Description = "Starts an OLE drag/drop event with the given control as the source."
UserControl.OLEDrag
End Sub

Private Sub UserControl_Resize()
Static LastHeight As Single, LastWidth As Single, LastAlign As Integer
Static InProc As Boolean
If InProc = True Then Exit Sub
InProc = True
With UserControl.Extender
Dim Align As Integer
If VBFlexGridAlignable = True Then Align = .Align Else Align = vbAlignNone
Select Case Align
    Case LastAlign
    Case vbAlignNone
    Case vbAlignTop, vbAlignBottom
        Select Case LastAlign
            Case vbAlignLeft, vbAlignRight
                .Height = LastWidth
        End Select
    Case vbAlignLeft, vbAlignRight
        Select Case LastAlign
            Case vbAlignTop, vbAlignBottom
                .Width = LastHeight
        End Select
End Select
LastHeight = .Height
LastWidth = .Width
LastAlign = Align
End With
With UserControl
If DPICorrectionFactor() <> 1 Then Call SyncObjectRectsToContainer(Me)
If VBFlexGridDesignMode = False Then
    If VBFlexGridHandle <> NULL_PTR Then MoveWindow VBFlexGridHandle, 0, 0, .ScaleWidth, .ScaleHeight, 1
Else
    If VBFlexGridDoubleBufferDC <> NULL_PTR Then
        If VBFlexGridDoubleBufferBmpOld <> NULL_PTR Then
            SelectObject VBFlexGridDoubleBufferDC, VBFlexGridDoubleBufferBmpOld
            VBFlexGridDoubleBufferBmpOld = NULL_PTR
        End If
        If VBFlexGridDoubleBufferBmp <> NULL_PTR Then
            DeleteObject VBFlexGridDoubleBufferBmp
            VBFlexGridDoubleBufferBmp = NULL_PTR
        End If
        DeleteDC VBFlexGridDoubleBufferDC
        VBFlexGridDoubleBufferDC = NULL_PTR
    End If
    SetRect VBFlexGridClientRect, 0, 0, .ScaleWidth, .ScaleHeight
    Call SetScrollBars
End If
End With
InProc = False
End Sub

Private Sub UserControl_Terminate()

#If ImplementPreTranslateMsg = True Then

If UsePreTranslateMsg = False Then Call RemoveVTableHandling(Me, VTableInterfaceInPlaceActiveObject)

#Else

Call RemoveVTableHandling(Me, VTableInterfaceInPlaceActiveObject)

#End If

Call RemoveVTableHandling(Me, VTableInterfaceControl)
Call DestroyVBFlexGrid
Call FlexWndReleaseClass
If VBFlexGridComboCalendarRegistered = True Then Call FlexComboCalendarReleaseClass
If VBFlexGridReaderModeAnchorRegistered = True Then Call FlexReaderModeAnchorReleaseClass
Call FlexReleaseShellMod
End Sub

Private Sub TimerIncrementalSearch_Timer()
Call CancelIncrementalSearch
End Sub

Public Property Get Name() As String
Attribute Name.VB_Description = "Returns the name used in code to identify an object."
Name = Ambient.DisplayName
End Property

Public Property Get Tag() As String
Attribute Tag.VB_Description = "Stores any extra data needed for your program."
Tag = Extender.Tag
End Property

Public Property Let Tag(ByVal Value As String)
Extender.Tag = Value
End Property

Public Property Get Parent() As Object
Attribute Parent.VB_Description = "Returns the object on which this object is located."
Set Parent = UserControl.Parent
End Property

Public Property Get Container() As Object
Attribute Container.VB_Description = "Returns the container of an object."
Set Container = Extender.Container
End Property

Public Property Set Container(ByVal Value As Object)
Set Extender.Container = Value
End Property

Public Property Get Left() As Single
Attribute Left.VB_Description = "Returns/sets the distance between the internal left edge of an object and the left edge of its container."
Left = Extender.Left
End Property

Public Property Let Left(ByVal Value As Single)
Extender.Left = Value
End Property

Public Property Get Top() As Single
Attribute Top.VB_Description = "Returns/sets the distance between the internal top edge of an object and the top edge of its container."
Top = Extender.Top
End Property

Public Property Let Top(ByVal Value As Single)
Extender.Top = Value
End Property

Public Property Get Width() As Single
Attribute Width.VB_Description = "Returns/sets the width of an object."
Width = Extender.Width
End Property

Public Property Let Width(ByVal Value As Single)
Extender.Width = Value
End Property

Public Property Get Height() As Single
Attribute Height.VB_Description = "Returns/sets the height of an object."
Height = Extender.Height
End Property

Public Property Let Height(ByVal Value As Single)
Extender.Height = Value
End Property

Public Property Get Visible() As Boolean
Attribute Visible.VB_Description = "Returns/sets a value that determines whether an object is visible or hidden."
Visible = Extender.Visible
End Property

Public Property Let Visible(ByVal Value As Boolean)
Extender.Visible = Value
End Property

Public Property Get ToolTipText() As String
Attribute ToolTipText.VB_Description = "Returns/sets the text displayed when the mouse is paused over the control."
Attribute ToolTipText.VB_MemberFlags = "400"
ToolTipText = Extender.ToolTipText
End Property

Public Property Let ToolTipText(ByVal Value As String)
Extender.ToolTipText = Value
End Property

Public Property Get HelpContextID() As Long
Attribute HelpContextID.VB_Description = "Specifies the default Help file context ID for an object."
HelpContextID = Extender.HelpContextID
End Property

Public Property Let HelpContextID(ByVal Value As Long)
Extender.HelpContextID = Value
End Property

Public Property Get WhatsThisHelpID() As Long
Attribute WhatsThisHelpID.VB_Description = "Returns/sets an associated context number for an object."
Attribute WhatsThisHelpID.VB_MemberFlags = "400"
WhatsThisHelpID = Extender.WhatsThisHelpID
End Property

Public Property Let WhatsThisHelpID(ByVal Value As Long)
Extender.WhatsThisHelpID = Value
End Property

Public Property Get Align() As Integer
Attribute Align.VB_Description = "Returns/sets a value that determines where an object is displayed on a form."
Attribute Align.VB_MemberFlags = "400"
Align = Extender.Align
End Property

Public Property Let Align(ByVal Value As Integer)
Extender.Align = Value
End Property

Public Property Get DragIcon() As IPictureDisp
Attribute DragIcon.VB_Description = "Returns/sets the icon to be displayed as the pointer in a drag-and-drop operation."
Attribute DragIcon.VB_MemberFlags = "400"
Set DragIcon = Extender.DragIcon
End Property

Public Property Let DragIcon(ByVal Value As IPictureDisp)
Extender.DragIcon = Value
End Property

Public Property Set DragIcon(ByVal Value As IPictureDisp)
Set Extender.DragIcon = Value
End Property

Public Property Get DragMode() As Integer
Attribute DragMode.VB_Description = "Returns/sets a value that determines whether manual or automatic drag mode is used."
Attribute DragMode.VB_MemberFlags = "400"
DragMode = Extender.DragMode
End Property

Public Property Let DragMode(ByVal Value As Integer)
Extender.DragMode = Value
End Property

Public Sub Drag(Optional ByRef Action As Variant)
Attribute Drag.VB_Description = "Begins, ends, or cancels a drag operation of any object except Line, Menu, Shape, and Timer."
If IsMissing(Action) Then Extender.Drag Else Extender.Drag Action
End Sub

Public Sub SetFocus()
Attribute SetFocus.VB_Description = "Moves the focus to the specified object."
Extender.SetFocus
End Sub

Public Sub ZOrder(Optional ByRef Position As Variant)
Attribute ZOrder.VB_Description = "Places a specified object at the front or back of the z-order within its graphical level."
If IsMissing(Position) Then Extender.ZOrder Else Extender.ZOrder Position
End Sub

#If VBA7 Then
Public Property Get hWnd() As LongPtr
Attribute hWnd.VB_Description = "Returns a handle to a control."
Attribute hWnd.VB_UserMemId = -515
#Else
Public Property Get hWnd() As Long
Attribute hWnd.VB_Description = "Returns a handle to a control."
Attribute hWnd.VB_UserMemId = -515
#End If
hWnd = VBFlexGridHandle
End Property

#If VBA7 Then
Public Property Get hWndUserControl() As LongPtr
Attribute hWndUserControl.VB_Description = "Returns a handle to a control."
#Else
Public Property Get hWndUserControl() As Long
Attribute hWndUserControl.VB_Description = "Returns a handle to a control."
#End If
hWndUserControl = UserControl.hWnd
End Property

#If VBA7 Then
Public Property Get hWndEdit() As LongPtr
Attribute hWndEdit.VB_Description = "Returns a handle to a control."
#Else
Public Property Get hWndEdit() As Long
Attribute hWndEdit.VB_Description = "Returns a handle to a control."
#End If
hWndEdit = VBFlexGridEditHandle
End Property

#If VBA7 Then
Public Property Get hWndComboButton() As LongPtr
Attribute hWndComboButton.VB_Description = "Returns a handle to a control."
#Else
Public Property Get hWndComboButton() As Long
Attribute hWndComboButton.VB_Description = "Returns a handle to a control."
#End If
hWndComboButton = VBFlexGridComboButtonHandle
End Property

#If VBA7 Then
Public Property Get hWndComboList() As LongPtr
Attribute hWndComboList.VB_Description = "Returns a handle to a control."
#Else
Public Property Get hWndComboList() As Long
Attribute hWndComboList.VB_Description = "Returns a handle to a control."
#End If
hWndComboList = VBFlexGridComboListHandle
End Property

#If VBA7 Then
Public Property Get hWndComboCalendar() As LongPtr
Attribute hWndComboCalendar.VB_Description = "Returns a handle to a control."
#Else
Public Property Get hWndComboCalendar() As Long
Attribute hWndComboCalendar.VB_Description = "Returns a handle to a control."
#End If
hWndComboCalendar = VBFlexGridComboCalendarHandle
End Property

#If ImplementDataSource = True Then

Public Property Get DataSource() As MSDATASRC.DataSource
Attribute DataSource.VB_Description = "Returns/sets the data source for the control."
Attribute DataSource.VB_MemberFlags = "4"
Set DataSource = PropDataSource
End Property

Public Property Let DataSource(ByVal Value As MSDATASRC.DataSource)
Set Me.DataSource = Value
End Property

Public Property Set DataSource(ByVal Value As MSDATASRC.DataSource)
Set PropDataSource = Value
If VBFlexGridDesignMode = False Then
    
    #If ImplementFlexDataSource = True Then
    
    If Not VBFlexGridFlexDataSource Is Nothing Then
        Set VBFlexGridFlexDataSource = Nothing
        Set VBFlexGridFlexDataSource2 = Nothing
        VBFlexGridFlexDataSourceFlags = 0
        Call RedrawGrid
    End If
    
    #End If
    
    If Not PropDataSource Is Nothing Then
        If PropRecordset Is Nothing Then Set PropRecordset = CreateObject("ADODB.Recordset")
        With PropRecordset
        If .State <> 0 Then .Close
        If StrPtr(PropDataMember) = NULL_PTR Then .DataMember = "" Else .DataMember = PropDataMember
        Set .DataSource = PropDataSource
        If .State <> 0 Then
            If .RecordCount > -1 Then ' The cursor type of the Recordset affects whether the number of records can be determined.
                Me.Rows = PropFixedRows + .RecordCount
                Me.Cols = PropFixedCols + .Fields.Count
                Me.Clear
                Dim iRow As Long, iCol As Long
                If PropFixedRows > 0 Then
                    For iCol = 0 To (PropFixedCols - 1)
                        VBFlexGridColsInfo(iCol).Key = vbNullString
                        VBFlexGridColsInfo(iCol).DataType = 0
                        If (VBFlexGridColsInfo(iCol).State And CLIS_NULLABLE) = CLIS_NULLABLE Then VBFlexGridColsInfo(iCol).State = VBFlexGridColsInfo(iCol).State And Not CLIS_NULLABLE
                        VBFlexGridColsInfo(iCol).NumericPrecision = 0
                        VBFlexGridColsInfo(iCol).NumericScale = 0
                        VBFlexGridColsInfo(iCol).DataCapacity = 0
                    Next iCol
                    For iCol = 0 To (.Fields.Count - 1)
                        Me.TextMatrix(0, iCol + PropFixedCols) = .Fields(iCol).Name
                        VBFlexGridColsInfo(iCol + PropFixedCols).Key = .Fields(iCol).Name
                        VBFlexGridColsInfo(iCol + PropFixedCols).DataType = .Fields(iCol).Type
                        If (.Fields(iCol).Attributes And &H20) = &H20 Then ' adFldIsNullable
                            If (VBFlexGridColsInfo(iCol + PropFixedCols).State And CLIS_NULLABLE) = 0 Then VBFlexGridColsInfo(iCol + PropFixedCols).State = VBFlexGridColsInfo(iCol + PropFixedCols).State Or CLIS_NULLABLE
                        Else
                            If (VBFlexGridColsInfo(iCol + PropFixedCols).State And CLIS_NULLABLE) = CLIS_NULLABLE Then VBFlexGridColsInfo(iCol + PropFixedCols).State = VBFlexGridColsInfo(iCol + PropFixedCols).State And Not CLIS_NULLABLE
                        End If
                        VBFlexGridColsInfo(iCol + PropFixedCols).NumericPrecision = .Fields(iCol).Precision
                        VBFlexGridColsInfo(iCol + PropFixedCols).NumericScale = .Fields(iCol).NumericScale
                        VBFlexGridColsInfo(iCol + PropFixedCols).DataCapacity = .Fields(iCol).DefinedSize
                    Next iCol
                End If
                If .RecordCount > 0 Then
                    Dim ArrRows As Variant
                    ArrRows = .GetRows(, 1) ' adBookmarkFirst
                    Dim LBoundCols As Long, UBoundCols As Long
                    LBoundCols = LBound(ArrRows, 1)
                    UBoundCols = UBound(ArrRows, 1)
                    Dim LBoundRows As Long, UBoundRows As Long
                    LBoundRows = LBound(ArrRows, 2)
                    UBoundRows = UBound(ArrRows, 2)
                    For iRow = LBoundRows To UBoundRows
                        For iCol = LBoundCols To UBoundCols
                            If Not IsNull(ArrRows(iCol, iRow)) Then
                                Call SetCellText((iRow + (0 - LBoundRows)) + PropFixedRows, (iCol + (0 - LBoundCols)) + PropFixedCols, (ArrRows(iCol, iRow)))
                            Else
                                Call SetCellText((iRow + (0 - LBoundRows)) + PropFixedRows, (iCol + (0 - LBoundCols)) + PropFixedCols, vbNullString)
                            End If
                        Next iCol
                    Next iRow
                    Call RedrawGrid
                End If
            End If
        End If
        End With
    Else
        Set PropRecordset = Nothing
    End If
End If
UserControl.PropertyChanged "DataSource"
End Property

Public Property Get DataMember() As MSDATASRC.DataMember
Attribute DataMember.VB_Description = "Returns/sets the data member for the control."
Attribute DataMember.VB_MemberFlags = "4"
DataMember = PropDataMember
End Property

Public Property Let DataMember(ByVal Value As MSDATASRC.DataMember)
PropDataMember = Value
Set Me.DataSource = PropDataSource
UserControl.PropertyChanged "DataMember"
End Property

#End If

Public Property Get Font() As StdFont
Attribute Font.VB_Description = "Returns a Font object."
Attribute Font.VB_UserMemId = -512
Set Font = PropFont
End Property

Public Property Let Font(ByVal NewFont As StdFont)
Set Me.Font = NewFont
End Property

Public Property Set Font(ByVal NewFont As StdFont)
If NewFont Is Nothing Then Set NewFont = Ambient.Font
Dim OldFontHandle As LongPtr
Set PropFont = NewFont
OldFontHandle = VBFlexGridFontHandle
VBFlexGridFontHandle = CreateGDIFontFromOLEFont(PropFont, PropFontQuality)
Dim hDCScreen As LongPtr
hDCScreen = GetDC(NULL_PTR)
If hDCScreen <> NULL_PTR Then
    Dim TM As TEXTMETRIC, hFontOld As LongPtr
    If VBFlexGridFontHandle <> NULL_PTR Then hFontOld = SelectObject(hDCScreen, VBFlexGridFontHandle)
    If GetTextMetrics(hDCScreen, TM) <> 0 Then
        VBFlexGridDefaultRowHeight = TM.TMHeight + VBFlexGridPixelMetrics.CellSpacing.CY
        VBFlexGridDefaultColWidth = VBFlexGridDefaultRowHeight * RATIO_OF_ROWINFO_HEIGHT_TO_COLINFO_WIDTH
    End If
    If hFontOld <> NULL_PTR Then SelectObject hDCScreen, hFontOld
    ReleaseDC NULL_PTR, hDCScreen
End If
Me.Refresh
If OldFontHandle <> NULL_PTR Then DeleteObject OldFontHandle
UserControl.PropertyChanged "Font"
End Property

Private Sub PropFont_FontChanged(ByVal PropertyName As String)
Dim OldFontHandle As LongPtr
OldFontHandle = VBFlexGridFontHandle
VBFlexGridFontHandle = CreateGDIFontFromOLEFont(PropFont, PropFontQuality)
Dim hDCScreen As LongPtr
hDCScreen = GetDC(NULL_PTR)
If hDCScreen <> NULL_PTR Then
    Dim TM As TEXTMETRIC, hFontOld As LongPtr
    If VBFlexGridFontHandle <> NULL_PTR Then hFontOld = SelectObject(hDCScreen, VBFlexGridFontHandle)
    If GetTextMetrics(hDCScreen, TM) <> 0 Then
        VBFlexGridDefaultRowHeight = TM.TMHeight + VBFlexGridPixelMetrics.CellSpacing.CY
        VBFlexGridDefaultColWidth = VBFlexGridDefaultRowHeight * RATIO_OF_ROWINFO_HEIGHT_TO_COLINFO_WIDTH
    End If
    If hFontOld <> NULL_PTR Then SelectObject hDCScreen, hFontOld
    ReleaseDC NULL_PTR, hDCScreen
End If
Me.Refresh
If OldFontHandle <> NULL_PTR Then DeleteObject OldFontHandle
UserControl.PropertyChanged "Font"
End Sub

Public Property Get FontFixed() As StdFont
Attribute FontFixed.VB_Description = "Returns a Font object."
If PropFontFixed Is Nothing Then
    Set FontFixed = PropFont
Else
    Set FontFixed = PropFontFixed
End If
End Property

Public Property Let FontFixed(ByVal NewFont As StdFont)
Set Me.FontFixed = NewFont
End Property

Public Property Set FontFixed(ByVal NewFont As StdFont)
Dim OldFontHandle As LongPtr
Set PropFontFixed = NewFont
OldFontHandle = VBFlexGridFontFixedHandle
If PropFontFixed Is Nothing Then
    VBFlexGridFontFixedHandle = NULL_PTR
    VBFlexGridDefaultFixedRowHeight = -1
    VBFlexGridDefaultFixedColWidth = -1
Else
    VBFlexGridFontFixedHandle = CreateGDIFontFromOLEFont(PropFontFixed, PropFontQuality)
    Dim hDCScreen As LongPtr
    hDCScreen = GetDC(NULL_PTR)
    If hDCScreen <> NULL_PTR Then
        Dim TM As TEXTMETRIC, hFontOld As LongPtr
        If VBFlexGridFontFixedHandle <> NULL_PTR Then hFontOld = SelectObject(hDCScreen, VBFlexGridFontFixedHandle)
        If GetTextMetrics(hDCScreen, TM) <> 0 Then
            VBFlexGridDefaultFixedRowHeight = TM.TMHeight + VBFlexGridPixelMetrics.CellSpacing.CY
            VBFlexGridDefaultFixedColWidth = VBFlexGridDefaultFixedRowHeight * RATIO_OF_ROWINFO_HEIGHT_TO_COLINFO_WIDTH
        End If
        If hFontOld <> NULL_PTR Then SelectObject hDCScreen, hFontOld
        ReleaseDC NULL_PTR, hDCScreen
    End If
End If
Me.Refresh
If OldFontHandle <> NULL_PTR Then DeleteObject OldFontHandle
UserControl.PropertyChanged "FontFixed"
End Property

Private Sub PropFontFixed_FontChanged(ByVal PropertyName As String)
Dim OldFontHandle As LongPtr
OldFontHandle = VBFlexGridFontFixedHandle
VBFlexGridFontFixedHandle = CreateGDIFontFromOLEFont(PropFontFixed, PropFontQuality)
Dim hDCScreen As LongPtr
hDCScreen = GetDC(NULL_PTR)
If hDCScreen <> NULL_PTR Then
    Dim TM As TEXTMETRIC, hFontOld As LongPtr
    If VBFlexGridFontFixedHandle <> NULL_PTR Then hFontOld = SelectObject(hDCScreen, VBFlexGridFontFixedHandle)
    If GetTextMetrics(hDCScreen, TM) <> 0 Then
        VBFlexGridDefaultFixedRowHeight = TM.TMHeight + VBFlexGridPixelMetrics.CellSpacing.CY
        VBFlexGridDefaultFixedColWidth = VBFlexGridDefaultFixedRowHeight * RATIO_OF_ROWINFO_HEIGHT_TO_COLINFO_WIDTH
    End If
    If hFontOld <> NULL_PTR Then SelectObject hDCScreen, hFontOld
    ReleaseDC NULL_PTR, hDCScreen
End If
Me.Refresh
If OldFontHandle <> NULL_PTR Then DeleteObject OldFontHandle
UserControl.PropertyChanged "FontFixed"
End Sub

Public Property Get VisualStyles() As Boolean
Attribute VisualStyles.VB_Description = "Returns/sets a value that determines whether the visual styles are enabled or not. Requires comctl32.dll version 6.0 or higher."
VisualStyles = PropVisualStyles
End Property

Public Property Let VisualStyles(ByVal Value As Boolean)
PropVisualStyles = Value
VBFlexGridEnabledVisualStyles = EnabledVisualStyles()
If VBFlexGridHandle <> NULL_PTR And VBFlexGridEnabledVisualStyles = True Then
    If PropVisualStyles = True Then
        ActivateVisualStyles VBFlexGridHandle
    Else
        RemoveVisualStyles VBFlexGridHandle
    End If
    Call SetVisualStylesToolTip
    Me.Refresh
    If VBFlexGridDesignMode = True Then SetWindowPos UserControl.hWnd, NULL_PTR, 0, 0, 0, 0, SWP_NOMOVE Or SWP_NOSIZE Or SWP_NOOWNERZORDER Or SWP_NOZORDER Or SWP_FRAMECHANGED
End If
UserControl.PropertyChanged "VisualStyles"
End Property

Public Property Get BackColor() As OLE_COLOR
Attribute BackColor.VB_Description = "Returns/sets the background color used to display text and graphics in an object."
BackColor = PropBackColor
End Property

Public Property Let BackColor(ByVal Value As OLE_COLOR)
PropBackColor = Value
PropBackColorAlt = Value
If VBFlexGridHandle <> NULL_PTR Then
    If VBFlexGridBackColorBrush <> NULL_PTR Then DeleteObject VBFlexGridBackColorBrush
    VBFlexGridBackColorBrush = CreateSolidBrush(WinColor(PropBackColor))
    If VBFlexGridBackColorAltBrush <> NULL_PTR Then DeleteObject VBFlexGridBackColorAltBrush
    VBFlexGridBackColorAltBrush = CreateSolidBrush(WinColor(PropBackColorAlt))
End If
Me.Refresh
UserControl.PropertyChanged "BackColor"
End Property

Public Property Get BackColorAlt() As OLE_COLOR
Attribute BackColorAlt.VB_Description = "Returns/sets the background color used to display text and graphics in an object."
BackColorAlt = PropBackColorAlt
End Property

Public Property Let BackColorAlt(ByVal Value As OLE_COLOR)
PropBackColorAlt = Value
If VBFlexGridHandle <> NULL_PTR Then
    If VBFlexGridBackColorAltBrush <> NULL_PTR Then DeleteObject VBFlexGridBackColorAltBrush
    VBFlexGridBackColorAltBrush = CreateSolidBrush(WinColor(PropBackColorAlt))
End If
Me.Refresh
UserControl.PropertyChanged "BackColorAlt"
End Property

Public Property Get BackColorBkg() As OLE_COLOR
Attribute BackColorBkg.VB_Description = "Returns/sets the background color used to display text and graphics in an object."
Attribute BackColorBkg.VB_UserMemId = -501
BackColorBkg = PropBackColorBkg
End Property

Public Property Let BackColorBkg(ByVal Value As OLE_COLOR)
PropBackColorBkg = Value
If VBFlexGridHandle <> NULL_PTR Then
    If VBFlexGridBackColorBkgBrush <> NULL_PTR Then DeleteObject VBFlexGridBackColorBkgBrush
    VBFlexGridBackColorBkgBrush = CreateSolidBrush(WinColor(PropBackColorBkg))
End If
UserControl.BackColor = PropBackColorBkg
Me.Refresh
UserControl.PropertyChanged "BackColorBkg"
End Property

Public Property Get BackColorFixed() As OLE_COLOR
Attribute BackColorFixed.VB_Description = "Returns/sets the background color used to display text and graphics in an object."
BackColorFixed = PropBackColorFixed
End Property

Public Property Let BackColorFixed(ByVal Value As OLE_COLOR)
PropBackColorFixed = Value
If VBFlexGridHandle <> NULL_PTR Then
    If VBFlexGridBackColorFixedBrush <> NULL_PTR Then DeleteObject VBFlexGridBackColorFixedBrush
    VBFlexGridBackColorFixedBrush = CreateSolidBrush(WinColor(PropBackColorFixed))
End If
Me.Refresh
UserControl.PropertyChanged "BackColorFixed"
End Property

Public Property Get BackColorSel() As OLE_COLOR
Attribute BackColorSel.VB_Description = "Returns/sets the background color used to display text and graphics in an object."
BackColorSel = PropBackColorSel
End Property

Public Property Let BackColorSel(ByVal Value As OLE_COLOR)
PropBackColorSel = Value
If VBFlexGridHandle <> NULL_PTR Then
    If VBFlexGridBackColorSelBrush <> NULL_PTR Then DeleteObject VBFlexGridBackColorSelBrush
    VBFlexGridBackColorSelBrush = CreateSolidBrush(WinColor(PropBackColorSel))
    If VBFlexGridFocusRectPen <> NULL_PTR Then
        DeleteObject VBFlexGridFocusRectPen
        VBFlexGridFocusRectPen = NULL_PTR
    End If
    If PropFocusRect = FlexFocusRectFlat Then VBFlexGridFocusRectPen = CreatePen(PS_INSIDEFRAME, GetFocusRectWidth(), WinColor(PropBackColorSel))
End If
Me.Refresh
UserControl.PropertyChanged "BackColorSel"
End Property

Public Property Get ForeColor() As OLE_COLOR
Attribute ForeColor.VB_Description = "Returns/sets the foreground color used to display text and graphics in an object."
Attribute ForeColor.VB_UserMemId = -513
ForeColor = PropForeColor
End Property

Public Property Let ForeColor(ByVal Value As OLE_COLOR)
PropForeColor = Value
Me.Refresh
UserControl.PropertyChanged "ForeColor"
End Property

Public Property Get ForeColorFixed() As OLE_COLOR
Attribute ForeColorFixed.VB_Description = "Returns/sets the foreground color used to display text and graphics in an object."
ForeColorFixed = PropForeColorFixed
End Property

Public Property Let ForeColorFixed(ByVal Value As OLE_COLOR)
PropForeColorFixed = Value
Me.Refresh
UserControl.PropertyChanged "ForeColorFixed"
End Property

Public Property Get ForeColorSel() As OLE_COLOR
Attribute ForeColorSel.VB_Description = "Returns/sets the foreground color used to display text and graphics in an object."
ForeColorSel = PropForeColorSel
End Property

Public Property Let ForeColorSel(ByVal Value As OLE_COLOR)
PropForeColorSel = Value
Me.Refresh
UserControl.PropertyChanged "ForeColorSel"
End Property

Public Property Get GridColor() As OLE_COLOR
Attribute GridColor.VB_Description = "Returns/sets the color used to draw the lines between flex grid cells."
GridColor = PropGridColor
End Property

Public Property Let GridColor(ByVal Value As OLE_COLOR)
PropGridColor = Value
If VBFlexGridHandle <> NULL_PTR Then
    If VBFlexGridGridLinePen <> NULL_PTR Then DeleteObject VBFlexGridGridLinePen
    VBFlexGridGridLinePen = CreatePen(VBFlexGridPenStyle, PropGridLineWidth, WinColor(PropGridColor))
End If
Me.Refresh
UserControl.PropertyChanged "GridColor"
End Property

Public Property Get GridColorFixed() As OLE_COLOR
Attribute GridColorFixed.VB_Description = "Returns/sets the color used to draw the lines between flex grid cells."
GridColorFixed = PropGridColorFixed
End Property

Public Property Let GridColorFixed(ByVal Value As OLE_COLOR)
PropGridColorFixed = Value
If VBFlexGridHandle <> NULL_PTR Then
    If VBFlexGridGridLineFixedPen <> NULL_PTR Then DeleteObject VBFlexGridGridLineFixedPen
    If PropGridLineWidthFixed = -1 Then
        VBFlexGridGridLineFixedPen = CreatePen(VBFlexGridFixedPenStyle, PropGridLineWidth, WinColor(PropGridColorFixed))
    Else
        VBFlexGridGridLineFixedPen = CreatePen(VBFlexGridFixedPenStyle, PropGridLineWidthFixed, WinColor(PropGridColorFixed))
    End If
End If
Me.Refresh
UserControl.PropertyChanged "GridColorFixed"
End Property

Public Property Get GridColorFrozen() As OLE_COLOR
Attribute GridColorFrozen.VB_Description = "Returns/sets the color used to draw the lines between flex grid cells."
GridColorFrozen = PropGridColorFrozen
End Property

Public Property Let GridColorFrozen(ByVal Value As OLE_COLOR)
PropGridColorFrozen = Value
If VBFlexGridHandle <> NULL_PTR Then
    If VBFlexGridGridLineFrozenPen <> NULL_PTR Then DeleteObject VBFlexGridGridLineFrozenPen
    If PropGridLineWidthFrozen = -1 Then
        If PropGridLineWidthFixed = -1 Then
            VBFlexGridGridLineFrozenPen = CreatePen(VBFlexGridFrozenPenStyle, PropGridLineWidth, WinColor(PropGridColorFrozen))
        Else
            VBFlexGridGridLineFrozenPen = CreatePen(VBFlexGridFrozenPenStyle, PropGridLineWidthFixed, WinColor(PropGridColorFrozen))
        End If
    Else
        VBFlexGridGridLineFrozenPen = CreatePen(VBFlexGridFrozenPenStyle, PropGridLineWidthFrozen, WinColor(PropGridColorFrozen))
    End If
End If
Me.Refresh
UserControl.PropertyChanged "GridColorFrozen"
End Property

Public Property Get SortArrowColor() As OLE_COLOR
Attribute SortArrowColor.VB_Description = "Returns/sets the sort arrow color."
SortArrowColor = PropSortArrowColor
End Property

Public Property Let SortArrowColor(ByVal Value As OLE_COLOR)
PropSortArrowColor = Value
Me.Refresh
UserControl.PropertyChanged "SortArrowColor"
End Property

Public Property Get FloodColor() As OLE_COLOR
Attribute FloodColor.VB_Description = "Returns/sets the color used to flood cells."
FloodColor = PropFloodColor
End Property

Public Property Let FloodColor(ByVal Value As OLE_COLOR)
PropFloodColor = Value
Me.Refresh
UserControl.PropertyChanged "FloodColor"
End Property

Public Property Get InsertMarkColor() As OLE_COLOR
Attribute InsertMarkColor.VB_Description = "Returns/sets the color of the insertion mark."
InsertMarkColor = PropInsertMarkColor
End Property

Public Property Let InsertMarkColor(ByVal Value As OLE_COLOR)
PropInsertMarkColor = Value
If VBFlexGridHandle <> NULL_PTR Then
    If VBFlexGridInsertMarkBrush <> NULL_PTR Then
        DeleteObject VBFlexGridInsertMarkBrush
        VBFlexGridInsertMarkBrush = NULL_PTR
    End If
End If
If VBFlexGridInsertMark > -1 Then Call RedrawGrid
UserControl.PropertyChanged "InsertMarkColor"
End Property

Public Property Get Enabled() As Boolean
Attribute Enabled.VB_Description = "Returns/sets a value that determines whether an object can respond to user-generated events."
Attribute Enabled.VB_UserMemId = -514
Enabled = UserControl.Enabled
End Property

Public Property Let Enabled(ByVal Value As Boolean)
UserControl.Enabled = Value
If VBFlexGridHandle <> NULL_PTR And VBFlexGridDesignMode = False Then EnableWindow VBFlexGridHandle, IIf(Value = True, 1, 0)
UserControl.PropertyChanged "Enabled"
End Property

Public Property Get AllowDropFiles() As Boolean
Attribute AllowDropFiles.VB_Description = "Returns/sets a value that determines whether drag-drop files are allowed or not. Only applicable when there is no OLE drop target available."
If VBFlexGridHandle <> NULL_PTR And VBFlexGridDesignMode = False Then
    AllowDropFiles = CBool((GetWindowLong(VBFlexGridHandle, GWL_EXSTYLE) And WS_EX_ACCEPTFILES) <> 0)
Else
    AllowDropFiles = PropAllowDropFiles
End If
End Property

Public Property Let AllowDropFiles(ByVal Value As Boolean)
PropAllowDropFiles = Value
If VBFlexGridHandle <> NULL_PTR And VBFlexGridDesignMode = False Then DragAcceptFiles VBFlexGridHandle, IIf(PropAllowDropFiles = True, 1, 0)
UserControl.PropertyChanged "AllowDropFiles"
End Property

Public Property Get OLEDragDropScroll() As Boolean
Attribute OLEDragDropScroll.VB_Description = "Returns/Sets whether this object will scroll during an OLE drag/drop operation."
OLEDragDropScroll = PropOLEDragDropScroll
End Property

Public Property Let OLEDragDropScroll(ByVal Value As Boolean)
PropOLEDragDropScroll = Value
UserControl.PropertyChanged "OLEDragDropScroll"
End Property

Public Property Get OLEDragDropScrollOrientation() As FlexScrollOrientationConstants
Attribute OLEDragDropScrollOrientation.VB_Description = "Returns/Sets the scroll orientation for an OLE drag/drop scroll."
OLEDragDropScrollOrientation = PropOLEDragDropScrollOrientation
End Property

Public Property Let OLEDragDropScrollOrientation(ByVal Value As FlexScrollOrientationConstants)
Select Case Value
    Case FlexScrollOrientationHorizontal, FlexScrollOrientationVertical, FlexScrollOrientationBoth
        PropOLEDragDropScrollOrientation = Value
    Case Else
        Err.Raise 380
End Select
UserControl.PropertyChanged "OLEDragDropScrollOrientation"
End Property

Public Property Get OLEDropMode() As FlexOLEDropModeConstants
Attribute OLEDropMode.VB_Description = "Returns/Sets whether this object can act as an OLE drop target."
OLEDropMode = UserControl.OLEDropMode
End Property

Public Property Let OLEDropMode(ByVal Value As FlexOLEDropModeConstants)
Select Case Value
    Case FlexOLEDropModeNone, FlexOLEDropModeManual
        UserControl.OLEDropMode = Value
    Case Else
        Err.Raise 380
End Select
UserControl.PropertyChanged "OLEDropMode"
End Property

Public Property Get MousePointer() As FlexMousePointerConstants
Attribute MousePointer.VB_Description = "Returns/sets the type of mouse pointer displayed when over part of an object."
MousePointer = PropMousePointer
End Property

Public Property Let MousePointer(ByVal Value As FlexMousePointerConstants)
Select Case Value
    Case 0 To 30, 99
        PropMousePointer = Value
    Case Else
        Err.Raise 380
End Select
If VBFlexGridDesignMode = False Then Call RefreshMousePointer
UserControl.PropertyChanged "MousePointer"
End Property

Public Property Get MouseIcon() As IPictureDisp
Attribute MouseIcon.VB_Description = "Returns/sets a custom mouse icon."
Set MouseIcon = PropMouseIcon
End Property

Public Property Let MouseIcon(ByVal Value As IPictureDisp)
Set Me.MouseIcon = Value
End Property

Public Property Set MouseIcon(ByVal Value As IPictureDisp)
If Value Is Nothing Then
    Set PropMouseIcon = Nothing
Else
    If Value.Type = vbPicTypeIcon Or Value.Handle = NULL_PTR Then
        Set PropMouseIcon = Value
    Else
        If VBFlexGridDesignMode = True Then
            MsgBox "Invalid property value", vbCritical + vbOKOnly
            Exit Property
        Else
            Err.Raise 380
        End If
    End If
End If
If VBFlexGridDesignMode = False Then Call RefreshMousePointer
UserControl.PropertyChanged "MouseIcon"
End Property

Public Property Get MouseTrack() As Boolean
Attribute MouseTrack.VB_Description = "Returns/sets whether mouse events occurs when the mouse pointer enters or leaves the control."
MouseTrack = PropMouseTrack
End Property

Public Property Let MouseTrack(ByVal Value As Boolean)
PropMouseTrack = Value
UserControl.PropertyChanged "MouseTrack"
End Property

Public Property Get RightToLeft() As Boolean
Attribute RightToLeft.VB_Description = "Determines text display direction and control visual appearance on a bidirectional system."
Attribute RightToLeft.VB_UserMemId = -611
RightToLeft = PropRightToLeft
End Property

Public Property Let RightToLeft(ByVal Value As Boolean)
PropRightToLeft = Value
UserControl.RightToLeft = PropRightToLeft
If PropRightToLeft = True Then
    Select Case PropRightToLeftMode
        Case FlexRightToLeftModeNoControl
        Case FlexRightToLeftModeVBAME
            PropRightToLeft = UserControl.RightToLeft
        Case FlexRightToLeftModeSystemLocale, FlexRightToLeftModeUserLocale, FlexRightToLeftModeOSLanguage
            Const LOCALE_FONTSIGNATURE As Long = &H58, SORT_DEFAULT As Long = &H0
            Dim LangID As Integer, LCID As Long, LocaleSig As TLOCALESIGNATURE
            Select Case PropRightToLeftMode
                Case FlexRightToLeftModeSystemLocale
                    LangID = GetSystemDefaultLangID()
                Case FlexRightToLeftModeUserLocale
                    LangID = GetUserDefaultLangID()
                Case FlexRightToLeftModeOSLanguage
                    LangID = GetUserDefaultUILanguage()
            End Select
            LCID = (SORT_DEFAULT * &H10000) Or LangID
            If GetLocaleInfo(LCID, LOCALE_FONTSIGNATURE, VarPtr(LocaleSig), (LenB(LocaleSig) / 2)) <> 0 Then
                ' Unicode subset bitfield 0 to 127. Bit 123 = Layout progress, horizontal from right to left
                PropRightToLeft = CBool((LocaleSig.lsUsb(15) And (2 ^ (4 - 1))) <> 0)
            End If
    End Select
End If
Dim dwMask As Long, dwExStyle As Long
If VBFlexGridDesignMode = False Then
    ' Only on run-time the UserControl gets the mirror placement with WS_EX_LAYOUTRTL.
    ' On design-time the mirror effect will be simulated by setting WS_EX_LEFTSCROLLBAR and SetLayout API.
    ' This way the design-time dragging of the control on a form will not be reversed and works as expected.
    If PropRightToLeft = True And PropRightToLeftLayout = True Then dwMask = WS_EX_LAYOUTRTL
    dwExStyle = GetWindowLong(UserControl.hWnd, GWL_EXSTYLE)
    If (dwExStyle And WS_EX_LAYOUTRTL) = WS_EX_LAYOUTRTL Then dwExStyle = dwExStyle And Not WS_EX_LAYOUTRTL
    If (dwExStyle And WS_EX_RTLREADING) = WS_EX_RTLREADING Then dwExStyle = dwExStyle And Not WS_EX_RTLREADING
    If (dwExStyle And WS_EX_RIGHT) = WS_EX_RIGHT Then dwExStyle = dwExStyle And Not WS_EX_RIGHT
    If (dwExStyle And WS_EX_LEFTSCROLLBAR) = WS_EX_LEFTSCROLLBAR Then dwExStyle = dwExStyle And Not WS_EX_LEFTSCROLLBAR
    If (dwMask And WS_EX_LAYOUTRTL) = WS_EX_LAYOUTRTL Then dwExStyle = dwExStyle Or WS_EX_LAYOUTRTL
    If (dwMask And WS_EX_RTLREADING) = WS_EX_RTLREADING Then dwExStyle = dwExStyle Or WS_EX_RTLREADING
    If (dwMask And WS_EX_RIGHT) = WS_EX_RIGHT Then dwExStyle = dwExStyle Or WS_EX_RIGHT
    If (dwMask And WS_EX_LEFTSCROLLBAR) = WS_EX_LEFTSCROLLBAR Then dwExStyle = dwExStyle Or WS_EX_LEFTSCROLLBAR
    SetWindowLong UserControl.hWnd, GWL_EXSTYLE, dwExStyle
    InvalidateRect UserControl.hWnd, ByVal NULL_PTR, 1
    SetWindowPos UserControl.hWnd, NULL_PTR, 0, 0, 0, 0, SWP_NOMOVE Or SWP_NOSIZE Or SWP_NOOWNERZORDER Or SWP_NOZORDER Or SWP_FRAMECHANGED
    dwMask = 0
    dwExStyle = 0
Else
    ' On design-time the right-to-left layout and reading flag are set manually on this property.
    ' Whereas on run-time the flags are set when receiving the WM_STYLECHANGED message.
    ' This enables an application to change the bidirectional appearance on his own,
    ' independently from this property. (by setting either WS_EX_LAYOUTRTL or WS_EX_RTLREADING)
    VBFlexGridRTLLayout = CBool(PropRightToLeft = True And PropRightToLeftLayout = True)
    VBFlexGridRTLReading = CBool(PropRightToLeft = True And PropRightToLeftLayout = False)
    If VBFlexGridDoubleBufferDC <> NULL_PTR Then SetLayout VBFlexGridDoubleBufferDC, IIf(VBFlexGridRTLLayout, LAYOUT_RTL, 0)
End If
If VBFlexGridHandle <> NULL_PTR Then
    If PropRightToLeft = True Then
        If VBFlexGridDesignMode = False Then
            If PropRightToLeftLayout = True Then dwMask = WS_EX_LAYOUTRTL Else dwMask = WS_EX_RTLREADING
        Else
            If PropRightToLeftLayout = True Then dwMask = WS_EX_LEFTSCROLLBAR
        End If
    End If
    dwExStyle = GetWindowLong(VBFlexGridHandle, GWL_EXSTYLE)
    If (dwExStyle And WS_EX_LAYOUTRTL) = WS_EX_LAYOUTRTL Then dwExStyle = dwExStyle And Not WS_EX_LAYOUTRTL
    If (dwExStyle And WS_EX_RTLREADING) = WS_EX_RTLREADING Then dwExStyle = dwExStyle And Not WS_EX_RTLREADING
    If (dwExStyle And WS_EX_RIGHT) = WS_EX_RIGHT Then dwExStyle = dwExStyle And Not WS_EX_RIGHT
    If (dwExStyle And WS_EX_LEFTSCROLLBAR) = WS_EX_LEFTSCROLLBAR Then dwExStyle = dwExStyle And Not WS_EX_LEFTSCROLLBAR
    If (dwMask And WS_EX_LAYOUTRTL) = WS_EX_LAYOUTRTL Then dwExStyle = dwExStyle Or WS_EX_LAYOUTRTL
    If (dwMask And WS_EX_RTLREADING) = WS_EX_RTLREADING Then dwExStyle = dwExStyle Or WS_EX_RTLREADING
    If (dwMask And WS_EX_RIGHT) = WS_EX_RIGHT Then dwExStyle = dwExStyle Or WS_EX_RIGHT
    If (dwMask And WS_EX_LEFTSCROLLBAR) = WS_EX_LEFTSCROLLBAR Then dwExStyle = dwExStyle Or WS_EX_LEFTSCROLLBAR
    SetWindowLong VBFlexGridHandle, GWL_EXSTYLE, dwExStyle
    InvalidateRect VBFlexGridHandle, ByVal NULL_PTR, 1
    SetWindowPos VBFlexGridHandle, NULL_PTR, 0, 0, 0, 0, SWP_NOMOVE Or SWP_NOSIZE Or SWP_NOOWNERZORDER Or SWP_NOZORDER Or SWP_FRAMECHANGED
    dwMask = 0
    dwExStyle = 0
End If
Dim hToolTip As LongPtr, j As Long
For j = 1 To 2
    hToolTip = VBA.Choose(j, VBFlexGridToolTipHandle, VBFlexGridScrollTipHandle)
    If hToolTip <> NULL_PTR Then
        If PropRightToLeft = True Then
            If PropRightToLeftLayout = True Then dwMask = WS_EX_LAYOUTRTL Else dwMask = WS_EX_RTLREADING
        Else
            dwMask = 0
        End If
        dwExStyle = GetWindowLong(hToolTip, GWL_EXSTYLE)
        If (dwExStyle And WS_EX_LAYOUTRTL) = WS_EX_LAYOUTRTL Then dwExStyle = dwExStyle And Not WS_EX_LAYOUTRTL
        If (dwExStyle And WS_EX_RTLREADING) = WS_EX_RTLREADING Then dwExStyle = dwExStyle And Not WS_EX_RTLREADING
        If (dwExStyle And WS_EX_RIGHT) = WS_EX_RIGHT Then dwExStyle = dwExStyle And Not WS_EX_RIGHT
        If (dwExStyle And WS_EX_LEFTSCROLLBAR) = WS_EX_LEFTSCROLLBAR Then dwExStyle = dwExStyle And Not WS_EX_LEFTSCROLLBAR
        If (dwMask And WS_EX_LAYOUTRTL) = WS_EX_LAYOUTRTL Then dwExStyle = dwExStyle Or WS_EX_LAYOUTRTL
        ' ToolTip control supports only the WS_EX_LAYOUTRTL flag.
        ' Set TTF_RTLREADING flag when dwMask contains WS_EX_RTLREADING, though WS_EX_RTLREADING will not be actually set.
        SetWindowLong hToolTip, GWL_EXSTYLE, dwExStyle
        Dim i As Long, TI As TOOLINFO, Buffer As String
        With TI
        .cbSize = LenB(TI)
        Buffer = String(80, vbNullChar)
        .lpszText = StrPtr(Buffer)
        For i = 1 To CLng(SendMessage(hToolTip, TTM_GETTOOLCOUNT, 0, ByVal 0&))
            If SendMessage(hToolTip, TTM_ENUMTOOLS, i - 1, ByVal VarPtr(TI)) <> 0 Then
                If (dwMask And WS_EX_LAYOUTRTL) = WS_EX_LAYOUTRTL Or (dwMask And WS_EX_RTLREADING) = 0 Then
                    If (.uFlags And TTF_RTLREADING) = TTF_RTLREADING Then .uFlags = .uFlags And Not TTF_RTLREADING
                Else
                    If (.uFlags And TTF_RTLREADING) = 0 Then .uFlags = .uFlags Or TTF_RTLREADING
                End If
                SendMessage hToolTip, TTM_SETTOOLINFO, 0, ByVal VarPtr(TI)
                SendMessage hToolTip, TTM_UPDATE, 0, ByVal 0&
            End If
        Next i
        End With
    End If
Next j
UserControl.PropertyChanged "RightToLeft"
End Property

Public Property Get RightToLeftLayout() As Boolean
Attribute RightToLeftLayout.VB_Description = "Returns/sets a value indicating if right-to-left mirror placement is turned on."
RightToLeftLayout = PropRightToLeftLayout
End Property

Public Property Let RightToLeftLayout(ByVal Value As Boolean)
PropRightToLeftLayout = Value
Me.RightToLeft = PropRightToLeft
UserControl.PropertyChanged "RightToLeftLayout"
End Property

Public Property Get RightToLeftMode() As FlexRightToLeftModeConstants
Attribute RightToLeftMode.VB_Description = "Returns/sets the right-to-left mode."
RightToLeftMode = PropRightToLeftMode
End Property

Public Property Let RightToLeftMode(ByVal Value As FlexRightToLeftModeConstants)
Select Case Value
    Case FlexRightToLeftModeNoControl, FlexRightToLeftModeVBAME, FlexRightToLeftModeSystemLocale, FlexRightToLeftModeUserLocale, FlexRightToLeftModeOSLanguage
        PropRightToLeftMode = Value
    Case Else
        Err.Raise 380
End Select
Me.RightToLeft = PropRightToLeft
UserControl.PropertyChanged "RightToLeftMode"
End Property

Public Property Get BorderStyle() As FlexBorderStyleConstants
Attribute BorderStyle.VB_Description = "Returns/sets the border style."
Attribute BorderStyle.VB_UserMemId = -504
BorderStyle = PropBorderStyle
End Property

Public Property Let BorderStyle(ByVal Value As FlexBorderStyleConstants)
Select Case Value
    Case FlexBorderStyleNone, FlexBorderStyleSingle, FlexBorderStyleThin, FlexBorderStyleSunken, FlexBorderStyleRaised
        PropBorderStyle = Value
    Case Else
        Err.Raise 380
End Select
If VBFlexGridHandle <> NULL_PTR Then
    Dim dwStyle As Long, dwExStyle As Long
    dwStyle = GetWindowLong(VBFlexGridHandle, GWL_STYLE)
    dwExStyle = GetWindowLong(VBFlexGridHandle, GWL_EXSTYLE)
    If (dwStyle And WS_BORDER) = WS_BORDER Then dwStyle = dwStyle And Not WS_BORDER
    If (dwStyle And WS_DLGFRAME) = WS_DLGFRAME Then dwStyle = dwStyle And Not WS_DLGFRAME
    If (dwExStyle And WS_EX_STATICEDGE) = WS_EX_STATICEDGE Then dwExStyle = dwExStyle And Not WS_EX_STATICEDGE
    If (dwExStyle And WS_EX_CLIENTEDGE) = WS_EX_CLIENTEDGE Then dwExStyle = dwExStyle And Not WS_EX_CLIENTEDGE
    If (dwExStyle And WS_EX_WINDOWEDGE) = WS_EX_WINDOWEDGE Then dwExStyle = dwExStyle And Not WS_EX_WINDOWEDGE
    Select Case PropBorderStyle
        Case FlexBorderStyleSingle
            dwStyle = dwStyle Or WS_BORDER
        Case FlexBorderStyleThin
            dwExStyle = dwExStyle Or WS_EX_STATICEDGE
        Case FlexBorderStyleSunken
            dwExStyle = dwExStyle Or WS_EX_CLIENTEDGE
        Case FlexBorderStyleRaised
            dwExStyle = dwExStyle Or WS_EX_WINDOWEDGE
            dwStyle = dwStyle Or WS_DLGFRAME
    End Select
    SetWindowLong VBFlexGridHandle, GWL_STYLE, dwStyle
    SetWindowLong VBFlexGridHandle, GWL_EXSTYLE, dwExStyle
    SetWindowPos VBFlexGridHandle, NULL_PTR, 0, 0, 0, 0, SWP_NOMOVE Or SWP_NOSIZE Or SWP_NOOWNERZORDER Or SWP_NOZORDER Or SWP_FRAMECHANGED
End If
UserControl.PropertyChanged "BorderStyle"
End Property

Public Property Get FixedRows() As Long
Attribute FixedRows.VB_Description = "Returns/sets the total number of fixed (non-scrollable) columns or rows for the flex grid."
FixedRows = PropFixedRows
End Property

Public Property Let FixedRows(ByVal Value As Long)
If Value < 0 Then
    If VBFlexGridDesignMode = True Then
        MsgBox "Invalid Row Value", vbCritical + vbOKOnly
        Exit Property
    Else
        Err.Raise Number:=30009, Description:="Invalid Row value"
    End If
ElseIf Value >= (PropRows - PropFrozenRows) Then
    If VBFlexGridDesignMode = True Then
        MsgBox "FixedRows must be at least one less than Rows minus FrozenRows value", vbCritical + vbOKOnly
        Exit Property
    Else
        Err.Raise Number:=30016, Description:="FixedRows must be at least one less than Rows minus FrozenRows value"
    End If
End If
PropFixedRows = Value
If PropRows > 0 And PropCols > 0 Then
    Dim RCP As TROWCOLPARAMS
    With RCP
    .Mask = RCPM_ROW Or RCPM_TOPROW
    .Flags = RCPF_FORCETOPROWMASK Or RCPF_SETSCROLLBARS Or RCPF_FORCEREDRAW
    .Row = PropFixedRows + PropFrozenRows
    .TopRow = PropFixedRows + PropFrozenRows
    Select Case PropSelectionMode
        Case FlexSelectionModeFree, FlexSelectionModeFreeByRow, FlexSelectionModeFreeByColumn
            .Mask = .Mask Or RCPM_ROWSEL
            .RowSel = .Row
        Case FlexSelectionModeByRow
            .Mask = .Mask Or RCPM_ROWSEL Or RCPM_COLSEL
            .RowSel = .Row
            .ColSel = (PropCols - 1)
    End Select
    Call SetRowColParams(RCP)
    End With
End If
UserControl.PropertyChanged "FixedRows"
End Property

Public Property Get FixedCols() As Long
Attribute FixedCols.VB_Description = "Returns/sets the total number of fixed (non-scrollable) columns or rows for the flex grid."
FixedCols = PropFixedCols
End Property

Public Property Let FixedCols(ByVal Value As Long)
If Value < 0 Then
    If VBFlexGridDesignMode = True Then
        MsgBox "Invalid Col value", vbCritical + vbOKOnly
        Exit Property
    Else
        Err.Raise Number:=30010, Description:="Invalid Col value"
    End If
ElseIf Value >= (PropCols - PropFrozenCols) Then
    If VBFlexGridDesignMode = True Then
        MsgBox "FixedCols must be at least one less than Cols minus FrozenCols value", vbCritical + vbOKOnly
        Exit Property
    Else
        Err.Raise Number:=30017, Description:="FixedCols must be at least one less than Cols minus FrozenCols value"
    End If
End If
PropFixedCols = Value
If PropRows > 0 And PropCols > 0 Then
    Dim RCP As TROWCOLPARAMS
    With RCP
    .Mask = RCPM_COL Or RCPM_LEFTCOL
    .Flags = RCPF_FORCELEFTCOLMASK Or RCPF_SETSCROLLBARS Or RCPF_FORCEREDRAW
    .Col = PropFixedCols + PropFrozenCols
    .LeftCol = PropFixedCols + PropFrozenCols
    Select Case PropSelectionMode
        Case FlexSelectionModeFree, FlexSelectionModeFreeByRow, FlexSelectionModeFreeByColumn
            .Mask = .Mask Or RCPM_COLSEL
            .ColSel = .Col
        Case FlexSelectionModeByColumn
            .Mask = .Mask Or RCPM_ROWSEL Or RCPM_COLSEL
            .RowSel = (PropRows - 1)
            .ColSel = .Col
    End Select
    Call SetRowColParams(RCP)
    End With
End If
UserControl.PropertyChanged "FixedCols"
End Property

Public Property Get FrozenRows() As Long
Attribute FrozenRows.VB_Description = "Returns/sets the total number of frozen (movable but non-scrollable) columns or rows for the flex grid."
FrozenRows = PropFrozenRows
End Property

Public Property Let FrozenRows(ByVal Value As Long)
If Value < 0 Then
    If VBFlexGridDesignMode = True Then
        MsgBox "Invalid Row Value", vbCritical + vbOKOnly
        Exit Property
    Else
        Err.Raise Number:=30009, Description:="Invalid Row value"
    End If
ElseIf Value >= (PropRows - PropFixedRows) Then
    If VBFlexGridDesignMode = True Then
        MsgBox "FrozenRows must be at least one less than Rows minus FixedRows value", vbCritical + vbOKOnly
        Exit Property
    Else
        Err.Raise Number:=30016, Description:="FrozenRows must be at least one less than Rows minus FixedRows value"
    End If
End If
PropFrozenRows = Value
If PropRows > 0 And PropCols > 0 Then
    Dim RCP As TROWCOLPARAMS
    With RCP
    .Mask = RCPM_ROW Or RCPM_TOPROW
    .Flags = RCPF_FORCETOPROWMASK Or RCPF_SETSCROLLBARS Or RCPF_FORCEREDRAW
    .Row = PropFixedRows + PropFrozenRows
    .TopRow = PropFixedRows + PropFrozenRows
    Select Case PropSelectionMode
        Case FlexSelectionModeFree, FlexSelectionModeFreeByRow, FlexSelectionModeFreeByColumn
            .Mask = .Mask Or RCPM_ROWSEL
            .RowSel = .Row
        Case FlexSelectionModeByRow
            .Mask = .Mask Or RCPM_ROWSEL Or RCPM_COLSEL
            .RowSel = .Row
            .ColSel = (PropCols - 1)
    End Select
    Call SetRowColParams(RCP)
    End With
End If
UserControl.PropertyChanged "FrozenRows"
End Property

Public Property Get FrozenCols() As Long
Attribute FrozenCols.VB_Description = "Returns/sets the total number of frozen (movable but non-scrollable) columns or rows for the flex grid."
FrozenCols = PropFrozenCols
End Property

Public Property Let FrozenCols(ByVal Value As Long)
If Value < 0 Then
    If VBFlexGridDesignMode = True Then
        MsgBox "Invalid Col value", vbCritical + vbOKOnly
        Exit Property
    Else
        Err.Raise Number:=30010, Description:="Invalid Col value"
    End If
ElseIf Value >= (PropCols - PropFixedCols) Then
    If VBFlexGridDesignMode = True Then
        MsgBox "FrozenCols must be at least one less than Cols minus FixedCols value", vbCritical + vbOKOnly
        Exit Property
    Else
        Err.Raise Number:=30017, Description:="FrozenCols must be at least one less than Cols minus FixedCols value"
    End If
End If
PropFrozenCols = Value
If PropRows > 0 And PropCols > 0 Then
    Dim RCP As TROWCOLPARAMS
    With RCP
    .Mask = RCPM_COL Or RCPM_LEFTCOL
    .Flags = RCPF_FORCELEFTCOLMASK Or RCPF_SETSCROLLBARS Or RCPF_FORCEREDRAW
    .Col = PropFixedCols + PropFrozenCols
    .LeftCol = PropFixedCols + PropFrozenCols
    Select Case PropSelectionMode
        Case FlexSelectionModeFree, FlexSelectionModeFreeByRow, FlexSelectionModeFreeByColumn
            .Mask = .Mask Or RCPM_COLSEL
            .ColSel = .Col
        Case FlexSelectionModeByColumn
            .Mask = .Mask Or RCPM_ROWSEL Or RCPM_COLSEL
            .RowSel = (PropRows - 1)
            .ColSel = .Col
    End Select
    Call SetRowColParams(RCP)
    End With
End If
UserControl.PropertyChanged "FrozenCols"
End Property

Public Property Get Rows() As Long
Attribute Rows.VB_Description = "Returns/sets the total number of columns or rows in the flex grid."
Attribute Rows.VB_MemberFlags = "200"
Rows = PropRows
End Property

Public Property Let Rows(ByVal Value As Long)
If PropRows = Value Then Exit Property
If Value < 0 Then
    If VBFlexGridDesignMode = True Then
        MsgBox "Invalid Row value", vbCritical + vbOKOnly
        Exit Property
    Else
        Err.Raise Number:=30009, Description:="Invalid Row value"
    End If
Else
    If Value < PropFixedRows And Value > 0 Then PropFixedRows = Value
    If Value <= (PropFixedRows + PropFrozenRows) And Value > 0 Then
        If (Value - PropFixedRows - 1) > 0 Then
            PropFrozenRows = Value - PropFixedRows - 1
        Else
            PropFrozenRows = 0
        End If
    End If
End If
Dim RowsPerPage As Long
RowsPerPage = -1
If Value > 0 And PropRows < 1 Then
    PropRows = Value
    If PropCols > 0 Then Call InitFlexGridCells
ElseIf Value < 1 And PropRows > 0 Then
    PropRows = Value
    PropFixedRows = 0
    PropFrozenRows = 0
    Call EraseFlexGridCells
ElseIf Value <> PropRows And PropCols > 0 Then
    Dim i As Long, j As Long
    If Value > PropRows Then
        ReDim Preserve VBFlexGridCells.Rows(0 To (Value - 1)) As TCOLS
        PropRows = PropRows + 1 ' First new row.
        For i = (PropRows - 1) To (Value - 1)
            LSet VBFlexGridCells.Rows(i) = VBFlexGridDefaultCols
        Next i
    Else
        For i = ((Value - 1) + 1) To (PropRows - 1)
            With VBFlexGridCells.Rows(i)
            For j = 0 To (PropCols - 1)
                Call FreeCellFmtg(.Cols(j).lpFmtg)
                Call FreeCellTag(.Cols(j).lpTag)
            Next j
            End With
        Next i
        ReDim Preserve VBFlexGridCells.Rows(0 To (Value - 1)) As TCOLS
        RowsPerPage = GetRowsPerPageRev(Value - 1)
    End If
    PropRows = Value
Else
    PropRows = Value
End If
If VBFlexGridDropHighlight > -1 Then
    If VBFlexGridDropHighlightMode = FlexDropTargetModeByRow Then
        If VBFlexGridDropHighlight > (PropRows - 1) Then VBFlexGridDropHighlight = -1
    End If
End If
If VBFlexGridInsertMark > -1 Then
    If VBFlexGridInsertMarkMode = FlexDropTargetModeByRow Then
        If VBFlexGridInsertMark > (PropRows - 1) Then VBFlexGridInsertMark = -1: VBFlexGridInsertMarkAfter = False
    End If
End If
If VBFlexGridComboCueRow > (PropRows - 1) Then VBFlexGridComboCueRow = (PropRows - 1)
If VBFlexGridSelectedRows > 0 Then
    Erase VBFlexGridSelectedRowIndices()
    VBFlexGridSelectedRows = 0
End If
If PropRows > 0 And PropCols > 0 Then
    Dim RCP As TROWCOLPARAMS
    With RCP
    .Flags = RCPF_SETSCROLLBARS Or RCPF_FORCEREDRAW
    .Row = VBFlexGridRow
    If .Row > (PropRows - 1) Then
        .Mask = .Mask Or RCPM_ROW
        .Row = (PropRows - 1)
    End If
    Select Case PropSelectionMode
        Case FlexSelectionModeFree, FlexSelectionModeByRow, FlexSelectionModeFreeByRow, FlexSelectionModeFreeByColumn
            If VBFlexGridRowSel > (PropRows - 1) Then
                .Mask = .Mask Or RCPM_ROWSEL
                .RowSel = (PropRows - 1)
            End If
        Case FlexSelectionModeByColumn
            If VBFlexGridRowSel <> (PropRows - 1) Then
                .Mask = .Mask Or RCPM_ROWSEL
                .RowSel = (PropRows - 1)
            End If
    End Select
    If .Row < PropFixedRows And PropRows > PropFixedRows Then
        ' In case there were no movable rows before and are now again available.
        ' Then it is necessary that the active row gets adjusted to the first movable row.
        If Not (.Mask And RCPM_ROW) = RCPM_ROW Then .Mask = .Mask Or RCPM_ROW
        .Row = PropFixedRows
        If Not (.Mask And RCPM_ROWSEL) = RCPM_ROWSEL Then .Mask = .Mask Or RCPM_ROWSEL
        If PropSelectionMode <> FlexSelectionModeByColumn Then .RowSel = PropFixedRows Else .RowSel = (PropRows - 1)
    End If
    If RowsPerPage > -1 Then
        If VBFlexGridTopRow > (PropRows - 1) - RowsPerPage + 1 Then
            .Mask = .Mask Or RCPM_TOPROW
            .Flags = .Flags Or RCPF_FORCETOPROWMASK
            .TopRow = (PropRows - 1) - RowsPerPage + 1
        End If
    ElseIf VBFlexGridTopRow > (PropRows - 1) Then
        .Mask = .Mask Or RCPM_TOPROW
        .Flags = .Flags Or RCPF_CHECKTOPROW Or RCPF_FORCETOPROWMASK
        .TopRow = (PropRows - 1)
    End If
    Call SetRowColParams(RCP)
    End With
Else
    Call RedrawGrid
End If
UserControl.PropertyChanged "Rows"
End Property

Public Property Get Cols() As Long
Attribute Cols.VB_Description = "Returns/sets the total number of columns or rows in the flex grid."
Cols = PropCols
End Property

Public Property Let Cols(ByVal Value As Long)
If PropCols = Value Then Exit Property
If Value < 0 Then
    If VBFlexGridDesignMode = True Then
        MsgBox "Invalid Col value", vbCritical + vbOKOnly
        Exit Property
    Else
        Err.Raise Number:=30010, Description:="Invalid Col value"
    End If
Else
    If Value < PropFixedCols And Value > 0 Then PropFixedCols = Value
    If Value <= (PropFixedCols + PropFrozenCols) And Value > 0 Then
        If (Value - PropFixedCols - 1) > 0 Then
            PropFrozenCols = Value - PropFixedCols - 1
        Else
            PropFrozenCols = 0
        End If
    End If
End If
Dim ColsPerPage As Long
ColsPerPage = -1
If Value > 0 And PropCols < 1 Then
    PropCols = Value
    If PropRows > 0 Then Call InitFlexGridCells
ElseIf Value < 1 And PropCols > 0 Then
    PropCols = Value
    PropFixedCols = 0
    PropFrozenCols = 0
    Call EraseFlexGridCells
ElseIf Value <> PropCols And PropRows > 0 Then
    Dim i As Long, j As Long
    If Value > PropCols Then
        PropCols = PropCols + 1 ' First new column.
        For i = 0 To (PropRows - 1)
            With VBFlexGridCells.Rows(i)
            ReDim Preserve .Cols(0 To (Value - 1)) As TCELL
            For j = (PropCols - 1) To (Value - 1)
                LSet .Cols(j) = VBFlexGridDefaultCell
            Next j
            End With
        Next i
        ReDim Preserve VBFlexGridColsInfo(0 To (Value - 1)) As TCOLINFO
        ReDim Preserve VBFlexGridDefaultCols.Cols(0 To (Value - 1)) As TCELL
        For j = (PropCols - 1) To (Value - 1)
            LSet VBFlexGridColsInfo(j) = VBFlexGridDefaultColInfo
            LSet VBFlexGridDefaultCols.Cols(j) = VBFlexGridDefaultCell
        Next j
    Else
        For i = 0 To (PropRows - 1)
            With VBFlexGridCells.Rows(i)
            For j = ((Value - 1) + 1) To (PropCols - 1)
                Call FreeCellFmtg(.Cols(j).lpFmtg)
                Call FreeCellTag(.Cols(j).lpTag)
            Next j
            ReDim Preserve .Cols(0 To (Value - 1)) As TCELL
            End With
        Next i
        ReDim Preserve VBFlexGridColsInfo(0 To (Value - 1)) As TCOLINFO
        ReDim Preserve VBFlexGridDefaultCols.Cols(0 To (Value - 1)) As TCELL
        ColsPerPage = GetColsPerPageRev(Value - 1)
    End If
    PropCols = Value
Else
    PropCols = Value
End If
If VBFlexGridDropHighlight > -1 Then
    If VBFlexGridDropHighlightMode = FlexDropTargetModeByColumn Then
        If VBFlexGridDropHighlight > (PropCols - 1) Then VBFlexGridDropHighlight = -1
    End If
End If
If VBFlexGridInsertMark > -1 Then
    If VBFlexGridInsertMarkMode = FlexDropTargetModeByColumn Then
        If VBFlexGridInsertMark > (PropCols - 1) Then VBFlexGridInsertMark = -1: VBFlexGridInsertMarkAfter = False
    End If
End If
If VBFlexGridComboCueCol > (PropCols - 1) Then VBFlexGridComboCueCol = (PropCols - 1)
If PropRows > 0 And PropCols > 0 Then
    VBFlexGridExtendLastCol = GetExtendLastCol()
    Dim RCP As TROWCOLPARAMS
    With RCP
    .Flags = RCPF_SETSCROLLBARS Or RCPF_FORCEREDRAW
    .Col = VBFlexGridCol
    If .Col > (PropCols - 1) Then
        .Mask = .Mask Or RCPM_COL
        .Col = (PropCols - 1)
    End If
    Select Case PropSelectionMode
        Case FlexSelectionModeFree, FlexSelectionModeByColumn, FlexSelectionModeFreeByRow, FlexSelectionModeFreeByColumn
            If VBFlexGridColSel > (PropCols - 1) Then
                .Mask = .Mask Or RCPM_COLSEL
                .ColSel = (PropCols - 1)
            End If
        Case FlexSelectionModeByRow
            If VBFlexGridColSel <> (PropCols - 1) Then
                .Mask = .Mask Or RCPM_COLSEL
                .ColSel = (PropCols - 1)
            End If
    End Select
    If .Col < PropFixedCols And PropCols > PropFixedCols Then
        ' In case there were no movable columns before and are now again available.
        ' Then it is necessary that the active col gets adjusted to the first movable column.
        If Not (.Mask And RCPM_COL) = RCPM_COL Then .Mask = .Mask Or RCPM_COL
        .Col = PropFixedCols
        If Not (.Mask And RCPM_COLSEL) = RCPM_COLSEL Then .Mask = .Mask Or RCPM_COLSEL
        If PropSelectionMode <> FlexSelectionModeByRow Then .ColSel = PropFixedCols Else .ColSel = (PropCols - 1)
    End If
    If ColsPerPage > -1 Then
        If VBFlexGridLeftCol > (PropCols - 1) - ColsPerPage + 1 Then
            .Mask = .Mask Or RCPM_LEFTCOL
            .Flags = .Flags Or RCPF_FORCELEFTCOLMASK
            .LeftCol = (PropCols - 1) - ColsPerPage + 1
        End If
    ElseIf VBFlexGridLeftCol > (PropCols - 1) Then
        .Mask = .Mask Or RCPM_LEFTCOL
        .Flags = .Flags Or RCPF_CHECKLEFTCOL Or RCPF_FORCELEFTCOLMASK
        .LeftCol = (PropCols - 1)
    End If
    Call SetRowColParams(RCP)
    End With
Else
    Call RedrawGrid
End If
UserControl.PropertyChanged "Cols"
End Property

Public Property Get AllowBigSelection() As Boolean
Attribute AllowBigSelection.VB_Description = "Returns/sets whether clicking on a column or row header should cause the entire column or row to be selected."
AllowBigSelection = PropAllowBigSelection
End Property

Public Property Let AllowBigSelection(ByVal Value As Boolean)
PropAllowBigSelection = Value
UserControl.PropertyChanged "AllowBigSelection"
End Property

Public Property Get AllowMultiSelection() As Boolean
Attribute AllowMultiSelection.VB_Description = "Returns/sets a value indicating if the flex grid enables selection of multiple (non-contiguous) ranges of cells."
AllowMultiSelection = PropAllowMultiSelection
End Property

Public Property Let AllowMultiSelection(ByVal Value As Boolean)
If PropAllowMultiSelection = Value Then Exit Property
If Value = True Then
    Select Case PropSelectionMode
        Case FlexSelectionModeByRow, FlexSelectionModeFreeByRow
        Case Else
            If VBFlexGridDesignMode = True Then
                MsgBox "AllowMultiSelection must be False when SelectionMode is not 1 - ByRow nor 3 - FreeByRow", vbCritical + vbOKOnly
                Exit Property
            Else
                Err.Raise Number:=383, Description:="AllowMultiSelection must be False when SelectionMode is not 1 - ByRow nor 3 - FreeByRow"
            End If
    End Select
End If
PropAllowMultiSelection = Value
If PropAllowMultiSelection = False Then
    VBFlexGridInvertSelection = False
    VBFlexGridExpandSelectedRows = False
    If VBFlexGridMultiSelChangeTimer = True Then
        If VBFlexGridHandle <> NULL_PTR Then KillTimer VBFlexGridHandle, IDT_MULTISELCHANGE
        VBFlexGridMultiSelChangeTimer = False
    End If
    Call ClearSelectedRows
Else
    Call InitSelectedRows
End If
Call RedrawGrid
UserControl.PropertyChanged "AllowMultiSelection"
End Property

Public Property Get AllowSelection() As Boolean
Attribute AllowSelection.VB_Description = "Returns/sets a value indicating if the flex grid enables selection of cells."
AllowSelection = PropAllowSelection
End Property

Public Property Let AllowSelection(ByVal Value As Boolean)
PropAllowSelection = Value
UserControl.PropertyChanged "AllowSelection"
End Property

Public Property Get AllowUserEditing() As Boolean
Attribute AllowUserEditing.VB_Description = "Returns/sets a value that determines if a user can edit the text of a cell. The control can be forced to go into editing mode using the StartEdit method."
AllowUserEditing = PropAllowUserEditing
End Property

Public Property Let AllowUserEditing(ByVal Value As Boolean)
PropAllowUserEditing = Value
UserControl.PropertyChanged "AllowUserEditing"
End Property

Public Property Get AllowUserFreezing() As FlexAllowUserFreezingConstants
Attribute AllowUserFreezing.VB_Description = "Returns/sets whether the user should be allowed to freeze rows and columns with the mouse."
AllowUserFreezing = PropAllowUserFreezing
End Property

Public Property Let AllowUserFreezing(ByVal Value As FlexAllowUserFreezingConstants)
Select Case Value
    Case FlexAllowUserFreezingNone, FlexAllowUserFreezingColumns, FlexAllowUserFreezingRows, FlexAllowUserFreezingBoth
        PropAllowUserFreezing = Value
    Case Else
        Err.Raise 380
End Select
UserControl.PropertyChanged "AllowUserFreezing"
End Property

Public Property Get AllowUserResizing() As FlexAllowUserResizingConstants
Attribute AllowUserResizing.VB_Description = "Returns/sets whether the user should be allowed to resize rows and columns with the mouse."
AllowUserResizing = PropAllowUserResizing
End Property

Public Property Let AllowUserResizing(ByVal Value As FlexAllowUserResizingConstants)
Select Case Value
    Case FlexAllowUserResizingNone, FlexAllowUserResizingColumns, FlexAllowUserResizingRows, FlexAllowUserResizingBoth
        PropAllowUserResizing = Value
    Case Else
        Err.Raise 380
End Select
UserControl.PropertyChanged "AllowUserResizing"
End Property

Public Property Get RowSizingMode() As FlexRowSizingModeConstants
Attribute RowSizingMode.VB_Description = "Returns/sets the row sizing mode."
RowSizingMode = PropRowSizingMode
End Property

Public Property Let RowSizingMode(ByVal Value As FlexRowSizingModeConstants)
Select Case Value
    Case FlexRowSizingModeIndividual, FlexRowSizingModeAll, FlexRowSizingModeUniform
        PropRowSizingMode = Value
    Case Else
        Err.Raise 380
End Select
UserControl.PropertyChanged "RowSizingMode"
End Property

Public Property Get MergeCells() As FlexMergeCellsConstants
Attribute MergeCells.VB_Description = "Returns/sets whether cells with the same contents should be grouped in a single cell spanning multiple rows or columns."
MergeCells = PropMergeCells
End Property

Public Property Let MergeCells(ByVal Value As FlexMergeCellsConstants)
Select Case Value
    Case FlexMergeCellsNever, FlexMergeCellsFree, FlexMergeCellsRestrictRows, FlexMergeCellsRestrictColumns, FlexMergeCellsRestrictAll, FlexMergeCellsFixedOnly
        PropMergeCells = Value
    Case Else
        Err.Raise 380
End Select
Call RedrawGrid
UserControl.PropertyChanged "MergeCells"
End Property

Public Property Get SelectionMode() As FlexSelectionModeConstants
Attribute SelectionMode.VB_Description = "Returns/sets whether the flex grid should allow regular cell selection, selection by rows, or selection by columns."
SelectionMode = PropSelectionMode
End Property

Public Property Let SelectionMode(ByVal Value As FlexSelectionModeConstants)
Select Case Value
    Case FlexSelectionModeFree, FlexSelectionModeByRow, FlexSelectionModeByColumn, FlexSelectionModeFreeByRow, FlexSelectionModeFreeByColumn
        PropSelectionMode = Value
    Case Else
        Err.Raise 380
End Select
Select Case PropSelectionMode
    Case FlexSelectionModeByRow, FlexSelectionModeFreeByRow
    Case Else
        If PropAllowMultiSelection = True Then
            PropAllowMultiSelection = False
            VBFlexGridInvertSelection = False
            VBFlexGridExpandSelectedRows = False
            If VBFlexGridMultiSelChangeTimer = True Then
                If VBFlexGridHandle <> NULL_PTR Then KillTimer VBFlexGridHandle, IDT_MULTISELCHANGE
                VBFlexGridMultiSelChangeTimer = False
            End If
            Call ClearSelectedRows
        End If
End Select
If VBFlexGridDesignMode = True Then
    Dim RCP As TROWCOLPARAMS
    With RCP
    .Mask = RCPM_ROW Or RCPM_COL Or RCPM_ROWSEL Or RCPM_COLSEL
    .Row = PropFixedRows
    .Col = PropFixedCols
    Select Case PropSelectionMode
        Case FlexSelectionModeFree, FlexSelectionModeFreeByRow, FlexSelectionModeFreeByColumn
            .RowSel = .Row
            .ColSel = .Col
        Case FlexSelectionModeByRow
            .RowSel = .Row
            .ColSel = (PropCols - 1)
        Case FlexSelectionModeByColumn
            .RowSel = (PropRows - 1)
            .ColSel = .Col
    End Select
    Call SetRowColParams(RCP)
    End With
End If
Call RedrawGrid
UserControl.PropertyChanged "SelectionMode"
End Property

Public Property Get FillStyle() As FlexFillStyleConstants
Attribute FillStyle.VB_Description = "Returns/sets whether setting the Text property or one of the cell formatting properties of the flex grid applies the change to all selected cells."
FillStyle = PropFillStyle
End Property

Public Property Let FillStyle(ByVal Value As FlexFillStyleConstants)
Select Case Value
    Case FlexFillStyleSingle, FlexFillStyleRepeat
        PropFillStyle = Value
    Case Else
        Err.Raise 380
End Select
UserControl.PropertyChanged "FillStyle"
End Property

Public Property Get ScrollBars() As VBRUN.ScrollBarConstants
Attribute ScrollBars.VB_Description = "Returns/sets a value indicating whether an object has vertical or horizontal scroll bars."
ScrollBars = PropScrollBars
End Property

Public Property Let ScrollBars(ByVal Value As VBRUN.ScrollBarConstants)
Select Case Value
    Case vbSBNone, vbHorizontal, vbVertical, vbBoth
        PropScrollBars = Value
    Case Else
        Err.Raise 380
End Select
Call SetScrollBars
UserControl.PropertyChanged "ScrollBars"
End Property

Public Property Get ScrollTrack() As Boolean
Attribute ScrollTrack.VB_Description = "Returns/sets whether the control should scroll its contents while the user moves the scroll box along the scroll bars."
ScrollTrack = PropScrollTrack
End Property

Public Property Let ScrollTrack(ByVal Value As Boolean)
PropScrollTrack = Value
UserControl.PropertyChanged "ScrollTrack"
End Property

Public Property Get ScrollTipFollowThumb() As Boolean
Attribute ScrollTipFollowThumb.VB_Description = "Returns/sets a value that determines whether the scroll tip should follow the thumb as the user scrolls."
ScrollTipFollowThumb = PropScrollTipFollowThumb
End Property

Public Property Let ScrollTipFollowThumb(ByVal Value As Boolean)
PropScrollTipFollowThumb = Value
UserControl.PropertyChanged "ScrollTipFollowThumb"
End Property

Public Property Get DisableNoScroll() As Boolean
Attribute DisableNoScroll.VB_Description = "Returns/sets a value that determines whether scroll bars are disabled instead of hided when they are not needed."
DisableNoScroll = PropDisableNoScroll
End Property

Public Property Let DisableNoScroll(ByVal Value As Boolean)
PropDisableNoScroll = Value
Call SetScrollBars
UserControl.PropertyChanged "DisableNoScroll"
End Property

Public Property Get HighLight() As FlexHighLightConstants
Attribute HighLight.VB_Description = "Returns/sets whether selected cells appear highlighted."
HighLight = PropHighLight
End Property

Public Property Let HighLight(ByVal Value As FlexHighLightConstants)
Select Case Value
    Case FlexHighLightNever, FlexHighLightAlways, FlexHighLightWithFocus, FlexHighLightAlwaysFocusRect
        PropHighLight = Value
    Case Else
        Err.Raise 380
End Select
Call RedrawGrid
UserControl.PropertyChanged "HighLight"
End Property

Public Property Get FocusRect() As FlexFocusRectConstants
Attribute FocusRect.VB_Description = "Returns/sets whether the flex grid control should draw a focus rectangle around the current cell."
FocusRect = PropFocusRect
End Property

Public Property Let FocusRect(ByVal Value As FlexFocusRectConstants)
Select Case Value
    Case FlexFocusRectNone, FlexFocusRectLight, FlexFocusRectHeavy, FlexFocusRectFlat
        PropFocusRect = Value
    Case Else
        Err.Raise 380
End Select
If VBFlexGridHandle <> NULL_PTR Then
    If VBFlexGridFocusRectPen <> NULL_PTR Then
        DeleteObject VBFlexGridFocusRectPen
        VBFlexGridFocusRectPen = NULL_PTR
    End If
    If PropFocusRect = FlexFocusRectFlat Then VBFlexGridFocusRectPen = CreatePen(PS_INSIDEFRAME, GetFocusRectWidth(), WinColor(PropBackColorSel))
End If
Call RedrawGrid
UserControl.PropertyChanged "FocusRect"
End Property

Public Property Get FocusRectWidth() As Integer
Attribute FocusRectWidth.VB_Description = "Returns/sets the width in pixels of the focus rectangle."
FocusRectWidth = GetFocusRectWidth()
End Property

Public Property Let FocusRectWidth(ByVal Value As Integer)
If Value < 1 And Not Value = -1 Then
    If VBFlexGridDesignMode = True Then
        MsgBox "Invalid property value", vbCritical + vbOKOnly
        Exit Property
    Else
        Err.Raise 380
    End If
End If
PropFocusRectWidth = Value
If VBFlexGridHandle <> NULL_PTR Then
    If VBFlexGridFocusRectPen <> NULL_PTR Then
        DeleteObject VBFlexGridFocusRectPen
        VBFlexGridFocusRectPen = NULL_PTR
    End If
    If PropFocusRect = FlexFocusRectFlat Then VBFlexGridFocusRectPen = CreatePen(PS_INSIDEFRAME, GetFocusRectWidth(), WinColor(PropBackColorSel))
End If
Call RedrawGrid
UserControl.PropertyChanged "FocusRectWidth"
End Property

Public Property Get RowHeightMin() As Long
Attribute RowHeightMin.VB_Description = "Returns/sets a minimum row height in twips for the entire control."
RowHeightMin = UserControl.ScaleY(PropRowHeightMin, vbPixels, vbTwips)
End Property

Public Property Let RowHeightMin(ByVal Value As Long)
If Value < 0 Then
    If VBFlexGridDesignMode = True Then
        MsgBox "Invalid Row Height value", vbCritical + vbOKOnly
        Exit Property
    Else
        Err.Raise Number:=30013, Description:="Invalid Row Height value"
    End If
End If
PropRowHeightMin = UserControl.ScaleY(Value, vbTwips, vbPixels)
Call RedrawGrid
Call SetScrollBars
UserControl.PropertyChanged "RowHeightMin"
End Property

Public Property Get RowHeightMax() As Long
Attribute RowHeightMax.VB_Description = "Returns/sets a maximum row height in twips for the entire control."
RowHeightMax = UserControl.ScaleY(PropRowHeightMax, vbPixels, vbTwips)
End Property

Public Property Let RowHeightMax(ByVal Value As Long)
If Value < 0 Then
    If VBFlexGridDesignMode = True Then
        MsgBox "Invalid Row Height value", vbCritical + vbOKOnly
        Exit Property
    Else
        Err.Raise Number:=30013, Description:="Invalid Row Height value"
    End If
End If
PropRowHeightMax = UserControl.ScaleY(Value, vbTwips, vbPixels)
Call RedrawGrid
Call SetScrollBars
UserControl.PropertyChanged "RowHeightMax"
End Property

Public Property Get ColWidthMin() As Long
Attribute ColWidthMin.VB_Description = "Returns/sets a minimum column width in twips for the entire control."
ColWidthMin = UserControl.ScaleX(PropColWidthMin, vbPixels, vbTwips)
End Property

Public Property Let ColWidthMin(ByVal Value As Long)
If Value < 0 Then
    If VBFlexGridDesignMode = True Then
        MsgBox "Invalid Col Width value", vbCritical + vbOKOnly
        Exit Property
    Else
        Err.Raise Number:=30014, Description:="Invalid Col Width value"
    End If
End If
PropColWidthMin = UserControl.ScaleX(Value, vbTwips, vbPixels)
Call RedrawGrid
Call SetScrollBars
UserControl.PropertyChanged "ColWidthMin"
End Property

Public Property Get ColWidthMax() As Long
Attribute ColWidthMax.VB_Description = "Returns/sets a maximum column width in twips for the entire control."
ColWidthMax = UserControl.ScaleX(PropColWidthMax, vbPixels, vbTwips)
End Property

Public Property Let ColWidthMax(ByVal Value As Long)
If Value < 0 Then
    If VBFlexGridDesignMode = True Then
        MsgBox "Invalid Col Width value", vbCritical + vbOKOnly
        Exit Property
    Else
        Err.Raise Number:=30014, Description:="Invalid Col Width value"
    End If
End If
PropColWidthMax = UserControl.ScaleX(Value, vbTwips, vbPixels)
Call RedrawGrid
Call SetScrollBars
UserControl.PropertyChanged "ColWidthMax"
End Property

Public Property Get GridLines() As FlexGridLineConstants
Attribute GridLines.VB_Description = "Returns/sets the type of lines that should be drawn between cells."
GridLines = PropGridLines
End Property

Public Property Let GridLines(ByVal Value As FlexGridLineConstants)
Select Case Value
    Case FlexGridLineNone, FlexGridLineFlat, FlexGridLineInset, FlexGridLineRaised, FlexGridLineDashes, FlexGridLineDots, FlexGridLineFlatHorz, FlexGridLineInsetHorz, FlexGridLineRaisedHorz, FlexGridLineDashesHorz, FlexGridLineDotsHorz, FlexGridLineFlatVert, FlexGridLineInsetVert, FlexGridLineRaisedVert, FlexGridLineDashesVert, FlexGridLineDotsVert
        PropGridLines = Value
        Select Case Value
            Case FlexGridLineDashes, FlexGridLineDashesHorz, FlexGridLineDashesVert
                VBFlexGridPenStyle = PS_DASH
            Case FlexGridLineDots, FlexGridLineDotsHorz, FlexGridLineDotsVert
                VBFlexGridPenStyle = PS_DOT
            Case Else
                VBFlexGridPenStyle = PS_SOLID
        End Select
    Case Else
        Err.Raise 380
End Select
If VBFlexGridHandle <> NULL_PTR Then
    If VBFlexGridGridLinePen <> NULL_PTR Then DeleteObject VBFlexGridGridLinePen
    VBFlexGridGridLinePen = CreatePen(VBFlexGridPenStyle, PropGridLineWidth, WinColor(PropGridColor))
End If
Call RedrawGrid
UserControl.PropertyChanged "GridLines"
End Property

Public Property Get GridLinesFixed() As FlexGridLineConstants
Attribute GridLinesFixed.VB_Description = "Returns/sets the type of lines that should be drawn between cells."
GridLinesFixed = PropGridLinesFixed
End Property

Public Property Let GridLinesFixed(ByVal Value As FlexGridLineConstants)
Select Case Value
    Case FlexGridLineNone, FlexGridLineFlat, FlexGridLineInset, FlexGridLineRaised, FlexGridLineDashes, FlexGridLineDots, FlexGridLineFlatHorz, FlexGridLineInsetHorz, FlexGridLineRaisedHorz, FlexGridLineDashesHorz, FlexGridLineDotsHorz, FlexGridLineFlatVert, FlexGridLineInsetVert, FlexGridLineRaisedVert, FlexGridLineDashesVert, FlexGridLineDotsVert
        PropGridLinesFixed = Value
        Select Case Value
            Case FlexGridLineDashes, FlexGridLineDashesHorz, FlexGridLineDashesVert
                VBFlexGridFixedPenStyle = PS_DASH
            Case FlexGridLineDots, FlexGridLineDotsHorz, FlexGridLineDotsVert
                VBFlexGridFixedPenStyle = PS_DOT
            Case Else
                VBFlexGridFixedPenStyle = PS_SOLID
        End Select
    Case Else
        Err.Raise 380
End Select
If VBFlexGridHandle <> NULL_PTR Then
    If VBFlexGridGridLineFixedPen <> NULL_PTR Then DeleteObject VBFlexGridGridLineFixedPen
    If PropGridLineWidthFixed = -1 Then
        VBFlexGridGridLineFixedPen = CreatePen(VBFlexGridFixedPenStyle, PropGridLineWidth, WinColor(PropGridColorFixed))
    Else
        VBFlexGridGridLineFixedPen = CreatePen(VBFlexGridFixedPenStyle, PropGridLineWidthFixed, WinColor(PropGridColorFixed))
    End If
End If
Call RedrawGrid
UserControl.PropertyChanged "GridLinesFixed"
End Property

Public Property Get GridLinesFrozen() As FlexGridLineConstants
Attribute GridLinesFrozen.VB_Description = "Returns/sets the type of lines that should be drawn between cells."
GridLinesFrozen = PropGridLinesFrozen
End Property

Public Property Let GridLinesFrozen(ByVal Value As FlexGridLineConstants)
Select Case Value
    Case FlexGridLineNone, FlexGridLineFlat, FlexGridLineInset, FlexGridLineRaised, FlexGridLineDashes, FlexGridLineDots, FlexGridLineFlatHorz, FlexGridLineInsetHorz, FlexGridLineRaisedHorz, FlexGridLineDashesHorz, FlexGridLineDotsHorz, FlexGridLineFlatVert, FlexGridLineInsetVert, FlexGridLineRaisedVert, FlexGridLineDashesVert, FlexGridLineDotsVert
        PropGridLinesFrozen = Value
        Select Case Value
            Case FlexGridLineDashes, FlexGridLineDashesHorz, FlexGridLineDashesVert
                VBFlexGridFrozenPenStyle = PS_DASH
            Case FlexGridLineDots, FlexGridLineDotsHorz, FlexGridLineDotsVert
                VBFlexGridFrozenPenStyle = PS_DOT
            Case Else
                VBFlexGridFrozenPenStyle = PS_SOLID
        End Select
    Case Else
        Err.Raise 380
End Select
If VBFlexGridHandle <> NULL_PTR Then
    If VBFlexGridGridLineFrozenPen <> NULL_PTR Then DeleteObject VBFlexGridGridLineFrozenPen
    If PropGridLineWidthFrozen = -1 Then
        If PropGridLineWidthFixed = -1 Then
            VBFlexGridGridLineFrozenPen = CreatePen(VBFlexGridFrozenPenStyle, PropGridLineWidth, WinColor(PropGridColorFrozen))
        Else
            VBFlexGridGridLineFrozenPen = CreatePen(VBFlexGridFrozenPenStyle, PropGridLineWidthFixed, WinColor(PropGridColorFrozen))
        End If
    Else
        VBFlexGridGridLineFrozenPen = CreatePen(VBFlexGridFrozenPenStyle, PropGridLineWidthFrozen, WinColor(PropGridColorFrozen))
    End If
End If
Call RedrawGrid
UserControl.PropertyChanged "GridLinesFrozen"
End Property

Public Property Get GridLineWidth() As Integer
Attribute GridLineWidth.VB_Description = "Returns/sets the width in pixels of the gridlines."
GridLineWidth = PropGridLineWidth
End Property

Public Property Let GridLineWidth(ByVal Value As Integer)
If Value < 1 Then
    If VBFlexGridDesignMode = True Then
        MsgBox "Invalid property value", vbCritical + vbOKOnly
        Exit Property
    Else
        Err.Raise 380
    End If
End If
PropGridLineWidth = Value
If VBFlexGridHandle <> NULL_PTR Then
    If VBFlexGridGridLinePen <> NULL_PTR Then DeleteObject VBFlexGridGridLinePen
    VBFlexGridGridLinePen = CreatePen(VBFlexGridPenStyle, PropGridLineWidth, WinColor(PropGridColor))
    If PropGridLineWidthFixed = -1 Then
        If VBFlexGridGridLineFixedPen <> NULL_PTR Then DeleteObject VBFlexGridGridLineFixedPen
        VBFlexGridGridLineFixedPen = CreatePen(VBFlexGridFixedPenStyle, PropGridLineWidth, WinColor(PropGridColorFixed))
    End If
    If PropGridLineWidthFrozen = -1 And PropGridLineWidthFixed = -1 Then
        If VBFlexGridGridLineFrozenPen <> NULL_PTR Then DeleteObject VBFlexGridGridLineFrozenPen
        VBFlexGridGridLineFrozenPen = CreatePen(VBFlexGridFrozenPenStyle, PropGridLineWidth, WinColor(PropGridColorFrozen))
    End If
End If
Call RedrawGrid
UserControl.PropertyChanged "GridLineWidth"
End Property

Public Property Get GridLineWidthFixed() As Integer
Attribute GridLineWidthFixed.VB_Description = "Returns/sets the width in pixels of the gridlines."
If PropGridLineWidthFixed = -1 Then GridLineWidthFixed = PropGridLineWidth Else GridLineWidthFixed = PropGridLineWidthFixed
End Property

Public Property Let GridLineWidthFixed(ByVal Value As Integer)
If Value < 1 And Not Value = -1 Then
    If VBFlexGridDesignMode = True Then
        MsgBox "Invalid property value", vbCritical + vbOKOnly
        Exit Property
    Else
        Err.Raise 380
    End If
End If
PropGridLineWidthFixed = Value
If VBFlexGridHandle <> NULL_PTR Then
    If VBFlexGridGridLineFixedPen <> NULL_PTR Then DeleteObject VBFlexGridGridLineFixedPen
    If PropGridLineWidthFixed = -1 Then
        VBFlexGridGridLineFixedPen = CreatePen(VBFlexGridFixedPenStyle, PropGridLineWidth, WinColor(PropGridColorFixed))
    Else
        VBFlexGridGridLineFixedPen = CreatePen(VBFlexGridFixedPenStyle, PropGridLineWidthFixed, WinColor(PropGridColorFixed))
    End If
    If PropGridLineWidthFrozen = -1 Then
        If VBFlexGridGridLineFrozenPen <> NULL_PTR Then DeleteObject VBFlexGridGridLineFrozenPen
        If PropGridLineWidthFixed = -1 Then
            VBFlexGridGridLineFrozenPen = CreatePen(VBFlexGridFrozenPenStyle, PropGridLineWidth, WinColor(PropGridColorFrozen))
        Else
            VBFlexGridGridLineFrozenPen = CreatePen(VBFlexGridFrozenPenStyle, PropGridLineWidthFixed, WinColor(PropGridColorFrozen))
        End If
    End If
End If
Call RedrawGrid
UserControl.PropertyChanged "GridLineWidthFixed"
End Property

Public Property Get GridLineWidthFrozen() As Integer
Attribute GridLineWidthFrozen.VB_Description = "Returns/sets the width in pixels of the gridlines."
If PropGridLineWidthFrozen = -1 Then
    If PropGridLineWidthFixed = -1 Then GridLineWidthFrozen = PropGridLineWidth Else GridLineWidthFrozen = PropGridLineWidthFixed
Else
    GridLineWidthFrozen = PropGridLineWidthFrozen
End If
End Property

Public Property Let GridLineWidthFrozen(ByVal Value As Integer)
If Value < 1 And Not Value = -1 Then
    If VBFlexGridDesignMode = True Then
        MsgBox "Invalid property value", vbCritical + vbOKOnly
        Exit Property
    Else
        Err.Raise 380
    End If
End If
PropGridLineWidthFrozen = Value
If VBFlexGridHandle <> NULL_PTR Then
    If VBFlexGridGridLineFrozenPen <> NULL_PTR Then DeleteObject VBFlexGridGridLineFrozenPen
    If PropGridLineWidthFrozen = -1 Then
        If PropGridLineWidthFixed = -1 Then
            VBFlexGridGridLineFrozenPen = CreatePen(VBFlexGridFrozenPenStyle, PropGridLineWidth, WinColor(PropGridColorFrozen))
        Else
            VBFlexGridGridLineFrozenPen = CreatePen(VBFlexGridFrozenPenStyle, PropGridLineWidthFixed, WinColor(PropGridColorFrozen))
        End If
    Else
        VBFlexGridGridLineFrozenPen = CreatePen(VBFlexGridFrozenPenStyle, PropGridLineWidthFrozen, WinColor(PropGridColorFrozen))
    End If
End If
Call RedrawGrid
UserControl.PropertyChanged "GridLineWidthFrozen"
End Property

Public Property Get TextStyle() As FlexTextStyleConstants
Attribute TextStyle.VB_Description = "Returns/sets 3D effects for displaying text."
TextStyle = PropTextStyle
End Property

Public Property Let TextStyle(ByVal Value As FlexTextStyleConstants)
Select Case Value
    Case FlexTextStyleFlat, FlexTextStyleRaised, FlexTextStyleInset, FlexTextStyleRaisedLight, FlexTextStyleInsetLight
        PropTextStyle = Value
    Case Else
        Err.Raise 380
End Select
Call RedrawGrid
UserControl.PropertyChanged "TextStyle"
End Property

Public Property Get TextStyleFixed() As FlexTextStyleConstants
Attribute TextStyleFixed.VB_Description = "Returns/sets 3D effects for displaying text."
TextStyleFixed = PropTextStyleFixed
End Property

Public Property Let TextStyleFixed(ByVal Value As FlexTextStyleConstants)
Select Case Value
    Case FlexTextStyleFlat, FlexTextStyleRaised, FlexTextStyleInset, FlexTextStyleRaisedLight, FlexTextStyleInsetLight
        PropTextStyleFixed = Value
    Case Else
        Err.Raise 380
End Select
Call RedrawGrid
UserControl.PropertyChanged "TextStyleFixed"
End Property

Public Property Get PictureType() As FlexPictureTypeConstants
Attribute PictureType.VB_Description = "Returns/sets the type of picture that should be generated by the picture property."
PictureType = PropPictureType
End Property

Public Property Let PictureType(ByVal Value As FlexPictureTypeConstants)
Select Case Value
    Case FlexPictureTypeColor, FlexPictureTypeMonochrome, FlexPictureTypeEnhMetafile
        PropPictureType = Value
    Case Else
        Err.Raise 380
End Select
UserControl.PropertyChanged "PictureType"
End Property

Public Property Get FixGridLineOffsets() As Boolean
Attribute FixGridLineOffsets.VB_Description = "Returns/sets whether to fix the grid line offsets. If set to false it ensures visual compatibility with the MS flex grid control."
FixGridLineOffsets = PropFixGridLineOffsets
End Property

Public Property Let FixGridLineOffsets(ByVal Value As Boolean)
PropFixGridLineOffsets = Value
Call RedrawGrid
UserControl.PropertyChanged "FixGridLineOffsets"
End Property

Public Property Get MirrorAlignGeneral() As Boolean
Attribute MirrorAlignGeneral.VB_Description = "Returns/sets whether to mirror alignment general. This may be useful for right-to-left reading-order properties."
MirrorAlignGeneral = PropMirrorAlignGeneral
End Property

Public Property Let MirrorAlignGeneral(ByVal Value As Boolean)
PropMirrorAlignGeneral = Value
Call RedrawGrid
UserControl.PropertyChanged "MirrorAlignGeneral"
End Property

Public Property Get WordWrap() As Boolean
Attribute WordWrap.VB_Description = "Returns/sets whether text within a cell should be allowed to wrap."
WordWrap = PropWordWrap
End Property

Public Property Let WordWrap(ByVal Value As Boolean)
If PropSingleLine = True And Value = True Then
    If VBFlexGridDesignMode = True Then
        MsgBox "WordWrap must be False when SingleLine is True", vbCritical + vbOKOnly
        Exit Property
    Else
        Err.Raise Number:=383, Description:="WordWrap must be False when SingleLine is True"
    End If
End If
PropWordWrap = Value
Call RedrawGrid
UserControl.PropertyChanged "WordWrap"
End Property

Public Property Get SingleLine() As Boolean
Attribute SingleLine.VB_Description = "Returns/sets whether text within a cell is displayed on a single line only."
SingleLine = PropSingleLine
End Property

Public Property Let SingleLine(ByVal Value As Boolean)
PropSingleLine = Value
If PropSingleLine = True Then PropWordWrap = False
Call RedrawGrid
UserControl.PropertyChanged "SingleLine"
End Property

Public Property Get EllipsisFormat() As FlexEllipsisFormatConstants
Attribute EllipsisFormat.VB_Description = "Returns/sets a value indicating if and where the ellipsis character is appended, denoting that the text extends beyond the length of the cell. The word wrap property may be set to false to see the ellipsis character."
EllipsisFormat = PropEllipsisFormat
End Property

Public Property Let EllipsisFormat(ByVal Value As FlexEllipsisFormatConstants)
Select Case Value
    Case FlexEllipsisFormatNone, FlexEllipsisFormatEnd, FlexEllipsisFormatPath, FlexEllipsisFormatWord
        PropEllipsisFormat = Value
    Case Else
        Err.Raise 380
End Select
Call RedrawGrid
UserControl.PropertyChanged "EllipsisFormat"
End Property

Public Property Get EllipsisFormatFixed() As FlexEllipsisFormatConstants
Attribute EllipsisFormatFixed.VB_Description = "Returns/sets a value indicating if and where the ellipsis character is appended, denoting that the text extends beyond the length of the cell. The word wrap property may be set to false to see the ellipsis character."
EllipsisFormatFixed = PropEllipsisFormatFixed
End Property

Public Property Let EllipsisFormatFixed(ByVal Value As FlexEllipsisFormatConstants)
Select Case Value
    Case FlexEllipsisFormatNone, FlexEllipsisFormatEnd, FlexEllipsisFormatPath, FlexEllipsisFormatWord
        PropEllipsisFormatFixed = Value
    Case Else
        Err.Raise 380
End Select
Call RedrawGrid
UserControl.PropertyChanged "EllipsisFormatFixed"
End Property

Public Property Get MimicTextBox() As Boolean
Attribute MimicTextBox.VB_Description = "Returns/sets a value that determines whether or not to mimic the text-displaying characteristics of a multiline text box. This includes to break on characters instead on words. This is only meaningful if the word wrap property is set to true."
MimicTextBox = PropMimicTextBox
End Property

Public Property Let MimicTextBox(ByVal Value As Boolean)
PropMimicTextBox = Value
Call RedrawGrid
UserControl.PropertyChanged "MimicTextBox"
End Property

Public Property Get Redraw() As Boolean
Attribute Redraw.VB_Description = "Enables or disables redrawing of the flex grid control."
Redraw = PropRedraw
End Property

Public Property Let Redraw(ByVal Value As Boolean)
PropRedraw = Value
If VBFlexGridHandle <> NULL_PTR And VBFlexGridDesignMode = False Then
    SendMessage VBFlexGridHandle, WM_SETREDRAW, IIf(PropRedraw = True, 1, 0), ByVal 0&
    If PropRedraw = True Then
        Me.Refresh
        Call SetScrollBars
    End If
End If
UserControl.PropertyChanged "Redraw"
End Property

Public Property Get DoubleBuffer() As Boolean
Attribute DoubleBuffer.VB_Description = "Returns/sets a value that determines whether the control paints via double-buffering, which reduces flicker."
DoubleBuffer = PropDoubleBuffer
End Property

Public Property Let DoubleBuffer(ByVal Value As Boolean)
PropDoubleBuffer = Value
UserControl.PropertyChanged "DoubleBuffer"
End Property

Public Property Get Sort() As FlexSortConstants
Attribute Sort.VB_Description = "Action-type property that sorts selected rows according to selected criteria."
Attribute Sort.VB_MemberFlags = "400"
Err.Raise Number:=394, Description:="Property is write-only"
End Property

Public Property Let Sort(ByVal Value As FlexSortConstants)

#If ImplementFlexDataSource Then

If Not VBFlexGridFlexDataSource Is Nothing Then
    If (VBFlexGridFlexDataSourceFlags And FlexDataSourceNoData) = 0 Then Err.Raise Number:=5, Description:="This functionality is disabled when custom data source is set."
End If

#End If

Select Case Value
    Case FlexSortNone
        Exit Property
    Case FlexSortNone, FlexSortGenericAscending, FlexSortGenericDescending, FlexSortNumericAscending, FlexSortNumericDescending, FlexSortStringNoCaseAscending, FlexSortStringNoCaseDescending, FlexSortStringAscending, FlexSortStringDescending, FlexSortCustom, FlexSortUseColSort, FlexSortCurrencyAscending, FlexSortCurrencyDescending, FlexSortDateAscending, FlexSortDateDescending, FlexSortCustomText
        If (VBFlexGridRow < 0 Or VBFlexGridRowSel < 0) Or (VBFlexGridCol < 0 Or VBFlexGridColSel < 0) Then
            ' Error shall not be raised. Do nothing in this case.
            Exit Property
        End If
        Dim SelRange As TCELLRANGE, Row1 As Long, Row2 As Long, Sort As FlexSortConstants, iRow As Long, iCol As Long
        Dim Data() As TINDIRECTMERGESORTDATA, Blank As TCOLS, Length As Long
        Call GetSelRangeStruct(SelRange)
        If VBFlexGridRow = VBFlexGridRowSel Then
            Row1 = PropFixedRows
            Row2 = PropRows - 1
        Else
            Row1 = SelRange.TopRow
            Row2 = SelRange.BottomRow
        End If
        ' The keys used for sorting are determined by the Col and ColSel properties.
        ' To specify the range to be sorted, set the Row and RowSel properties.
        ' Sorting is always done in a left-to-right direction. (Technically the sorting is performed from right-to-left)
        For iCol = SelRange.RightCol To SelRange.LeftCol Step -1
            If Value <> FlexSortUseColSort Then Sort = Value Else Sort = VBFlexGridColsInfo(iCol).Sort
            ' MergeSort/BubbleSort are used as they are 'stable sort' algorithms.
            If Sort <> FlexSortCustom Then
                If VBFlexGridColsInfo(iCol).SortMode = FlexSortModeNormal Then
                    Call MergeSortRec(Row1, Row2, iCol, VBFlexGridCells.Rows(), Sort)
                ElseIf VBFlexGridColsInfo(iCol).SortMode = FlexSortModeTextDisplay Then
                    Length = LenB(Blank)
                    ReDim Data(Row1 To Row2) As TINDIRECTMERGESORTDATA
                    For iRow = Row1 To Row2
                        Data(iRow).TextDisplay = VBFlexGridCells.Rows(iRow).Cols(iCol).Text
                        Call GetTextDisplay(iRow, iCol, Data(iRow).TextDisplay)
                        CopyMemory ByVal VarPtr(Data(iRow).Swap), ByVal VarPtr(VBFlexGridCells.Rows(iRow)), Length
                    Next iRow
                    Call TextDisplayMergeSortRec(Row1, Row2, iCol, Data(), Sort)
                    For iRow = Row1 To Row2
                        CopyMemory ByVal VarPtr(VBFlexGridCells.Rows(iRow)), ByVal VarPtr(Data(iRow).Swap), Length
                    Next iRow
                    For iRow = Row1 To Row2
                        ZeroMemory ByVal VarPtr(Data(iRow).Swap), Length
                    Next iRow
                End If
            Else
                ' CustomMergeSort/BubbleSort is used for custom sorting as row1/row2 must be meaningful in the 'Compare' event.
                ' Call BubbleSortIter(Row1, Row2, iCol, VBFlexGridCells.Rows())
                Length = LenB(Blank)
                ReDim Data(Row1 To Row2) As TINDIRECTMERGESORTDATA
                For iRow = Row1 To Row2
                    Data(iRow).Row = iRow
                    CopyMemory ByVal VarPtr(Data(iRow).Swap), ByVal VarPtr(VBFlexGridCells.Rows(iRow)), Length
                Next iRow
                Call CustomMergeSortRec(Row1, Row2, iCol, Data())
                For iRow = Row1 To Row2
                    CopyMemory ByVal VarPtr(VBFlexGridCells.Rows(iRow)), ByVal VarPtr(Data(iRow).Swap), Length
                Next iRow
                For iRow = Row1 To Row2
                    ZeroMemory ByVal VarPtr(Data(iRow).Swap), Length
                Next iRow
            End If
        Next iCol
        Dim RCP As TROWCOLPARAMS
        With RCP
        .Mask = RCPM_TOPROW
        .Flags = RCPF_CHECKTOPROW Or RCPF_FORCETOPROWMASK Or RCPF_SETSCROLLBARS Or RCPF_FORCEREDRAW
        .TopRow = VBFlexGridTopRow
        End With
        If VBFlexGridIndirectCellRef.InProc = False Then
            Call SetRowColParams(RCP)
        Else
            LSet VBFlexGridIndirectCellRef.RCP = RCP
            VBFlexGridIndirectCellRef.SetRCP = True
        End If
    Case Else
        Err.Raise 380
End Select
' Action-type property. Not real property.
End Property

Public Property Get TabBehavior() As FlexTabBehaviorConstants
Attribute TabBehavior.VB_Description = "Returns/sets a value that defines the behavior of the tab key."
TabBehavior = PropTabBehavior
End Property

Public Property Let TabBehavior(ByVal Value As FlexTabBehaviorConstants)
Select Case Value
    Case FlexTabControls, FlexTabCells, FlexTabNext
        PropTabBehavior = Value
    Case Else
        Err.Raise 380
End Select
UserControl.PropertyChanged "TabBehavior"
End Property

Public Property Get DirectionAfterReturn() As FlexDirectionAfterReturnConstants
Attribute DirectionAfterReturn.VB_Description = "Returns/sets a value that determines the relative position of the next cell when the user presses the return (Enter) key."
DirectionAfterReturn = PropDirectionAfterReturn
End Property

Public Property Let DirectionAfterReturn(ByVal Value As FlexDirectionAfterReturnConstants)
Select Case Value
    Case FlexDirectionAfterReturnNone, FlexDirectionAfterReturnUp, FlexDirectionAfterReturnDown, FlexDirectionAfterReturnLeft, FlexDirectionAfterReturnRight, FlexDirectionAfterReturnEdit
        PropDirectionAfterReturn = Value
    Case Else
        Err.Raise 380
End Select
UserControl.PropertyChanged "DirectionAfterReturn"
End Property

Public Property Get WrapCellBehavior() As FlexWrapCellBehaviorConstants
Attribute WrapCellBehavior.VB_Description = "Returns/sets a value that determines what the flex grid does when at last or first column in a row."
WrapCellBehavior = PropWrapCellBehavior
End Property

Public Property Let WrapCellBehavior(ByVal Value As FlexWrapCellBehaviorConstants)
Select Case Value
    Case FlexWrapNone, FlexWrapRow, FlexWrapGrid
        PropWrapCellBehavior = Value
    Case Else
        Err.Raise 380
End Select
UserControl.PropertyChanged "WrapCellBehavior"
End Property

Public Property Get ShowInfoTips() As Boolean
Attribute ShowInfoTips.VB_Description = "Returns/sets a value that determines whether the tool tip text properties will be displayed or not."
ShowInfoTips = PropShowInfoTips
End Property

Public Property Let ShowInfoTips(ByVal Value As Boolean)
PropShowInfoTips = Value
If VBFlexGridHandle <> NULL_PTR And VBFlexGridDesignMode = False Then
    If PropShowInfoTips = False And PropShowLabelTips = False Then
        Call DestroyToolTip
    Else
        Call CreateToolTip
    End If
End If
UserControl.PropertyChanged "ShowInfoTips"
End Property

Public Property Get ShowLabelTips() As Boolean
Attribute ShowLabelTips.VB_Description = "Returns/sets a value indicating that if a partially hidden label lacks tool tip text, the flex grid will unfold the label or not."
ShowLabelTips = PropShowLabelTips
End Property

Public Property Let ShowLabelTips(ByVal Value As Boolean)
PropShowLabelTips = Value
If VBFlexGridHandle <> NULL_PTR And VBFlexGridDesignMode = False Then
    If PropShowInfoTips = False And PropShowLabelTips = False Then
        Call DestroyToolTip
    Else
        Call CreateToolTip
    End If
End If
UserControl.PropertyChanged "ShowLabelTips"
End Property

Public Property Get ShowScrollTips() As Boolean
Attribute ShowScrollTips.VB_Description = "Returns/sets a value that determines whether scroll tips appear when the user moves the scroll box."
ShowScrollTips = PropShowScrollTips
End Property

Public Property Let ShowScrollTips(ByVal Value As Boolean)
PropShowScrollTips = Value
If VBFlexGridHandle <> NULL_PTR And VBFlexGridDesignMode = False Then
    If PropShowScrollTips = False Then
        Call DestroyScrollTip
    Else
        Call CreateScrollTip
    End If
End If
UserControl.PropertyChanged "ShowScrollTips"
End Property

Public Property Get ClipSeparators() As String
Attribute ClipSeparators.VB_Description = "Returns/sets two distinct characters to be used as column (first) and row (second) separators in clip strings. If it is empty, the defaults vbTab and vbCr are used."
ClipSeparators = PropClipSeparators
End Property

Public Property Let ClipSeparators(ByVal Value As String)
Select Case Len(Value)
    Case Is > 2, 1
        If VBFlexGridDesignMode = True Then
            MsgBox "Invalid property value", vbCritical + vbOKOnly
            Exit Property
        Else
            Err.Raise 380
        End If
    Case 2
        If StrComp(Left$(Value, 1), Right$(Value, 1)) = 0 Then
            If VBFlexGridDesignMode = True Then
                MsgBox "Invalid property value", vbCritical + vbOKOnly
                Exit Property
            Else
                Err.Raise 380
            End If
        End If
End Select
PropClipSeparators = Value
UserControl.PropertyChanged "ClipSeparators"
End Property

Public Property Get ClipMode() As FlexClipModeConstants
Attribute ClipMode.VB_Description = "Returns/sets a value that determines whether to include or exclude hidden cells when doing a clip command."
ClipMode = PropClipMode
End Property

Public Property Let ClipMode(ByVal Value As FlexClipModeConstants)
Select Case Value
    Case FlexClipModeNormal, FlexClipModeExcludeHidden, FlexClipModeLookupConv, FlexClipModeLookupConvExcludeHidden
        PropClipMode = Value
    Case Else
        Err.Raise 380
End Select
UserControl.PropertyChanged "ClipMode"
End Property

Public Property Get ClipCopyMode() As FlexClipCopyModeConstants
Attribute ClipCopyMode.VB_Description = "Returns/sets a value that determines what parts are copied to the clipboard or returned by a clip command."
ClipCopyMode = PropClipCopyMode
End Property

Public Property Let ClipCopyMode(ByVal Value As FlexClipCopyModeConstants)
Select Case Value
    Case FlexClipCopyModeNormal, FlexClipCopyModeIncludeFixedRows, FlexClipCopyModeIncludeFixedColumns, FlexClipCopyModeIncludeFixedAll, FlexClipCopyModeExtended, FlexClipCopyModeExtendedFixedRows, FlexClipCopyModeExtendedFixedColumns, FlexClipCopyModeExtendedFixedAll
        PropClipCopyMode = Value
    Case Else
        Err.Raise 380
End Select
UserControl.PropertyChanged "ClipCopyMode"
End Property

Public Property Get ClipPasteMode() As FlexClipPasteModeConstants
Attribute ClipPasteMode.VB_Description = "Returns/sets a value that determines how content is pasted from the clipboard or by doing a clip command."
ClipPasteMode = PropClipPasteMode
End Property

Public Property Let ClipPasteMode(ByVal Value As FlexClipPasteModeConstants)
Select Case Value
    Case FlexClipPasteModeNormal, FlexClipPasteModeAutoSelection, FlexClipPasteModeExtended, FlexClipPasteModeExtendedAutoSelection
        PropClipPasteMode = Value
    Case Else
        Err.Raise 380
End Select
UserControl.PropertyChanged "ClipPasteMode"
End Property

Public Property Get FormatString() As String
Attribute FormatString.VB_Description = "Allows you to set up column widths, alignments, and fixed row and column text in the flex grid at design time."
FormatString = PropFormatString
End Property

Public Property Let FormatString(ByVal Value As String)
PropFormatString = Value
If VBFlexGridDesignMode = True Then
    If PropRows > 0 And PropCols > 0 Then
        Call EraseFlexGridCells
        Call InitFlexGridCells
        Call RedrawGrid
    End If
End If
If Not PropFormatString = vbNullString Then
    If PropFixedRows > 0 Then
        Dim PosRemainder As Long
        Dim FormatCol As String, FormatRow As String
        PosRemainder = InStr(1, PropFormatString, ";")
        If PosRemainder > 0 Then
            FormatCol = Mid$(PropFormatString, 1, PosRemainder - 1)
            FormatRow = Mid$(PropFormatString, PosRemainder + 1)
        Else
            FormatCol = PropFormatString
        End If
        Dim Pos1 As Long, Pos2 As Long, Temp As String, Spacing As Long
        Spacing = VBFlexGridPixelMetrics.CellSpacing.CX
        If Not FormatCol = vbNullString Then
            Dim iCol As Long
            Do
                Pos1 = InStr(Pos1 + 1, FormatCol, "|")
                Pos2 = Pos1
                iCol = iCol + 1
            Loop Until Pos1 = 0
            If iCol > PropCols Then Me.Cols = iCol
            Pos1 = 0
            Pos2 = 0
            iCol = 0
            Do
                Pos1 = InStr(Pos1 + 1, FormatCol, "|")
                If Pos1 > 0 Then
                    Temp = Mid$(FormatCol, Pos2 + 1, Pos1 - Pos2 - 1)
                Else
                    Temp = Mid$(FormatCol, Pos2 + 1)
                End If
                With VBFlexGridColsInfo(iCol)
                Select Case Left$(Temp, 1)
                    Case "<"
                        .Alignment = FlexAlignmentLeftCenter
                        Temp = Mid$(Temp, 2)
                    Case "^"
                        .Alignment = FlexAlignmentCenterCenter
                        Temp = Mid$(Temp, 2)
                    Case ">"
                        .Alignment = FlexAlignmentRightCenter
                        Temp = Mid$(Temp, 2)
                    Case Else
                        .Alignment = FlexAlignmentGeneral
                End Select
                .Width = GetBestWidth(0, iCol, Temp) + Spacing
                End With
                Call SetCellText(0, iCol, Trim$(Temp))
                Pos2 = Pos1
                iCol = iCol + 1
            Loop Until Pos1 = 0
            Pos1 = 0
            Pos2 = 0
        End If
        If (Not FormatRow = vbNullString Or PosRemainder > 0) And PropFixedCols > 0 Then
            Dim iRow As Long, CX As Long
            Do
                Pos1 = InStr(Pos1 + 1, FormatRow, "|")
                Pos2 = Pos1
                iRow = iRow + 1
            Loop Until Pos1 = 0
            If iRow > PropRows Then Me.Rows = iRow
            Pos1 = 0
            Pos2 = 0
            iRow = 0
            Do
                Pos1 = InStr(Pos1 + 1, FormatRow, "|")
                If Pos1 > 0 Then
                    Temp = Mid$(FormatRow, Pos2 + 1, Pos1 - Pos2 - 1)
                Else
                    Temp = Mid$(FormatRow, Pos2 + 1)
                End If
                CX = GetBestWidth(iRow, 0, Temp)
                If (CX + Spacing) > VBFlexGridColsInfo(0).Width Then VBFlexGridColsInfo(0).Width = CX + Spacing
                Call SetCellText(iRow, 0, Trim$(Temp))
                Pos2 = Pos1
                iRow = iRow + 1
            Loop Until Pos1 = 0
            Pos1 = 0
            Pos2 = 0
        End If
        Dim RCP As TROWCOLPARAMS
        With RCP
        .Mask = RCPM_LEFTCOL
        .Flags = RCPF_CHECKLEFTCOL Or RCPF_SETSCROLLBARS Or RCPF_FORCEREDRAW
        .LeftCol = VBFlexGridLeftCol
        Call SetRowColParams(RCP)
        End With
    End If
End If
UserControl.PropertyChanged "FormatString"
End Property

Public Property Get IMEMode() As FlexIMEModeConstants
Attribute IMEMode.VB_Description = "Returns/sets the Input Method Editor (IME) mode."
IMEMode = PropIMEMode
End Property

Public Property Let IMEMode(ByVal Value As FlexIMEModeConstants)
Select Case Value
    Case FlexIMEModeNoControl, FlexIMEModeOn, FlexIMEModeOff, FlexIMEModeDisable, FlexIMEModeHiragana, FlexIMEModeKatakana, FlexIMEModeKatakanaHalf, FlexIMEModeAlphaFull, FlexIMEModeAlpha, FlexIMEModeHangulFull, FlexIMEModeHangul
        PropIMEMode = Value
    Case Else
        Err.Raise 380
End Select
If VBFlexGridHandle <> NULL_PTR And VBFlexGridDesignMode = False Then
    If GetFocus() = VBFlexGridHandle Then
        Call SetIMEMode(VBFlexGridHandle, VBFlexGridIMCHandle, PropIMEMode)
    ElseIf VBFlexGridEditHandle <> NULL_PTR Then
        If GetFocus() = VBFlexGridEditHandle Then Call SetIMEMode(VBFlexGridEditHandle, VBFlexGridIMCHandle, PropIMEMode)
    End If
End If
UserControl.PropertyChanged "IMEMode"
End Property

Public Property Get WantReturn() As Boolean
Attribute WantReturn.VB_Description = "Returns/sets a value that determines when the user presses RETURN to perform the default button or to allow the flex grid to handle the return key. This property applies only when there is any default button on the form."
WantReturn = PropWantReturn
End Property

Public Property Let WantReturn(ByVal Value As Boolean)
If PropWantReturn = Value Then Exit Property
PropWantReturn = Value
If VBFlexGridHandle <> NULL_PTR And VBFlexGridDesignMode = False Then
    Dim PropOleObject As OLEGuids.IOleObject
    Dim PropClientSite As OLEGuids.IOleClientSite
    Dim PropUnknown As IUnknown
    Dim PropControlSite As OLEGuids.IOleControlSite
    On Error Resume Next
    Set PropOleObject = Me
    Set PropClientSite = PropOleObject.GetClientSite
    Set PropUnknown = PropClientSite
    Set PropControlSite = PropUnknown
    PropControlSite.OnControlInfoChanged
    If GetFocus() = VBFlexGridHandle Then
        ' If focus is on the control then force the change immediately.
        PropControlSite.OnFocus 1
    End If
    On Error GoTo 0
End If
UserControl.PropertyChanged "WantReturn"
End Property

Public Property Get ExtendLastCol() As Boolean
Attribute ExtendLastCol.VB_Description = "Returns/sets a value that determines whether the last column should be adjusted to fit the width of the flex grid control."
ExtendLastCol = PropExtendLastCol
End Property

Public Property Let ExtendLastCol(ByVal Value As Boolean)
PropExtendLastCol = Value
If PropRows > 0 And PropCols > 0 Then
    VBFlexGridExtendLastCol = GetExtendLastCol()
    Dim RCP As TROWCOLPARAMS
    With RCP
    .Mask = RCPM_LEFTCOL
    .Flags = RCPF_CHECKLEFTCOL Or RCPF_SETSCROLLBARS Or RCPF_FORCEREDRAW
    .LeftCol = VBFlexGridLeftCol
    Call SetRowColParams(RCP)
    End With
End If
UserControl.PropertyChanged "ExtendLastCol"
End Property

Public Property Get RowSortArrows() As Long
Attribute RowSortArrows.VB_Description = "Returns/sets the row for the sort arrows."
RowSortArrows = PropRowSortArrows
End Property

Public Property Let RowSortArrows(ByVal Value As Long)
If Value < 0 Then
    If VBFlexGridDesignMode = True Then
        MsgBox "Invalid property value", vbCritical + vbOKOnly
        Exit Property
    Else
        Err.Raise 380
    End If
End If
PropRowSortArrows = Value
Call RedrawGrid
End Property

Public Property Get AllowScrollLock() As Boolean
Attribute AllowScrollLock.VB_Description = "Returns/sets whether the control lets you use the arrow keys to scroll its contents when the scroll lock key is toggled on."
AllowScrollLock = PropAllowScrollLock
End Property

Public Property Let AllowScrollLock(ByVal Value As Boolean)
PropAllowScrollLock = Value
UserControl.PropertyChanged "AllowScrollLock"
End Property

Public Property Get SheetBorder() As Boolean
Attribute SheetBorder.VB_Description = "Returns/sets whether the flex grid control should draw a border around the sheet."
SheetBorder = PropSheetBorder
End Property

Public Property Let SheetBorder(ByVal Value As Boolean)
PropSheetBorder = Value
Call RedrawGrid
UserControl.PropertyChanged "SheetBorder"
End Property

Public Property Get AutoClipboard() As Boolean
Attribute AutoClipboard.VB_Description = "Returns/sets whether the flex grid should handle the clipboard keys and automatically perform copy, cut, paste and delete operations."
AutoClipboard = PropAutoClipboard
End Property

Public Property Let AutoClipboard(ByVal Value As Boolean)
PropAutoClipboard = Value
UserControl.PropertyChanged "AutoClipboard"
End Property

Public Property Get BestFitMode() As FlexBestFitModeConstants
Attribute BestFitMode.VB_Description = "Returns/sets a value that determines which cell contents are considered in best-fit resizing operations."
BestFitMode = PropBestFitMode
End Property

Public Property Let BestFitMode(ByVal Value As FlexBestFitModeConstants)
Select Case Value
    Case FlexBestFitModeTextOnly, FlexBestFitModeFull, FlexBestFitModeSortArrowText, FlexBestFitModeOtherText
        PropBestFitMode = Value
    Case Else
        Err.Raise 380
End Select
UserControl.PropertyChanged "BestFitMode"
End Property

Public Property Get WallPaper() As IPictureDisp
Attribute WallPaper.VB_Description = "Returns/sets a picture to be used as a background for the non-fixed area of the flex grid control."
Set WallPaper = PropWallPaper
End Property

Public Property Let WallPaper(ByVal Value As IPictureDisp)
Set Me.WallPaper = Value
End Property

Public Property Set WallPaper(ByVal Value As IPictureDisp)
Set UserControl.Picture = Value
Set PropWallPaper = UserControl.Picture
Set UserControl.Picture = Nothing
VBFlexGridWallPaperRenderFlag = 0
Call RedrawGrid
UserControl.PropertyChanged "WallPaper"
End Property

Public Property Get WallPaperAlignment() As FlexWallPaperAlignmentConstants
Attribute WallPaperAlignment.VB_Description = "Returns/sets the alignment of the wall paper background picture."
WallPaperAlignment = PropWallPaperAlignment
End Property

Public Property Let WallPaperAlignment(ByVal Value As FlexWallPaperAlignmentConstants)
Select Case Value
    Case FlexWallPaperAlignmentLeftTop, FlexWallPaperAlignmentLeftCenter, FlexWallPaperAlignmentLeftBottom, FlexWallPaperAlignmentCenterTop, FlexWallPaperAlignmentCenterCenter, FlexWallPaperAlignmentCenterBottom, FlexWallPaperAlignmentRightTop, FlexWallPaperAlignmentRightCenter, FlexWallPaperAlignmentRightBottom, FlexWallPaperAlignmentStretch, FlexWallPaperAlignmentTile
        PropWallPaperAlignment = Value
    Case Else
        Err.Raise 380
End Select
Call RedrawGrid
End Property

Public Property Get AllowIncrementalSearch() As Boolean
Attribute AllowIncrementalSearch.VB_Description = "Returns/sets a value that determines whether an incremental search can be performed."
AllowIncrementalSearch = PropAllowIncrementalSearch
End Property

Public Property Let AllowIncrementalSearch(ByVal Value As Boolean)
PropAllowIncrementalSearch = Value
If PropAllowIncrementalSearch = False Then
    If Not VBFlexGridIncrementalSearch.SearchString = vbNullString Then Call CancelIncrementalSearch
End If
UserControl.PropertyChanged "AllowIncrementalSearch"
End Property

Public Property Get AllowReaderMode() As Boolean
Attribute AllowReaderMode.VB_Description = "Returns/sets a value that determines whether the control supports reader-mode for auto-scrolling and panning."
AllowReaderMode = PropAllowReaderMode
End Property

Public Property Let AllowReaderMode(ByVal Value As Boolean)
PropAllowReaderMode = Value
UserControl.PropertyChanged "AllowReaderMode"
End Property

Public Property Get AlwaysAllowComboCues() As Boolean
Attribute AlwaysAllowComboCues.VB_Description = "Returns/sets a value indicating if combo cues can be displayed always. The ComboCueClick event is fired when either the allow user editing property is set to false or a user attempt to edit has been canceled."
AlwaysAllowComboCues = PropAlwaysAllowComboCues
End Property

Public Property Let AlwaysAllowComboCues(ByVal Value As Boolean)
PropAlwaysAllowComboCues = Value
UserControl.PropertyChanged "AlwaysAllowComboCues"
End Property

Public Property Get UndoLimit() As Long
Attribute UndoLimit.VB_Description = "Returns/sets the maximum number of actions that can be stored in the undo queue. A value of 0 indicates that the undo feature is disabled."
UndoLimit = PropUndoLimit
End Property

Public Property Let UndoLimit(ByVal Value As Long)
If Value < 0 Then
    If VBFlexGridDesignMode = True Then
        MsgBox "Invalid property value", vbCritical + vbOKOnly
        Exit Property
    Else
        Err.Raise 380
    End If
End If
If Value > 1000 Then Value = 1000
PropUndoLimit = Value
Call ResetUndo
Call ResetRedo
UserControl.PropertyChanged "UndoLimit"
End Property

Public Property Get FontQuality() As FlexFontQualityConstants
Attribute FontQuality.VB_Description = "Returns/sets the font quality."
FontQuality = PropFontQuality
End Property

Public Property Let FontQuality(ByVal Value As FlexFontQualityConstants)
Select Case Value
    Case FlexFontQualityDefault, FlexFontQualityDraft, FlexFontQualityProof, FlexFontQualityNonAntiAliased, FlexFontQualityAntiAliased, FlexFontQualityClearType, FlexFontQualityClearTypeNatural
        PropFontQuality = Value
    Case Else
        Err.Raise 380
End Select
Set Me.Font = PropFont
Set Me.FontFixed = PropFontFixed
UserControl.PropertyChanged "FontQuality"
End Property

Public Property Get MultiSelChangeTime() As Long
Attribute MultiSelChangeTime.VB_Description = "Returns/sets the time in milliseconds before the MultiSelChange event is fired by a window message after a change in the multi-selection. A value of 0 indicates that it is fired immediately."
MultiSelChangeTime = PropMultiSelChangeTime
End Property

Public Property Let MultiSelChangeTime(ByVal Value As Long)
If Value < 0 Or Value > 65535 Then
    If VBFlexGridDesignMode = True Then
        MsgBox "Invalid property value", vbCritical + vbOKOnly
        Exit Property
    Else
        Err.Raise 380
    End If
End If
PropMultiSelChangeTime = Value
UserControl.PropertyChanged "MultiSelChangeTime"
End Property

Private Sub CreateVBFlexGrid()
If VBFlexGridHandle <> NULL_PTR Then Exit Sub
Call InitFlexGridCells
If VBFlexGridDesignMode = False Then
    Dim dwStyle As Long, dwExStyle As Long
    dwStyle = WS_CHILD Or WS_VISIBLE Or WS_CLIPCHILDREN Or WS_CLIPSIBLINGS
    dwExStyle = WS_EX_NOINHERITLAYOUT
    If PropAllowDropFiles = True Then dwExStyle = dwExStyle Or WS_EX_ACCEPTFILES
    If PropRightToLeft = True Then
        If PropRightToLeftLayout = True Then
            dwExStyle = dwExStyle Or WS_EX_LAYOUTRTL
        Else
            dwExStyle = dwExStyle Or WS_EX_RTLREADING
        End If
    End If
    Select Case PropBorderStyle
        Case FlexBorderStyleSingle
            dwStyle = dwStyle Or WS_BORDER
        Case FlexBorderStyleThin
            dwExStyle = dwExStyle Or WS_EX_STATICEDGE
        Case FlexBorderStyleSunken
            dwExStyle = dwExStyle Or WS_EX_CLIENTEDGE
        Case FlexBorderStyleRaised
            dwExStyle = dwExStyle Or WS_EX_WINDOWEDGE
            dwStyle = dwStyle Or WS_DLGFRAME
    End Select
    VBFlexGridRTLLayout = CBool((dwExStyle And WS_EX_LAYOUTRTL) = WS_EX_LAYOUTRTL)
    VBFlexGridRTLReading = CBool((dwExStyle And WS_EX_RTLREADING) = WS_EX_RTLREADING)
    VBFlexGridHandle = CreateWindowEx(dwExStyle, StrPtr("VBFlexGridWndClass"), NULL_PTR, dwStyle, 0, 0, UserControl.ScaleWidth, UserControl.ScaleHeight, UserControl.hWnd, NULL_PTR, App.hInstance, ByVal ObjPtr(Me))
    If VBFlexGridHandle <> NULL_PTR Then
        SetWindowLongPtr VBFlexGridHandle, 0, ObjPtr(Me)
        If VBFlexGridIMCHandle = NULL_PTR Then
            VBFlexGridIMCHandle = ImmCreateContext()
            If VBFlexGridIMCHandle <> NULL_PTR Then ImmAssociateContext VBFlexGridHandle, VBFlexGridIMCHandle
        End If
    End If
    If PropShowInfoTips = True Or PropShowLabelTips = True Then Call CreateToolTip
    If PropShowScrollTips = True Then Call CreateScrollTip
Else
    VBFlexGridHandle = UserControl.hWnd
    SetRect VBFlexGridClientRect, 0, 0, UserControl.ScaleWidth, UserControl.ScaleHeight
    If PropRightToLeft = True Then Me.RightToLeft = True
    Me.BorderStyle = PropBorderStyle
End If
If VBFlexGridHandle <> NULL_PTR Then
    VBFlexGridBackColorBrush = CreateSolidBrush(WinColor(PropBackColor))
    VBFlexGridBackColorAltBrush = CreateSolidBrush(WinColor(PropBackColorAlt))
    VBFlexGridBackColorBkgBrush = CreateSolidBrush(WinColor(PropBackColorBkg))
    VBFlexGridBackColorFixedBrush = CreateSolidBrush(WinColor(PropBackColorFixed))
    VBFlexGridBackColorSelBrush = CreateSolidBrush(WinColor(PropBackColorSel))
    If PropFocusRect = FlexFocusRectFlat Then VBFlexGridFocusRectPen = CreatePen(PS_INSIDEFRAME, GetFocusRectWidth(), WinColor(PropBackColorSel))
    Select Case PropGridLines
        Case FlexGridLineDashes, FlexGridLineDashesHorz, FlexGridLineDashesVert
            VBFlexGridPenStyle = PS_DASH
        Case FlexGridLineDots, FlexGridLineDotsHorz, FlexGridLineDotsVert
            VBFlexGridPenStyle = PS_DOT
        Case Else
            VBFlexGridPenStyle = PS_SOLID
    End Select
    VBFlexGridGridLinePen = CreatePen(VBFlexGridPenStyle, PropGridLineWidth, WinColor(PropGridColor))
    Select Case PropGridLinesFixed
        Case FlexGridLineDashes, FlexGridLineDashesHorz, FlexGridLineDashesVert
            VBFlexGridFixedPenStyle = PS_DASH
        Case FlexGridLineDots, FlexGridLineDotsHorz, FlexGridLineDotsVert
            VBFlexGridFixedPenStyle = PS_DOT
        Case Else
            VBFlexGridFixedPenStyle = PS_SOLID
    End Select
    If PropGridLineWidthFixed = -1 Then
        VBFlexGridGridLineFixedPen = CreatePen(VBFlexGridFixedPenStyle, PropGridLineWidth, WinColor(PropGridColorFixed))
    Else
        VBFlexGridGridLineFixedPen = CreatePen(VBFlexGridFixedPenStyle, PropGridLineWidthFixed, WinColor(PropGridColorFixed))
    End If
    Select Case PropGridLinesFrozen
        Case FlexGridLineDashes, FlexGridLineDashesHorz, FlexGridLineDashesVert
            VBFlexGridFrozenPenStyle = PS_DASH
        Case FlexGridLineDots, FlexGridLineDotsHorz, FlexGridLineDotsVert
            VBFlexGridFrozenPenStyle = PS_DOT
        Case Else
            VBFlexGridFrozenPenStyle = PS_SOLID
    End Select
    If PropGridLineWidthFrozen = -1 Then
        If PropGridLineWidthFixed = -1 Then
            VBFlexGridGridLineFrozenPen = CreatePen(VBFlexGridFrozenPenStyle, PropGridLineWidth, WinColor(PropGridColorFrozen))
        Else
            VBFlexGridGridLineFrozenPen = CreatePen(VBFlexGridFrozenPenStyle, PropGridLineWidthFixed, WinColor(PropGridColorFrozen))
        End If
    Else
        VBFlexGridGridLineFrozenPen = CreatePen(VBFlexGridFrozenPenStyle, PropGridLineWidthFrozen, WinColor(PropGridColorFrozen))
    End If
    VBFlexGridGridLineWhitePen = CreatePen(PS_SOLID, 0, vbWhite)
    VBFlexGridGridLineBlackPen = CreatePen(PS_SOLID, 0, vbBlack)
End If
Set Me.Font = PropFont
Set Me.FontFixed = PropFontFixed
Me.VisualStyles = PropVisualStyles
Me.Enabled = UserControl.Enabled
If PropRedraw = False Then Me.Redraw = False
Me.FormatString = PropFormatString
If PropUndoLimit > 0 Then Me.UndoLimit = PropUndoLimit
Call SetScrollBars
If VBFlexGridDesignMode = False Then
    Call FlexSetSubclass(UserControl.hWnd, Me, 6)
    
    #If ImplementPreTranslateMsg = True Then
    
    If UsePreTranslateMsg = True Then Call FlexPreTranslateMsgAddHook
    
    #End If
    
End If
UserControl.BackColor = PropBackColorBkg
End Sub

Private Sub CreateToolTip()
Static Done As Boolean
If VBFlexGridToolTipHandle <> NULL_PTR Then Exit Sub
If Done = False Then
    Call FlexInitCC(ICC_TAB_CLASSES)
    Done = True
End If
Dim dwExStyle As Long
dwExStyle = WS_EX_TOOLWINDOW Or WS_EX_TOPMOST Or WS_EX_TRANSPARENT
If VBFlexGridRTLLayout = True Then dwExStyle = dwExStyle Or WS_EX_LAYOUTRTL
VBFlexGridToolTipHandle = CreateWindowEx(dwExStyle, StrPtr("tooltips_class32"), StrPtr("Tool Tip"), WS_POPUP Or TTS_ALWAYSTIP Or TTS_NOPREFIX, 0, 0, 0, 0, UserControl.hWnd, NULL_PTR, App.hInstance, ByVal NULL_PTR)
If VBFlexGridToolTipHandle <> NULL_PTR Then
    SendMessage VBFlexGridToolTipHandle, TTM_SETMAXTIPWIDTH, 0, ByVal &H7FFF&
    Dim TI As TOOLINFO
    With TI
    .cbSize = LenB(TI)
    .hWnd = VBFlexGridHandle
    .uId = 0
    .uFlags = TTF_SUBCLASS Or TTF_TRANSPARENT Or TTF_PARSELINKS
    If VBFlexGridRTLReading = True Then .uFlags = .uFlags Or TTF_RTLREADING
    .lpszText = LPSTR_TEXTCALLBACK
    LSet .RC = VBFlexGridClientRect
    End With
    SendMessage VBFlexGridToolTipHandle, TTM_ADDTOOL, 0, ByVal VarPtr(TI)
End If
Call SetVisualStylesToolTip
End Sub

Private Sub CreateScrollTip()
Static Done As Boolean
If VBFlexGridScrollTipHandle <> NULL_PTR Then Exit Sub
If Done = False Then
    Call FlexInitCC(ICC_TAB_CLASSES)
    Done = True
End If
Dim dwExStyle As Long
dwExStyle = WS_EX_TOOLWINDOW Or WS_EX_TOPMOST Or WS_EX_TRANSPARENT
If VBFlexGridRTLLayout = True Then dwExStyle = dwExStyle Or WS_EX_LAYOUTRTL
VBFlexGridScrollTipHandle = CreateWindowEx(dwExStyle, StrPtr("tooltips_class32"), StrPtr("Scroll Tip"), WS_POPUP Or TTS_ALWAYSTIP Or TTS_NOPREFIX, 0, 0, 0, 0, UserControl.hWnd, NULL_PTR, App.hInstance, ByVal NULL_PTR)
If VBFlexGridScrollTipHandle <> NULL_PTR Then
    SendMessage VBFlexGridScrollTipHandle, TTM_SETMAXTIPWIDTH, 0, ByVal &H7FFF&
    Dim TI As TOOLINFO
    With TI
    .cbSize = LenB(TI)
    .hWnd = VBFlexGridHandle
    .uId = 0
    .uFlags = TTF_TRACK
    If VBFlexGridRTLReading = True Then .uFlags = .uFlags Or TTF_RTLREADING
    .lpszText = NULL_PTR
    End With
    SendMessage VBFlexGridScrollTipHandle, TTM_ADDTOOL, 0, ByVal VarPtr(TI)
End If
Call SetVisualStylesScrollTip
End Sub

Private Sub DestroyVBFlexGrid()
If VBFlexGridHandle = NULL_PTR Then Exit Sub
Call FlexRemoveSubclass(UserControl.hWnd)
Call DestroyToolTip
Call DestroyScrollTip
If VBFlexGridDesignMode = False Then
    If VBFlexGridMultiSelChangeTimer = True Then
        KillTimer VBFlexGridHandle, IDT_MULTISELCHANGE
        VBFlexGridMultiSelChangeTimer = False
    End If
    
    #If ImplementPreTranslateMsg = True Then
    
    If UsePreTranslateMsg = True Then Call FlexPreTranslateMsgReleaseHook
    
    #End If
    
    SetWindowLongPtr VBFlexGridHandle, 0, NULL_PTR
    If VBFlexGridIMCHandle <> NULL_PTR Then
        ImmAssociateContext VBFlexGridHandle, NULL_PTR
        ImmDestroyContext VBFlexGridIMCHandle
        VBFlexGridIMCHandle = NULL_PTR
    End If
    ShowWindow VBFlexGridHandle, SW_HIDE
    SetParent VBFlexGridHandle, NULL_PTR
    DestroyWindow VBFlexGridHandle
End If
VBFlexGridHandle = NULL_PTR
If VBFlexGridDoubleBufferDC <> NULL_PTR Then
    If VBFlexGridDoubleBufferBmpOld <> NULL_PTR Then
        SelectObject VBFlexGridDoubleBufferDC, VBFlexGridDoubleBufferBmpOld
        VBFlexGridDoubleBufferBmpOld = NULL_PTR
    End If
    If VBFlexGridDoubleBufferBmp <> NULL_PTR Then
        DeleteObject VBFlexGridDoubleBufferBmp
        VBFlexGridDoubleBufferBmp = NULL_PTR
    End If
    DeleteDC VBFlexGridDoubleBufferDC
    VBFlexGridDoubleBufferDC = NULL_PTR
End If
Call EraseFlexGridCells
If VBFlexGridFontHandle <> NULL_PTR Then
    DeleteObject VBFlexGridFontHandle
    VBFlexGridFontHandle = NULL_PTR
End If
If VBFlexGridFontFixedHandle <> NULL_PTR Then
    DeleteObject VBFlexGridFontFixedHandle
    VBFlexGridFontFixedHandle = NULL_PTR
End If
If VBFlexGridFontToolTipHandle <> NULL_PTR Then
    DeleteObject VBFlexGridFontToolTipHandle
    VBFlexGridFontToolTipHandle = NULL_PTR
End If
If VBFlexGridBackColorBrush <> NULL_PTR Then
    DeleteObject VBFlexGridBackColorBrush
    VBFlexGridBackColorBrush = NULL_PTR
End If
If VBFlexGridBackColorAltBrush <> NULL_PTR Then
    DeleteObject VBFlexGridBackColorAltBrush
    VBFlexGridBackColorAltBrush = NULL_PTR
End If
If VBFlexGridBackColorBkgBrush <> NULL_PTR Then
    DeleteObject VBFlexGridBackColorBkgBrush
    VBFlexGridBackColorBkgBrush = NULL_PTR
End If
If VBFlexGridBackColorFixedBrush <> NULL_PTR Then
    DeleteObject VBFlexGridBackColorFixedBrush
    VBFlexGridBackColorFixedBrush = NULL_PTR
End If
If VBFlexGridBackColorSelBrush <> NULL_PTR Then
    DeleteObject VBFlexGridBackColorSelBrush
    VBFlexGridBackColorSelBrush = NULL_PTR
End If
If VBFlexGridFocusRectPen <> NULL_PTR Then
    DeleteObject VBFlexGridFocusRectPen
    VBFlexGridFocusRectPen = NULL_PTR
End If
If VBFlexGridGridLinePen <> NULL_PTR Then
    DeleteObject VBFlexGridGridLinePen
    VBFlexGridGridLinePen = NULL_PTR
End If
If VBFlexGridGridLineFixedPen <> NULL_PTR Then
    DeleteObject VBFlexGridGridLineFixedPen
    VBFlexGridGridLineFixedPen = NULL_PTR
End If
If VBFlexGridGridLineFrozenPen <> NULL_PTR Then
    DeleteObject VBFlexGridGridLineFrozenPen
    VBFlexGridGridLineFrozenPen = NULL_PTR
End If
If VBFlexGridGridLineWhitePen <> NULL_PTR Then
    DeleteObject VBFlexGridGridLineWhitePen
    VBFlexGridGridLineWhitePen = NULL_PTR
End If
If VBFlexGridGridLineBlackPen <> NULL_PTR Then
    DeleteObject VBFlexGridGridLineBlackPen
    VBFlexGridGridLineBlackPen = NULL_PTR
End If
If VBFlexGridInsertMarkBrush <> NULL_PTR Then
    DeleteObject VBFlexGridInsertMarkBrush
    VBFlexGridInsertMarkBrush = NULL_PTR
End If
End Sub

Private Sub DestroyToolTip()
If VBFlexGridToolTipHandle = NULL_PTR Then Exit Sub
DestroyWindow VBFlexGridToolTipHandle
VBFlexGridToolTipHandle = NULL_PTR
VBFlexGridToolTipRow = -1
VBFlexGridToolTipCol = -1
VBFlexGridToolTipHitResult = FlexHitResultNoWhere
End Sub

Private Sub DestroyScrollTip()
If VBFlexGridScrollTipHandle = NULL_PTR Then Exit Sub
DestroyWindow VBFlexGridScrollTipHandle
VBFlexGridScrollTipHandle = NULL_PTR
VBFlexGridScrollTipTrack = False
End Sub

Private Function CreateEdit(ByVal Reason As FlexEditReasonConstants, Optional ByVal Row As Long = -1, Optional ByVal Col As Long = -1) As Boolean
Static InProc As Boolean
If VBFlexGridHandle = NULL_PTR Or VBFlexGridEditHandle <> NULL_PTR Or InProc = True Then Exit Function
If VBFlexGridEditRow > -1 And VBFlexGridEditCol > -1 Then Exit Function
If VBFlexGridDesignMode = True Then Exit Function
If Row = -1 Then Row = VBFlexGridRow
If Col = -1 Then Col = VBFlexGridCol
If (Row < 0 Or Row > (PropRows - 1)) Or (Col < 0 Or Col > (PropCols - 1)) Then Exit Function
If IsWindowEnabled(VBFlexGridHandle) = 0 Then Exit Function
InProc = True
Dim Cancel As Boolean
RaiseEvent BeforeEdit(Row, Col, Reason, Cancel)
If Cancel = True Then
    VBFlexGridEditReason = -1
    InProc = False
    Exit Function
Else
    If (Row >= 0 And Row <= (PropRows - 1)) Then VBFlexGridEditRow = Row Else VBFlexGridEditRow = VBFlexGridRow
    If (Col >= 0 And Col <= (PropCols - 1)) Then VBFlexGridEditCol = Col Else VBFlexGridEditCol = VBFlexGridCol
    VBFlexGridEditReason = Reason
    VBFlexGridEditCloseMode = -1
    VBFlexGridComboModeActive = FlexComboModeNone
End If
If PropAllowIncrementalSearch = True Then
    If Not VBFlexGridIncrementalSearch.SearchString = vbNullString Then Call CancelIncrementalSearch
End If
If VBFlexGridCaptureDividerDrag = True Then ReleaseCapture
If VBFlexGridFocused = False Then SetFocusAPI UserControl.hWnd
Dim IsFixedCell As Boolean, Text As String
IsFixedCell = CBool(VBFlexGridEditRow < PropFixedRows Or VBFlexGridEditCol < PropFixedCols)
Call GetCellText(VBFlexGridEditRow, VBFlexGridEditCol, Text)
If VBFlexGridColsInfo(VBFlexGridEditCol).Lookup.Count > 0 Then
    Dim Hash As Long, i As Long
    Hash = CalcHash(Text)
    For i = 0 To (VBFlexGridColsInfo(VBFlexGridEditCol).Lookup.Count - 1)
        If VBFlexGridColsInfo(VBFlexGridEditCol).Lookup.Items(i).Hash = Hash Then
            If StrComp(VBFlexGridColsInfo(VBFlexGridEditCol).Lookup.Items(i).Key, Text, vbTextCompare) = 0 Then
                Text = VBFlexGridColsInfo(VBFlexGridEditCol).Lookup.Items(i).Value
                Exit For
            End If
        End If
    Next i
End If
Dim dwStyle As Long, dwExStyle As Long
dwStyle = WS_CHILD
dwExStyle = 0
If VBFlexGridRTLReading = True Or VBFlexGridRTLLayout = True Then dwExStyle = dwExStyle Or WS_EX_RTLREADING Or WS_EX_LEFTSCROLLBAR
Dim CellFmtg As TCELLFMTG
Call GetCellFmtg(VBFlexGridEditRow, VBFlexGridEditCol, CFM_ALIGNMENT Or CFM_BACKCOLOR Or CFM_FORECOLOR Or CFM_FONT, CellFmtg)
Dim Alignment As FlexAlignmentConstants
With CellFmtg
If .Alignment = -1 Then
    If IsFixedCell = False Then
        Alignment = VBFlexGridColsInfo(VBFlexGridEditCol).Alignment
    Else
        Alignment = VBFlexGridColsInfo(VBFlexGridEditCol).FixedAlignment
    End If
Else
    Alignment = .Alignment
End If
End With
Select Case Alignment
    Case FlexAlignmentLeftTop, FlexAlignmentLeftCenter, FlexAlignmentLeftBottom
        If VBFlexGridRTLLayout = False Then dwStyle = dwStyle Or ES_LEFT Else dwStyle = dwStyle Or ES_RIGHT
    Case FlexAlignmentCenterTop, FlexAlignmentCenterCenter, FlexAlignmentCenterBottom
        dwStyle = dwStyle Or ES_CENTER
    Case FlexAlignmentRightTop, FlexAlignmentRightCenter, FlexAlignmentRightBottom
        If VBFlexGridRTLLayout = False Then dwStyle = dwStyle Or ES_RIGHT Else dwStyle = dwStyle Or ES_LEFT
    Case FlexAlignmentGeneral, FlexAlignmentGeneralTop, FlexAlignmentGeneralCenter, FlexAlignmentGeneralBottom
        If PropMirrorAlignGeneral = False Then
            If Not IsNumeric(Text) And Not IsDate(Text) Then
                If VBFlexGridRTLLayout = False Then dwStyle = dwStyle Or ES_LEFT Else dwStyle = dwStyle Or ES_RIGHT
            Else
                If VBFlexGridRTLLayout = False Then dwStyle = dwStyle Or ES_RIGHT Else dwStyle = dwStyle Or ES_LEFT
            End If
        Else
            If Not IsNumeric(Text) And Not IsDate(Text) Then
                If VBFlexGridRTLLayout = False Then dwStyle = dwStyle Or ES_RIGHT Else dwStyle = dwStyle Or ES_LEFT
            Else
                If VBFlexGridRTLLayout = False Then dwStyle = dwStyle Or ES_LEFT Else dwStyle = dwStyle Or ES_RIGHT
            End If
        End If
End Select
If PropWordWrap = True Or PropSingleLine = False Then
    dwStyle = dwStyle Or ES_MULTILINE Or ES_AUTOVSCROLL
Else
    dwStyle = dwStyle Or ES_AUTOHSCROLL
End If
' Ellipsis format will be ignored.
RaiseEvent EditSetupStyle(dwStyle, dwExStyle)
If (dwStyle And WS_BORDER) = WS_BORDER Then dwStyle = dwStyle And Not WS_BORDER
If (dwStyle And WS_DLGFRAME) = WS_DLGFRAME Then dwStyle = dwStyle And Not WS_DLGFRAME
If (dwExStyle And WS_EX_STATICEDGE) = WS_EX_STATICEDGE Then dwExStyle = dwExStyle And Not WS_EX_STATICEDGE
If (dwExStyle And WS_EX_CLIENTEDGE) = WS_EX_CLIENTEDGE Then dwExStyle = dwExStyle And Not WS_EX_CLIENTEDGE
If (dwExStyle And WS_EX_WINDOWEDGE) = WS_EX_WINDOWEDGE Then dwExStyle = dwExStyle And Not WS_EX_WINDOWEDGE
Dim CellRangeRect As RECT, EditRect As RECT, ComboItems As String, ComboHeader As String, ComboBoundColumn As Long, ComboButtonWidth As Long, ComboButtonAlignment As FlexLeftRightAlignmentConstants
Call GetMergedRangeStruct(VBFlexGridEditRow, VBFlexGridEditCol, VBFlexGridEditMergedRange)
Call GetGridLineOffsetsStruct(VBFlexGridEditRow, VBFlexGridEditCol, VBFlexGridEditGridLineOffsets)
Me.CellEnsureVisible , VBFlexGridEditMergedRange.TopRow, VBFlexGridEditMergedRange.LeftCol
Call GetCellRangeRect(VBFlexGridEditMergedRange, CellRangeRect)
With EditRect
.Left = CellRangeRect.Left + VBFlexGridEditGridLineOffsets.LeftTop.CX
.Top = CellRangeRect.Top + VBFlexGridEditGridLineOffsets.LeftTop.CY
.Right = CellRangeRect.Right - VBFlexGridEditGridLineOffsets.RightBottom.CX
.Bottom = CellRangeRect.Bottom - VBFlexGridEditGridLineOffsets.RightBottom.CY
End With
If VBFlexGridColsInfo(VBFlexGridEditCol).ComboMode <> FlexComboModeNone Then
    VBFlexGridComboModeActive = VBFlexGridColsInfo(VBFlexGridEditCol).ComboMode
    ComboItems = VBFlexGridColsInfo(VBFlexGridEditCol).ComboItems
    ComboHeader = VBFlexGridColsInfo(VBFlexGridEditCol).ComboHeader
    ComboBoundColumn = VBFlexGridColsInfo(VBFlexGridEditCol).ComboBoundColumn
ElseIf VBFlexGridComboMode <> FlexComboModeNone Then
    VBFlexGridComboModeActive = VBFlexGridComboMode
    ComboItems = VBFlexGridComboItems
    ComboHeader = VBFlexGridComboHeader
    ComboBoundColumn = VBFlexGridComboBoundColumn
End If
If VBFlexGridComboModeActive <> FlexComboModeNone Then
    ComboButtonWidth = GetComboButtonWidth(VBFlexGridEditRow, VBFlexGridEditCol, FlexComboCueNone)
    If VBFlexGridColsInfo(VBFlexGridEditCol).ComboButtonAlignment = -1 Then
        ComboButtonAlignment = VBFlexGridComboButtonAlignment
    Else
        ComboButtonAlignment = VBFlexGridColsInfo(VBFlexGridEditCol).ComboButtonAlignment
    End If
    If ComboButtonAlignment = FlexLeftRightAlignmentRight Then
        EditRect.Right = EditRect.Right - ComboButtonWidth
        If EditRect.Right < EditRect.Left Then EditRect.Right = EditRect.Left
    ElseIf ComboButtonAlignment = FlexLeftRightAlignmentLeft Then
        EditRect.Left = EditRect.Left + ComboButtonWidth
        If EditRect.Left > EditRect.Right Then EditRect.Left = EditRect.Right
    End If
    If (((CellRangeRect.Right - CellRangeRect.Left) - (VBFlexGridEditGridLineOffsets.LeftTop.CX + VBFlexGridEditGridLineOffsets.RightBottom.CX)) - ComboButtonWidth) < 0 Then ComboButtonWidth = ((CellRangeRect.Right - CellRangeRect.Left) - (VBFlexGridEditGridLineOffsets.LeftTop.CX + VBFlexGridEditGridLineOffsets.RightBottom.CX))
    Select Case VBFlexGridComboModeActive
        Case FlexComboModeDropDown
            If Not (dwStyle And ES_READONLY) = ES_READONLY Then dwStyle = dwStyle Or ES_READONLY
        Case FlexComboModeEditable
            If (dwStyle And ES_READONLY) = ES_READONLY Then dwStyle = dwStyle And Not ES_READONLY
    End Select
End If
VBFlexGridEditHandle = CreateWindowEx(dwExStyle, StrPtr("Edit"), NULL_PTR, dwStyle, EditRect.Left, EditRect.Top, (EditRect.Right - EditRect.Left), (EditRect.Bottom - EditRect.Top), VBFlexGridHandle, ID_EDITCHILD, App.hInstance, ByVal NULL_PTR)
If VBFlexGridEditHandle <> NULL_PTR Then
    With CellFmtg
    Dim hFont As LongPtr
    If .FontName = vbNullString Then
        If IsFixedCell = False Then
            hFont = VBFlexGridFontHandle
        Else
            If VBFlexGridFontFixedHandle = NULL_PTR Then
                hFont = VBFlexGridFontHandle
            Else
                hFont = VBFlexGridFontFixedHandle
            End If
        End If
    Else
        Dim TempFont As StdFont
        Set TempFont = New StdFont
        TempFont.Name = .FontName
        TempFont.Size = .FontSize
        TempFont.Bold = CBool((.FontStyle And FS_BOLD) = FS_BOLD)
        TempFont.Italic = CBool((.FontStyle And FS_ITALIC) = FS_ITALIC)
        TempFont.Strikethrough = CBool((.FontStyle And FS_STRIKEOUT) = FS_STRIKEOUT)
        TempFont.Underline = CBool((.FontStyle And FS_UNDERLINE) = FS_UNDERLINE)
        TempFont.Charset = .FontCharset
        VBFlexGridEditTempFontHandle = CreateGDIFontFromOLEFont(TempFont, PropFontQuality)
        hFont = VBFlexGridEditTempFontHandle
        Set TempFont = Nothing
    End If
    If .BackColor = -1 Then
        If IsFixedCell = False Then
            If PropBackColor = PropBackColorAlt Then
                VBFlexGridEditBackColor = PropBackColor
            Else
                If (VBFlexGridEditRow - PropFixedRows) Mod 2 = 0 Then
                    VBFlexGridEditBackColor = PropBackColor
                Else
                    VBFlexGridEditBackColor = PropBackColorAlt
                End If
            End If
        Else
            VBFlexGridEditBackColor = PropBackColorFixed
        End If
    Else
        VBFlexGridEditBackColor = .BackColor
    End If
    If .ForeColor = -1 Then
        If IsFixedCell = False Then
            VBFlexGridEditForeColor = PropForeColor
        Else
            VBFlexGridEditForeColor = PropForeColorFixed
        End If
    Else
        VBFlexGridEditForeColor = .ForeColor
    End If
    End With
    SendMessage VBFlexGridEditHandle, WM_SETFONT, hFont, ByVal 0&
    Dim TextIndent As TTEXTINDENT
    If (VBFlexGridColsInfo(VBFlexGridEditCol).State And CLIS_TEXTINDENT) = CLIS_TEXTINDENT Then
        With TextIndent
        RaiseEvent CellTextIndent(VBFlexGridEditRow, VBFlexGridEditCol, .Left, .Right)
        If .Left > 0 Then .Left = UserControl.ScaleX(.Left, vbTwips, vbPixels) Else .Left = 0
        If .Right > 0 Then .Right = UserControl.ScaleX(.Right, vbTwips, vbPixels) Else .Right = 0
        End With
    End If
    If VBFlexGridRTLLayout = False Then
        SendMessage VBFlexGridEditHandle, EM_SETMARGINS, EC_LEFTMARGIN Or EC_RIGHTMARGIN, ByVal MakeDWord(VBFlexGridPixelMetrics.TextPadding.CX + TextIndent.Left - VBFlexGridEditGridLineOffsets.LeftTop.CX, VBFlexGridPixelMetrics.TextPadding.CX + TextIndent.Right - VBFlexGridEditGridLineOffsets.RightBottom.CX)
    Else
        SendMessage VBFlexGridEditHandle, EM_SETMARGINS, EC_LEFTMARGIN Or EC_RIGHTMARGIN, ByVal MakeDWord(VBFlexGridPixelMetrics.TextPadding.CX + TextIndent.Right - VBFlexGridEditGridLineOffsets.RightBottom.CX, VBFlexGridPixelMetrics.TextPadding.CX + TextIndent.Left - VBFlexGridEditGridLineOffsets.LeftTop.CX)
    End If
    SendMessage VBFlexGridEditHandle, WM_SETTEXT, 0, ByVal StrPtr(Text)
    VBFlexGridEditTextChanged = False
    VBFlexGridEditAlreadyValidated = False
    SendMessage VBFlexGridEditHandle, EM_SETSEL, 0, ByVal -1&
    If Not (dwStyle And ES_READONLY) = ES_READONLY Then
        Select Case Reason
            Case FlexEditReasonSpace, FlexEditReasonReturn
                SendMessage VBFlexGridEditHandle, EM_SETSEL, -1, ByVal -1&
            Case FlexEditReasonBackSpace
                SendMessage VBFlexGridEditHandle, EM_REPLACESEL, 1, ByVal StrPtr("")
        End Select
    End If
    If ComboButtonWidth > 0 Then
        dwStyle = WS_CHILD Or SS_OWNERDRAW Or SS_NOTIFY
        dwExStyle = 0
        If VBFlexGridRTLReading = True Then dwExStyle = dwExStyle Or WS_EX_RTLREADING
        If VBFlexGridRTLLayout = True Then dwExStyle = dwExStyle Or WS_EX_LAYOUTRTL
        If ComboButtonAlignment = FlexLeftRightAlignmentRight Then
            VBFlexGridComboButtonHandle = CreateWindowEx(dwExStyle, StrPtr("Static"), NULL_PTR, dwStyle, EditRect.Right, EditRect.Top, ComboButtonWidth, (EditRect.Bottom - EditRect.Top), VBFlexGridHandle, ID_COMBOBUTTONCHILD, App.hInstance, ByVal NULL_PTR)
        ElseIf ComboButtonAlignment = FlexLeftRightAlignmentLeft Then
            VBFlexGridComboButtonHandle = CreateWindowEx(dwExStyle, StrPtr("Static"), NULL_PTR, dwStyle, EditRect.Left - ComboButtonWidth, EditRect.Top, ComboButtonWidth, (EditRect.Bottom - EditRect.Top), VBFlexGridHandle, ID_COMBOBUTTONCHILD, App.hInstance, ByVal NULL_PTR)
        End If
        If VBFlexGridComboButtonHandle <> NULL_PTR Then
            Dim WndRect As RECT
            Select Case VBFlexGridComboModeActive
                Case FlexComboModeDropDown, FlexComboModeEditable
                    dwStyle = WS_POPUP Or WS_BORDER Or LBS_NOTIFY Or LBS_SORT Or WS_VSCROLL Or WS_HSCROLL
                    If InStr(ComboItems, vbTab) > 0 Then dwStyle = dwStyle Or LBS_OWNERDRAWFIXED Or LBS_HASSTRINGS Or LBS_NOINTEGRALHEIGHT
                    dwExStyle = WS_EX_TOOLWINDOW Or WS_EX_TOPMOST
                    If ComboButtonAlignment = FlexLeftRightAlignmentLeft Then dwExStyle = dwExStyle Or WS_EX_RIGHT Or WS_EX_LEFTSCROLLBAR
                    If VBFlexGridRTLReading = True Then dwExStyle = dwExStyle Or WS_EX_RTLREADING
                    If VBFlexGridRTLLayout = True Then dwExStyle = dwExStyle Or WS_EX_LAYOUTRTL
                    SetRect VBFlexGridComboBoxRect, CellRangeRect.Left, CellRangeRect.Top, CellRangeRect.Right, CellRangeRect.Bottom
                    LSet WndRect = VBFlexGridComboBoxRect
                    MapWindowPoints VBFlexGridHandle, HWND_DESKTOP, WndRect, 2
                    VBFlexGridComboListHandle = CreateWindowEx(dwExStyle, StrPtr("ComboLBox"), NULL_PTR, dwStyle, WndRect.Left, WndRect.Bottom, WndRect.Right - WndRect.Left, WndRect.Bottom - WndRect.Top, VBFlexGridHandle, NULL_PTR, App.hInstance, ByVal NULL_PTR)
                    If VBFlexGridComboListHandle <> NULL_PTR Then
                        SendMessage VBFlexGridComboListHandle, WM_SETFONT, hFont, ByVal 0&
                        If VBFlexGridComboModeActive = FlexComboModeDropDown Then SendMessage VBFlexGridComboListHandle, LB_CARETON, 0, ByVal 0&
                        Dim hDC As LongPtr, Size As SIZEAPI, CX As Long
                        hDC = GetDC(VBFlexGridComboListHandle)
                        SelectObject hDC, hFont
                        If (dwStyle And LBS_OWNERDRAWFIXED) = LBS_OWNERDRAWFIXED Then
                            Dim TM As TEXTMETRIC
                            If GetTextMetrics(hDC, TM) <> 0 Then SendMessage VBFlexGridComboListHandle, LB_SETITEMHEIGHT, 0, ByVal TM.TMHeight
                        End If
                        If StrPtr(ComboItems) <> NULL_PTR Then
                            Dim Pos1 As Long, Pos2 As Long, Temp As String, Index As Long
                            If Not (dwStyle And LBS_OWNERDRAWFIXED) = LBS_OWNERDRAWFIXED Then
                                Do
                                    Pos1 = InStr(Pos1 + 1, ComboItems, "|")
                                    If Pos1 > 0 Then
                                        Temp = Mid$(ComboItems, Pos2 + 1, Pos1 - Pos2 - 1)
                                    Else
                                        Temp = Mid$(ComboItems, Pos2 + 1)
                                    End If
                                    SendMessage VBFlexGridComboListHandle, LB_INSERTSTRING, Index, ByVal StrPtr(Temp)
                                    GetTextExtentPoint32 hDC, ByVal StrPtr(Temp), Len(Temp), Size
                                    If Size.CX > CX Then CX = Size.CX
                                    Pos2 = Pos1
                                    Index = Index + 1
                                Loop Until Pos1 = 0
                            Else
                                With VBFlexGridComboMultiColumn
                                .BoundColumn = ComboBoundColumn
                                Dim Pos3 As Long, Pos4 As Long, Column As String, iCol As Long
                                Do
                                    Pos1 = InStr(Pos1 + 1, ComboItems, "|")
                                    If Pos1 > 0 Then
                                        Temp = Mid$(ComboItems, Pos2 + 1, Pos1 - Pos2 - 1)
                                    Else
                                        Temp = Mid$(ComboItems, Pos2 + 1)
                                    End If
                                    ReDim Preserve .Items(0 To Index) As TCOMBOMULTICOLUMNITEM
                                    Do
                                        Pos3 = InStr(Pos3 + 1, Temp, vbTab)
                                        If Pos3 > 0 Then
                                            Column = Mid$(Temp, Pos4 + 1, Pos3 - Pos4 - 1)
                                        Else
                                            Column = Mid$(Temp, Pos4 + 1)
                                        End If
                                        If (iCol + 1) > .MaxCount Then
                                            .MaxCount = iCol + 1
                                            ReDim Preserve .MaxWidths(0 To (.MaxCount - 1)) As Long
                                        End If
                                        With .Items(Index)
                                        If (iCol + 1) > .Count Then
                                            .Count = iCol + 1
                                            ReDim Preserve .Column(0 To (.Count - 1)) As String
                                            .Column(iCol) = Column
                                        End If
                                        End With
                                        If iCol = .BoundColumn Then SendMessage VBFlexGridComboListHandle, LB_INSERTSTRING, Index, ByVal StrPtr(Column)
                                        GetTextExtentPoint32 hDC, ByVal StrPtr(Column), Len(Column), Size
                                        If Size.CX > .MaxWidths(iCol) Then .MaxWidths(iCol) = Size.CX
                                        Pos4 = Pos3
                                        iCol = iCol + 1
                                    Loop Until Pos3 = 0
                                    If iCol <= .BoundColumn Then SendMessage VBFlexGridComboListHandle, LB_INSERTSTRING, Index, ByVal StrPtr("")
                                    Pos2 = Pos1
                                    Pos4 = 0
                                    Index = Index + 1
                                    iCol = 0
                                Loop Until Pos1 = 0
                                If Not ComboHeader = vbNullString Then
                                    Do
                                        Pos1 = InStr(Pos1 + 1, ComboHeader, vbTab)
                                        If Pos1 > 0 Then
                                            Column = Mid$(ComboHeader, Pos2 + 1, Pos1 - Pos2 - 1)
                                        Else
                                            Column = Mid$(ComboHeader, Pos2 + 1)
                                        End If
                                        If (iCol + 1) > .MaxCount Then
                                            .MaxCount = iCol + 1
                                            ReDim Preserve .MaxWidths(0 To (.MaxCount - 1)) As Long
                                        End If
                                        With .Header
                                        If (iCol + 1) > .Count Then
                                            .Count = iCol + 1
                                            ReDim Preserve .Column(0 To (.Count - 1)) As String
                                            .Column(iCol) = Column
                                        End If
                                        End With
                                        GetTextExtentPoint32 hDC, ByVal StrPtr(Column), Len(Column), Size
                                        If Size.CX > .MaxWidths(iCol) Then .MaxWidths(iCol) = Size.CX
                                        Pos2 = Pos1
                                        iCol = iCol + 1
                                    Loop Until Pos1 = 0
                                End If
                                For iCol = 0 To (.MaxCount - 1)
                                    If iCol > 0 Then CX = CX + 5
                                    CX = CX + .MaxWidths(iCol)
                                Next iCol
                                End With
                            End If
                        End If
                        ReleaseDC VBFlexGridComboListHandle, hDC
                        Const EDIT_MAXDROPDOWNITEMS As Integer = 9
                        Dim Count As Long, Height As Long
                        Count = CLng(SendMessage(VBFlexGridComboListHandle, LB_GETCOUNT, 0, ByVal 0&))
                        Select Case Count
                            Case 0
                                Count = 1
                            Case Is > EDIT_MAXDROPDOWNITEMS
                                Count = EDIT_MAXDROPDOWNITEMS
                                CX = CX + GetSystemMetrics(SM_CXVSCROLL)
                        End Select
                        If VBFlexGridComboMultiColumn.Header.Count = 0 Then
                            Height = CLng(SendMessage(VBFlexGridComboListHandle, LB_GETITEMHEIGHT, 0, ByVal 0&)) * Count
                        Else
                            Height = (CLng(SendMessage(VBFlexGridComboListHandle, LB_GETITEMHEIGHT, 0, ByVal 0&)) * (Count + 1)) + 1
                        End If
                        If (CX + 6) > (WndRect.Right - WndRect.Left) Then WndRect.Right = WndRect.Left + (CX + 6)
                        MoveWindow VBFlexGridComboListHandle, WndRect.Left, WndRect.Bottom, WndRect.Right - WndRect.Left, Height + 2, 0
                    End If
                Case FlexComboModeCalendar
                    If VBFlexGridComboCalendarRegistered = False Then
                        Call FlexInitCC(ICC_DATE_CLASSES)
                        Call FlexComboCalendarRegisterClass
                        VBFlexGridComboCalendarRegistered = True
                    End If
                    dwStyle = WS_POPUP Or WS_BORDER
                    dwExStyle = WS_EX_TOOLWINDOW Or WS_EX_TOPMOST
                    If VBFlexGridRTLReading = True Then dwExStyle = dwExStyle Or WS_EX_RTLREADING
                    If VBFlexGridRTLLayout = True Then dwExStyle = dwExStyle Or WS_EX_LAYOUTRTL
                    SetRect VBFlexGridComboBoxRect, CellRangeRect.Left, CellRangeRect.Top, CellRangeRect.Right, CellRangeRect.Bottom
                    VBFlexGridComboCalendarHandle = CreateWindowEx(dwExStyle, StrPtr("VBFlexGridComboCalendarClass"), NULL_PTR, dwStyle, 0, 0, 0, 0, VBFlexGridHandle, NULL_PTR, App.hInstance, ByVal NULL_PTR)
                    If VBFlexGridComboCalendarHandle <> NULL_PTR Then
                        SendMessage VBFlexGridComboCalendarHandle, WM_SETFONT, hFont, ByVal 0&
                        SendMessage VBFlexGridComboCalendarHandle, MCM_SETCALENDARBORDER, 1, ByVal 0&
                        Dim ST(0 To 1) As SYSTEMTIME
                        ST(0).wYear = 1900
                        ST(0).wMonth = 1
                        ST(0).wDay = 1
                        ST(1).wYear = 9999
                        ST(1).wMonth = 12
                        ST(1).wDay = 31
                        SendMessage VBFlexGridComboCalendarHandle, MCM_SETRANGE, GDTR_MIN Or GDTR_MAX, ByVal VarPtr(ST(0))
                        If IsDate(Text) Then Me.ComboCalendarValue = CDate(Text)
                    End If
            End Select
        End If
    End If
    If VBFlexGridEnabledVisualStyles = True Then
        If PropVisualStyles = True Then
            ActivateVisualStyles VBFlexGridEditHandle
            If VBFlexGridComboButtonHandle <> NULL_PTR Then ActivateVisualStyles VBFlexGridComboButtonHandle
            If VBFlexGridComboListHandle <> NULL_PTR Then ActivateVisualStyles VBFlexGridComboListHandle
            If VBFlexGridComboCalendarHandle <> NULL_PTR Then ActivateVisualStyles VBFlexGridComboCalendarHandle
        Else
            RemoveVisualStyles VBFlexGridEditHandle
            If VBFlexGridComboButtonHandle <> NULL_PTR Then RemoveVisualStyles VBFlexGridComboButtonHandle
            If VBFlexGridComboListHandle <> NULL_PTR Then RemoveVisualStyles VBFlexGridComboListHandle
            If VBFlexGridComboCalendarHandle <> NULL_PTR Then RemoveVisualStyles VBFlexGridComboCalendarHandle
        End If
    End If
    If VBFlexGridComboCalendarHandle <> NULL_PTR Then
        Dim ReqRect As RECT
        SendMessage VBFlexGridComboCalendarHandle, MCM_GETMINREQRECT, 0, ByVal VarPtr(ReqRect)
        Dim TodayWidth As Long
        TodayWidth = CLng(SendMessage(VBFlexGridComboCalendarHandle, MCM_GETMAXTODAYWIDTH, 0, ByVal 0&))
        If TodayWidth > (ReqRect.Right - ReqRect.Left) Then ReqRect.Right = ReqRect.Left + TodayWidth
        LSet WndRect = VBFlexGridComboBoxRect
        MapWindowPoints VBFlexGridHandle, HWND_DESKTOP, WndRect, 2
        If ComboButtonAlignment = FlexLeftRightAlignmentRight Then
            MoveWindow VBFlexGridComboCalendarHandle, WndRect.Left, WndRect.Bottom, (ReqRect.Right - ReqRect.Left), (ReqRect.Bottom - ReqRect.Top), 0
        ElseIf ComboButtonAlignment = FlexLeftRightAlignmentLeft Then
            MoveWindow VBFlexGridComboCalendarHandle, WndRect.Right - (ReqRect.Right - ReqRect.Left), WndRect.Bottom, (ReqRect.Right - ReqRect.Left), (ReqRect.Bottom - ReqRect.Top), 0
        End If
    End If
    Call FlexSetSubclass(VBFlexGridEditHandle, Me, 2)
    If VBFlexGridComboButtonHandle <> NULL_PTR Then Call FlexSetSubclass(VBFlexGridComboButtonHandle, Me, 3)
    If VBFlexGridComboListHandle <> NULL_PTR Then Call FlexSetSubclass(VBFlexGridComboListHandle, Me, 4)
    If VBFlexGridComboCalendarHandle <> NULL_PTR Then Call FlexSetSubclass(VBFlexGridComboCalendarHandle, Me, 5)
    SetWindowPos VBFlexGridEditHandle, NULL_PTR, 0, 0, 0, 0, SWP_NOMOVE Or SWP_NOSIZE Or SWP_NOOWNERZORDER Or SWP_NOZORDER Or SWP_FRAMECHANGED
    If VBFlexGridComboListHandle <> NULL_PTR Then
        If VBFlexGridComboMultiColumn.Header.Count > 0 Then SetWindowPos VBFlexGridComboListHandle, NULL_PTR, 0, 0, 0, 0, SWP_NOMOVE Or SWP_NOSIZE Or SWP_NOOWNERZORDER Or SWP_NOZORDER Or SWP_NOACTIVATE Or SWP_FRAMECHANGED
        SendMessage VBFlexGridComboListHandle, LB_SETCURSEL, SendMessage(VBFlexGridComboListHandle, LB_FINDSTRINGEXACT, -1, ByVal StrPtr(Text)), ByVal 0&
    End If
    RaiseEvent EditSetupWindow(VBFlexGridEditBackColor, VBFlexGridEditForeColor)
    VBFlexGridEditBackColorBrush = CreateSolidBrush(WinColor(VBFlexGridEditBackColor))
    ShowWindow VBFlexGridEditHandle, SW_SHOW
    SetFocusAPI VBFlexGridEditHandle
    If VBFlexGridComboButtonHandle <> NULL_PTR Then
        ShowWindow VBFlexGridComboButtonHandle, SW_SHOW
        Select Case Reason
            Case FlexEditReasonComboCueClick, FlexEditReasonComboCueDblClick, FlexEditReasonComboCueF4, FlexEditReasonComboCueAltUpDown
                If VBFlexGridComboListHandle <> NULL_PTR Or VBFlexGridComboCalendarHandle <> NULL_PTR Then
                    Call ComboShowDropDown(True, FlexComboDropDownReasonInitialize)
                Else
                    Call ComboButtonPerformClick
                End If
            Case Else
                If VBFlexGridComboListHandle <> NULL_PTR Then
                    If VBFlexGridComboModeActive = FlexComboModeDropDown Then Call ComboShowDropDown(True, FlexComboDropDownReasonInitialize)
                ElseIf VBFlexGridComboCalendarHandle <> NULL_PTR Then
                    If (GetWindowLong(VBFlexGridEditHandle, GWL_STYLE) And ES_READONLY) <> 0 Then
                        Call ComboShowDropDown(True, FlexComboDropDownReasonInitialize)
                    End If
                End If
        End Select
    End If
    RaiseEvent EnterEdit
    CreateEdit = True
End If
InProc = False
End Function

Private Function DestroyEdit(ByVal Discard As Boolean, ByVal CloseMode As FlexEditCloseModeConstants) As Boolean
Static InProc As Boolean
If VBFlexGridEditHandle = NULL_PTR Or InProc = True Then Exit Function
Dim Cancel As Boolean
If CloseMode <> FlexEditCloseModeLostFocus Then
    RaiseEvent EditQueryClose(CloseMode, Cancel)
    If Cancel = True Then Exit Function
Else
    If VBFlexGridEditOnValidate = True Or VBFlexGridEditNoLostFocus = True Then Exit Function
End If
If Discard = False And VBFlexGridEditTextChanged = True Then
    If VBFlexGridEditAlreadyValidated = False Then
        VBFlexGridEditOnValidate = True
        RaiseEvent ValidateEdit(Cancel)
        VBFlexGridEditOnValidate = False
        If VBFlexGridEditHandle = NULL_PTR Then
            DestroyEdit = True
            Exit Function
        End If
    Else
        VBFlexGridEditAlreadyValidated = False
    End If
    If Cancel = False Then
        Dim Text As String, iRow As Long, iCol As Long
        Text = Me.EditText
        If VBFlexGridColsInfo(VBFlexGridEditCol).Lookup.Count > 0 Then
            Dim i As Long
            For i = 0 To (VBFlexGridColsInfo(VBFlexGridEditCol).Lookup.Count - 1)
                If StrComp(VBFlexGridColsInfo(VBFlexGridEditCol).Lookup.Items(i).Value, Text) = 0 Then
                    Text = VBFlexGridColsInfo(VBFlexGridEditCol).Lookup.Items(i).Key
                    Exit For
                End If
            Next i
        End If
        If PropUndoLimit > 0 Then
            Dim UndoRedoEntry As TUNDOREDOENTRY
            With UndoRedoEntry
            Call GetCellText(VBFlexGridEditRow, VBFlexGridEditCol, .OldString)
            .NewString = Text
            .Clip = False
            .ClearClip = False
            .Row = VBFlexGridEditRow
            .Col = VBFlexGridEditCol
            .RowSel = -1
            .ColSel = -1
            LSet .MergedRange = VBFlexGridEditMergedRange
            End With
            Call AddUndo(UndoRedoEntry)
            Call ResetRedo
        End If
        With VBFlexGridEditMergedRange
        For iRow = .TopRow To .BottomRow
            For iCol = .LeftCol To .RightCol
                Call SetCellText(iRow, iCol, Text)
            Next iCol
        Next iRow
        End With
        Call RedrawGrid
    Else
        InProc = False
        Exit Function
    End If
Else
    VBFlexGridEditAlreadyValidated = False
End If
InProc = True
VBFlexGridEditCloseMode = CloseMode
RaiseEvent LeaveEdit
Dim Row As Long, Col As Long
' It is necessary to preserve the edit row and col from here on.
' When the edit control has been destroyed it could be started again resulting that the edit row and col will be overwritten.
Row = VBFlexGridEditRow
Col = VBFlexGridEditCol
If VBFlexGridComboButtonHandle <> NULL_PTR Then
    Call FlexRemoveSubclass(VBFlexGridComboButtonHandle)
    ShowWindow VBFlexGridComboButtonHandle, SW_HIDE
    SetParent VBFlexGridComboButtonHandle, NULL_PTR
    DestroyWindow VBFlexGridComboButtonHandle
End If
If VBFlexGridComboListHandle <> NULL_PTR Then
    Call FlexRemoveSubclass(VBFlexGridComboListHandle)
    DestroyWindow VBFlexGridComboListHandle
End If
If VBFlexGridComboCalendarHandle <> NULL_PTR Then
    Call FlexRemoveSubclass(VBFlexGridComboCalendarHandle)
    DestroyWindow VBFlexGridComboCalendarHandle
End If
Call FlexRemoveSubclass(VBFlexGridEditHandle)
Dim hWndTemp As LongPtr
' Temporary cache is necessary as the variable needs to be cleared for internal control before the edit window is destroyed.
hWndTemp = VBFlexGridEditHandle
VBFlexGridEditHandle = NULL_PTR
ShowWindow hWndTemp, SW_HIDE
SetParent hWndTemp, NULL_PTR
DestroyWindow hWndTemp
hWndTemp = NULL_PTR
VBFlexGridComboButtonHandle = NULL_PTR
VBFlexGridComboListHandle = NULL_PTR
VBFlexGridComboCalendarHandle = NULL_PTR
VBFlexGridEditRectChanged = False
If VBFlexGridEditTempFontHandle <> NULL_PTR Then
    DeleteObject VBFlexGridEditTempFontHandle
    VBFlexGridEditTempFontHandle = NULL_PTR
End If
If VBFlexGridEditBackColorBrush <> NULL_PTR Then
    DeleteObject VBFlexGridEditBackColorBrush
    VBFlexGridEditBackColorBrush = NULL_PTR
End If
VBFlexGridEditRow = -1
VBFlexGridEditCol = -1
VBFlexGridComboModeActive = FlexComboModeNone
With VBFlexGridComboMultiColumn
If .MaxCount > 0 Then
    .MaxCount = 0
    Erase .MaxWidths()
    Erase .Items()
    .Header.Count = 0
    Erase .Header.Column()
    .BoundColumn = 0
End If
End With
If Discard = False And VBFlexGridEditTextChanged = True Then
    RaiseEvent AfterEdit(Row, Col, True)
Else
    RaiseEvent AfterEdit(Row, Col, False)
End If
DestroyEdit = True
InProc = False
End Function

Public Sub Refresh()
Attribute Refresh.VB_Description = "Forces a complete repaint of a object."
Attribute Refresh.VB_UserMemId = -550
UserControl.Refresh
If VBFlexGridNoRedraw = False And VBFlexGridDesignMode = False Then RedrawWindow UserControl.hWnd, NULL_PTR, NULL_PTR, RDW_UPDATENOW Or RDW_INVALIDATE Or RDW_ERASE Or RDW_ALLCHILDREN
If VBFlexGridEditRow > -1 And VBFlexGridEditCol > -1 Then Call UpdateEditRect
End Sub

#If ImplementDataSource = True Or ImplementFlexDataSource = True Then

Public Sub DataRefresh()
Attribute DataRefresh.VB_Description = "Forces the control to re-fetch all data from its data source."

#If ImplementDataSource = True Then

If Not PropDataSource Is Nothing Then Set Me.DataSource = PropDataSource

#End If

#If ImplementFlexDataSource = True Then

If Not VBFlexGridFlexDataSource Is Nothing Then Set Me.FlexDataSource = VBFlexGridFlexDataSource

#End If

End Sub

#End If

#If ImplementFlexDataSource = True Then

Public Property Get FlexDataSource() As IVBFlexDataSource
Attribute FlexDataSource.VB_Description = "Returns/sets a custom data source for the control."
Attribute FlexDataSource.VB_MemberFlags = "400"
Set FlexDataSource = VBFlexGridFlexDataSource
End Property

Public Property Let FlexDataSource(ByVal Value As IVBFlexDataSource)
Set Me.FlexDataSource = Value
End Property

Public Property Set FlexDataSource(ByVal Value As IVBFlexDataSource)
Set VBFlexGridFlexDataSource = Value
If Not VBFlexGridFlexDataSource Is Nothing Then
    If TypeOf VBFlexGridFlexDataSource Is IVBFlexDataSource2 Then
        Set VBFlexGridFlexDataSource2 = VBFlexGridFlexDataSource
        VBFlexGridFlexDataSourceFlags = VBFlexGridFlexDataSource2.GetFlags()
    Else
        Set VBFlexGridFlexDataSource2 = Nothing
        VBFlexGridFlexDataSourceFlags = 0
    End If
    With VBFlexGridFlexDataSource
    Dim FieldCount As Long, RecordCount As Long, iRow As Long, iCol As Long
    FieldCount = .GetFieldCount
    If FieldCount > 0 Then
        If (VBFlexGridFlexDataSourceFlags And FlexDataSourceUnboundFixedColumns) = 0 Then
            Me.Cols = FieldCount
        Else
            Me.Cols = PropFixedCols + FieldCount
        End If
        If PropFixedRows > 0 Then
            Dim FieldName As String
            If (VBFlexGridFlexDataSourceFlags And FlexDataSourceUnboundFixedColumns) = 0 Then
                If (VBFlexGridFlexDataSourceFlags And FlexDataSourceNoFieldNames) = 0 Then
                    For iCol = 0 To (FieldCount - 1)
                        FieldName = .GetFieldName(iCol)
                        Me.TextMatrix(0, iCol) = FieldName
                        VBFlexGridColsInfo(iCol).Key = FieldName
                    Next iCol
                End If
            Else
                For iCol = 0 To (PropFixedCols - 1)
                    VBFlexGridColsInfo(iCol).Key = vbNullString
                Next iCol
                If (VBFlexGridFlexDataSourceFlags And FlexDataSourceNoFieldNames) = 0 Then
                    For iCol = 0 To (FieldCount - 1)
                        FieldName = .GetFieldName(iCol)
                        Me.TextMatrix(0, iCol + PropFixedCols) = FieldName
                        VBFlexGridColsInfo(iCol + PropFixedCols).Key = FieldName
                    Next iCol
                End If
            End If
        End If
        RecordCount = .GetRecordCount
        If RecordCount > 0 Then
            Me.Rows = PropFixedRows + RecordCount
        Else
            Me.Rows = PropFixedRows + 1
        End If
    End If
    End With
Else
    Set VBFlexGridFlexDataSource2 = Nothing
    VBFlexGridFlexDataSourceFlags = 0
    Call RedrawGrid
End If
End Property

#End If

Public Function CopyFromRecordset(ByRef Data As Object, Optional ByVal Rows As Long = -1, Optional ByVal Cols As Long = -1, Optional ByVal Row As Long = -1, Optional ByVal Col As Long = -1) As Long
Attribute CopyFromRecordset.VB_Description = "Copies the contents of an ADO or DAO Recordset onto the flex grid."
If Data Is Nothing Then Err.Raise 5
If Not TypeName(Data) = "Recordset" Then Err.Raise 430
If Rows < -1 Then Err.Raise 380
If Cols < -1 Then Err.Raise 380
If Row < -1 Then Err.Raise 380
If Col < -1 Then Err.Raise 380
If Row = -1 Then Row = PropFixedRows
If Col = -1 Then Col = PropFixedCols
If (Row < 0 Or Row > (PropRows - 1)) Or (Col < 0 Or Col > (PropCols - 1)) Then Err.Raise Number:=381, Description:="Subscript out of range"
If Rows = -1 Then Rows = PropRows - Row
If Cols = -1 Then Cols = PropCols - Col
If Data.RecordCount > 0 And Rows > 0 And Cols > 0 Then
    If Rows > (PropRows - Row) Then Rows = PropRows - Row
    If Cols > (PropCols - Col) Then Cols = PropCols - Col
    Dim ArrRows As Variant
    ArrRows = Data.GetRows(Rows)
    Dim LBoundCols As Long, UBoundCols As Long
    LBoundCols = LBound(ArrRows, 1)
    UBoundCols = UBound(ArrRows, 1)
    Dim LBoundRows As Long, UBoundRows As Long
    LBoundRows = LBound(ArrRows, 2)
    UBoundRows = UBound(ArrRows, 2)
    Dim iRow As Long, iCol As Long
    If (Col + (UBoundCols - LBoundCols)) > (Cols - 1) Then UBoundCols = LBoundCols + (Cols - 1)
    For iRow = LBoundRows To UBoundRows
        For iCol = LBoundCols To UBoundCols
            If Not IsNull(ArrRows(iCol, iRow)) Then
                Call SetCellText((iRow + (0 - LBoundRows)) + Row, (iCol + (0 - LBoundCols)) + Col, (ArrRows(iCol, iRow)))
            Else
                Call SetCellText((iRow + (0 - LBoundRows)) + Row, (iCol + (0 - LBoundCols)) + Col, vbNullString)
            End If
        Next iCol
    Next iRow
    Call RedrawGrid
    CopyFromRecordset = (UBoundRows - LBoundRows) + 1
End If
End Function

Public Function LoadArray(ByRef Data As Variant, Optional ByVal RowDim As Long = 2, Optional ByVal ColDim As Long = 1, Optional ByVal PageDim As Long = 0, Optional ByVal CurrentPage As Long, Optional ByVal Rows As Long = -1, Optional ByVal Cols As Long = -1, Optional ByVal Row As Long = -1, Optional ByVal Col As Long = -1, Optional ByVal RestrictRows As Boolean, Optional ByVal RestrictColumns As Boolean) As Long
Attribute LoadArray.VB_Description = "Loads the flex grid control with data from a variant or string array."
If IsEmpty(Data) Then Exit Function
If Rows < -1 Then Err.Raise 380
If Cols < -1 Then Err.Raise 380
If Row < -1 Then Err.Raise 380
If Col < -1 Then Err.Raise 380
If Row = -1 Then Row = PropFixedRows
If Col = -1 Then Col = PropFixedCols
If (Row < 0 Or Row > (PropRows - 1)) Or (Col < 0 Or Col > (PropCols - 1)) Then Err.Raise Number:=381, Description:="Subscript out of range"
If IsArray(Data) Then
    Dim LBoundRows As Long, UBoundRows As Long, LBoundCols As Long, UBoundCols As Long
    UBoundRows = -1
    UBoundCols = -1
    Dim Ptr As LongPtr
    CopyMemory Ptr, ByVal UnsignedAdd(VarPtr(Data), 8), PTR_SIZE
    Const VT_BYREF As Integer = &H4000
    Dim VT As Integer
    CopyMemory VT, ByVal VarPtr(Data), 2
    If (VT And VT_BYREF) = VT_BYREF Then CopyMemory Ptr, ByVal Ptr, PTR_SIZE
    If Ptr <> NULL_PTR Then
        Dim DimensionCount As Integer
        CopyMemory DimensionCount, ByVal Ptr, 2
        If DimensionCount >= 2 Then
            If DimensionCount <= 9 Then
                If (RowDim < 1 Or RowDim > DimensionCount) Or (ColDim < 1 Or ColDim > DimensionCount) Or (PageDim < 0 Or PageDim > DimensionCount) Then Err.Raise Number:=381, Description:="Invalid property array index"
                Select Case VarType(Data)
                    Case (vbArray + vbVariant), (vbArray + vbString)
                        LBoundRows = LBound(Data, RowDim)
                        UBoundRows = UBound(Data, RowDim)
                        LBoundCols = LBound(Data, ColDim)
                        UBoundCols = UBound(Data, ColDim)
                    Case Else
                        Err.Raise 13
                End Select
            Else
                Err.Raise Number:=5, Description:="Array has too many dimensions"
            End If
        Else
            Err.Raise Number:=5, Description:="Array must be at least double dimensioned"
        End If
    Else
        Err.Raise Number:=91, Description:="Array is not allocated"
    End If
    If (UBoundRows - LBoundRows) > -1 And (UBoundCols - LBoundCols) > -1 Then
        If RestrictRows = False Then Me.Rows = Row + (UBoundRows - LBoundRows) + 1
        If RestrictColumns = False Then Me.Cols = Col + (UBoundCols - LBoundCols) + 1
        If Rows = -1 Then Rows = PropRows - Row
        If Cols = -1 Then Cols = PropCols - Col
        If Rows > 0 And Cols > 0 Then
            If Rows > (PropRows - Row) Then Rows = PropRows - Row
            If Cols > (PropCols - Col) Then Cols = PropCols - Col
            If (Row + (UBoundRows - LBoundRows)) > (Rows - 1) Then UBoundRows = LBoundRows + (Rows - 1)
            If (Col + (UBoundCols - LBoundCols)) > (Cols - 1) Then UBoundCols = LBoundCols + (Cols - 1)
            Dim ArrDim() As Long, Index As Long
            ReDim ArrDim(1 To DimensionCount) As Long
            For Index = 1 To DimensionCount
                Select Case Index
                    Case RowDim
                        ArrDim(Index) = LBoundRows
                    Case ColDim
                        ArrDim(Index) = LBoundCols
                    Case PageDim
                        ArrDim(Index) = CurrentPage
                    Case Else
                        ArrDim(Index) = LBound(Data, Index)
                End Select
            Next Index
            Dim iRow As Long, iCol As Long
            Select Case VarType(Data)
                Case (vbArray + vbVariant)
                    Select Case DimensionCount
                        Case 2
                            For iRow = LBoundRows To UBoundRows: For iCol = LBoundCols To UBoundCols
                                ArrDim(RowDim) = iRow: ArrDim(ColDim) = iCol
                                If Not IsNull(Data(ArrDim(1), ArrDim(2))) Then
                                    Call SetCellText((iRow + (0 - LBoundRows)) + Row, (iCol + (0 - LBoundCols)) + Col, (Data(ArrDim(1), ArrDim(2))))
                                Else
                                    Call SetCellText((iRow + (0 - LBoundRows)) + Row, (iCol + (0 - LBoundCols)) + Col, vbNullString)
                                End If
                            Next iCol, iRow
                        Case 3
                            For iRow = LBoundRows To UBoundRows: For iCol = LBoundCols To UBoundCols
                                ArrDim(RowDim) = iRow: ArrDim(ColDim) = iCol
                                If Not IsNull(Data(ArrDim(1), ArrDim(2), ArrDim(3))) Then
                                    Call SetCellText((iRow + (0 - LBoundRows)) + Row, (iCol + (0 - LBoundCols)) + Col, (Data(ArrDim(1), ArrDim(2), ArrDim(3))))
                                Else
                                    Call SetCellText((iRow + (0 - LBoundRows)) + Row, (iCol + (0 - LBoundCols)) + Col, vbNullString)
                                End If
                            Next iCol, iRow
                        Case 4
                            For iRow = LBoundRows To UBoundRows: For iCol = LBoundCols To UBoundCols
                                ArrDim(RowDim) = iRow: ArrDim(ColDim) = iCol
                                If Not IsNull(Data(ArrDim(1), ArrDim(2), ArrDim(3), ArrDim(4))) Then
                                    Call SetCellText((iRow + (0 - LBoundRows)) + Row, (iCol + (0 - LBoundCols)) + Col, (Data(ArrDim(1), ArrDim(2), ArrDim(3), ArrDim(4))))
                                Else
                                    Call SetCellText((iRow + (0 - LBoundRows)) + Row, (iCol + (0 - LBoundCols)) + Col, vbNullString)
                                End If
                            Next iCol, iRow
                        Case 5
                            For iRow = LBoundRows To UBoundRows: For iCol = LBoundCols To UBoundCols
                                ArrDim(RowDim) = iRow: ArrDim(ColDim) = iCol
                                If Not IsNull(Data(ArrDim(1), ArrDim(2), ArrDim(3), ArrDim(4), ArrDim(5))) Then
                                    Call SetCellText((iRow + (0 - LBoundRows)) + Row, (iCol + (0 - LBoundCols)) + Col, (Data(ArrDim(1), ArrDim(2), ArrDim(3), ArrDim(4), ArrDim(5))))
                                Else
                                    Call SetCellText((iRow + (0 - LBoundRows)) + Row, (iCol + (0 - LBoundCols)) + Col, vbNullString)
                                End If
                            Next iCol, iRow
                        Case 6
                            For iRow = LBoundRows To UBoundRows: For iCol = LBoundCols To UBoundCols
                                ArrDim(RowDim) = iRow: ArrDim(ColDim) = iCol
                                If Not IsNull(Data(ArrDim(1), ArrDim(2), ArrDim(3), ArrDim(4), ArrDim(5), ArrDim(6))) Then
                                    Call SetCellText((iRow + (0 - LBoundRows)) + Row, (iCol + (0 - LBoundCols)) + Col, (Data(ArrDim(1), ArrDim(2), ArrDim(3), ArrDim(4), ArrDim(5), ArrDim(6))))
                                Else
                                    Call SetCellText((iRow + (0 - LBoundRows)) + Row, (iCol + (0 - LBoundCols)) + Col, vbNullString)
                                End If
                            Next iCol, iRow
                        Case 7
                            For iRow = LBoundRows To UBoundRows: For iCol = LBoundCols To UBoundCols
                                ArrDim(RowDim) = iRow: ArrDim(ColDim) = iCol
                                If Not IsNull(Data(ArrDim(1), ArrDim(2), ArrDim(3), ArrDim(4), ArrDim(5), ArrDim(6), ArrDim(7))) Then
                                    Call SetCellText((iRow + (0 - LBoundRows)) + Row, (iCol + (0 - LBoundCols)) + Col, (Data(ArrDim(1), ArrDim(2), ArrDim(3), ArrDim(4), ArrDim(5), ArrDim(6), ArrDim(7))))
                                Else
                                    Call SetCellText((iRow + (0 - LBoundRows)) + Row, (iCol + (0 - LBoundCols)) + Col, vbNullString)
                                End If
                            Next iCol, iRow
                        Case 8
                            For iRow = LBoundRows To UBoundRows: For iCol = LBoundCols To UBoundCols
                                ArrDim(RowDim) = iRow: ArrDim(ColDim) = iCol
                                If Not IsNull(Data(ArrDim(1), ArrDim(2), ArrDim(3), ArrDim(4), ArrDim(5), ArrDim(6), ArrDim(7), ArrDim(8))) Then
                                    Call SetCellText((iRow + (0 - LBoundRows)) + Row, (iCol + (0 - LBoundCols)) + Col, (Data(ArrDim(1), ArrDim(2), ArrDim(3), ArrDim(4), ArrDim(5), ArrDim(6), ArrDim(7), ArrDim(8))))
                                Else
                                    Call SetCellText((iRow + (0 - LBoundRows)) + Row, (iCol + (0 - LBoundCols)) + Col, vbNullString)
                                End If
                            Next iCol, iRow
                        Case 9
                            For iRow = LBoundRows To UBoundRows: For iCol = LBoundCols To UBoundCols
                                ArrDim(RowDim) = iRow: ArrDim(ColDim) = iCol
                                If Not IsNull(Data(ArrDim(1), ArrDim(2), ArrDim(3), ArrDim(4), ArrDim(5), ArrDim(6), ArrDim(7), ArrDim(8), ArrDim(9))) Then
                                    Call SetCellText((iRow + (0 - LBoundRows)) + Row, (iCol + (0 - LBoundCols)) + Col, (Data(ArrDim(1), ArrDim(2), ArrDim(3), ArrDim(4), ArrDim(5), ArrDim(6), ArrDim(7), ArrDim(8), ArrDim(9))))
                                Else
                                    Call SetCellText((iRow + (0 - LBoundRows)) + Row, (iCol + (0 - LBoundCols)) + Col, vbNullString)
                                End If
                            Next iCol, iRow
                    End Select
                Case (vbArray + vbString)
                    Select Case DimensionCount
                        Case 2
                            For iRow = LBoundRows To UBoundRows: For iCol = LBoundCols To UBoundCols
                                ArrDim(RowDim) = iRow: ArrDim(ColDim) = iCol
                                Call SetCellText((iRow + (0 - LBoundRows)) + Row, (iCol + (0 - LBoundCols)) + Col, (Data(ArrDim(1), ArrDim(2))))
                            Next iCol, iRow
                        Case 3
                            For iRow = LBoundRows To UBoundRows: For iCol = LBoundCols To UBoundCols
                                ArrDim(RowDim) = iRow: ArrDim(ColDim) = iCol
                                Call SetCellText((iRow + (0 - LBoundRows)) + Row, (iCol + (0 - LBoundCols)) + Col, (Data(ArrDim(1), ArrDim(2), ArrDim(3))))
                            Next iCol, iRow
                        Case 4
                            For iRow = LBoundRows To UBoundRows: For iCol = LBoundCols To UBoundCols
                                ArrDim(RowDim) = iRow: ArrDim(ColDim) = iCol
                                Call SetCellText((iRow + (0 - LBoundRows)) + Row, (iCol + (0 - LBoundCols)) + Col, (Data(ArrDim(1), ArrDim(2), ArrDim(3), ArrDim(4))))
                            Next iCol, iRow
                        Case 5
                            For iRow = LBoundRows To UBoundRows: For iCol = LBoundCols To UBoundCols
                                ArrDim(RowDim) = iRow: ArrDim(ColDim) = iCol
                                Call SetCellText((iRow + (0 - LBoundRows)) + Row, (iCol + (0 - LBoundCols)) + Col, (Data(ArrDim(1), ArrDim(2), ArrDim(3), ArrDim(4), ArrDim(5))))
                            Next iCol, iRow
                        Case 6
                            For iRow = LBoundRows To UBoundRows: For iCol = LBoundCols To UBoundCols
                                ArrDim(RowDim) = iRow: ArrDim(ColDim) = iCol
                                Call SetCellText((iRow + (0 - LBoundRows)) + Row, (iCol + (0 - LBoundCols)) + Col, (Data(ArrDim(1), ArrDim(2), ArrDim(3), ArrDim(4), ArrDim(5), ArrDim(6))))
                            Next iCol, iRow
                        Case 7
                            For iRow = LBoundRows To UBoundRows: For iCol = LBoundCols To UBoundCols
                                ArrDim(RowDim) = iRow: ArrDim(ColDim) = iCol
                                Call SetCellText((iRow + (0 - LBoundRows)) + Row, (iCol + (0 - LBoundCols)) + Col, (Data(ArrDim(1), ArrDim(2), ArrDim(3), ArrDim(4), ArrDim(5), ArrDim(6), ArrDim(7))))
                            Next iCol, iRow
                        Case 8
                            For iRow = LBoundRows To UBoundRows: For iCol = LBoundCols To UBoundCols
                                ArrDim(RowDim) = iRow: ArrDim(ColDim) = iCol
                                Call SetCellText((iRow + (0 - LBoundRows)) + Row, (iCol + (0 - LBoundCols)) + Col, (Data(ArrDim(1), ArrDim(2), ArrDim(3), ArrDim(4), ArrDim(5), ArrDim(6), ArrDim(7), ArrDim(8))))
                            Next iCol, iRow
                        Case 9
                            For iRow = LBoundRows To UBoundRows: For iCol = LBoundCols To UBoundCols
                                ArrDim(RowDim) = iRow: ArrDim(ColDim) = iCol
                                Call SetCellText((iRow + (0 - LBoundRows)) + Row, (iCol + (0 - LBoundCols)) + Col, (Data(ArrDim(1), ArrDim(2), ArrDim(3), ArrDim(4), ArrDim(5), ArrDim(6), ArrDim(7), ArrDim(8), ArrDim(9))))
                            Next iCol, iRow
                    End Select
            End Select
            Call RedrawGrid
            LoadArray = (UBoundRows - LBoundRows) + 1
        End If
    End If
Else
    Err.Raise 380
End If
End Function

Public Property Get ClientLeft() As Long
Attribute ClientLeft.VB_Description = "Returns the left coordinate in twips of the control's client area."
Attribute ClientLeft.VB_MemberFlags = "400"
Dim RC(0 To 1) As RECT
LSet RC(0) = VBFlexGridClientRect
SetRect RC(1), 0, 0, UserControl.ScaleWidth, UserControl.ScaleHeight
If VBFlexGridHandle <> NULL_PTR Then
    MapWindowPoints VBFlexGridHandle, UserControl.ContainerHwnd, RC(0), 2
    MapWindowPoints UserControl.hWnd, UserControl.ContainerHwnd, RC(1), 2
End If
ClientLeft = UserControl.ScaleX(RC(0).Left - RC(1).Left, vbPixels, vbTwips)
End Property

Public Property Get ClientTop() As Long
Attribute ClientTop.VB_Description = "Returns the top coordinate in twips of the control's client area."
Attribute ClientTop.VB_MemberFlags = "400"
Dim RC As RECT
LSet RC = VBFlexGridClientRect
If VBFlexGridHandle <> NULL_PTR Then MapWindowPoints VBFlexGridHandle, UserControl.hWnd, RC, 2
ClientTop = UserControl.ScaleY(RC.Top, vbPixels, vbTwips)
End Property

Public Property Get ClientWidth() As Long
Attribute ClientWidth.VB_Description = "Returns the width in twips of the control's client area."
Attribute ClientWidth.VB_MemberFlags = "400"
ClientWidth = UserControl.ScaleX((VBFlexGridClientRect.Right - VBFlexGridClientRect.Left), vbPixels, vbTwips)
End Property

Public Property Get ClientHeight() As Long
Attribute ClientHeight.VB_Description = "Returns the height in twips of the control's client area."
Attribute ClientHeight.VB_MemberFlags = "400"
ClientHeight = UserControl.ScaleY((VBFlexGridClientRect.Bottom - VBFlexGridClientRect.Top), vbPixels, vbTwips)
End Property

Public Sub AddItem(ByVal Item As String, Optional ByVal Index As Variant)
Attribute AddItem.VB_Description = "Adds an item to the flex grid."
Dim IndexLong As Long
If IsMissing(Index) = True Then
    IndexLong = PropRows
Else
    Select Case VarType(Index)
        Case vbLong, vbInteger, vbByte
            IndexLong = Index
        Case vbDouble, vbSingle, vbString
            IndexLong = CLng(Index)
        Case Else
            Err.Raise 13
    End Select
End If
If IndexLong > -1 And IndexLong < PropFixedRows Then
    Err.Raise Number:=30001, Description:="Cannot use AddItem on a fixed row"
ElseIf IndexLong < 0 Or IndexLong > PropRows Then
    Err.Raise Number:=30002, Description:="Grid does not contain that row"
Else
    If PropRows > 0 Then
        PropRows = PropRows + 1
        ReDim Preserve VBFlexGridCells.Rows(0 To (PropRows - 1)) As TCOLS
        Dim iRow As Long, Blank As TCOLS, Length As Long
        Length = LenB(Blank)
        If IndexLong < (PropRows - 1) Then
            For iRow = ((PropRows - 1) - 1) To IndexLong Step -1
                CopyMemory ByVal VarPtr(VBFlexGridCells.Rows(iRow + 1)), ByVal VarPtr(VBFlexGridCells.Rows(iRow)), Length
            Next iRow
        End If
        ZeroMemory ByVal VarPtr(VBFlexGridCells.Rows(IndexLong)), Length
        LSet VBFlexGridCells.Rows(IndexLong) = VBFlexGridDefaultCols
    Else
        PropRows = PropRows + 1
        If PropCols > 0 Then Call InitFlexGridCells
    End If
    If PropRows > 0 And PropCols > 0 Then
        Dim i As Long
        If VBFlexGridSelectedRows > 0 Then
            ' Erase not needed as increase of the row indices is sufficient.
            For i = 0 To (VBFlexGridSelectedRows - 1)
                If VBFlexGridSelectedRowIndices(i) >= IndexLong Then VBFlexGridSelectedRowIndices(i) = VBFlexGridSelectedRowIndices(i) + 1
            Next i
        End If
        Dim Text As String
        Dim Pos1 As Long, Pos2 As Long, iCol As Long
        Dim CSCol As String, CSColLen As Long
        CSCol = GetClipSeparatorCol()
        CSColLen = Len(CSCol)
        If PropClipMode = FlexClipModeNormal Or PropClipMode = FlexClipModeLookupConv Then
            Do
                Pos1 = InStr(Pos1 + 1, Item, CSCol)
                If Pos1 > 0 Then
                    Pos1 = Pos1 + CSColLen - 1
                    If iCol < PropCols Then
                        If PropClipMode = FlexClipModeNormal Then
                            Call SetCellText(IndexLong, iCol, Mid$(Item, Pos2 + 1, Pos1 - Pos2 - CSColLen))
                        ElseIf PropClipMode = FlexClipModeLookupConv Then
                            Text = Mid$(Item, Pos2 + 1, Pos1 - Pos2 - CSColLen)
                            If VBFlexGridColsInfo(iCol).Lookup.Count > 0 Then
                                For i = 0 To (VBFlexGridColsInfo(iCol).Lookup.Count - 1)
                                    If StrComp(VBFlexGridColsInfo(iCol).Lookup.Items(i).Value, Text) = 0 Then
                                        Text = VBFlexGridColsInfo(iCol).Lookup.Items(i).Key
                                        Exit For
                                    End If
                                Next i
                            End If
                            Call SetCellText(IndexLong, iCol, Text)
                        End If
                    End If
                Else
                    If iCol < PropCols Then
                        If PropClipMode = FlexClipModeNormal Then
                            Call SetCellText(IndexLong, iCol, Mid$(Item, Pos2 + 1))
                        ElseIf PropClipMode = FlexClipModeLookupConv Then
                            Text = Mid$(Item, Pos2 + 1)
                            If VBFlexGridColsInfo(iCol).Lookup.Count > 0 Then
                                For i = 0 To (VBFlexGridColsInfo(iCol).Lookup.Count - 1)
                                    If StrComp(VBFlexGridColsInfo(iCol).Lookup.Items(i).Value, Text) = 0 Then
                                        Text = VBFlexGridColsInfo(iCol).Lookup.Items(i).Key
                                        Exit For
                                    End If
                                Next i
                            End If
                            Call SetCellText(IndexLong, iCol, Text)
                        End If
                    End If
                End If
                Pos2 = Pos1
                iCol = iCol + 1
            Loop Until Pos1 = 0
        ElseIf PropClipMode = FlexClipModeExcludeHidden Or PropClipMode = FlexClipModeLookupConvExcludeHidden Then
            Dim ColLoop As Boolean
            Do
                If (VBFlexGridColsInfo(iCol).State And CLIS_HIDDEN) = 0 Then
                    Pos1 = InStr(Pos1 + 1, Item, CSCol)
                    If Pos1 > 0 Then
                        Pos1 = Pos1 + CSColLen - 1
                        If iCol < PropCols Then
                            If PropClipMode = FlexClipModeExcludeHidden Then
                                Call SetCellText(IndexLong, iCol, Mid$(Item, Pos2 + 1, Pos1 - Pos2 - CSColLen))
                            ElseIf PropClipMode = FlexClipModeLookupConvExcludeHidden Then
                                Text = Mid$(Item, Pos2 + 1, Pos1 - Pos2 - CSColLen)
                                If VBFlexGridColsInfo(iCol).Lookup.Count > 0 Then
                                    For i = 0 To (VBFlexGridColsInfo(iCol).Lookup.Count - 1)
                                        If StrComp(VBFlexGridColsInfo(iCol).Lookup.Items(i).Value, Text) = 0 Then
                                            Text = VBFlexGridColsInfo(iCol).Lookup.Items(i).Key
                                            Exit For
                                        End If
                                    Next i
                                End If
                                Call SetCellText(IndexLong, iCol, Text)
                            End If
                        End If
                    Else
                        If iCol < PropCols Then
                            If PropClipMode = FlexClipModeExcludeHidden Then
                                Call SetCellText(IndexLong, iCol, Mid$(Item, Pos2 + 1))
                            ElseIf PropClipMode = FlexClipModeLookupConvExcludeHidden Then
                                Text = Mid$(Item, Pos2 + 1)
                                If VBFlexGridColsInfo(iCol).Lookup.Count > 0 Then
                                    For i = 0 To (VBFlexGridColsInfo(iCol).Lookup.Count - 1)
                                        If StrComp(VBFlexGridColsInfo(iCol).Lookup.Items(i).Value, Text) = 0 Then
                                            Text = VBFlexGridColsInfo(iCol).Lookup.Items(i).Key
                                            Exit For
                                        End If
                                    Next i
                                End If
                                Call SetCellText(IndexLong, iCol, Text)
                            End If
                        End If
                    End If
                    Pos2 = Pos1
                    iCol = iCol + 1
                    ColLoop = CBool(Pos1 <> 0 And iCol < PropCols)
                Else
                    iCol = iCol + 1
                    ColLoop = CBool(iCol < PropCols)
                End If
            Loop Until ColLoop = False
        End If
        Dim RCP As TROWCOLPARAMS
        With RCP
        .Flags = RCPF_SETSCROLLBARS Or RCPF_FORCEREDRAW
        Select Case PropSelectionMode
            Case FlexSelectionModeByColumn
                .Mask = .Mask Or RCPM_ROWSEL
                .RowSel = (PropRows - 1)
        End Select
        Call SetRowColParams(RCP)
        End With
    End If
End If
End Sub

Public Sub RemoveItem(ByVal Index As Long)
Attribute RemoveItem.VB_Description = "Removes an item from the flex grid."
If Index > -1 And Index < PropFixedRows Then
    Err.Raise Number:=30000, Description:="Cannot do a RemoveItem on a fixed row"
ElseIf Index < 0 Or Index > (PropRows - 1) Then
    Err.Raise Number:=30002, Description:="Grid does not contain that row"
Else
    PropRows = PropRows - 1
    Dim RowsPerPage As Long
    RowsPerPage = -1
    If PropRows > 0 And PropCols > 0 Then
        Dim iRow As Long, iCol As Long, Blank As TCOLS, Length As Long
        Length = LenB(Blank)
        If Index < ((PropRows - 1) + 1) Then
            For iCol = 0 To (PropCols - 1)
                Call FreeCellFmtg(VBFlexGridCells.Rows(Index).Cols(iCol).lpFmtg)
                Call FreeCellTag(VBFlexGridCells.Rows(Index).Cols(iCol).lpTag)
            Next iCol
            For iRow = Index To (PropRows - 1)
                CopyMemory ByVal VarPtr(VBFlexGridCells.Rows(iRow)), ByVal VarPtr(VBFlexGridCells.Rows(iRow + 1)), Length
            Next iRow
        End If
        ZeroMemory ByVal VarPtr(VBFlexGridCells.Rows(((PropRows - 1) + 1))), Length
        ReDim Preserve VBFlexGridCells.Rows(0 To (PropRows - 1)) As TCOLS
        RowsPerPage = GetRowsPerPageRev(PropRows - 1)
    Else
        If PropCols > 0 Then Call EraseFlexGridCells
    End If
    If VBFlexGridDropHighlight > -1 Then
        If VBFlexGridDropHighlightMode = FlexDropTargetModeByRow Then
            If VBFlexGridDropHighlight > (PropRows - 1) Then VBFlexGridDropHighlight = -1
        End If
    End If
    If VBFlexGridInsertMark > -1 Then
        If VBFlexGridInsertMarkMode = FlexDropTargetModeByRow Then
            If VBFlexGridInsertMark > (PropRows - 1) Then VBFlexGridInsertMark = -1: VBFlexGridInsertMarkAfter = False
        End If
    End If
    If VBFlexGridComboCueRow > (PropRows - 1) Then VBFlexGridComboCueRow = (PropRows - 1)
    If VBFlexGridSelectedRows > 0 Then
        Erase VBFlexGridSelectedRowIndices()
        VBFlexGridSelectedRows = 0
    End If
    If PropRows > 0 And PropCols > 0 Then
        Dim RCP As TROWCOLPARAMS
        With RCP
        .Flags = RCPF_SETSCROLLBARS Or RCPF_FORCEREDRAW
        If VBFlexGridRow > (PropRows - 1) Then
            .Mask = .Mask Or RCPM_ROW
            .Row = (PropRows - 1)
        End If
        Select Case PropSelectionMode
            Case FlexSelectionModeFree, FlexSelectionModeByRow, FlexSelectionModeFreeByRow, FlexSelectionModeFreeByColumn
                If VBFlexGridRowSel > (PropRows - 1) Then
                    .Mask = .Mask Or RCPM_ROWSEL
                    .RowSel = (PropRows - 1)
                End If
            Case FlexSelectionModeByColumn
                .Mask = .Mask Or RCPM_ROWSEL
                .RowSel = (PropRows - 1)
        End Select
        If RowsPerPage > -1 Then
            If VBFlexGridTopRow > (PropRows - 1) - RowsPerPage + 1 Then
                .Mask = .Mask Or RCPM_TOPROW
                .Flags = .Flags Or RCPF_FORCETOPROWMASK
                .TopRow = (PropRows - 1) - RowsPerPage + 1
            End If
        ElseIf VBFlexGridTopRow > (PropRows - 1) Then
            .Mask = .Mask Or RCPM_TOPROW
            .Flags = .Flags Or RCPF_CHECKTOPROW Or RCPF_FORCETOPROWMASK
            .TopRow = (PropRows - 1)
        End If
        Call SetRowColParams(RCP)
        End With
    Else
        Call RedrawGrid
    End If
End If
End Sub

Public Sub Copy()
Attribute Copy.VB_Description = "Copies the current selection of the flex grid to the clipboard."
Dim Text As String, Cancel As Boolean
Text = Me.Clip
RaiseEvent BeforeClipboardAction(FlexClipboardActionCopy, Text, Cancel)
If Cancel = False Then
    Call SetClipboardText(Text)
    RaiseEvent AfterClipboardAction(FlexClipboardActionCopy)
End If
End Sub

Public Sub Cut()
Attribute Cut.VB_Description = "Deletes (cuts) the current selection of the flex grid and copy the deleted text to the clipboard."
Dim Text As String, Cancel As Boolean
Text = Me.Clip
RaiseEvent BeforeClipboardAction(FlexClipboardActionCut, Text, Cancel)
If Cancel = False Then
    Call SetClipboardText(Text)
    If PropUndoLimit > 0 Then
        Dim UndoRedoEntry As TUNDOREDOENTRY
        With UndoRedoEntry
        .OldString = Me.Clip
        .NewString = vbNullString
        .Clip = True
        .ClearClip = True
        .Row = VBFlexGridRow
        .Col = VBFlexGridCol
        .RowSel = VBFlexGridRowSel
        .ColSel = VBFlexGridColSel
        End With
        Call AddUndo(UndoRedoEntry)
        Call ResetRedo
    End If
    Me.Clear FlexClearClip, FlexClearText
    Me.CellEnsureVisible
    RaiseEvent AfterClipboardAction(FlexClipboardActionCut)
End If
End Sub

Public Sub Paste()
Attribute Paste.VB_Description = "Pastes the current content of the clipboard at the current selection of the flex grid."
If HasClipboardText() = False Then Exit Sub
Dim Text As String, Cancel As Boolean
Text = GetClipboardText()
RaiseEvent BeforeClipboardAction(FlexClipboardActionPaste, Text, Cancel)
If Cancel = False Then
    If PropUndoLimit > 0 Then
        Dim UndoRedoEntry As TUNDOREDOENTRY
        With UndoRedoEntry
        .OldString = Me.Clip
        .NewString = Text
        .Clip = True
        .ClearClip = False
        .Row = VBFlexGridRow
        .Col = VBFlexGridCol
        .RowSel = VBFlexGridRowSel
        .ColSel = VBFlexGridColSel
        End With
        Call AddUndo(UndoRedoEntry)
        Call ResetRedo
    End If
    Me.Clip = Text
    Me.CellEnsureVisible
    RaiseEvent AfterClipboardAction(FlexClipboardActionPaste)
End If
End Sub

Public Function CanPaste() As Boolean
Attribute CanPaste.VB_Description = "Determines whether there is a text format currently on the clipboard that can be pasted."
CanPaste = HasClipboardText()
End Function

Public Sub Delete()
Attribute Delete.VB_Description = "Deletes the current selection of the flex grid."
Dim Cancel As Boolean
RaiseEvent BeforeClipboardAction(FlexClipboardActionDelete, vbNullString, Cancel)
If Cancel = False Then
    If PropUndoLimit > 0 Then
        Dim UndoRedoEntry As TUNDOREDOENTRY
        With UndoRedoEntry
        .OldString = Me.Clip
        .NewString = vbNullString
        .Clip = True
        .ClearClip = True
        .Row = VBFlexGridRow
        .Col = VBFlexGridCol
        .RowSel = VBFlexGridRowSel
        .ColSel = VBFlexGridColSel
        End With
        Call AddUndo(UndoRedoEntry)
        Call ResetRedo
    End If
    Me.Clear FlexClearClip, FlexClearText
    Me.CellEnsureVisible
    RaiseEvent AfterClipboardAction(FlexClipboardActionDelete)
End If
End Sub

Public Sub Undo()
Attribute Undo.VB_Description = "Undoes the last operation, if any."
If VBFlexGridUndoQueueIndex > -1 Then
    With VBFlexGridUndoQueue(VBFlexGridUndoQueueIndex)
    Me.SelectRange .Row, .Col, .RowSel, .ColSel
    Me.CellEnsureVisible
    If .Clip = False Then
        Dim iRow As Long, iCol As Long
        For iRow = .MergedRange.TopRow To .MergedRange.BottomRow
            For iCol = .MergedRange.LeftCol To .MergedRange.RightCol
                Call SetCellText(iRow, iCol, .OldString)
            Next iCol
        Next iRow
    Else
        Me.Clip = .OldString
    End If
    End With
    Call AddRedo(VBFlexGridUndoQueue(VBFlexGridUndoQueueIndex))
    VBFlexGridUndoQueueIndex = VBFlexGridUndoQueueIndex - 1
    Call RedrawGrid
End If
End Sub

Public Function CanUndo() As Boolean
Attribute CanUndo.VB_Description = "Determines whether there are any actions in the undo queue."
CanUndo = CBool(VBFlexGridUndoQueueIndex > -1)
End Function

Public Sub ResetUndoQueue()
Attribute ResetUndoQueue.VB_Description = "Resets the undo queue."
Call ResetUndo
Call ResetRedo
End Sub

Public Sub Redo()
Attribute Redo.VB_Description = "Redoes the next action in the redo queue, if any."
If VBFlexGridRedoQueueIndex > -1 Then
    With VBFlexGridRedoQueue(VBFlexGridRedoQueueIndex)
    Me.SelectRange .Row, .Col, .RowSel, .ColSel
    Me.CellEnsureVisible
    If .Clip = False Then
        Dim iRow As Long, iCol As Long
        For iRow = .MergedRange.TopRow To .MergedRange.BottomRow
            For iCol = .MergedRange.LeftCol To .MergedRange.RightCol
                Call SetCellText(iRow, iCol, .NewString)
            Next iCol
        Next iRow
    Else
        If .ClearClip = False Then
            Me.Clip = .NewString
        Else
            Me.Clear FlexClearClip, FlexClearText
        End If
    End If
    End With
    Call AddUndo(VBFlexGridRedoQueue(VBFlexGridRedoQueueIndex))
    VBFlexGridRedoQueueIndex = VBFlexGridRedoQueueIndex - 1
    Call RedrawGrid
End If
End Sub

Public Function CanRedo() As Boolean
Attribute CanRedo.VB_Description = "Determines whether there are any actions in the redo queue."
CanRedo = CBool(VBFlexGridRedoQueueIndex > -1)
End Function

Public Sub Clear(Optional ByVal Where As FlexClearWhereConstants, Optional ByVal What As FlexClearWhatConstants)
Attribute Clear.VB_Description = "Clears the contents of the flex grid."
Select Case Where
    Case FlexClearEverywhere, FlexClearFixed, FlexClearScrollable, FlexClearMovable, FlexClearFrozen, FlexClearSelection, FlexClearClip
    Case Else
        Err.Raise 380
End Select
Select Case What
    Case FlexClearEverything
        
        #If ImplementFlexDataSource Then
        
        If Not VBFlexGridFlexDataSource Is Nothing Then Err.Raise Number:=5, Description:="This function cannot be used to clear everything when custom data source is set."
        
        #End If
        
    Case FlexClearText, FlexClearFormatting, FlexClearTag
    Case Else
        Err.Raise 380
End Select
If PropRows < 1 Or PropCols < 1 Then Exit Sub
Dim iRow As Long, iCol As Long, iSelRow As Long, SelRange As TCELLRANGE
Select Case Where
    Case FlexClearEverywhere
        Select Case What
            Case FlexClearEverything
                For iRow = 0 To (PropRows - 1)
                    With VBFlexGridCells.Rows(iRow)
                    For iCol = 0 To (PropCols - 1)
                        Call FreeCellFmtg(.Cols(iCol).lpFmtg)
                        Call FreeCellTag(.Cols(iCol).lpTag)
                    Next iCol
                    .Cols() = VBFlexGridDefaultCols.Cols()
                    End With
                Next iRow
            Case FlexClearText
                For iRow = 0 To (PropRows - 1)
                    For iCol = 0 To (PropCols - 1)
                        Call SetCellText(iRow, iCol, vbNullString)
                    Next iCol
                Next iRow
            Case FlexClearFormatting
                For iRow = 0 To (PropRows - 1)
                    With VBFlexGridCells.Rows(iRow)
                    For iCol = 0 To (PropCols - 1)
                        Call FreeCellFmtg(.Cols(iCol).lpFmtg)
                    Next iCol
                    End With
                Next iRow
            Case FlexClearTag
                For iRow = 0 To (PropRows - 1)
                    With VBFlexGridCells.Rows(iRow)
                    For iCol = 0 To (PropCols - 1)
                        Call FreeCellTag(.Cols(iCol).lpTag)
                    Next iCol
                    End With
                Next iRow
        End Select
    Case FlexClearFixed
        Select Case What
            Case FlexClearEverything
                For iRow = 0 To (PropFixedRows - 1)
                    With VBFlexGridCells.Rows(iRow)
                    For iCol = 0 To (PropCols - 1)
                        Call FreeCellFmtg(.Cols(iCol).lpFmtg)
                        Call FreeCellTag(.Cols(iCol).lpTag)
                    Next iCol
                    .Cols() = VBFlexGridDefaultCols.Cols()
                    End With
                Next iRow
                For iCol = 0 To (PropFixedCols - 1)
                    For iRow = PropFixedRows To (PropRows - 1)
                        With VBFlexGridCells.Rows(iRow)
                        Call FreeCellFmtg(.Cols(iCol).lpFmtg)
                        Call FreeCellTag(.Cols(iCol).lpTag)
                        LSet .Cols(iCol) = VBFlexGridDefaultCell
                        End With
                    Next iRow
                Next iCol
            Case FlexClearText
                For iRow = 0 To (PropFixedRows - 1)
                    For iCol = 0 To (PropCols - 1)
                        Call SetCellText(iRow, iCol, vbNullString)
                    Next iCol
                Next iRow
                For iCol = 0 To (PropFixedCols - 1)
                    For iRow = PropFixedRows To (PropRows - 1)
                        Call SetCellText(iRow, iCol, vbNullString)
                    Next iRow
                Next iCol
            Case FlexClearFormatting
                For iRow = 0 To (PropFixedRows - 1)
                    With VBFlexGridCells.Rows(iRow)
                    For iCol = 0 To (PropCols - 1)
                        Call FreeCellFmtg(.Cols(iCol).lpFmtg)
                    Next iCol
                    End With
                Next iRow
                For iCol = 0 To (PropFixedCols - 1)
                    For iRow = PropFixedRows To (PropRows - 1)
                        Call FreeCellFmtg(VBFlexGridCells.Rows(iRow).Cols(iCol).lpFmtg)
                    Next iRow
                Next iCol
            Case FlexClearTag
                For iRow = 0 To (PropFixedRows - 1)
                    With VBFlexGridCells.Rows(iRow)
                    For iCol = 0 To (PropCols - 1)
                        Call FreeCellTag(.Cols(iCol).lpTag)
                    Next iCol
                    End With
                Next iRow
                For iCol = 0 To (PropFixedCols - 1)
                    For iRow = PropFixedRows To (PropRows - 1)
                        Call FreeCellTag(VBFlexGridCells.Rows(iRow).Cols(iCol).lpTag)
                    Next iRow
                Next iCol
        End Select
    Case FlexClearScrollable
        Select Case What
            Case FlexClearEverything
                For iRow = (PropFixedRows + PropFrozenRows) To (PropRows - 1)
                    With VBFlexGridCells.Rows(iRow)
                    For iCol = (PropFixedCols + PropFrozenCols) To (PropCols - 1)
                        Call FreeCellFmtg(.Cols(iCol).lpFmtg)
                        Call FreeCellTag(.Cols(iCol).lpTag)
                        LSet .Cols(iCol) = VBFlexGridDefaultCell
                    Next iCol
                    End With
                Next iRow
            Case FlexClearText
                For iRow = (PropFixedRows + PropFrozenRows) To (PropRows - 1)
                    For iCol = (PropFixedCols + PropFrozenCols) To (PropCols - 1)
                        Call SetCellText(iRow, iCol, vbNullString)
                    Next iCol
                Next iRow
            Case FlexClearFormatting
                For iRow = (PropFixedRows + PropFrozenRows) To (PropRows - 1)
                    For iCol = (PropFixedCols + PropFrozenCols) To (PropCols - 1)
                        Call FreeCellFmtg(VBFlexGridCells.Rows(iRow).Cols(iCol).lpFmtg)
                    Next iCol
                Next iRow
            Case FlexClearTag
                For iRow = (PropFixedRows + PropFrozenRows) To (PropRows - 1)
                    For iCol = (PropFixedCols + PropFrozenCols) To (PropCols - 1)
                        Call FreeCellTag(VBFlexGridCells.Rows(iRow).Cols(iCol).lpTag)
                    Next iCol
                Next iRow
        End Select
    Case FlexClearMovable
        Select Case What
            Case FlexClearEverything
                For iRow = PropFixedRows To (PropRows - 1)
                    With VBFlexGridCells.Rows(iRow)
                    For iCol = PropFixedCols To (PropCols - 1)
                        Call FreeCellFmtg(.Cols(iCol).lpFmtg)
                        Call FreeCellTag(.Cols(iCol).lpTag)
                        LSet .Cols(iCol) = VBFlexGridDefaultCell
                    Next iCol
                    End With
                Next iRow
            Case FlexClearText
                For iRow = PropFixedRows To (PropRows - 1)
                    For iCol = PropFixedCols To (PropCols - 1)
                        Call SetCellText(iRow, iCol, vbNullString)
                    Next iCol
                Next iRow
            Case FlexClearFormatting
                For iRow = PropFixedRows To (PropRows - 1)
                    For iCol = PropFixedCols To (PropCols - 1)
                        Call FreeCellFmtg(VBFlexGridCells.Rows(iRow).Cols(iCol).lpFmtg)
                    Next iCol
                Next iRow
            Case FlexClearTag
                For iRow = PropFixedRows To (PropRows - 1)
                    For iCol = PropFixedCols To (PropCols - 1)
                        Call FreeCellTag(VBFlexGridCells.Rows(iRow).Cols(iCol).lpTag)
                    Next iCol
                Next iRow
        End Select
    Case FlexClearFrozen
        Select Case What
            Case FlexClearEverything
                For iRow = PropFixedRows To ((PropFixedRows + PropFrozenRows) - 1)
                    With VBFlexGridCells.Rows(iRow)
                    For iCol = PropFixedCols To (PropCols - 1)
                        Call FreeCellFmtg(.Cols(iCol).lpFmtg)
                        Call FreeCellTag(.Cols(iCol).lpTag)
                        LSet .Cols(iCol) = VBFlexGridDefaultCell
                    Next iCol
                    End With
                Next iRow
                For iCol = PropFixedCols To ((PropFixedCols + PropFrozenCols) - 1)
                    For iRow = (PropFixedRows + PropFrozenRows) To (PropRows - 1)
                        With VBFlexGridCells.Rows(iRow)
                        Call FreeCellFmtg(.Cols(iCol).lpFmtg)
                        LSet .Cols(iCol) = VBFlexGridDefaultCell
                        End With
                    Next iRow
                Next iCol
            Case FlexClearText
                For iRow = PropFixedRows To ((PropFixedRows + PropFrozenRows) - 1)
                    For iCol = PropFixedCols To (PropCols - 1)
                        Call SetCellText(iRow, iCol, vbNullString)
                    Next iCol
                Next iRow
                For iCol = PropFixedCols To ((PropFixedCols + PropFrozenCols) - 1)
                    For iRow = (PropFixedRows + PropFrozenRows) To (PropRows - 1)
                        Call SetCellText(iRow, iCol, vbNullString)
                    Next iRow
                Next iCol
            Case FlexClearFormatting
                For iRow = PropFixedRows To ((PropFixedRows + PropFrozenRows) - 1)
                    For iCol = PropFixedCols To (PropCols - 1)
                        Call FreeCellFmtg(VBFlexGridCells.Rows(iRow).Cols(iCol).lpFmtg)
                    Next iCol
                Next iRow
                For iCol = PropFixedCols To ((PropFixedCols + PropFrozenCols) - 1)
                    For iRow = (PropFixedRows + PropFrozenRows) To (PropRows - 1)
                        Call FreeCellFmtg(VBFlexGridCells.Rows(iRow).Cols(iCol).lpFmtg)
                    Next iRow
                Next iCol
            Case FlexClearTag
                For iRow = PropFixedRows To ((PropFixedRows + PropFrozenRows) - 1)
                    For iCol = PropFixedCols To (PropCols - 1)
                        Call FreeCellTag(VBFlexGridCells.Rows(iRow).Cols(iCol).lpTag)
                    Next iCol
                Next iRow
                For iCol = PropFixedCols To ((PropFixedCols + PropFrozenCols) - 1)
                    For iRow = (PropFixedRows + PropFrozenRows) To (PropRows - 1)
                        Call FreeCellTag(VBFlexGridCells.Rows(iRow).Cols(iCol).lpTag)
                    Next iRow
                Next iCol
        End Select
    Case FlexClearSelection
        Call GetSelRangeStruct(SelRange)
        Select Case What
            Case FlexClearEverything
                For iRow = SelRange.TopRow To SelRange.BottomRow
                    For iCol = SelRange.LeftCol To SelRange.RightCol
                        With VBFlexGridCells.Rows(iRow)
                        Call FreeCellFmtg(.Cols(iCol).lpFmtg)
                        Call FreeCellTag(.Cols(iCol).lpTag)
                        LSet .Cols(iCol) = VBFlexGridDefaultCell
                        End With
                    Next iCol
                Next iRow
            Case FlexClearText
                For iRow = SelRange.TopRow To SelRange.BottomRow
                    For iCol = SelRange.LeftCol To SelRange.RightCol
                        Call SetCellText(iRow, iCol, vbNullString)
                    Next iCol
                Next iRow
            Case FlexClearFormatting
                For iRow = SelRange.TopRow To SelRange.BottomRow
                    For iCol = SelRange.LeftCol To SelRange.RightCol
                        Call FreeCellFmtg(VBFlexGridCells.Rows(iRow).Cols(iCol).lpFmtg)
                    Next iCol
                Next iRow
            Case FlexClearTag
                For iRow = SelRange.TopRow To SelRange.BottomRow
                    For iCol = SelRange.LeftCol To SelRange.RightCol
                        Call FreeCellTag(VBFlexGridCells.Rows(iRow).Cols(iCol).lpTag)
                    Next iCol
                Next iRow
        End Select
    Case FlexClearClip
        Call GetSelRangeStruct(SelRange)
        If PropClipPasteMode >= FlexClipPasteModeExtended Then
            Select Case PropSelectionMode
                Case FlexSelectionModeFreeByRow
                    If SelRange.LeftCol > PropFixedCols Then SelRange.LeftCol = PropFixedCols
                    SelRange.RightCol = PropCols - 1
                Case FlexSelectionModeFreeByColumn
                    If SelRange.TopRow > PropFixedRows Then SelRange.TopRow = PropFixedRows
                    SelRange.BottomRow = PropRows - 1
            End Select
        End If
        If PropClipMode = FlexClipModeNormal Or PropClipMode = FlexClipModeLookupConv Then
            If PropAllowMultiSelection = False Or PropClipPasteMode < FlexClipPasteModeExtended Then
                Select Case What
                    Case FlexClearEverything
                        For iRow = SelRange.TopRow To SelRange.BottomRow
                            For iCol = SelRange.LeftCol To SelRange.RightCol
                                With VBFlexGridCells.Rows(iRow)
                                Call FreeCellFmtg(.Cols(iCol).lpFmtg)
                                Call FreeCellTag(.Cols(iCol).lpTag)
                                LSet .Cols(iCol) = VBFlexGridDefaultCell
                                End With
                            Next iCol
                        Next iRow
                    Case FlexClearText
                        For iRow = SelRange.TopRow To SelRange.BottomRow
                            For iCol = SelRange.LeftCol To SelRange.RightCol
                                Call SetCellText(iRow, iCol, vbNullString)
                            Next iCol
                        Next iRow
                    Case FlexClearFormatting
                        For iRow = SelRange.TopRow To SelRange.BottomRow
                            For iCol = SelRange.LeftCol To SelRange.RightCol
                                Call FreeCellFmtg(VBFlexGridCells.Rows(iRow).Cols(iCol).lpFmtg)
                            Next iCol
                        Next iRow
                    Case FlexClearTag
                        For iRow = SelRange.TopRow To SelRange.BottomRow
                            For iCol = SelRange.LeftCol To SelRange.RightCol
                                Call FreeCellTag(VBFlexGridCells.Rows(iRow).Cols(iCol).lpTag)
                            Next iCol
                        Next iRow
                End Select
            Else
                Select Case What
                    Case FlexClearEverything
                        For iRow = 0 To Me.SelectedRows - 1
                            iSelRow = Me.SelectedRow(iRow)
                            For iCol = SelRange.LeftCol To SelRange.RightCol
                                With VBFlexGridCells.Rows(iSelRow)
                                Call FreeCellFmtg(.Cols(iCol).lpFmtg)
                                Call FreeCellTag(.Cols(iCol).lpTag)
                                LSet .Cols(iCol) = VBFlexGridDefaultCell
                                End With
                            Next iCol
                        Next iRow
                    Case FlexClearText
                        For iRow = 0 To Me.SelectedRows - 1
                            iSelRow = Me.SelectedRow(iRow)
                            For iCol = SelRange.LeftCol To SelRange.RightCol
                                Call SetCellText(iSelRow, iCol, vbNullString)
                            Next iCol
                        Next iRow
                    Case FlexClearFormatting
                        For iRow = 0 To Me.SelectedRows - 1
                            iSelRow = Me.SelectedRow(iRow)
                            For iCol = SelRange.LeftCol To SelRange.RightCol
                                Call FreeCellFmtg(VBFlexGridCells.Rows(iSelRow).Cols(iCol).lpFmtg)
                            Next iCol
                        Next iRow
                    Case FlexClearTag
                        For iRow = 0 To Me.SelectedRows - 1
                            iSelRow = Me.SelectedRow(iRow)
                            For iCol = SelRange.LeftCol To SelRange.RightCol
                                Call FreeCellTag(VBFlexGridCells.Rows(iSelRow).Cols(iCol).lpTag)
                            Next iCol
                        Next iRow
                End Select
            End If
        ElseIf PropClipMode = FlexClipModeExcludeHidden Or PropClipMode = FlexClipModeLookupConvExcludeHidden Then
            If PropAllowMultiSelection = False Or PropClipPasteMode < FlexClipPasteModeExtended Then
                Select Case What
                    Case FlexClearEverything
                        For iRow = SelRange.TopRow To SelRange.BottomRow
                            If (VBFlexGridCells.Rows(iRow).RowInfo.State And RWIS_HIDDEN) = 0 Then
                                For iCol = SelRange.LeftCol To SelRange.RightCol
                                    If (VBFlexGridColsInfo(iCol).State And CLIS_HIDDEN) = 0 Then
                                        With VBFlexGridCells.Rows(iRow)
                                        Call FreeCellFmtg(.Cols(iCol).lpFmtg)
                                        Call FreeCellTag(.Cols(iCol).lpTag)
                                        LSet .Cols(iCol) = VBFlexGridDefaultCell
                                        End With
                                    End If
                                Next iCol
                            End If
                        Next iRow
                    Case FlexClearText
                        For iRow = SelRange.TopRow To SelRange.BottomRow
                            If (VBFlexGridCells.Rows(iRow).RowInfo.State And RWIS_HIDDEN) = 0 Then
                                For iCol = SelRange.LeftCol To SelRange.RightCol
                                    If (VBFlexGridColsInfo(iCol).State And CLIS_HIDDEN) = 0 Then
                                        Call SetCellText(iRow, iCol, vbNullString)
                                    End If
                                Next iCol
                            End If
                        Next iRow
                    Case FlexClearFormatting
                        For iRow = SelRange.TopRow To SelRange.BottomRow
                            If (VBFlexGridCells.Rows(iRow).RowInfo.State And RWIS_HIDDEN) = 0 Then
                                For iCol = SelRange.LeftCol To SelRange.RightCol
                                    If (VBFlexGridColsInfo(iCol).State And CLIS_HIDDEN) = 0 Then
                                        Call FreeCellFmtg(VBFlexGridCells.Rows(iRow).Cols(iCol).lpFmtg)
                                    End If
                                Next iCol
                            End If
                        Next iRow
                    Case FlexClearTag
                        For iRow = SelRange.TopRow To SelRange.BottomRow
                            If (VBFlexGridCells.Rows(iRow).RowInfo.State And RWIS_HIDDEN) = 0 Then
                                For iCol = SelRange.LeftCol To SelRange.RightCol
                                    If (VBFlexGridColsInfo(iCol).State And CLIS_HIDDEN) = 0 Then
                                        Call FreeCellTag(VBFlexGridCells.Rows(iRow).Cols(iCol).lpTag)
                                    End If
                                Next iCol
                            End If
                        Next iRow
                End Select
            Else
                Select Case What
                    Case FlexClearEverything
                        For iRow = 0 To Me.SelectedRows - 1
                            iSelRow = Me.SelectedRow(iRow)
                            If (VBFlexGridCells.Rows(iSelRow).RowInfo.State And RWIS_HIDDEN) = 0 Then
                                For iCol = SelRange.LeftCol To SelRange.RightCol
                                    If (VBFlexGridColsInfo(iCol).State And CLIS_HIDDEN) = 0 Then
                                        With VBFlexGridCells.Rows(iSelRow)
                                        Call FreeCellFmtg(.Cols(iCol).lpFmtg)
                                        Call FreeCellTag(.Cols(iCol).lpTag)
                                        LSet .Cols(iCol) = VBFlexGridDefaultCell
                                        End With
                                    End If
                                Next iCol
                            End If
                        Next iRow
                    Case FlexClearText
                        For iRow = 0 To Me.SelectedRows - 1
                            iSelRow = Me.SelectedRow(iRow)
                            If (VBFlexGridCells.Rows(iSelRow).RowInfo.State And RWIS_HIDDEN) = 0 Then
                                For iCol = SelRange.LeftCol To SelRange.RightCol
                                    If (VBFlexGridColsInfo(iCol).State And CLIS_HIDDEN) = 0 Then
                                        Call SetCellText(iSelRow, iCol, vbNullString)
                                    End If
                                Next iCol
                            End If
                        Next iRow
                    Case FlexClearFormatting
                        For iRow = 0 To Me.SelectedRows - 1
                            iSelRow = Me.SelectedRow(iRow)
                            If (VBFlexGridCells.Rows(iSelRow).RowInfo.State And RWIS_HIDDEN) = 0 Then
                                For iCol = SelRange.LeftCol To SelRange.RightCol
                                    If (VBFlexGridColsInfo(iCol).State And CLIS_HIDDEN) = 0 Then
                                        Call FreeCellFmtg(VBFlexGridCells.Rows(iSelRow).Cols(iCol).lpFmtg)
                                    End If
                                Next iCol
                            End If
                        Next iRow
                    Case FlexClearTag
                        For iRow = 0 To Me.SelectedRows - 1
                            iSelRow = Me.SelectedRow(iRow)
                            If (VBFlexGridCells.Rows(iSelRow).RowInfo.State And RWIS_HIDDEN) = 0 Then
                                For iCol = SelRange.LeftCol To SelRange.RightCol
                                    If (VBFlexGridColsInfo(iCol).State And CLIS_HIDDEN) = 0 Then
                                        Call FreeCellTag(VBFlexGridCells.Rows(iSelRow).Cols(iCol).lpTag)
                                    End If
                                Next iCol
                            End If
                        Next iRow
                End Select
            End If
        End If
End Select
Call RedrawGrid
End Sub

Public Sub ClearRowInfo(ByVal Index As Long)
Attribute ClearRowInfo.VB_Description = "Clears the info structure for the specified row."
If Index <> -1 And (Index < 0 Or Index > (PropRows - 1)) Then Err.Raise Number:=30009, Description:="Invalid Row value"
If Index > -1 Then
    LSet VBFlexGridCells.Rows(Index).RowInfo = VBFlexGridDefaultRowInfo
Else
    If PropRows < 1 Or PropCols < 1 Then Exit Sub
    Dim i As Long
    For i = 0 To (PropRows - 1)
        LSet VBFlexGridCells.Rows(i).RowInfo = VBFlexGridDefaultRowInfo
    Next i
End If
Dim RCP As TROWCOLPARAMS
With RCP
.Mask = RCPM_TOPROW
.Flags = RCPF_CHECKTOPROW Or RCPF_FORCETOPROWMASK Or RCPF_SETSCROLLBARS Or RCPF_FORCEREDRAW
.TopRow = VBFlexGridTopRow
Call SetRowColParams(RCP)
End With
End Sub

Public Sub ClearColInfo(ByVal Index As Long)
Attribute ClearColInfo.VB_Description = "Clears the info structure for the specified column."
If Index <> -1 And (Index < 0 Or Index > (PropCols - 1)) Then Err.Raise Number:=30010, Description:="Invalid Col value"
If Index > -1 Then
    LSet VBFlexGridColsInfo(Index) = VBFlexGridDefaultColInfo
Else
    If PropRows < 1 Or PropCols < 1 Then Exit Sub
    Dim i As Long
    For i = 0 To (PropCols - 1)
        LSet VBFlexGridColsInfo(i) = VBFlexGridDefaultColInfo
    Next i
End If
If Index > -1 And VBFlexGridExtendLastCol > -1 Then
    If Index >= VBFlexGridExtendLastCol Then VBFlexGridExtendLastCol = GetExtendLastCol()
Else
    VBFlexGridExtendLastCol = GetExtendLastCol()
End If
Dim RCP As TROWCOLPARAMS
With RCP
.Mask = RCPM_LEFTCOL
.Flags = RCPF_CHECKLEFTCOL Or RCPF_FORCELEFTCOLMASK Or RCPF_SETSCROLLBARS Or RCPF_FORCEREDRAW
.LeftCol = VBFlexGridLeftCol
Call SetRowColParams(RCP)
End With
End Sub

Public Property Get Row() As Long
Attribute Row.VB_Description = "Returns/sets the active cell in the flex grid."
Attribute Row.VB_MemberFlags = "400"
Row = VBFlexGridRow
End Property

Public Property Let Row(ByVal Value As Long)
If Value < 0 Or Value > (PropRows - 1) Then Err.Raise Number:=30009, Description:="Invalid Row value"
If VBFlexGridCol < 0 Or VBFlexGridCol > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
Dim RCP As TROWCOLPARAMS
With RCP
.Mask = RCPM_ROW Or RCPM_ROWSEL Or RCPM_COLSEL
.Row = Value
.RowSel = .Row
.ColSel = VBFlexGridCol
Call SetRowColParams(RCP)
End With
End Property

Public Property Get Col() As Long
Attribute Col.VB_Description = "Returns/sets the active cell in the flex grid."
Attribute Col.VB_MemberFlags = "400"
Col = VBFlexGridCol
End Property

Public Property Let Col(ByVal Value As Long)
If VBFlexGridRow < 0 Or VBFlexGridRow > (PropRows - 1) Then Err.Raise Number:=30009, Description:="Invalid Row value"
If Value < 0 Or Value > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
Dim RCP As TROWCOLPARAMS
With RCP
.Mask = RCPM_COL Or RCPM_ROWSEL Or RCPM_COLSEL
.Col = Value
.RowSel = VBFlexGridRow
.ColSel = .Col
Call SetRowColParams(RCP)
End With
End Property

Public Property Get RowSel() As Long
Attribute RowSel.VB_Description = "Returns/sets the starting or ending row or column for a range of cells."
Attribute RowSel.VB_MemberFlags = "400"
RowSel = VBFlexGridRowSel
End Property

Public Property Let RowSel(ByVal Value As Long)
If Value < 0 Or Value > (PropRows - 1) Then Err.Raise Number:=30009, Description:="Invalid Row value"
Dim RCP As TROWCOLPARAMS
With RCP
.Mask = RCPM_ROWSEL
.RowSel = Value
Call SetRowColParams(RCP)
End With
End Property

Public Property Get ColSel() As Long
Attribute ColSel.VB_Description = "Returns/sets the starting or ending row or column for a range of cells."
Attribute ColSel.VB_MemberFlags = "400"
ColSel = VBFlexGridColSel
End Property

Public Property Let ColSel(ByVal Value As Long)
If Value < 0 Or Value > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
Dim RCP As TROWCOLPARAMS
With RCP
.Mask = RCPM_COLSEL
.ColSel = Value
Call SetRowColParams(RCP)
End With
End Property

Public Sub GetSelRange(ByRef Row1 As Long, ByRef Col1 As Long, ByRef Row2 As Long, ByRef Col2 As Long)
Attribute GetSelRange.VB_Description = "Retrieves the starting and ending row and column for a range of cells ordered so that Row1 <= Row2 and Col1 <= Col2."
Dim SelRange As TCELLRANGE
Call GetSelRangeStruct(SelRange)
With SelRange
Row1 = .TopRow
Col1 = .LeftCol
Row2 = .BottomRow
Col2 = .RightCol
End With
End Sub

Public Sub GetMergedRange(ByVal Row As Long, ByVal Col As Long, ByRef Row1 As Long, ByRef Col1 As Long, ByRef Row2 As Long, ByRef Col2 As Long)
Attribute GetMergedRange.VB_Description = "Retrieves the range of merged cells that includes a given cell."
If (Row < 0 Or Row > (PropRows - 1)) Or (Col < 0 Or Col > (PropCols - 1)) Then Err.Raise Number:=381, Description:="Subscript out of range"
Dim MergedRange As TCELLRANGE
Call GetMergedRangeStruct(Row, Col, MergedRange)
With MergedRange
Row1 = .TopRow
Col1 = .LeftCol
Row2 = .BottomRow
Col2 = .RightCol
End With
End Sub

Public Sub SelectRange(ByVal Row As Long, ByVal Col As Long, Optional ByVal RowSel As Long = -1, Optional ByVal ColSel As Long = -1)
Attribute SelectRange.VB_Description = "Selects a range of cells or a cell (by omitting the last two parameters) with a single command."
If RowSel = -1 Then
    If PropSelectionMode <> FlexSelectionModeByColumn Then
        RowSel = Row
    Else
        RowSel = (PropRows - 1)
    End If
End If
If ColSel = -1 Then
    If PropSelectionMode <> FlexSelectionModeByRow Then
        ColSel = Col
    Else
        ColSel = (PropCols - 1)
    End If
End If
If (Row < 0 Or Row > (PropRows - 1)) Or (Col < 0 Or Col > (PropCols - 1)) Or (RowSel < 0 Or RowSel > (PropRows - 1)) Or (ColSel < 0 Or ColSel > (PropCols - 1)) Then Err.Raise Number:=381, Description:="Subscript out of range"
Dim RCP As TROWCOLPARAMS
With RCP
.Mask = RCPM_ROW Or RCPM_COL Or RCPM_ROWSEL Or RCPM_COLSEL
.Row = Row
.Col = Col
.RowSel = RowSel
.ColSel = ColSel
Call SetRowColParams(RCP)
End With
End Sub

Public Sub SelectAll()
Attribute SelectAll.VB_Description = "Selects all cells with a single command."
If PropRows < 1 Or PropCols < 1 Then Exit Sub
Dim RCP As TROWCOLPARAMS
With RCP
.Mask = RCPM_ROW Or RCPM_COL Or RCPM_ROWSEL Or RCPM_COLSEL
.Row = PropFixedRows
.Col = PropFixedCols
.RowSel = (PropRows - 1)
.ColSel = (PropCols - 1)
Call SetRowColParams(RCP)
End With
End Sub

Public Property Get TopRow() As Long
Attribute TopRow.VB_Description = "Returns/sets the uppermost row displayed in the flex grid."
Attribute TopRow.VB_MemberFlags = "400"
TopRow = VBFlexGridTopRow
End Property

Public Property Let TopRow(ByVal Value As Long)
If Value < 0 Or Value > (PropRows - 1) Then Err.Raise Number:=30009, Description:="Invalid Row value"
Dim RCP As TROWCOLPARAMS
With RCP
.Mask = RCPM_TOPROW
.Flags = RCPF_CHECKTOPROW Or RCPF_FORCETOPROWMASK
.TopRow = Value
Call SetRowColParams(RCP)
End With
End Property

Public Property Get BottomRow(Optional ByVal Visibility As FlexVisibilityConstants) As Long
Attribute BottomRow.VB_Description = "Returns the bottommost row displayed in the flex grid."
Attribute BottomRow.VB_MemberFlags = "400"
Select Case Visibility
    Case FlexVisibilityPartialOK, FlexVisibilityCompleteOnly
    Case Else
        Err.Raise 380
End Select
If VBFlexGridHandle = NULL_PTR Or (PropRows < 1 Or PropCols < 1) Then Exit Property
Dim GridRect As RECT, iRow As Long
With GridRect
For iRow = 0 To ((PropFixedRows + PropFrozenRows) - 1)
    .Bottom = .Bottom + GetRowHeight(iRow)
Next iRow
BottomRow = VBFlexGridTopRow
For iRow = VBFlexGridTopRow To (PropRows - 1)
    If Visibility = FlexVisibilityPartialOK Then If .Bottom > VBFlexGridClientRect.Bottom Then Exit For
    .Bottom = .Bottom + GetRowHeight(iRow)
    If Visibility = FlexVisibilityCompleteOnly Then If .Bottom > VBFlexGridClientRect.Bottom Then Exit For
    BottomRow = iRow
Next iRow
End With
End Property

Public Property Get LeftCol() As Long
Attribute LeftCol.VB_Description = "Returns/sets the leftmost column displayed in the flex grid."
Attribute LeftCol.VB_MemberFlags = "400"
LeftCol = VBFlexGridLeftCol
End Property

Public Property Let LeftCol(ByVal Value As Long)
If Value < 0 Or Value > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
Dim RCP As TROWCOLPARAMS
With RCP
.Mask = RCPM_LEFTCOL
.Flags = RCPF_CHECKLEFTCOL Or RCPF_FORCELEFTCOLMASK
.LeftCol = Value
Call SetRowColParams(RCP)
End With
End Property

Public Property Get RightCol(Optional ByVal Visibility As FlexVisibilityConstants) As Long
Attribute RightCol.VB_Description = "Returns the rightmost column displayed in the flex grid."
Attribute RightCol.VB_MemberFlags = "400"
Select Case Visibility
    Case FlexVisibilityPartialOK, FlexVisibilityCompleteOnly
    Case Else
        Err.Raise 380
End Select
If VBFlexGridHandle = NULL_PTR Or (PropRows < 1 Or PropCols < 1) Then Exit Property
Dim GridRect As RECT, iCol As Long
With GridRect
For iCol = 0 To ((PropFixedCols + PropFrozenCols) - 1)
    .Right = .Right + GetColWidth(iCol)
Next iCol
RightCol = VBFlexGridLeftCol
For iCol = VBFlexGridLeftCol To (PropCols - 1)
    If Visibility = FlexVisibilityPartialOK Then If .Right > VBFlexGridClientRect.Right Then Exit For
    .Right = .Right + GetColWidth(iCol)
    If Visibility = FlexVisibilityCompleteOnly Then If .Right > VBFlexGridClientRect.Right Then Exit For
    RightCol = iCol
Next iCol
End With
End Property

Public Property Get MouseRow() As Long
Attribute MouseRow.VB_Description = "Returns the row over which the mouse pointer is."
Attribute MouseRow.VB_MemberFlags = "400"
If VBFlexGridHandle <> NULL_PTR Then
    Dim P As POINTAPI, HTI As THITTESTINFO
    GetCursorPos P
    ScreenToClient VBFlexGridHandle, P
    HTI.PT.X = P.X
    HTI.PT.Y = P.Y
    Call GetHitTestInfo(HTI)
    MouseRow = HTI.MouseRow
End If
End Property

Public Property Get MouseCol() As Long
Attribute MouseCol.VB_Description = "Returns the column over which the mouse pointer is."
Attribute MouseCol.VB_MemberFlags = "400"
If VBFlexGridHandle <> NULL_PTR Then
    Dim P As POINTAPI, HTI As THITTESTINFO
    GetCursorPos P
    ScreenToClient VBFlexGridHandle, P
    HTI.PT.X = P.X
    HTI.PT.Y = P.Y
    Call GetHitTestInfo(HTI)
    MouseCol = HTI.MouseCol
End If
End Property

Public Property Get HitRow() As Long
Attribute HitRow.VB_Description = "Returns the row returned from the last hit test."
Attribute HitRow.VB_MemberFlags = "400"
HitRow = VBFlexGridHitRow
End Property

Public Property Get HitCol() As Long
Attribute HitCol.VB_Description = "Returns the column returned from the last hit test."
Attribute HitCol.VB_MemberFlags = "400"
HitCol = VBFlexGridHitCol
End Property

Public Property Get HitRowDivider() As Long
Attribute HitRowDivider.VB_Description = "Returns the divider row returned from the last hit test."
Attribute HitRowDivider.VB_MemberFlags = "400"
HitRowDivider = VBFlexGridHitRowDivider
End Property

Public Property Get HitColDivider() As Long
Attribute HitColDivider.VB_Description = "Returns the divider column returned from the last hit test."
Attribute HitColDivider.VB_MemberFlags = "400"
HitColDivider = VBFlexGridHitColDivider
End Property

Public Property Get HitResult() As FlexHitResultConstants
Attribute HitResult.VB_Description = "Returns the result returned from the last hit test."
Attribute HitResult.VB_MemberFlags = "400"
HitResult = VBFlexGridHitResult
End Property

Public Function DragRow(ByVal Index As Long) As Long
Attribute DragRow.VB_Description = "Begins a drag operation used to rearrange rows by dragging the specified row with the mouse to a new position."
If (Index < PropFixedRows Or Index > (PropRows - 1)) Then Err.Raise Number:=381, Description:="Subscript out of range"
If VBFlexGridDoDragRowCol = False Then
    DragRow = DoDragRowCol(Index, -1)
Else
    Err.Raise 5
End If
End Function

Public Function DragCol(ByVal Index As Long) As Long
Attribute DragCol.VB_Description = "Begins a drag operation used to rearrange columns by dragging the specified column with the mouse to a new position."
If (Index < PropFixedCols Or Index > (PropCols - 1)) Then Err.Raise Number:=381, Description:="Subscript out of range"
If VBFlexGridDoDragRowCol = False Then
    DragCol = DoDragRowCol(-1, Index)
Else
    Err.Raise 5
End If
End Function

Public Property Get DropHighlight() As Long
Attribute DropHighlight.VB_Description = "Returns/sets the row or column which is used to highlight the target of a drag/drop operation."
Attribute DropHighlight.VB_MemberFlags = "400"
DropHighlight = VBFlexGridDropHighlight
End Property

Public Property Let DropHighlight(ByVal Value As Long)
If VBFlexGridDropHighlight = Value Then Exit Property
If VBFlexGridDropHighlightMode = FlexDropTargetModeByRow Then
    If Value <> -1 And (Value < 0 Or Value > (PropRows - 1)) Then Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridDropHighlightMode = FlexDropTargetModeByColumn Then
    If Value <> -1 And (Value < 0 Or Value > (PropCols - 1)) Then Err.Raise Number:=30010, Description:="Invalid Col value"
End If
VBFlexGridDropHighlight = Value
Call RedrawGrid
End Property

Public Property Get DropHighlightMode() As FlexDropTargetModeConstants
Attribute DropHighlightMode.VB_Description = "Returns/sets a value that determines whether a row or a column is used as a drop target."
Attribute DropHighlightMode.VB_MemberFlags = "400"
DropHighlightMode = VBFlexGridDropHighlightMode
End Property

Public Property Let DropHighlightMode(ByVal Value As FlexDropTargetModeConstants)
If VBFlexGridDropHighlightMode = Value Then Exit Property
Select Case Value
    Case FlexDropTargetModeByRow, FlexDropTargetModeByColumn
        VBFlexGridDropHighlightMode = Value
        VBFlexGridDropHighlight = -1
    Case Else
        Err.Raise 380
End Select
Call RedrawGrid
End Property

Public Property Get InsertMark(Optional ByRef After As Boolean) As Long
Attribute InsertMark.VB_Description = "Returns/sets the row or column where an insertion mark is positioned to indicate the target of a drag/drop operation."
Attribute InsertMark.VB_MemberFlags = "400"
InsertMark = VBFlexGridInsertMark
After = VBFlexGridInsertMarkAfter
End Property

Public Property Let InsertMark(Optional ByRef After As Boolean, ByVal Value As Long)
If VBFlexGridInsertMark = Value And VBFlexGridInsertMarkAfter = After Then Exit Property
If VBFlexGridInsertMarkMode = FlexDropTargetModeByRow Then
    If Value <> -1 And (Value < 0 Or Value > (PropRows - 1)) Then Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridDropHighlightMode = FlexDropTargetModeByColumn Then
    If Value <> -1 And (Value < 0 Or Value > (PropCols - 1)) Then Err.Raise Number:=30010, Description:="Invalid Col value"
End If
VBFlexGridInsertMark = Value
VBFlexGridInsertMarkAfter = After
Call RedrawGrid
End Property

Public Property Get InsertMarkMode() As FlexDropTargetModeConstants
Attribute InsertMarkMode.VB_Description = "Returns/sets a value that determines whether a row or a column is used as a drop target."
Attribute InsertMarkMode.VB_MemberFlags = "400"
InsertMarkMode = VBFlexGridInsertMarkMode
End Property

Public Property Let InsertMarkMode(ByVal Value As FlexDropTargetModeConstants)
If VBFlexGridInsertMarkMode = Value Then Exit Property
Select Case Value
    Case FlexDropTargetModeByRow, FlexDropTargetModeByColumn
        VBFlexGridInsertMarkMode = Value
        VBFlexGridInsertMark = -1
        VBFlexGridInsertMarkAfter = False
    Case Else
        Err.Raise 380
End Select
Call RedrawGrid
End Property

Public Property Get RowPos(ByVal Index As Long) As Long
Attribute RowPos.VB_Description = "Returns the distance in twips between the upper-left corner of the control and the upper-left corner of a specified row."
Attribute RowPos.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropRows - 1) Then Err.Raise Number:=30009, Description:="Invalid Row value"
Dim i As Long, Value As Long
If Index > ((PropFixedRows + PropFrozenRows) - 1) Then
    For i = 0 To ((PropFixedRows + PropFrozenRows) - 1)
        If i < Index Then Value = Value + GetRowHeight(i)
    Next i
    For i = VBFlexGridTopRow To (Index - 1)
        Value = Value + GetRowHeight(i)
    Next i
    If Index < VBFlexGridTopRow Then
        For i = (PropFixedRows + PropFrozenRows) To (VBFlexGridTopRow - 1)
            Value = Value - GetRowHeight(i)
        Next i
    End If
Else
    For i = 0 To (Index - 1)
        Value = Value + GetRowHeight(i)
    Next i
End If
RowPos = UserControl.ScaleY(Value, vbPixels, vbTwips)
End Property

Public Property Get RowPosition(ByVal Index As Long) As Long
Attribute RowPosition.VB_Description = "Sets the position of an row, allowing you to move rows to specific positions."
Attribute RowPosition.VB_MemberFlags = "400"
Err.Raise Number:=394, Description:="Property is write-only"
End Property

Public Property Let RowPosition(ByVal Index As Long, ByVal Value As Long)
If (Index < 0 Or Index > (PropRows - 1)) Or (Value < 0 Or Value > (PropRows - 1)) Then Err.Raise Number:=381, Description:="Subscript out of range"
If Index = Value Then Exit Property
Dim iRow As Long, Swap As TCOLS, Length As Long
Length = LenB(Swap)
With VBFlexGridCells
CopyMemory ByVal VarPtr(Swap), ByVal VarPtr(.Rows(Index)), Length
If Index > Value Then
    For iRow = Index To (Value + 1) Step -1
        CopyMemory ByVal VarPtr(.Rows(iRow)), ByVal VarPtr(.Rows(iRow - 1)), Length
    Next iRow
ElseIf Index < Value Then
    For iRow = Index To (Value - 1)
        CopyMemory ByVal VarPtr(.Rows(iRow)), ByVal VarPtr(.Rows(iRow + 1)), Length
    Next iRow
End If
CopyMemory ByVal VarPtr(.Rows(Value)), ByVal VarPtr(Swap), Length
ZeroMemory ByVal VarPtr(Swap), Length
End With
If VBFlexGridSelectedRows > 0 Then
    Erase VBFlexGridSelectedRowIndices()
    VBFlexGridSelectedRows = 0
End If
Dim RCP As TROWCOLPARAMS
With RCP
.Mask = RCPM_TOPROW
.Flags = RCPF_CHECKTOPROW Or RCPF_FORCETOPROWMASK Or RCPF_SETSCROLLBARS Or RCPF_FORCEREDRAW
.TopRow = VBFlexGridTopRow
Call SetRowColParams(RCP)
End With
End Property

Public Property Get RowHeight(ByVal Index As Long) As Long
Attribute RowHeight.VB_Description = "Returns/sets the height in twips of the specified row."
Attribute RowHeight.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropRows - 1) Then Err.Raise Number:=30009, Description:="Invalid Row value"
RowHeight = UserControl.ScaleY(GetRowHeight(Index), vbPixels, vbTwips)
End Property

Public Property Let RowHeight(ByVal Index As Long, ByVal Value As Long)
If Index <> -1 And (Index < 0 Or Index > (PropRows - 1)) Then Err.Raise Number:=30009, Description:="Invalid Row value"
If Value < -1 Then Err.Raise Number:=30013, Description:="Invalid Row Height value"
If Index > -1 Then
    If Value > -1 Then
        VBFlexGridCells.Rows(Index).RowInfo.Height = UserControl.ScaleY(Value, vbTwips, vbPixels)
    Else
        VBFlexGridCells.Rows(Index).RowInfo.Height = -1
    End If
Else
    Dim i As Long
    For i = 0 To (PropRows - 1)
        If Value > -1 Then
            VBFlexGridCells.Rows(i).RowInfo.Height = UserControl.ScaleY(Value, vbTwips, vbPixels)
        Else
            VBFlexGridCells.Rows(i).RowInfo.Height = -1
        End If
    Next i
End If
Dim RCP As TROWCOLPARAMS
With RCP
.Mask = RCPM_TOPROW
.Flags = RCPF_CHECKTOPROW Or RCPF_FORCETOPROWMASK Or RCPF_SETSCROLLBARS Or RCPF_FORCEREDRAW
.TopRow = VBFlexGridTopRow
Call SetRowColParams(RCP)
End With
End Property

Public Property Get RowHeightUniform() As Long
Attribute RowHeightUniform.VB_Description = "Returns/sets a uniform row height in twips for all rows that do not have specific height assigned to them."
Attribute RowHeightUniform.VB_MemberFlags = "400"
If VBFlexGridUniformRowHeight > -1 Then
    RowHeightUniform = UserControl.ScaleY(VBFlexGridUniformRowHeight, vbPixels, vbTwips)
Else
    RowHeightUniform = -1
End If
End Property

Public Property Let RowHeightUniform(ByVal Value As Long)
If Value < -1 Then Err.Raise Number:=30013, Description:="Invalid Row Height value"
If Value > -1 Then
    VBFlexGridUniformRowHeight = UserControl.ScaleY(Value, vbTwips, vbPixels)
Else
    VBFlexGridUniformRowHeight = -1
End If
Dim RCP As TROWCOLPARAMS
With RCP
.Mask = RCPM_TOPROW
.Flags = RCPF_CHECKTOPROW Or RCPF_FORCETOPROWMASK Or RCPF_SETSCROLLBARS Or RCPF_FORCEREDRAW
.TopRow = VBFlexGridTopRow
Call SetRowColParams(RCP)
End With
End Property

#If VBA7 Then
Public Property Get RowData(ByVal Index As Long) As LongPtr
Attribute RowData.VB_Description = "Array of long integer values with one item for each row (RowData) and for each column (ColData) of the flex grid."
Attribute RowData.VB_MemberFlags = "400"
#Else
Public Property Get RowData(ByVal Index As Long) As Long
Attribute RowData.VB_Description = "Array of long integer values with one item for each row (RowData) and for each column (ColData) of the flex grid."
Attribute RowData.VB_MemberFlags = "400"
#End If
If Index < 0 Or Index > (PropRows - 1) Then Err.Raise Number:=30009, Description:="Invalid Row value"
RowData = VBFlexGridCells.Rows(Index).RowInfo.Data
End Property

#If VBA7 Then
Public Property Let RowData(ByVal Index As Long, ByVal Value As LongPtr)
#Else
Public Property Let RowData(ByVal Index As Long, ByVal Value As Long)
#End If
If Index < 0 Or Index > (PropRows - 1) Then Err.Raise Number:=30009, Description:="Invalid Row value"
VBFlexGridCells.Rows(Index).RowInfo.Data = Value
End Property

Public Property Get RowHidden(ByVal Index As Long) As Boolean
Attribute RowHidden.VB_Description = "Returns/sets a value indicating if the specified row is hidden."
Attribute RowHidden.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropRows - 1) Then Err.Raise Number:=30009, Description:="Invalid Row value"
RowHidden = CBool((VBFlexGridCells.Rows(Index).RowInfo.State And RWIS_HIDDEN) = RWIS_HIDDEN)
End Property

Public Property Let RowHidden(ByVal Index As Long, ByVal Value As Boolean)
If Index <> -1 And (Index < 0 Or Index > (PropRows - 1)) Then Err.Raise Number:=30009, Description:="Invalid Row value"
If Index > -1 Then
    With VBFlexGridCells.Rows(Index).RowInfo
    If Value = True Then
        If (.State And RWIS_HIDDEN) = 0 Then .State = .State Or RWIS_HIDDEN
    Else
        If (.State And RWIS_HIDDEN) = RWIS_HIDDEN Then .State = .State And Not RWIS_HIDDEN
    End If
    End With
Else
    Dim i As Long
    If Value = True Then
        For i = 0 To (PropRows - 1)
            With VBFlexGridCells.Rows(i).RowInfo
            If (.State And RWIS_HIDDEN) = 0 Then .State = .State Or RWIS_HIDDEN
            End With
        Next i
    Else
        For i = 0 To (PropRows - 1)
            With VBFlexGridCells.Rows(i).RowInfo
            If (.State And RWIS_HIDDEN) = RWIS_HIDDEN Then .State = .State And Not RWIS_HIDDEN
            End With
        Next i
    End If
End If
Dim RCP As TROWCOLPARAMS
With RCP
.Mask = RCPM_TOPROW
.Flags = RCPF_CHECKTOPROW Or RCPF_FORCETOPROWMASK Or RCPF_SETSCROLLBARS Or RCPF_FORCEREDRAW
.TopRow = VBFlexGridTopRow
Call SetRowColParams(RCP)
End With
End Property

Public Property Get RowSelected(ByVal Index As Long) As Boolean
Attribute RowSelected.VB_Description = "Returns/sets a value indicating if the specified row is selected for multiple (non-contiguous) selections."
Attribute RowSelected.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropRows - 1) Then Err.Raise Number:=30009, Description:="Invalid Row value"
RowSelected = CBool((VBFlexGridCells.Rows(Index).RowInfo.State And RWIS_SELECTED) = RWIS_SELECTED)
End Property

Public Property Let RowSelected(ByVal Index As Long, ByVal Value As Boolean)
If Index <> -1 And (Index < 0 Or Index > (PropRows - 1)) Then Err.Raise Number:=30009, Description:="Invalid Row value"
If Index > -1 Then
    With VBFlexGridCells.Rows(Index).RowInfo
    If Value = True Then
        If (.State And RWIS_SELECTED) = 0 Then .State = .State Or RWIS_SELECTED
    Else
        If (.State And RWIS_SELECTED) = RWIS_SELECTED Then .State = .State And Not RWIS_SELECTED
    End If
    End With
Else
    Dim i As Long
    If Value = True Then
        For i = 0 To (PropRows - 1)
            With VBFlexGridCells.Rows(i).RowInfo
            If (.State And RWIS_SELECTED) = 0 Then .State = .State Or RWIS_SELECTED
            End With
        Next i
    Else
        For i = 0 To (PropRows - 1)
            With VBFlexGridCells.Rows(i).RowInfo
            If (.State And RWIS_SELECTED) = RWIS_SELECTED Then .State = .State And Not RWIS_SELECTED
            End With
        Next i
    End If
End If
If VBFlexGridSelectedRows > 0 Then
    Erase VBFlexGridSelectedRowIndices()
    VBFlexGridSelectedRows = 0
End If
Call RedrawGrid
End Property

Public Property Get SelectedRow(ByVal Index As Long) As Long
Attribute SelectedRow.VB_Description = "Returns the position of a selected row for multiple (non-contiguous) selections."
Attribute SelectedRow.VB_MemberFlags = "400"
SelectedRow = -1
If VBFlexGridSelectedRows > 0 Then
    If Index >= 0 And Index <= (VBFlexGridSelectedRows - 1) Then SelectedRow = VBFlexGridSelectedRowIndices(Index)
Else
    Dim i As Long, Count As Long
    If VBFlexGridExpandSelectedRows = False Then
        For i = 0 To (PropRows - 1)
            If (VBFlexGridCells.Rows(i).RowInfo.State And RWIS_SELECTED) = RWIS_SELECTED Then
                If Count = Index Then
                    SelectedRow = i
                    Exit For
                End If
                Count = Count + 1
            End If
        Next i
    Else
        Dim SelRange As TCELLRANGE
        Call GetSelRangeStruct(SelRange)
        If VBFlexGridInvertSelection = False Then
            For i = 0 To (PropRows - 1)
                If (VBFlexGridCells.Rows(i).RowInfo.State And RWIS_SELECTED) = RWIS_SELECTED Or (i >= SelRange.TopRow And i <= SelRange.BottomRow) Then
                    If Count = Index Then
                        SelectedRow = i
                        Exit For
                    End If
                    Count = Count + 1
                End If
            Next i
        Else
            For i = 0 To (PropRows - 1)
                If (VBFlexGridCells.Rows(i).RowInfo.State And RWIS_SELECTED) = RWIS_SELECTED And Not (i >= SelRange.TopRow And i <= SelRange.BottomRow) Then
                    If Count = Index Then
                        SelectedRow = i
                        Exit For
                    End If
                    Count = Count + 1
                End If
            Next i
        End If
    End If
End If
End Property

Public Property Get SelectedRows() As Long
Attribute SelectedRows.VB_Description = "Returns the number of selected rows for multiple (non-contiguous) selections."
Attribute SelectedRows.VB_MemberFlags = "400"
Dim i As Long, Count As Long
If VBFlexGridExpandSelectedRows = False Then
    For i = 0 To (PropRows - 1)
        If (VBFlexGridCells.Rows(i).RowInfo.State And RWIS_SELECTED) = RWIS_SELECTED Then Count = Count + 1
    Next i
Else
    Dim SelRange As TCELLRANGE
    Call GetSelRangeStruct(SelRange)
    If VBFlexGridInvertSelection = False Then
        For i = 0 To (PropRows - 1)
            If (VBFlexGridCells.Rows(i).RowInfo.State And RWIS_SELECTED) = RWIS_SELECTED Or (i >= SelRange.TopRow And i <= SelRange.BottomRow) Then Count = Count + 1
        Next i
    Else
        For i = 0 To (PropRows - 1)
            If (VBFlexGridCells.Rows(i).RowInfo.State And RWIS_SELECTED) = RWIS_SELECTED And Not (i >= SelRange.TopRow And i <= SelRange.BottomRow) Then Count = Count + 1
        Next i
    End If
End If
If VBFlexGridSelectedRows = 0 And Count > 0 Then
    ReDim VBFlexGridSelectedRowIndices(0 To (Count - 1)) As Long
    Dim Index As Long
    If VBFlexGridExpandSelectedRows = False Then
        For i = 0 To (PropRows - 1)
            If (VBFlexGridCells.Rows(i).RowInfo.State And RWIS_SELECTED) = RWIS_SELECTED Then
                VBFlexGridSelectedRowIndices(Index) = i
                Index = Index + 1
            End If
        Next i
    Else
        If VBFlexGridInvertSelection = False Then
            For i = 0 To (PropRows - 1)
                If (VBFlexGridCells.Rows(i).RowInfo.State And RWIS_SELECTED) = RWIS_SELECTED Or (i >= SelRange.TopRow And i <= SelRange.BottomRow) Then
                    VBFlexGridSelectedRowIndices(Index) = i
                    Index = Index + 1
                End If
            Next i
        Else
            For i = 0 To (PropRows - 1)
                If (VBFlexGridCells.Rows(i).RowInfo.State And RWIS_SELECTED) = RWIS_SELECTED And Not (i >= SelRange.TopRow And i <= SelRange.BottomRow) Then
                    VBFlexGridSelectedRowIndices(Index) = i
                    Index = Index + 1
                End If
            Next i
        End If
    End If
    VBFlexGridSelectedRows = Count
End If
SelectedRows = Count
End Property

Public Property Get RowID(ByVal Index As Long) As Long
Attribute RowID.VB_Description = "Returns/sets an identification used to identify the specified row."
Attribute RowID.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropRows - 1) Then Err.Raise Number:=30009, Description:="Invalid Row value"
RowID = VBFlexGridCells.Rows(Index).RowInfo.ID
End Property

Public Property Let RowID(ByVal Index As Long, ByVal Value As Long)
If Index < 0 Or Index > (PropRows - 1) Then Err.Raise Number:=30009, Description:="Invalid Row value"
VBFlexGridCells.Rows(Index).RowInfo.ID = Value
End Property

Public Property Get RowIndex(ByVal ID As Long) As Long
Attribute RowIndex.VB_Description = "Returns a row index given its identification."
Attribute RowIndex.VB_MemberFlags = "400"
RowIndex = -1
Dim i As Long
With VBFlexGridCells
For i = 0 To (PropRows - 1)
    With .Rows(i).RowInfo
    If .ID = ID And .ID <> 0 Then
        RowIndex = i
        Exit For
    End If
    End With
Next i
End With
End Property

Public Property Let RowIndex(ByVal ID As Long, ByVal Value As Long)
Err.Raise Number:=383, Description:="Property is read-only"
End Property

Public Property Get RowResizable(ByVal Index As Long) As Boolean
Attribute RowResizable.VB_Description = "Returns/sets a value that determines whether the user can resize the specified row."
Attribute RowResizable.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropRows - 1) Then Err.Raise Number:=30009, Description:="Invalid Row value"
RowResizable = CBool((VBFlexGridCells.Rows(Index).RowInfo.State And RWIS_NOSIZING) = 0)
End Property

Public Property Let RowResizable(ByVal Index As Long, ByVal Value As Boolean)
If Index <> -1 And (Index < 0 Or Index > (PropRows - 1)) Then Err.Raise Number:=30009, Description:="Invalid Row value"
If Index > -1 Then
    With VBFlexGridCells.Rows(Index).RowInfo
    If Value = True Then
        If (.State And RWIS_NOSIZING) = RWIS_NOSIZING Then .State = .State And Not RWIS_NOSIZING
    Else
        If (.State And RWIS_NOSIZING) = 0 Then .State = .State Or RWIS_NOSIZING
    End If
    End With
Else
    Dim i As Long
    If Value = True Then
        For i = 0 To (PropRows - 1)
            With VBFlexGridCells.Rows(i).RowInfo
            If (.State And RWIS_NOSIZING) = RWIS_NOSIZING Then .State = .State And Not RWIS_NOSIZING
            End With
        Next i
    Else
        For i = 0 To (PropRows - 1)
            With VBFlexGridCells.Rows(i).RowInfo
            If (.State And RWIS_NOSIZING) = 0 Then .State = .State Or RWIS_NOSIZING
            End With
        Next i
    End If
End If
End Property

Public Property Get RowIsVisible(ByVal Index As Long, Optional ByVal Visibility As FlexVisibilityConstants) As Boolean
Attribute RowIsVisible.VB_Description = "Returns a value indicating if the specified row is visible."
Attribute RowIsVisible.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropRows - 1) Then Err.Raise Number:=30009, Description:="Invalid Row value"
Select Case Visibility
    Case FlexVisibilityPartialOK, FlexVisibilityCompleteOnly
    Case Else
        Err.Raise 380
End Select
If VBFlexGridHandle <> NULL_PTR Then
    Dim GridRect As RECT, iRow As Long
    With GridRect
    If Index <= ((PropFixedRows + PropFrozenRows) - 1) Then
        RowIsVisible = True
        For iRow = 0 To ((PropFixedRows + PropFrozenRows) - 1)
            If Visibility = FlexVisibilityCompleteOnly Then .Bottom = .Bottom + GetRowHeight(iRow)
            If .Bottom > VBFlexGridClientRect.Bottom Then
                RowIsVisible = False
                Exit For
            End If
            If Visibility = FlexVisibilityPartialOK Then .Bottom = .Bottom + GetRowHeight(iRow)
            If iRow >= Index Then Exit For
        Next iRow
    ElseIf Index >= VBFlexGridTopRow Then
        RowIsVisible = True
        For iRow = 0 To ((PropFixedRows + PropFrozenRows) - 1)
            .Bottom = .Bottom + GetRowHeight(iRow)
        Next iRow
        For iRow = VBFlexGridTopRow To (PropRows - 1)
            If Visibility = FlexVisibilityCompleteOnly Then .Bottom = .Bottom + GetRowHeight(iRow)
            If .Bottom > VBFlexGridClientRect.Bottom Then
                RowIsVisible = False
                Exit For
            End If
            If Visibility = FlexVisibilityPartialOK Then .Bottom = .Bottom + GetRowHeight(iRow)
            If iRow >= Index Then Exit For
        Next iRow
    End If
    End With
End If
End Property

Public Property Get RowsVisible(Optional ByVal Visibility As FlexVisibilityConstants = FlexVisibilityCompleteOnly) As Long
Attribute RowsVisible.VB_Description = "Returns the total number of columns or rows visible in the flex grid."
Attribute RowsVisible.VB_MemberFlags = "400"
Select Case Visibility
    Case FlexVisibilityPartialOK, FlexVisibilityCompleteOnly
    Case Else
        Err.Raise 380
End Select
If VBFlexGridHandle = NULL_PTR Or (PropRows < 1 Or PropCols < 1) Then Exit Property
Dim GridRect As RECT, iRow As Long, Count As Long
With GridRect
For iRow = 0 To ((PropFixedRows + PropFrozenRows) - 1)
    If Visibility = FlexVisibilityPartialOK Then If .Bottom > VBFlexGridClientRect.Bottom Then Exit For
    .Bottom = .Bottom + GetRowHeight(iRow)
    If Visibility = FlexVisibilityCompleteOnly Then If .Bottom > VBFlexGridClientRect.Bottom Then Exit For
    Count = Count + 1
Next iRow
For iRow = VBFlexGridTopRow To (PropRows - 1)
    If Visibility = FlexVisibilityPartialOK Then If .Bottom > VBFlexGridClientRect.Bottom Then Exit For
    .Bottom = .Bottom + GetRowHeight(iRow)
    If Visibility = FlexVisibilityCompleteOnly Then If .Bottom > VBFlexGridClientRect.Bottom Then Exit For
    Count = Count + 1
Next iRow
RowsVisible = Count
End With
End Property

Public Property Get FixedRowsVisible(Optional ByVal Visibility As FlexVisibilityConstants = FlexVisibilityCompleteOnly) As Long
Attribute FixedRowsVisible.VB_Description = "Returns the total number of fixed (non-scrollable) columns or rows visible in the flex grid."
Attribute FixedRowsVisible.VB_MemberFlags = "400"
Select Case Visibility
    Case FlexVisibilityPartialOK, FlexVisibilityCompleteOnly
    Case Else
        Err.Raise 380
End Select
If VBFlexGridHandle = NULL_PTR Or (PropRows < 1 Or PropCols < 1) Then Exit Property
Dim GridRect As RECT, iRow As Long, Count As Long
With GridRect
For iRow = 0 To (PropFixedRows - 1)
    If Visibility = FlexVisibilityPartialOK Then If .Bottom > VBFlexGridClientRect.Bottom Then Exit For
    .Bottom = .Bottom + GetRowHeight(iRow)
    If Visibility = FlexVisibilityCompleteOnly Then If .Bottom > VBFlexGridClientRect.Bottom Then Exit For
    Count = Count + 1
Next iRow
FixedRowsVisible = Count
End With
End Property

Public Property Get FrozenRowsVisible(Optional ByVal Visibility As FlexVisibilityConstants = FlexVisibilityCompleteOnly) As Long
Attribute FrozenRowsVisible.VB_Description = "Returns the total number of frozen (movable but non-scrollable) columns or rows visible in the flex grid."
Attribute FrozenRowsVisible.VB_MemberFlags = "400"
Select Case Visibility
    Case FlexVisibilityPartialOK, FlexVisibilityCompleteOnly
    Case Else
        Err.Raise 380
End Select
If VBFlexGridHandle = NULL_PTR Or (PropRows < 1 Or PropCols < 1) Then Exit Property
Dim GridRect As RECT, iRow As Long, Count As Long
With GridRect
For iRow = PropFixedRows To ((PropFixedRows + PropFrozenRows) - 1)
    If Visibility = FlexVisibilityPartialOK Then If .Bottom > VBFlexGridClientRect.Bottom Then Exit For
    .Bottom = .Bottom + GetRowHeight(iRow)
    If Visibility = FlexVisibilityCompleteOnly Then If .Bottom > VBFlexGridClientRect.Bottom Then Exit For
    Count = Count + 1
Next iRow
FrozenRowsVisible = Count
End With
End Property

Public Property Get RowsPerPage() As Long
Attribute RowsPerPage.VB_Description = "Returns the total number of non-fixed (scrollable) columns or rows displayed on the current page to scroll through in the flex grid."
Attribute RowsPerPage.VB_MemberFlags = "400"
RowsPerPage = GetRowsPerPage(VBFlexGridTopRow)
End Property

Public Property Get ColPos(ByVal Index As Long) As Long
Attribute ColPos.VB_Description = "Returns the distance in twips between the upper-left corner of the control and the upper-left corner of a specified column."
Attribute ColPos.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
Dim i As Long, Value As Long
If Index > ((PropFixedCols + PropFrozenCols) - 1) Then
    For i = 0 To ((PropFixedCols + PropFrozenCols) - 1)
        If i < Index Then Value = Value + GetColWidth(i)
    Next i
    For i = VBFlexGridLeftCol To (Index - 1)
        Value = Value + GetColWidth(i)
    Next i
    If Index < VBFlexGridLeftCol Then
        For i = (PropFixedCols + PropFrozenCols) To (VBFlexGridLeftCol - 1)
            Value = Value - GetColWidth(i)
        Next i
    End If
Else
    For i = 0 To (Index - 1)
        Value = Value + GetColWidth(i)
    Next i
End If
ColPos = UserControl.ScaleX(Value, vbPixels, vbTwips)
End Property

Public Property Get ColPosition(ByVal Index As Long) As Long
Attribute ColPosition.VB_Description = "Sets the position of an column, allowing you to move columns to specific positions."
Attribute ColPosition.VB_MemberFlags = "400"
Err.Raise Number:=394, Description:="Property is write-only"
End Property

Public Property Let ColPosition(ByVal Index As Long, ByVal Value As Long)
If (Index < 0 Or Index > (PropCols - 1)) Or (Value < 0 Or Value > (PropCols - 1)) Then Err.Raise Number:=381, Description:="Subscript out of range"
If Index = Value Then Exit Property
Dim iRow As Long, iCol As Long, Swap As TCELL, Length As Long, SwapColInfo As TCOLINFO
Length = LenB(Swap)
LSet SwapColInfo = VBFlexGridColsInfo(Index)
If Index > Value Then
    For iRow = 0 To (PropRows - 1)
        With VBFlexGridCells.Rows(iRow)
        CopyMemory ByVal VarPtr(Swap), ByVal VarPtr(.Cols(Index)), Length
        For iCol = Index To (Value + 1) Step -1
            CopyMemory ByVal VarPtr(.Cols(iCol)), ByVal VarPtr(.Cols(iCol - 1)), Length
        Next iCol
        CopyMemory ByVal VarPtr(.Cols(Value)), ByVal VarPtr(Swap), Length
        ZeroMemory ByVal VarPtr(Swap), Length
        End With
    Next iRow
    For iCol = Index To (Value + 1) Step -1
        LSet VBFlexGridColsInfo(iCol) = VBFlexGridColsInfo(iCol - 1)
    Next iCol
ElseIf Index < Value Then
    For iRow = 0 To (PropRows - 1)
        With VBFlexGridCells.Rows(iRow)
        CopyMemory ByVal VarPtr(Swap), ByVal VarPtr(.Cols(Index)), Length
        For iCol = Index To (Value - 1)
            CopyMemory ByVal VarPtr(.Cols(iCol)), ByVal VarPtr(.Cols(iCol + 1)), Length
        Next iCol
        CopyMemory ByVal VarPtr(.Cols(Value)), ByVal VarPtr(Swap), Length
        ZeroMemory ByVal VarPtr(Swap), Length
        End With
    Next iRow
    For iCol = Index To (Value - 1)
        LSet VBFlexGridColsInfo(iCol) = VBFlexGridColsInfo(iCol + 1)
    Next iCol
End If
LSet VBFlexGridColsInfo(Value) = SwapColInfo
Dim RCP As TROWCOLPARAMS
With RCP
.Mask = RCPM_LEFTCOL
.Flags = RCPF_CHECKLEFTCOL Or RCPF_FORCELEFTCOLMASK Or RCPF_SETSCROLLBARS Or RCPF_FORCEREDRAW
.LeftCol = VBFlexGridLeftCol
Call SetRowColParams(RCP)
End With
End Property

Public Property Get ColWidth(ByVal Index As Long) As Long
Attribute ColWidth.VB_Description = "Returns/sets the width in twips of the specified column."
Attribute ColWidth.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
ColWidth = UserControl.ScaleX(GetColWidth_NoExtendLastCol(Index), vbPixels, vbTwips)
End Property

Public Property Let ColWidth(ByVal Index As Long, ByVal Value As Long)
If Index <> -1 And (Index < 0 Or Index > (PropCols - 1)) Then Err.Raise Number:=30010, Description:="Invalid Col value"
If Value < -1 Then Err.Raise Number:=30014, Description:="Invalid Col Width value"
If Index > -1 Then
    If Value > -1 Then
        VBFlexGridColsInfo(Index).Width = UserControl.ScaleX(Value, vbTwips, vbPixels)
    Else
        VBFlexGridColsInfo(Index).Width = -1
    End If
Else
    Dim i As Long
    For i = 0 To (PropCols - 1)
        If Value > -1 Then
            VBFlexGridColsInfo(i).Width = UserControl.ScaleX(Value, vbTwips, vbPixels)
        Else
            VBFlexGridColsInfo(i).Width = -1
        End If
    Next i
End If
If Index > -1 And VBFlexGridExtendLastCol > -1 Then
    If Index >= VBFlexGridExtendLastCol Then VBFlexGridExtendLastCol = GetExtendLastCol()
Else
    VBFlexGridExtendLastCol = GetExtendLastCol()
End If
Dim RCP As TROWCOLPARAMS
With RCP
.Mask = RCPM_LEFTCOL
.Flags = RCPF_CHECKLEFTCOL Or RCPF_FORCELEFTCOLMASK Or RCPF_SETSCROLLBARS Or RCPF_FORCEREDRAW
.LeftCol = VBFlexGridLeftCol
Call SetRowColParams(RCP)
End With
End Property

#If VBA7 Then
Public Property Get ColData(ByVal Index As Long) As LongPtr
Attribute ColData.VB_Description = "Array of long integer values with one item for each row (RowData) and for each column (ColData) of the flex grid."
Attribute ColData.VB_MemberFlags = "400"
#Else
Public Property Get ColData(ByVal Index As Long) As Long
Attribute ColData.VB_Description = "Array of long integer values with one item for each row (RowData) and for each column (ColData) of the flex grid."
Attribute ColData.VB_MemberFlags = "400"
#End If
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
ColData = VBFlexGridColsInfo(Index).Data
End Property

#If VBA7 Then
Public Property Let ColData(ByVal Index As Long, ByVal Value As LongPtr)
#Else
Public Property Let ColData(ByVal Index As Long, ByVal Value As Long)
#End If
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
VBFlexGridColsInfo(Index).Data = Value
End Property

Public Property Get ColHidden(ByVal Index As Long) As Boolean
Attribute ColHidden.VB_Description = "Returns/sets a value indicating if the specified column is hidden."
Attribute ColHidden.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
ColHidden = CBool((VBFlexGridColsInfo(Index).State And CLIS_HIDDEN) = CLIS_HIDDEN)
End Property

Public Property Let ColHidden(ByVal Index As Long, ByVal Value As Boolean)
If Index <> -1 And (Index < 0 Or Index > (PropCols - 1)) Then Err.Raise Number:=30010, Description:="Invalid Col value"
If Index > -1 Then
    With VBFlexGridColsInfo(Index)
    If Value = True Then
        If (.State And CLIS_HIDDEN) = 0 Then .State = .State Or CLIS_HIDDEN
    Else
        If (.State And CLIS_HIDDEN) = CLIS_HIDDEN Then .State = .State And Not CLIS_HIDDEN
    End If
    End With
Else
    Dim i As Long
    If Value = True Then
        For i = 0 To (PropCols - 1)
            With VBFlexGridColsInfo(i)
            If (.State And CLIS_HIDDEN) = 0 Then .State = .State Or CLIS_HIDDEN
            End With
        Next i
    Else
        For i = 0 To (PropCols - 1)
            With VBFlexGridColsInfo(i)
            If (.State And CLIS_HIDDEN) = CLIS_HIDDEN Then .State = .State And Not CLIS_HIDDEN
            End With
        Next i
    End If
End If
If Index > -1 And VBFlexGridExtendLastCol > -1 Then
    If Index >= VBFlexGridExtendLastCol Then VBFlexGridExtendLastCol = GetExtendLastCol()
Else
    VBFlexGridExtendLastCol = GetExtendLastCol()
End If
Dim RCP As TROWCOLPARAMS
With RCP
.Mask = RCPM_LEFTCOL
.Flags = RCPF_CHECKLEFTCOL Or RCPF_FORCELEFTCOLMASK Or RCPF_SETSCROLLBARS Or RCPF_FORCEREDRAW
.LeftCol = VBFlexGridLeftCol
Call SetRowColParams(RCP)
End With
End Property

Public Property Get ColKey(ByVal Index As Long) As String
Attribute ColKey.VB_Description = "Returns/sets a key used to identify the specified column."
Attribute ColKey.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
ColKey = VBFlexGridColsInfo(Index).Key
End Property

Public Property Let ColKey(ByVal Index As Long, ByVal Value As String)
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
VBFlexGridColsInfo(Index).Key = Value
End Property

Public Property Get ColIndex(ByVal Key As String) As Long
Attribute ColIndex.VB_Description = "Returns a column index given its key."
Attribute ColIndex.VB_MemberFlags = "400"
ColIndex = -1
Dim i As Long
For i = 0 To (PropCols - 1)
    If Not VBFlexGridColsInfo(i).Key = vbNullString Then
        If StrComp(VBFlexGridColsInfo(i).Key, Key, vbTextCompare) = 0 Then
            ColIndex = i
            Exit For
        End If
    End If
Next i
End Property

Public Property Let ColIndex(ByVal Key As String, ByVal Value As Long)
Err.Raise Number:=383, Description:="Property is read-only"
End Property

Public Property Get ColIsVisible(ByVal Index As Long, Optional ByVal Visibility As FlexVisibilityConstants) As Boolean
Attribute ColIsVisible.VB_Description = "Returns a value indicating if the specified column is visible."
Attribute ColIsVisible.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
Select Case Visibility
    Case FlexVisibilityPartialOK, FlexVisibilityCompleteOnly
    Case Else
        Err.Raise 380
End Select
If VBFlexGridHandle <> NULL_PTR Then
    Dim GridRect As RECT, iCol As Long
    With GridRect
    If Index <= ((PropFixedCols + PropFrozenCols) - 1) Then
        ColIsVisible = True
        For iCol = 0 To ((PropFixedCols + PropFrozenCols) - 1)
            If Visibility = FlexVisibilityCompleteOnly Then .Right = .Right + GetColWidth(iCol)
            If .Right > VBFlexGridClientRect.Right Then
                ColIsVisible = False
                Exit For
            End If
            If Visibility = FlexVisibilityPartialOK Then .Right = .Right + GetColWidth(iCol)
            If iCol >= Index Then Exit For
        Next iCol
    ElseIf Index >= VBFlexGridLeftCol Then
        ColIsVisible = True
        For iCol = 0 To ((PropFixedCols + PropFrozenCols) - 1)
            .Right = .Right + GetColWidth(iCol)
        Next iCol
        For iCol = VBFlexGridLeftCol To (PropCols - 1)
            If Visibility = FlexVisibilityCompleteOnly Then .Right = .Right + GetColWidth(iCol)
            If .Right > VBFlexGridClientRect.Right Then
                ColIsVisible = False
                Exit For
            End If
            If Visibility = FlexVisibilityPartialOK Then .Right = .Right + GetColWidth(iCol)
            If iCol >= Index Then Exit For
        Next iCol
    End If
    End With
End If
End Property

Public Property Get ColsVisible(Optional ByVal Visibility As FlexVisibilityConstants = FlexVisibilityCompleteOnly) As Long
Attribute ColsVisible.VB_Description = "Returns the total number of columns or rows visible in the flex grid."
Attribute ColsVisible.VB_MemberFlags = "400"
Select Case Visibility
    Case FlexVisibilityPartialOK, FlexVisibilityCompleteOnly
    Case Else
        Err.Raise 380
End Select
If VBFlexGridHandle = NULL_PTR Or (PropRows < 1 Or PropCols < 1) Then Exit Property
Dim GridRect As RECT, iCol As Long, Count As Long
With GridRect
For iCol = 0 To ((PropFixedCols + PropFrozenCols) - 1)
    If Visibility = FlexVisibilityPartialOK Then If .Right > VBFlexGridClientRect.Right Then Exit For
    .Right = .Right + GetColWidth(iCol)
    If Visibility = FlexVisibilityCompleteOnly Then If .Right > VBFlexGridClientRect.Right Then Exit For
    Count = Count + 1
Next iCol
For iCol = VBFlexGridLeftCol To (PropCols - 1)
    If Visibility = FlexVisibilityPartialOK Then If .Right > VBFlexGridClientRect.Right Then Exit For
    .Right = .Right + GetColWidth(iCol)
    If Visibility = FlexVisibilityCompleteOnly Then If .Right > VBFlexGridClientRect.Right Then Exit For
    Count = Count + 1
Next iCol
ColsVisible = Count
End With
End Property

Public Property Get FixedColsVisible(Optional ByVal Visibility As FlexVisibilityConstants = FlexVisibilityCompleteOnly) As Long
Attribute FixedColsVisible.VB_Description = "Returns the total number of fixed (non-scrollable) columns or rows visible in the flex grid."
Attribute FixedColsVisible.VB_MemberFlags = "400"
Select Case Visibility
    Case FlexVisibilityPartialOK, FlexVisibilityCompleteOnly
    Case Else
        Err.Raise 380
End Select
If VBFlexGridHandle = NULL_PTR Or (PropRows < 1 Or PropCols < 1) Then Exit Property
Dim GridRect As RECT, iCol As Long, Count As Long
With GridRect
For iCol = 0 To (PropFixedCols - 1)
    If Visibility = FlexVisibilityPartialOK Then If .Right > VBFlexGridClientRect.Right Then Exit For
    .Right = .Right + GetColWidth(iCol)
    If Visibility = FlexVisibilityCompleteOnly Then If .Right > VBFlexGridClientRect.Right Then Exit For
    Count = Count + 1
Next iCol
FixedColsVisible = Count
End With
End Property

Public Property Get FrozenColsVisible(Optional ByVal Visibility As FlexVisibilityConstants = FlexVisibilityCompleteOnly) As Long
Attribute FrozenColsVisible.VB_Description = "Returns the total number of frozen (movable but non-scrollable) columns or rows visible in the flex grid."
Attribute FrozenColsVisible.VB_MemberFlags = "400"
Select Case Visibility
    Case FlexVisibilityPartialOK, FlexVisibilityCompleteOnly
    Case Else
        Err.Raise 380
End Select
If VBFlexGridHandle = NULL_PTR Or (PropRows < 1 Or PropCols < 1) Then Exit Property
Dim GridRect As RECT, iCol As Long, Count As Long
With GridRect
For iCol = PropFixedCols To ((PropFixedCols + PropFrozenCols) - 1)
    If Visibility = FlexVisibilityPartialOK Then If .Right > VBFlexGridClientRect.Right Then Exit For
    .Right = .Right + GetColWidth(iCol)
    If Visibility = FlexVisibilityCompleteOnly Then If .Right > VBFlexGridClientRect.Right Then Exit For
    Count = Count + 1
Next iCol
FrozenColsVisible = Count
End With
End Property

Public Property Get ColsPerPage() As Long
Attribute ColsPerPage.VB_Description = "Returns the total number of non-fixed (scrollable) columns or rows displayed on the current page to scroll through in the flex grid."
Attribute ColsPerPage.VB_MemberFlags = "400"
ColsPerPage = GetColsPerPage(VBFlexGridLeftCol)
End Property

Public Property Get ColAlignment(ByVal Index As Long) As FlexAlignmentConstants
Attribute ColAlignment.VB_Description = "Returns/sets the alignment of data in a column. Indirectly available at design time through the format string property."
Attribute ColAlignment.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30004, Description:="Invalid Col value for alignment"
ColAlignment = VBFlexGridColsInfo(Index).Alignment
End Property

Public Property Let ColAlignment(ByVal Index As Long, ByVal Value As FlexAlignmentConstants)
If Index <> -1 And (Index < 0 Or Index > (PropCols - 1)) Then Err.Raise Number:=30004, Description:="Invalid Col value for alignment"
Select Case Value
    Case FlexAlignmentLeftTop, FlexAlignmentLeftCenter, FlexAlignmentLeftBottom, FlexAlignmentCenterTop, FlexAlignmentCenterCenter, FlexAlignmentCenterBottom, FlexAlignmentRightTop, FlexAlignmentRightCenter, FlexAlignmentRightBottom, FlexAlignmentGeneral, FlexAlignmentGeneralTop, FlexAlignmentGeneralCenter, FlexAlignmentGeneralBottom
    Case Else
        Err.Raise Number:=30005, Description:="Invalid Alignment value"
End Select
If Index > -1 Then
    VBFlexGridColsInfo(Index).Alignment = Value
Else
    Dim i As Long
    For i = 0 To (PropCols - 1)
        VBFlexGridColsInfo(i).Alignment = Value
    Next i
End If
Call RedrawGrid
End Property

Public Property Get FixedAlignment(ByVal Index As Long) As FlexAlignmentConstants
Attribute FixedAlignment.VB_Description = "Returns/sets the alignment of data in the fixed cells of a column."
Attribute FixedAlignment.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30004, Description:="Invalid Col value for alignment"
If VBFlexGridColsInfo(Index).FixedAlignment = -1 Then
    FixedAlignment = VBFlexGridColsInfo(Index).Alignment
Else
    FixedAlignment = VBFlexGridColsInfo(Index).FixedAlignment
End If
End Property

Public Property Let FixedAlignment(ByVal Index As Long, ByVal Value As FlexAlignmentConstants)
If Index <> -1 And (Index < 0 Or Index > (PropCols - 1)) Then Err.Raise Number:=30004, Description:="Invalid Col value for alignment"
Select Case Value
    Case -1, FlexAlignmentLeftTop, FlexAlignmentLeftCenter, FlexAlignmentLeftBottom, FlexAlignmentCenterTop, FlexAlignmentCenterCenter, FlexAlignmentCenterBottom, FlexAlignmentRightTop, FlexAlignmentRightCenter, FlexAlignmentRightBottom, FlexAlignmentGeneral, FlexAlignmentGeneralTop, FlexAlignmentGeneralCenter, FlexAlignmentGeneralBottom
    Case Else
        Err.Raise Number:=30005, Description:="Invalid Alignment value"
End Select
If Index > -1 Then
    VBFlexGridColsInfo(Index).FixedAlignment = Value
Else
    Dim i As Long
    For i = 0 To (PropCols - 1)
        VBFlexGridColsInfo(i).FixedAlignment = Value
    Next i
End If
Call RedrawGrid
End Property

Public Property Get ColImageList(ByVal Index As Long) As Variant
Attribute ColImageList.VB_Description = "Returns/sets the image list control or handle to be used for the specified column."
Attribute ColImageList.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
With VBFlexGridColsInfo(Index).ImageList
If .ObjectPointer <> NULL_PTR Then
    Set ColImageList = PtrToObj(.ObjectPointer)
ElseIf .Handle <> NULL_PTR Then
    ColImageList = .Handle
Else
    ColImageList = Empty
End If
End With
End Property

Public Property Set ColImageList(ByVal Index As Long, ByVal Value As Variant)
Me.ColImageList(Index) = Value
End Property

Public Property Let ColImageList(ByVal Index As Long, ByVal Value As Variant)
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
With VBFlexGridColsInfo(Index).ImageList
Dim Success As Boolean, Handle As LongPtr
If IsObject(Value) Then
    If Not Value Is Nothing Then
        If TypeName(Value) = "ImageList" Then
            On Error Resume Next
            Handle = Value.hImageList
            Success = CBool(Err.Number = 0 And Handle <> NULL_PTR)
            On Error GoTo 0
        Else
            Err.Raise Number:=35610, Description:="Invalid object"
        End If
    End If
    If Success = True Then
        .ObjectPointer = ObjPtr(Value)
        .Handle = Handle
        If ImageList_GetIconSize(.Handle, .Size.CX, .Size.CY) = 0 Then Success = False
    End If
Else
    Select Case VarType(Value)
        Case vbLong, &H14 ' vbLongLong
            Handle = Value
            Success = CBool(Handle <> NULL_PTR)
            If Success = True Then
                .ObjectPointer = NULL_PTR
                .Handle = Handle
                If ImageList_GetIconSize(.Handle, .Size.CX, .Size.CY) = 0 Then Success = False
            End If
        Case vbEmpty
        Case Else
            Err.Raise 13
    End Select
End If
If Success = False Then
    .ObjectPointer = NULL_PTR
    .Handle = NULL_PTR
    .Size.CX = 0
    .Size.CY = 0
End If
End With
Call RedrawGrid
End Property

Public Property Get ColWordWrapOption(ByVal Index As Long) As FlexWordWrapOptions
Attribute ColWordWrapOption.VB_Description = "Returns/sets how the text is displayed per column."
Attribute ColWordWrapOption.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
If VBFlexGridColsInfo(Index).WordWrapOption = -1 Then
    If PropWordWrap = True Then
        Select Case PropEllipsisFormat
            Case FlexEllipsisFormatNone
                ColWordWrapOption = FlexWordBreak
            Case FlexEllipsisFormatEnd
                ColWordWrapOption = FlexWordBreakEndEllipsis
            Case FlexEllipsisFormatPath
                ColWordWrapOption = FlexWordBreakPathEllipsis
            Case FlexEllipsisFormatWord
                ColWordWrapOption = FlexWordBreakWordEllipsis
        End Select
    ElseIf PropSingleLine = True Then
        Select Case PropEllipsisFormat
            Case FlexEllipsisFormatNone
                ColWordWrapOption = FlexSingleLine
            Case FlexEllipsisFormatEnd
                ColWordWrapOption = FlexSingleLineEndEllipsis
            Case FlexEllipsisFormatPath
                ColWordWrapOption = FlexSingleLinePathEllipsis
            Case FlexEllipsisFormatWord
                ColWordWrapOption = FlexSingleLineWordEllipsis
        End Select
    Else
        Select Case PropEllipsisFormat
            Case FlexEllipsisFormatNone
                ColWordWrapOption = FlexWordWrapNone
            Case FlexEllipsisFormatEnd
                ColWordWrapOption = FlexEndEllipsis
            Case FlexEllipsisFormatPath
                ColWordWrapOption = FlexPathEllipsis
            Case FlexEllipsisFormatWord
                ColWordWrapOption = FlexWordEllipsis
        End Select
    End If
Else
    ColWordWrapOption = VBFlexGridColsInfo(Index).WordWrapOption
End If
End Property

Public Property Let ColWordWrapOption(ByVal Index As Long, ByVal Value As FlexWordWrapOptions)
If Index <> -1 And (Index < 0 Or Index > (PropCols - 1)) Then Err.Raise Number:=30010, Description:="Invalid Col value"
Select Case Value
    Case -1, FlexWordWrapNone, FlexWordBreak, FlexSingleLine, FlexEndEllipsis, FlexPathEllipsis, FlexWordEllipsis, FlexWordBreakEndEllipsis, FlexWordBreakPathEllipsis, FlexWordBreakWordEllipsis, FlexSingleLineEndEllipsis, FlexSingleLinePathEllipsis, FlexSingleLineWordEllipsis
    Case Else
        Err.Raise 380
End Select
If Index > -1 Then
    VBFlexGridColsInfo(Index).WordWrapOption = Value
Else
    Dim i As Long
    For i = 0 To (PropCols - 1)
        VBFlexGridColsInfo(i).WordWrapOption = Value
    Next i
End If
Call RedrawGrid
End Property

Public Property Get ColWordWrapOptionFixed(ByVal Index As Long) As FlexWordWrapOptions
Attribute ColWordWrapOptionFixed.VB_Description = "Returns/sets how the text is displayed per column."
Attribute ColWordWrapOptionFixed.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
If VBFlexGridColsInfo(Index).WordWrapOptionFixed = -1 Then
    If PropWordWrap = True Then
        Select Case PropEllipsisFormatFixed
            Case FlexEllipsisFormatNone
                ColWordWrapOptionFixed = FlexWordBreak
            Case FlexEllipsisFormatEnd
                ColWordWrapOptionFixed = FlexWordBreakEndEllipsis
            Case FlexEllipsisFormatPath
                ColWordWrapOptionFixed = FlexWordBreakPathEllipsis
            Case FlexEllipsisFormatWord
                ColWordWrapOptionFixed = FlexWordBreakWordEllipsis
        End Select
    ElseIf PropSingleLine = True Then
        Select Case PropEllipsisFormatFixed
            Case FlexEllipsisFormatNone
                ColWordWrapOptionFixed = FlexSingleLine
            Case FlexEllipsisFormatEnd
                ColWordWrapOptionFixed = FlexSingleLineEndEllipsis
            Case FlexEllipsisFormatPath
                ColWordWrapOptionFixed = FlexSingleLinePathEllipsis
            Case FlexEllipsisFormatWord
                ColWordWrapOptionFixed = FlexSingleLineWordEllipsis
        End Select
    Else
        Select Case PropEllipsisFormatFixed
            Case FlexEllipsisFormatNone
                ColWordWrapOptionFixed = FlexWordWrapNone
            Case FlexEllipsisFormatEnd
                ColWordWrapOptionFixed = FlexEndEllipsis
            Case FlexEllipsisFormatPath
                ColWordWrapOptionFixed = FlexPathEllipsis
            Case FlexEllipsisFormatWord
                ColWordWrapOptionFixed = FlexWordEllipsis
        End Select
    End If
Else
    ColWordWrapOptionFixed = VBFlexGridColsInfo(Index).WordWrapOptionFixed
End If
End Property

Public Property Let ColWordWrapOptionFixed(ByVal Index As Long, ByVal Value As FlexWordWrapOptions)
If Index <> -1 And (Index < 0 Or Index > (PropCols - 1)) Then Err.Raise Number:=30010, Description:="Invalid Col value"
Select Case Value
    Case -1, FlexWordWrapNone, FlexWordBreak, FlexSingleLine, FlexEndEllipsis, FlexPathEllipsis, FlexWordEllipsis, FlexWordBreakEndEllipsis, FlexWordBreakPathEllipsis, FlexWordBreakWordEllipsis, FlexSingleLineEndEllipsis, FlexSingleLinePathEllipsis, FlexSingleLineWordEllipsis
    Case Else
        Err.Raise 380
End Select
If Index > -1 Then
    VBFlexGridColsInfo(Index).WordWrapOptionFixed = Value
Else
    Dim i As Long
    For i = 0 To (PropCols - 1)
        VBFlexGridColsInfo(i).WordWrapOptionFixed = Value
    Next i
End If
Call RedrawGrid
End Property

Public Property Get ColMimicTextBox(ByVal Index As Long) As FlexMimicTextBoxConstants
Attribute ColMimicTextBox.VB_Description = "Returns/sets a value that determines whether or not to mimic the text-displaying characteristics of a multiline text box for the specified column. This includes to break on characters instead on words. This is only meaningful if the word wrap property is set to true."
Attribute ColMimicTextBox.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
If VBFlexGridColsInfo(Index).MimicTextBox = -1 Then
    If PropMimicTextBox = True Then
        ColMimicTextBox = FlexMimicTextBoxOn
    Else
        ColMimicTextBox = FlexMimicTextBoxOff
    End If
Else
    ColMimicTextBox = VBFlexGridColsInfo(Index).MimicTextBox
End If
End Property

Public Property Let ColMimicTextBox(ByVal Index As Long, ByVal Value As FlexMimicTextBoxConstants)
If Index <> -1 And (Index < 0 Or Index > (PropCols - 1)) Then Err.Raise Number:=30010, Description:="Invalid Col value"
Select Case Value
    Case -1, FlexMimicTextBoxOn, FlexMimicTextBoxOff
    Case Else
        Err.Raise 380
End Select
If Index > -1 Then
    VBFlexGridColsInfo(Index).MimicTextBox = Value
Else
    Dim i As Long
    For i = 0 To (PropCols - 1)
        VBFlexGridColsInfo(i).MimicTextBox = Value
    Next i
End If
Call RedrawGrid
End Property

Public Property Get ColMimicTextBoxFixed(ByVal Index As Long) As FlexMimicTextBoxConstants
Attribute ColMimicTextBoxFixed.VB_Description = "Returns/sets a value that determines whether or not to mimic the text-displaying characteristics of a multiline text box for the specified column. This includes to break on characters instead on words. This is only meaningful if the word wrap property is set to true."
Attribute ColMimicTextBoxFixed.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
If VBFlexGridColsInfo(Index).MimicTextBoxFixed = -1 Then
    If PropMimicTextBox = True Then
        ColMimicTextBoxFixed = FlexMimicTextBoxOn
    Else
        ColMimicTextBoxFixed = FlexMimicTextBoxOff
    End If
Else
    ColMimicTextBoxFixed = VBFlexGridColsInfo(Index).MimicTextBoxFixed
End If
End Property

Public Property Let ColMimicTextBoxFixed(ByVal Index As Long, ByVal Value As FlexMimicTextBoxConstants)
If Index <> -1 And (Index < 0 Or Index > (PropCols - 1)) Then Err.Raise Number:=30010, Description:="Invalid Col value"
Select Case Value
    Case -1, FlexMimicTextBoxOn, FlexMimicTextBoxOff
    Case Else
        Err.Raise 380
End Select
If Index > -1 Then
    VBFlexGridColsInfo(Index).MimicTextBoxFixed = Value
Else
    Dim i As Long
    For i = 0 To (PropCols - 1)
        VBFlexGridColsInfo(i).MimicTextBoxFixed = Value
    Next i
End If
Call RedrawGrid
End Property

Public Property Get ColSort(ByVal Index As Long) As FlexSortConstants
Attribute ColSort.VB_Description = "Returns/sets the sorting order for the specified column. In order to perform the sort using the different sorting orders for each column, set the sort property to 'UseColSort'."
Attribute ColSort.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
ColSort = VBFlexGridColsInfo(Index).Sort
End Property

Public Property Let ColSort(ByVal Index As Long, ByVal Value As FlexSortConstants)
If Index <> -1 And (Index < 0 Or Index > (PropCols - 1)) Then Err.Raise Number:=30010, Description:="Invalid Col value"
Select Case Value
    Case FlexSortNone, FlexSortGenericAscending, FlexSortGenericDescending, FlexSortNumericAscending, FlexSortNumericDescending, FlexSortStringNoCaseAscending, FlexSortStringNoCaseDescending, FlexSortStringAscending, FlexSortStringDescending, FlexSortCustom, FlexSortCurrencyAscending, FlexSortCurrencyDescending, FlexSortDateAscending, FlexSortDateDescending, FlexSortCustomText
    Case Else
        Err.Raise 380
End Select
If Index > -1 Then
    VBFlexGridColsInfo(Index).Sort = Value
Else
    Dim i As Long
    For i = 0 To (PropCols - 1)
        VBFlexGridColsInfo(i).Sort = Value
    Next i
End If
End Property

Public Property Get ColSortMode(ByVal Index As Long) As FlexSortModeConstants
Attribute ColSortMode.VB_Description = "Returns/sets the sort mode for the specified column."
Attribute ColSortMode.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
ColSortMode = VBFlexGridColsInfo(Index).SortMode
End Property

Public Property Let ColSortMode(ByVal Index As Long, ByVal Value As FlexSortModeConstants)
If Index <> -1 And (Index < 0 Or Index > (PropCols - 1)) Then Err.Raise Number:=30010, Description:="Invalid Col value"
Select Case Value
    Case FlexSortModeNormal, FlexSortModeTextDisplay
    Case Else
        Err.Raise 380
End Select
If Index > -1 Then
    VBFlexGridColsInfo(Index).SortMode = Value
Else
    Dim i As Long
    For i = 0 To (PropCols - 1)
        VBFlexGridColsInfo(i).SortMode = Value
    Next i
End If
End Property

Public Property Get ColSortArrow(ByVal Index As Long) As FlexSortArrowConstants
Attribute ColSortArrow.VB_Description = "Returns/sets the sort arrow to be drawn for the specified column."
Attribute ColSortArrow.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
ColSortArrow = VBFlexGridColsInfo(Index).SortArrow
End Property

Public Property Let ColSortArrow(ByVal Index As Long, ByVal Value As FlexSortArrowConstants)
If Index <> -1 And (Index < 0 Or Index > (PropCols - 1)) Then Err.Raise Number:=30010, Description:="Invalid Col value"
Select Case Value
    Case FlexSortArrowNone, FlexSortArrowAscending, FlexSortArrowDescending
    Case Else
        Err.Raise 380
End Select
If Index > -1 Then
    VBFlexGridColsInfo(Index).SortArrow = Value
Else
    Dim i As Long
    For i = 0 To (PropCols - 1)
        VBFlexGridColsInfo(i).SortArrow = Value
    Next i
End If
Call RedrawGrid
End Property

Public Property Get ColSortArrowAlignment(ByVal Index As Long) As FlexLeftRightAlignmentConstants
Attribute ColSortArrowAlignment.VB_Description = "Returns/sets the sort arrow alignment for the specified column."
Attribute ColSortArrowAlignment.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
ColSortArrowAlignment = VBFlexGridColsInfo(Index).SortArrowAlignment
End Property

Public Property Let ColSortArrowAlignment(ByVal Index As Long, ByVal Value As FlexLeftRightAlignmentConstants)
If Index <> -1 And (Index < 0 Or Index > (PropCols - 1)) Then Err.Raise Number:=30010, Description:="Invalid Col value"
Select Case Value
    Case FlexLeftRightAlignmentLeft, FlexLeftRightAlignmentRight
    Case Else
        Err.Raise 380
End Select
If Index > -1 Then
    VBFlexGridColsInfo(Index).SortArrowAlignment = Value
Else
    Dim i As Long
    For i = 0 To (PropCols - 1)
        VBFlexGridColsInfo(i).SortArrowAlignment = Value
    Next i
End If
Call RedrawGrid
End Property

Public Property Get ColSortArrowColor(ByVal Index As Long) As Long
Attribute ColSortArrowColor.VB_Description = "Returns/sets the sort arrow color for the specified column."
Attribute ColSortArrowColor.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
If VBFlexGridColsInfo(Index).SortArrowColor = -1 Then
    ColSortArrowColor = PropSortArrowColor
Else
    ColSortArrowColor = VBFlexGridColsInfo(Index).SortArrowColor
End If
End Property

Public Property Let ColSortArrowColor(ByVal Index As Long, ByVal Value As Long)
If Index <> -1 And (Index < 0 Or Index > (PropCols - 1)) Then Err.Raise Number:=30010, Description:="Invalid Col value"
If Index > -1 Then
    VBFlexGridColsInfo(Index).SortArrowColor = Value
Else
    Dim i As Long
    For i = 0 To (PropCols - 1)
        VBFlexGridColsInfo(i).SortArrowColor = Value
    Next i
End If
Call RedrawGrid
End Property

Public Property Get ColComboCue(ByVal Index As Long) As FlexComboCueConstants
Attribute ColComboCue.VB_Description = "Returns/sets the combo cue to visually indicate a combo functionality for the specified column."
Attribute ColComboCue.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
ColComboCue = VBFlexGridColsInfo(Index).ComboCue
End Property

Public Property Let ColComboCue(ByVal Index As Long, ByVal Value As FlexComboCueConstants)
If Index <> -1 And (Index < 0 Or Index > (PropCols - 1)) Then Err.Raise Number:=30010, Description:="Invalid Col value"
Select Case Value
    Case FlexComboCueHidden, FlexComboCueNone, FlexComboCueDropDown, FlexComboCueButton, FlexComboCueDisabledDropDown, FlexComboCueDisabledButton
    Case Else
        Err.Raise 380
End Select
If Index > -1 Then
    VBFlexGridColsInfo(Index).ComboCue = Value
Else
    Dim i As Long
    For i = 0 To (PropCols - 1)
        VBFlexGridColsInfo(i).ComboCue = Value
    Next i
End If
Call RedrawGrid
End Property

Public Property Get ColComboMode(ByVal Index As Long) As FlexComboModeConstants
Attribute ColComboMode.VB_Description = "Returns/sets the combo functionality mode when editing a cell for the specified column."
Attribute ColComboMode.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
ColComboMode = VBFlexGridColsInfo(Index).ComboMode
End Property

Public Property Let ColComboMode(ByVal Index As Long, ByVal Value As FlexComboModeConstants)
If Index <> -1 And (Index < 0 Or Index > (PropCols - 1)) Then Err.Raise Number:=30010, Description:="Invalid Col value"
Select Case Value
    Case FlexComboModeNone, FlexComboModeDropDown, FlexComboModeEditable, FlexComboModeButton, FlexComboModeCalendar
    Case Else
        Err.Raise 380
End Select
If Index > -1 Then
    VBFlexGridColsInfo(Index).ComboMode = Value
Else
    Dim i As Long
    For i = 0 To (PropCols - 1)
        VBFlexGridColsInfo(i).ComboMode = Value
    Next i
End If
End Property

Public Property Get ColComboButtonPicture(ByVal Index As Long) As IPictureDisp
Attribute ColComboButtonPicture.VB_Description = "Returns/sets the combo button picture for the specified column. Only applicable if the combo button draw mode property is set to normal and the combo mode property is set to button."
Attribute ColComboButtonPicture.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
Set ColComboButtonPicture = VBFlexGridColsInfo(Index).ComboButtonPicture
End Property

Public Property Let ColComboButtonPicture(ByVal Index As Long, ByVal Value As IPictureDisp)
Set Me.ColComboButtonPicture(Index) = Value
End Property

Public Property Set ColComboButtonPicture(ByVal Index As Long, ByVal Value As IPictureDisp)
If Index <> -1 And (Index < 0 Or Index > (PropCols - 1)) Then Err.Raise Number:=30010, Description:="Invalid Col value"
If Index > -1 Then
    If Value Is Nothing Then
        Set VBFlexGridColsInfo(Index).ComboButtonPicture = Nothing
    Else
        Set UserControl.Picture = Value
        Set VBFlexGridColsInfo(Index).ComboButtonPicture = UserControl.Picture
        Set UserControl.Picture = Nothing
    End If
    VBFlexGridColsInfo(Index).ComboButtonPictureRenderFlag = 0
Else
    Dim i As Long
    If Value Is Nothing Then
        For i = 0 To (PropCols - 1)
            Set VBFlexGridColsInfo(i).ComboButtonPicture = Nothing
            VBFlexGridColsInfo(i).ComboButtonPictureRenderFlag = 0
        Next i
    Else
        Set UserControl.Picture = Value
        For i = 0 To (PropCols - 1)
            Set VBFlexGridColsInfo(i).ComboButtonPicture = UserControl.Picture
            VBFlexGridColsInfo(i).ComboButtonPictureRenderFlag = 0
        Next i
        Set UserControl.Picture = Nothing
    End If
End If
If VBFlexGridComboButtonHandle <> NULL_PTR Then InvalidateRect VBFlexGridComboButtonHandle, ByVal NULL_PTR, 0
Call RedrawGrid
End Property

Public Property Get ColComboButtonAlignment(ByVal Index As Long) As FlexLeftRightAlignmentConstants
Attribute ColComboButtonAlignment.VB_Description = "Returns/sets the combo button alignment for the specified column."
Attribute ColComboButtonAlignment.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
If VBFlexGridColsInfo(Index).ComboButtonAlignment = -1 Then
    ColComboButtonAlignment = VBFlexGridComboButtonAlignment
Else
    ColComboButtonAlignment = VBFlexGridColsInfo(Index).ComboButtonAlignment
End If
End Property

Public Property Let ColComboButtonAlignment(ByVal Index As Long, ByVal Value As FlexLeftRightAlignmentConstants)
If Index <> -1 And (Index < 0 Or Index > (PropCols - 1)) Then Err.Raise Number:=30010, Description:="Invalid Col value"
Select Case Value
    Case -1, FlexLeftRightAlignmentLeft, FlexLeftRightAlignmentRight
    Case Else
        Err.Raise 380
End Select
If Index > -1 Then
    VBFlexGridColsInfo(Index).ComboButtonAlignment = Value
Else
    Dim i As Long
    For i = 0 To (PropCols - 1)
        VBFlexGridColsInfo(i).ComboButtonAlignment = Value
    Next i
End If
End Property

Public Property Get ColComboButtonWidth(ByVal Index As Long) As Long
Attribute ColComboButtonWidth.VB_Description = "Returns/sets the combo button width in twips for the specified column. Only applicable if the combo mode property is set to button."
Attribute ColComboButtonWidth.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
If VBFlexGridColsInfo(Index).ComboButtonWidth = -1 Then
    ColComboButtonWidth = UserControl.ScaleX(VBFlexGridPixelMetrics.ScrollBarSize, vbPixels, vbTwips)
Else
    ColComboButtonWidth = UserControl.ScaleX(VBFlexGridColsInfo(Index).ComboButtonWidth, vbPixels, vbTwips)
End If
End Property

Public Property Let ColComboButtonWidth(ByVal Index As Long, ByVal Value As Long)
If Index <> -1 And (Index < 0 Or Index > (PropCols - 1)) Then Err.Raise Number:=30010, Description:="Invalid Col value"
If Value < -1 Then Err.Raise Number:=30014, Description:="Invalid Col Width value"
If Index > -1 Then
    If Value > -1 Then
        VBFlexGridColsInfo(Index).ComboButtonWidth = UserControl.ScaleX(Value, vbTwips, vbPixels)
    Else
        VBFlexGridColsInfo(Index).ComboButtonWidth = -1
    End If
Else
    Dim i As Long
    For i = 0 To (PropCols - 1)
        If Value > -1 Then
            VBFlexGridColsInfo(i).ComboButtonWidth = UserControl.ScaleX(Value, vbTwips, vbPixels)
        Else
            VBFlexGridColsInfo(i).ComboButtonWidth = -1
        End If
    Next i
End If
End Property

Public Property Get ColComboItems(ByVal Index As Long) As String
Attribute ColComboItems.VB_Description = "Returns/sets the items to be used for the drop-down list when editing a cell for the specified column. To define a multi-column list, seperate columns with tab characters."
Attribute ColComboItems.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
ColComboItems = VBFlexGridColsInfo(Index).ComboItems
End Property

Public Property Let ColComboItems(ByVal Index As Long, ByVal Value As String)
If Index <> -1 And (Index < 0 Or Index > (PropCols - 1)) Then Err.Raise Number:=30010, Description:="Invalid Col value"
If Index > -1 Then
    VBFlexGridColsInfo(Index).ComboItems = Value
Else
    Dim i As Long
    For i = 0 To (PropCols - 1)
        VBFlexGridColsInfo(i).ComboItems = Value
    Next i
End If
End Property

Public Property Get ColComboHeader(ByVal Index As Long) As String
Attribute ColComboHeader.VB_Description = "Returns/sets the header to be used for the multi-column drop-down list when editing a cell for the specified column."
Attribute ColComboHeader.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
ColComboHeader = VBFlexGridColsInfo(Index).ComboHeader
End Property

Public Property Let ColComboHeader(ByVal Index As Long, ByVal Value As String)
If Index <> -1 And (Index < 0 Or Index > (PropCols - 1)) Then Err.Raise Number:=30010, Description:="Invalid Col value"
If Index > -1 Then
    VBFlexGridColsInfo(Index).ComboHeader = Value
Else
    Dim i As Long
    For i = 0 To (PropCols - 1)
        VBFlexGridColsInfo(i).ComboHeader = Value
    Next i
End If
End Property

Public Property Get ColComboBoundColumn(ByVal Index As Long) As Long
Attribute ColComboBoundColumn.VB_Description = "Returns/sets the bound column to be used for the multi-column drop-down list when editing a cell for the specified column."
Attribute ColComboBoundColumn.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
ColComboBoundColumn = VBFlexGridColsInfo(Index).ComboBoundColumn
End Property

Public Property Let ColComboBoundColumn(ByVal Index As Long, ByVal Value As Long)
If Index <> -1 And (Index < 0 Or Index > (PropCols - 1)) Then Err.Raise Number:=30010, Description:="Invalid Col value"
If Value < 0 Then Err.Raise 380
If Index > -1 Then
    VBFlexGridColsInfo(Index).ComboBoundColumn = Value
Else
    Dim i As Long
    For i = 0 To (PropCols - 1)
        VBFlexGridColsInfo(i).ComboBoundColumn = Value
    Next i
End If
End Property

Public Property Get ColCheckBoxAlignment(ByVal Index As Long) As FlexCheckBoxAlignmentConstants
Attribute ColCheckBoxAlignment.VB_Description = "Returns/sets the check box alignment in a column."
Attribute ColCheckBoxAlignment.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30004, Description:="Invalid Col value for alignment"
ColCheckBoxAlignment = VBFlexGridColsInfo(Index).CheckBoxAlignment
End Property

Public Property Let ColCheckBoxAlignment(ByVal Index As Long, ByVal Value As FlexCheckBoxAlignmentConstants)
If Index <> -1 And (Index < 0 Or Index > (PropCols - 1)) Then Err.Raise Number:=30004, Description:="Invalid Col value for alignment"
Select Case Value
    Case FlexCheckBoxAlignmentLeftTop, FlexCheckBoxAlignmentLeftCenter, FlexCheckBoxAlignmentLeftBottom, FlexCheckBoxAlignmentCenterTop, FlexCheckBoxAlignmentCenterCenter, FlexCheckBoxAlignmentCenterBottom, FlexCheckBoxAlignmentRightTop, FlexCheckBoxAlignmentRightCenter, FlexCheckBoxAlignmentRightBottom, FlexCheckBoxAlignmentUsePictureAlignment
    Case Else
        Err.Raise Number:=30005, Description:="Invalid Alignment value"
End Select
If Index > -1 Then
    VBFlexGridColsInfo(Index).CheckBoxAlignment = Value
Else
    Dim i As Long
    For i = 0 To (PropCols - 1)
        VBFlexGridColsInfo(i).CheckBoxAlignment = Value
    Next i
End If
Call RedrawGrid
End Property

Public Property Get FixedCheckBoxAlignment(ByVal Index As Long) As FlexCheckBoxAlignmentConstants
Attribute FixedCheckBoxAlignment.VB_Description = "Returns/sets the check box alignment in the fixed cells of a column."
Attribute FixedCheckBoxAlignment.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30004, Description:="Invalid Col value for alignment"
If VBFlexGridColsInfo(Index).FixedCheckBoxAlignment = -1 Then
    FixedCheckBoxAlignment = VBFlexGridColsInfo(Index).CheckBoxAlignment
Else
    FixedCheckBoxAlignment = VBFlexGridColsInfo(Index).FixedCheckBoxAlignment
End If
End Property

Public Property Let FixedCheckBoxAlignment(ByVal Index As Long, ByVal Value As FlexCheckBoxAlignmentConstants)
If Index <> -1 And (Index < 0 Or Index > (PropCols - 1)) Then Err.Raise Number:=30004, Description:="Invalid Col value for alignment"
Select Case Value
    Case -1, FlexCheckBoxAlignmentLeftTop, FlexCheckBoxAlignmentLeftCenter, FlexCheckBoxAlignmentLeftBottom, FlexCheckBoxAlignmentCenterTop, FlexCheckBoxAlignmentCenterCenter, FlexCheckBoxAlignmentCenterBottom, FlexCheckBoxAlignmentRightTop, FlexCheckBoxAlignmentRightCenter, FlexCheckBoxAlignmentRightBottom, FlexCheckBoxAlignmentUsePictureAlignment
    Case Else
        Err.Raise Number:=30005, Description:="Invalid Alignment value"
End Select
If Index > -1 Then
    VBFlexGridColsInfo(Index).FixedCheckBoxAlignment = Value
Else
    Dim i As Long
    For i = 0 To (PropCols - 1)
        VBFlexGridColsInfo(i).FixedCheckBoxAlignment = Value
    Next i
End If
Call RedrawGrid
End Property

Public Property Get ColLookup(ByVal Index As Long) As String
Attribute ColLookup.VB_Description = "Returns/sets the lookup used to map keys to associated values in a column."
Attribute ColLookup.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
ColLookup = VBFlexGridColsInfo(Index).Lookup.Property
End Property

Public Property Let ColLookup(ByVal Index As Long, ByVal Value As String)
If Index <> -1 And (Index < 0 Or Index > (PropCols - 1)) Then Err.Raise Number:=30010, Description:="Invalid Col value"
Dim Pos1 As Long, Pos2 As Long, Pos3 As Long, Temp As String
If Index > -1 Then
    With VBFlexGridColsInfo(Index).Lookup
    .Property = Value
    .Count = 0
    Erase .Items()
    If Not .Property = vbNullString Then
        Do
            Pos1 = InStr(Pos1 + 1, .Property, "|")
            If Pos1 > 0 Then
                Temp = Mid$(Value, Pos2 + 1, Pos1 - Pos2 - 1)
            Else
                Temp = Mid$(Value, Pos2 + 1)
            End If
            Pos3 = InStr(Pos3 + 1, Temp, ";")
            ReDim Preserve .Items(0 To .Count) As TLOOKUPITEM
            If Pos3 > 0 Then
                .Items(.Count).Key = Mid$(Temp, 1, Pos3 - 1)
                .Items(.Count).Value = Mid$(Temp, Pos3 + 1)
                .Items(.Count).Hash = CalcHash(.Items(.Count).Key)
            Else
                .Items(.Count).Key = vbNullString
                .Items(.Count).Value = Temp
                .Items(.Count).Hash = 0
            End If
            .Count = .Count + 1
            Pos2 = Pos1
            Pos3 = 0
        Loop Until Pos1 = 0
    End If
    End With
Else
    Dim i As Long
    For i = 0 To (PropCols - 1)
        With VBFlexGridColsInfo(i).Lookup
        .Property = Value
        .Count = 0
        Erase .Items()
        If Not .Property = vbNullString Then
            Do
                Pos1 = InStr(Pos1 + 1, .Property, "|")
                If Pos1 > 0 Then
                    Temp = Mid$(Value, Pos2 + 1, Pos1 - Pos2 - 1)
                Else
                    Temp = Mid$(Value, Pos2 + 1)
                End If
                Pos3 = InStr(Pos3 + 1, Temp, ";")
                ReDim Preserve .Items(0 To .Count) As TLOOKUPITEM
                If Pos3 > 0 Then
                    .Items(.Count).Key = Mid$(Temp, 1, Pos3 - 1)
                    .Items(.Count).Value = Mid$(Temp, Pos3 + 1)
                    .Items(.Count).Hash = CalcHash(.Items(.Count).Key)
                Else
                    .Items(.Count).Key = vbNullString
                    .Items(.Count).Value = Temp
                    .Items(.Count).Hash = 0
                End If
                .Count = .Count + 1
                Pos2 = Pos1
                Pos3 = 0
            Loop Until Pos1 = 0
        End If
        End With
    Next i
End If
Call RedrawGrid
End Property

Public Property Get ColFormat(ByVal Index As Long) As String
Attribute ColFormat.VB_Description = "Returns/sets the format used to display numeric, string, or date/time values in a column."
Attribute ColFormat.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
ColFormat = VBFlexGridColsInfo(Index).Format
End Property

Public Property Let ColFormat(ByVal Index As Long, ByVal Value As String)
If Index <> -1 And (Index < 0 Or Index > (PropCols - 1)) Then Err.Raise Number:=30010, Description:="Invalid Col value"
If Index > -1 Then
    VBFlexGridColsInfo(Index).Format = Value
Else
    Dim i As Long
    For i = 0 To (PropCols - 1)
        VBFlexGridColsInfo(i).Format = Value
    Next i
End If
Call RedrawGrid
End Property

Public Property Get FixedFormat(ByVal Index As Long) As String
Attribute FixedFormat.VB_Description = "Returns/sets the format used to display numeric, string, or date/time values in the fixed cells of a column."
Attribute FixedFormat.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
If StrPtr(VBFlexGridColsInfo(Index).FixedFormat) = NULL_PTR Then
    FixedFormat = VBFlexGridColsInfo(Index).Format
Else
    FixedFormat = VBFlexGridColsInfo(Index).FixedFormat
End If
End Property

Public Property Let FixedFormat(ByVal Index As Long, ByVal Value As String)
If Index <> -1 And (Index < 0 Or Index > (PropCols - 1)) Then Err.Raise Number:=30010, Description:="Invalid Col value"
If Index > -1 Then
    VBFlexGridColsInfo(Index).FixedFormat = Value
Else
    Dim i As Long
    For i = 0 To (PropCols - 1)
        VBFlexGridColsInfo(i).FixedFormat = Value
    Next i
End If
Call RedrawGrid
End Property

Public Property Get ColDataType(ByVal Index As Long) As Integer
Attribute ColDataType.VB_Description = "Returns/sets the data type for the specified column."
Attribute ColDataType.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
ColDataType = VBFlexGridColsInfo(Index).DataType
End Property

Public Property Let ColDataType(ByVal Index As Long, ByVal Value As Integer)
If Index <> -1 And (Index < 0 Or Index > (PropCols - 1)) Then Err.Raise Number:=30010, Description:="Invalid Col value"
If Index > -1 Then
    VBFlexGridColsInfo(Index).DataType = Value
Else
    Dim i As Long
    For i = 0 To (PropCols - 1)
        VBFlexGridColsInfo(i).DataType = Value
    Next i
End If
End Property

Public Property Get ColNullable(ByVal Index As Long) As Boolean
Attribute ColNullable.VB_Description = "Returns/sets a value that determines whether null values are allowed at the data source for the specified column."
Attribute ColNullable.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
ColNullable = CBool((VBFlexGridColsInfo(Index).State And CLIS_NULLABLE) = CLIS_NULLABLE)
End Property

Public Property Let ColNullable(ByVal Index As Long, ByVal Value As Boolean)
If Index <> -1 And (Index < 0 Or Index > (PropCols - 1)) Then Err.Raise Number:=30010, Description:="Invalid Col value"
If Index > -1 Then
    With VBFlexGridColsInfo(Index)
    If Value = True Then
        If (.State And CLIS_NULLABLE) = 0 Then .State = .State Or CLIS_NULLABLE
    Else
        If (.State And CLIS_NULLABLE) = CLIS_NULLABLE Then .State = .State And Not CLIS_NULLABLE
    End If
    End With
Else
    Dim i As Long
    If Value = True Then
        For i = 0 To (PropCols - 1)
            If (VBFlexGridColsInfo(i).State And CLIS_NULLABLE) = 0 Then VBFlexGridColsInfo(i).State = VBFlexGridColsInfo(i).State Or CLIS_NULLABLE
        Next i
    Else
        For i = 0 To (PropCols - 1)
            If (VBFlexGridColsInfo(i).State And CLIS_NULLABLE) = CLIS_NULLABLE Then VBFlexGridColsInfo(i).State = VBFlexGridColsInfo(i).State And Not CLIS_NULLABLE
        Next i
    End If
End If
End Property

Public Property Get ColNumericPrecision(ByVal Index As Long) As Byte
Attribute ColNumericPrecision.VB_Description = "Returns/sets the numeric precision of the data for the specified column."
Attribute ColNumericPrecision.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
ColNumericPrecision = VBFlexGridColsInfo(Index).NumericPrecision
End Property

Public Property Let ColNumericPrecision(ByVal Index As Long, ByVal Value As Byte)
If Index <> -1 And (Index < 0 Or Index > (PropCols - 1)) Then Err.Raise Number:=30010, Description:="Invalid Col value"
If Index > -1 Then
    VBFlexGridColsInfo(Index).NumericPrecision = Value
Else
    Dim i As Long
    For i = 0 To (PropCols - 1)
        VBFlexGridColsInfo(i).NumericPrecision = Value
    Next i
End If
End Property

Public Property Get ColNumericScale(ByVal Index As Long) As Byte
Attribute ColNumericScale.VB_Description = "Returns/sets the numeric scale of the data for the specified column."
Attribute ColNumericScale.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
ColNumericScale = VBFlexGridColsInfo(Index).NumericScale
End Property

Public Property Let ColNumericScale(ByVal Index As Long, ByVal Value As Byte)
If Index <> -1 And (Index < 0 Or Index > (PropCols - 1)) Then Err.Raise Number:=30010, Description:="Invalid Col value"
If Index > -1 Then
    VBFlexGridColsInfo(Index).NumericScale = Value
Else
    Dim i As Long
    For i = 0 To (PropCols - 1)
        VBFlexGridColsInfo(i).NumericScale = Value
    Next i
End If
End Property

Public Property Get ColDataCapacity(ByVal Index As Long) As Long
Attribute ColDataCapacity.VB_Description = "Returns/sets the data capacity for the specified column."
Attribute ColDataCapacity.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
ColDataCapacity = VBFlexGridColsInfo(Index).DataCapacity
End Property

Public Property Let ColDataCapacity(ByVal Index As Long, ByVal Value As Long)
If Index <> -1 And (Index < 0 Or Index > (PropCols - 1)) Then Err.Raise Number:=30010, Description:="Invalid Col value"
If Index > -1 Then
    VBFlexGridColsInfo(Index).DataCapacity = Value
Else
    Dim i As Long
    For i = 0 To (PropCols - 1)
        VBFlexGridColsInfo(i).DataCapacity = Value
    Next i
End If
End Property

Public Property Get ColResizable(ByVal Index As Long) As Boolean
Attribute ColResizable.VB_Description = "Returns/sets a value that determines whether the user can resize the specified column."
Attribute ColResizable.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
ColResizable = CBool((VBFlexGridColsInfo(Index).State And CLIS_NOSIZING) = 0)
End Property

Public Property Let ColResizable(ByVal Index As Long, ByVal Value As Boolean)
If Index <> -1 And (Index < 0 Or Index > (PropCols - 1)) Then Err.Raise Number:=30010, Description:="Invalid Col value"
If Index > -1 Then
    With VBFlexGridColsInfo(Index)
    If Value = True Then
        If (.State And CLIS_NOSIZING) = CLIS_NOSIZING Then .State = .State And Not CLIS_NOSIZING
    Else
        If (.State And CLIS_NOSIZING) = 0 Then .State = .State Or CLIS_NOSIZING
    End If
    End With
Else
    Dim i As Long
    If Value = True Then
        For i = 0 To (PropCols - 1)
            If (VBFlexGridColsInfo(i).State And CLIS_NOSIZING) = CLIS_NOSIZING Then VBFlexGridColsInfo(i).State = VBFlexGridColsInfo(i).State And Not CLIS_NOSIZING
        Next i
    Else
        For i = 0 To (PropCols - 1)
            If (VBFlexGridColsInfo(i).State And CLIS_NOSIZING) = 0 Then VBFlexGridColsInfo(i).State = VBFlexGridColsInfo(i).State Or CLIS_NOSIZING
        Next i
    End If
End If
End Property

Public Property Get ColCheckBoxes(ByVal Index As Long) As Boolean
Attribute ColCheckBoxes.VB_Description = "Returns/sets a value that determines whether check boxes are predefined for the specified column."
Attribute ColCheckBoxes.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
ColCheckBoxes = CBool((VBFlexGridColsInfo(Index).State And CLIS_CHECKBOXES) = CLIS_CHECKBOXES)
End Property

Public Property Let ColCheckBoxes(ByVal Index As Long, ByVal Value As Boolean)
If Index <> -1 And (Index < 0 Or Index > (PropCols - 1)) Then Err.Raise Number:=30010, Description:="Invalid Col value"
If Index > -1 Then
    With VBFlexGridColsInfo(Index)
    If Value = True Then
        If (.State And CLIS_CHECKBOXES) = 0 Then .State = .State Or CLIS_CHECKBOXES
    Else
        If (.State And CLIS_CHECKBOXES) = CLIS_CHECKBOXES Then .State = .State And Not CLIS_CHECKBOXES
    End If
    End With
Else
    Dim i As Long
    If Value = True Then
        For i = 0 To (PropCols - 1)
            If (VBFlexGridColsInfo(i).State And CLIS_CHECKBOXES) = 0 Then VBFlexGridColsInfo(i).State = VBFlexGridColsInfo(i).State Or CLIS_CHECKBOXES
        Next i
    Else
        For i = 0 To (PropCols - 1)
            If (VBFlexGridColsInfo(i).State And CLIS_CHECKBOXES) = CLIS_CHECKBOXES Then VBFlexGridColsInfo(i).State = VBFlexGridColsInfo(i).State And Not CLIS_CHECKBOXES
        Next i
    End If
End If
Call RedrawGrid
End Property

Public Property Get ColCheckBoxesHitTestInvisible(ByVal Index As Long, Optional ByRef DisabledOnly As Boolean) As Boolean
Attribute ColCheckBoxesHitTestInvisible.VB_Description = "Returns/sets a value that determines whether check boxes are visible but not hit-testable (cannot interact with mouse cursor) for the specified column."
Attribute ColCheckBoxesHitTestInvisible.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
ColCheckBoxesHitTestInvisible = CBool((VBFlexGridColsInfo(Index).State And CLIS_CHECKBOXESHITTESTINVISIBLE) = CLIS_CHECKBOXESHITTESTINVISIBLE)
DisabledOnly = CBool((VBFlexGridColsInfo(Index).State And CLIS_CHECKBOXESHITTESTINVISIBLEDISABLEDONLY) = CLIS_CHECKBOXESHITTESTINVISIBLEDISABLEDONLY)
End Property

Public Property Let ColCheckBoxesHitTestInvisible(ByVal Index As Long, Optional ByRef DisabledOnly As Boolean, ByVal Value As Boolean)
If Index <> -1 And (Index < 0 Or Index > (PropCols - 1)) Then Err.Raise Number:=30010, Description:="Invalid Col value"
If Index > -1 Then
    With VBFlexGridColsInfo(Index)
    If Value = True Then
        If (.State And CLIS_CHECKBOXESHITTESTINVISIBLE) = 0 Then .State = .State Or CLIS_CHECKBOXESHITTESTINVISIBLE
        If DisabledOnly = False Then
            If (.State And CLIS_CHECKBOXESHITTESTINVISIBLEDISABLEDONLY) = CLIS_CHECKBOXESHITTESTINVISIBLEDISABLEDONLY Then .State = .State And Not CLIS_CHECKBOXESHITTESTINVISIBLEDISABLEDONLY
        Else
            If (.State And CLIS_CHECKBOXESHITTESTINVISIBLEDISABLEDONLY) = 0 Then .State = .State Or CLIS_CHECKBOXESHITTESTINVISIBLEDISABLEDONLY
        End If
    Else
        If (.State And CLIS_CHECKBOXESHITTESTINVISIBLE) = CLIS_CHECKBOXESHITTESTINVISIBLE Then .State = .State And Not CLIS_CHECKBOXESHITTESTINVISIBLE
        If DisabledOnly = False Then
            If (.State And CLIS_CHECKBOXESHITTESTINVISIBLEDISABLEDONLY) = CLIS_CHECKBOXESHITTESTINVISIBLEDISABLEDONLY Then .State = .State And Not CLIS_CHECKBOXESHITTESTINVISIBLEDISABLEDONLY
        Else
            If (.State And CLIS_CHECKBOXESHITTESTINVISIBLEDISABLEDONLY) = 0 Then .State = .State Or CLIS_CHECKBOXESHITTESTINVISIBLEDISABLEDONLY
        End If
    End If
    End With
Else
    Dim i As Long
    If Value = True Then
        If DisabledOnly = False Then
            For i = 0 To (PropCols - 1)
                If (VBFlexGridColsInfo(i).State And CLIS_CHECKBOXESHITTESTINVISIBLE) = 0 Then VBFlexGridColsInfo(i).State = VBFlexGridColsInfo(i).State Or CLIS_CHECKBOXESHITTESTINVISIBLE
                If (VBFlexGridColsInfo(i).State And CLIS_CHECKBOXESHITTESTINVISIBLEDISABLEDONLY) = CLIS_CHECKBOXESHITTESTINVISIBLEDISABLEDONLY Then VBFlexGridColsInfo(i).State = VBFlexGridColsInfo(i).State And Not CLIS_CHECKBOXESHITTESTINVISIBLEDISABLEDONLY
            Next i
        Else
            For i = 0 To (PropCols - 1)
                If (VBFlexGridColsInfo(i).State And CLIS_CHECKBOXESHITTESTINVISIBLE) = 0 Then VBFlexGridColsInfo(i).State = VBFlexGridColsInfo(i).State Or CLIS_CHECKBOXESHITTESTINVISIBLE
                If (VBFlexGridColsInfo(i).State And CLIS_CHECKBOXESHITTESTINVISIBLEDISABLEDONLY) = 0 Then VBFlexGridColsInfo(i).State = VBFlexGridColsInfo(i).State Or CLIS_CHECKBOXESHITTESTINVISIBLEDISABLEDONLY
            Next i
        End If
    Else
        If DisabledOnly = False Then
            For i = 0 To (PropCols - 1)
                If (VBFlexGridColsInfo(i).State And CLIS_CHECKBOXESHITTESTINVISIBLE) = CLIS_CHECKBOXESHITTESTINVISIBLE Then VBFlexGridColsInfo(i).State = VBFlexGridColsInfo(i).State And Not CLIS_CHECKBOXESHITTESTINVISIBLE
                If (VBFlexGridColsInfo(i).State And CLIS_CHECKBOXESHITTESTINVISIBLEDISABLEDONLY) = CLIS_CHECKBOXESHITTESTINVISIBLEDISABLEDONLY Then VBFlexGridColsInfo(i).State = VBFlexGridColsInfo(i).State And Not CLIS_CHECKBOXESHITTESTINVISIBLEDISABLEDONLY
            Next i
        Else
            For i = 0 To (PropCols - 1)
                If (VBFlexGridColsInfo(i).State And CLIS_CHECKBOXESHITTESTINVISIBLE) = CLIS_CHECKBOXESHITTESTINVISIBLE Then VBFlexGridColsInfo(i).State = VBFlexGridColsInfo(i).State And Not CLIS_CHECKBOXESHITTESTINVISIBLE
                If (VBFlexGridColsInfo(i).State And CLIS_CHECKBOXESHITTESTINVISIBLEDISABLEDONLY) = 0 Then VBFlexGridColsInfo(i).State = VBFlexGridColsInfo(i).State Or CLIS_CHECKBOXESHITTESTINVISIBLEDISABLEDONLY
            Next i
        End If
    End If
End If
Call RedrawGrid
End Property

Public Property Get ColCheckBoxesHitTestInvisibleFixed(ByVal Index As Long, Optional ByRef DisabledOnly As Boolean) As Boolean
Attribute ColCheckBoxesHitTestInvisibleFixed.VB_Description = "Returns/sets a value that determines whether check boxes are visible but not hit-testable (cannot interact with mouse cursor) for the specified column."
Attribute ColCheckBoxesHitTestInvisibleFixed.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
ColCheckBoxesHitTestInvisibleFixed = CBool((VBFlexGridColsInfo(Index).State And CLIS_CHECKBOXESHITTESTINVISIBLEFIXED) = CLIS_CHECKBOXESHITTESTINVISIBLEFIXED)
DisabledOnly = CBool((VBFlexGridColsInfo(Index).State And CLIS_CHECKBOXESHITTESTINVISIBLEFIXEDDISABLEDONLY) = CLIS_CHECKBOXESHITTESTINVISIBLEFIXEDDISABLEDONLY)
End Property

Public Property Let ColCheckBoxesHitTestInvisibleFixed(ByVal Index As Long, Optional ByRef DisabledOnly As Boolean, ByVal Value As Boolean)
If Index <> -1 And (Index < 0 Or Index > (PropCols - 1)) Then Err.Raise Number:=30010, Description:="Invalid Col value"
If Index > -1 Then
    With VBFlexGridColsInfo(Index)
    If Value = True Then
        If (.State And CLIS_CHECKBOXESHITTESTINVISIBLEFIXED) = 0 Then .State = .State Or CLIS_CHECKBOXESHITTESTINVISIBLEFIXED
        If DisabledOnly = False Then
            If (.State And CLIS_CHECKBOXESHITTESTINVISIBLEFIXEDDISABLEDONLY) = CLIS_CHECKBOXESHITTESTINVISIBLEFIXEDDISABLEDONLY Then .State = .State And Not CLIS_CHECKBOXESHITTESTINVISIBLEFIXEDDISABLEDONLY
        Else
            If (.State And CLIS_CHECKBOXESHITTESTINVISIBLEFIXEDDISABLEDONLY) = 0 Then .State = .State Or CLIS_CHECKBOXESHITTESTINVISIBLEFIXEDDISABLEDONLY
        End If
    Else
        If (.State And CLIS_CHECKBOXESHITTESTINVISIBLEFIXED) = CLIS_CHECKBOXESHITTESTINVISIBLEFIXED Then .State = .State And Not CLIS_CHECKBOXESHITTESTINVISIBLEFIXED
        If DisabledOnly = False Then
            If (.State And CLIS_CHECKBOXESHITTESTINVISIBLEFIXEDDISABLEDONLY) = CLIS_CHECKBOXESHITTESTINVISIBLEFIXEDDISABLEDONLY Then .State = .State And Not CLIS_CHECKBOXESHITTESTINVISIBLEFIXEDDISABLEDONLY
        Else
            If (.State And CLIS_CHECKBOXESHITTESTINVISIBLEFIXEDDISABLEDONLY) = 0 Then .State = .State Or CLIS_CHECKBOXESHITTESTINVISIBLEFIXEDDISABLEDONLY
        End If
    End If
    End With
Else
    Dim i As Long
    If Value = True Then
        If DisabledOnly = False Then
            For i = 0 To (PropCols - 1)
                If (VBFlexGridColsInfo(i).State And CLIS_CHECKBOXESHITTESTINVISIBLEFIXED) = 0 Then VBFlexGridColsInfo(i).State = VBFlexGridColsInfo(i).State Or CLIS_CHECKBOXESHITTESTINVISIBLEFIXED
                If (VBFlexGridColsInfo(i).State And CLIS_CHECKBOXESHITTESTINVISIBLEFIXEDDISABLEDONLY) = CLIS_CHECKBOXESHITTESTINVISIBLEFIXEDDISABLEDONLY Then VBFlexGridColsInfo(i).State = VBFlexGridColsInfo(i).State And Not CLIS_CHECKBOXESHITTESTINVISIBLEFIXEDDISABLEDONLY
            Next i
        Else
            For i = 0 To (PropCols - 1)
                If (VBFlexGridColsInfo(i).State And CLIS_CHECKBOXESHITTESTINVISIBLEFIXED) = 0 Then VBFlexGridColsInfo(i).State = VBFlexGridColsInfo(i).State Or CLIS_CHECKBOXESHITTESTINVISIBLEFIXED
                If (VBFlexGridColsInfo(i).State And CLIS_CHECKBOXESHITTESTINVISIBLEFIXEDDISABLEDONLY) = 0 Then VBFlexGridColsInfo(i).State = VBFlexGridColsInfo(i).State Or CLIS_CHECKBOXESHITTESTINVISIBLEFIXEDDISABLEDONLY
            Next i
        End If
    Else
        If DisabledOnly = False Then
            For i = 0 To (PropCols - 1)
                If (VBFlexGridColsInfo(i).State And CLIS_CHECKBOXESHITTESTINVISIBLEFIXED) = CLIS_CHECKBOXESHITTESTINVISIBLEFIXED Then VBFlexGridColsInfo(i).State = VBFlexGridColsInfo(i).State And Not CLIS_CHECKBOXESHITTESTINVISIBLEFIXED
                If (VBFlexGridColsInfo(i).State And CLIS_CHECKBOXESHITTESTINVISIBLEFIXEDDISABLEDONLY) = CLIS_CHECKBOXESHITTESTINVISIBLEFIXEDDISABLEDONLY Then VBFlexGridColsInfo(i).State = VBFlexGridColsInfo(i).State And Not CLIS_CHECKBOXESHITTESTINVISIBLEFIXEDDISABLEDONLY
            Next i
        Else
            For i = 0 To (PropCols - 1)
                If (VBFlexGridColsInfo(i).State And CLIS_CHECKBOXESHITTESTINVISIBLEFIXED) = CLIS_CHECKBOXESHITTESTINVISIBLEFIXED Then VBFlexGridColsInfo(i).State = VBFlexGridColsInfo(i).State And Not CLIS_CHECKBOXESHITTESTINVISIBLEFIXED
                If (VBFlexGridColsInfo(i).State And CLIS_CHECKBOXESHITTESTINVISIBLEFIXEDDISABLEDONLY) = 0 Then VBFlexGridColsInfo(i).State = VBFlexGridColsInfo(i).State Or CLIS_CHECKBOXESHITTESTINVISIBLEFIXEDDISABLEDONLY
            Next i
        End If
    End If
End If
Call RedrawGrid
End Property

Public Property Get ColTextIndent(ByVal Index As Long) As Boolean
Attribute ColTextIndent.VB_Description = "Returns/sets a value that determines whether to indent text in cells for the specified column. The CellTextIndent event is fired for all cells within this column."
Attribute ColTextIndent.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
ColTextIndent = CBool((VBFlexGridColsInfo(Index).State And CLIS_TEXTINDENT) = CLIS_TEXTINDENT)
End Property

Public Property Let ColTextIndent(ByVal Index As Long, ByVal Value As Boolean)
If Index <> -1 And (Index < 0 Or Index > (PropCols - 1)) Then Err.Raise Number:=30010, Description:="Invalid Col value"
If Index > -1 Then
    With VBFlexGridColsInfo(Index)
    If Value = True Then
        If (.State And CLIS_TEXTINDENT) = 0 Then .State = .State Or CLIS_TEXTINDENT
    Else
        If (.State And CLIS_TEXTINDENT) = CLIS_TEXTINDENT Then .State = .State And Not CLIS_TEXTINDENT
    End If
    End With
Else
    Dim i As Long
    If Value = True Then
        For i = 0 To (PropCols - 1)
            If (VBFlexGridColsInfo(i).State And CLIS_TEXTINDENT) = 0 Then VBFlexGridColsInfo(i).State = VBFlexGridColsInfo(i).State Or CLIS_TEXTINDENT
        Next i
    Else
        For i = 0 To (PropCols - 1)
            If (VBFlexGridColsInfo(i).State And CLIS_TEXTINDENT) = CLIS_TEXTINDENT Then VBFlexGridColsInfo(i).State = VBFlexGridColsInfo(i).State And Not CLIS_TEXTINDENT
        Next i
    End If
End If
Call RedrawGrid
End Property

Public Property Get MergeRow(ByVal Index As Long) As Boolean
Attribute MergeRow.VB_Description = "Returns/sets which columns or rows should have their contents merged when the merge cells property is set to a value other than 0 (never)."
Attribute MergeRow.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropRows - 1) Then Err.Raise Number:=30009, Description:="Invalid Row value"
MergeRow = CBool((VBFlexGridCells.Rows(Index).RowInfo.State And RWIS_MERGE) = RWIS_MERGE)
End Property

Public Property Let MergeRow(ByVal Index As Long, ByVal Value As Boolean)
If Index < 0 Or Index > (PropRows - 1) Then Err.Raise Number:=30009, Description:="Invalid Row value"
With VBFlexGridCells.Rows(Index).RowInfo
If Value = True Then
    If (.State And RWIS_MERGE) = 0 Then .State = .State Or RWIS_MERGE
Else
    If (.State And RWIS_MERGE) = RWIS_MERGE Then .State = .State And Not RWIS_MERGE
End If
End With
Call RedrawGrid
End Property

Public Property Get MergeCol(ByVal Index As Long) As Boolean
Attribute MergeCol.VB_Description = "Returns/sets which columns or rows should have their contents merged when the merge cells property is set to a value other than 0 (never)."
Attribute MergeCol.VB_MemberFlags = "400"
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
MergeCol = CBool((VBFlexGridColsInfo(Index).State And CLIS_MERGE) = CLIS_MERGE)
End Property

Public Property Let MergeCol(ByVal Index As Long, ByVal Value As Boolean)
If Index < 0 Or Index > (PropCols - 1) Then Err.Raise Number:=30010, Description:="Invalid Col value"
With VBFlexGridColsInfo(Index)
If Value = True Then
    If (.State And CLIS_MERGE) = 0 Then .State = .State Or CLIS_MERGE
Else
    If (.State And CLIS_MERGE) = CLIS_MERGE Then .State = .State And Not CLIS_MERGE
End If
End With
Call RedrawGrid
End Property

Public Property Get Cell(ByVal Setting As FlexCellSettings, Optional ByVal Row As Long = -1, Optional ByVal Col As Long = -1, Optional ByVal RowSel As Long = -1, Optional ByVal ColSel As Long = -1) As Variant
Attribute Cell.VB_Description = "Returns/sets cell settings for an arbitrary cell or range of cells."
Attribute Cell.VB_MemberFlags = "400"
If (Row < -1 Or Row > (PropRows - 1)) Or (Col < -1 Or Col > (PropCols - 1)) Or (RowSel < -1 Or RowSel > (PropRows - 1)) Or (ColSel < -1 Or ColSel > (PropCols - 1)) Then Err.Raise Number:=381, Description:="Subscript out of range"
Dim OldRow As Long, OldCol As Long, OldRowSel As Long, OldColSel As Long
OldRow = VBFlexGridRow
OldCol = VBFlexGridCol
OldRowSel = VBFlexGridRowSel
OldColSel = VBFlexGridColSel
If Row > -1 Then VBFlexGridRow = Row
If Col > -1 Then VBFlexGridCol = Col
If RowSel > -1 Then VBFlexGridRowSel = RowSel Else VBFlexGridRowSel = VBFlexGridRow
If ColSel > -1 Then VBFlexGridColSel = ColSel Else VBFlexGridColSel = VBFlexGridCol
On Error GoTo Cancel
Select Case Setting
    Case FlexCellText
        Cell = Me.Text
    Case FlexCellClip
        Cell = Me.Clip
    Case FlexCellTextStyle
        Cell = Me.CellTextStyle
    Case FlexCellAlignment
        Cell = Me.CellAlignment
    Case FlexCellPicture
        Set Cell = Me.CellPicture
    Case FlexCellPictureAlignment
        Cell = Me.CellPictureAlignment
    Case FlexCellBackColor
        Cell = Me.CellBackColor
    Case FlexCellForeColor
        Cell = Me.CellForeColor
    Case FlexCellToolTipText
        Cell = Me.CellToolTipText
    Case FlexCellComboCue
        Cell = Me.CellComboCue
    Case FlexCellChecked
        Cell = Me.CellChecked
    Case FlexCellFloodPercent
        Cell = Me.CellFloodPercent
    Case FlexCellFloodColor
        Cell = Me.CellFloodColor
    Case FlexCellFontName
        Cell = Me.CellFontName
    Case FlexCellFontSize
        Cell = Me.CellFontSize
    Case FlexCellFontBold
        Cell = Me.CellFontBold
    Case FlexCellFontItalic
        Cell = Me.CellFontItalic
    Case FlexCellFontStrikeThrough
        Cell = Me.CellFontStrikeThrough
    Case FlexCellFontUnderline
        Cell = Me.CellFontUnderline
    Case FlexCellFontCharset
        Cell = Me.CellFontCharset
    Case FlexCellLeft
        Cell = Me.CellLeft
    Case FlexCellTop
        Cell = Me.CellTop
    Case FlexCellWidth
        Cell = Me.CellWidth
    Case FlexCellHeight
        Cell = Me.CellHeight
    Case FlexCellSort
        Err.Raise Number:=394, Description:="Property is write-only"
    Case FlexCellTextDisplay
        Cell = CellTextDisplay()
    Case FlexCellTextHidden
        Cell = CellTextHidden()
    Case FlexCellHasCustomFormatting
        Cell = Me.CellHasCustomFormatting
    Case FlexCellHasTag
        Cell = Me.CellHasTag
    Case FlexCellTag
        VariantCopy Cell, Me.CellTag
    Case Else
        Err.Raise 380
End Select
Cancel:
VBFlexGridRow = OldRow
VBFlexGridCol = OldCol
VBFlexGridRowSel = OldRowSel
VBFlexGridColSel = OldColSel
If Err.Number <> 0 Then Err.Raise Number:=Err.Number, Description:=Err.Description
End Property

Public Property Let Cell(ByVal Setting As FlexCellSettings, Optional ByVal Row As Long = -1, Optional ByVal Col As Long = -1, Optional ByVal RowSel As Long = -1, Optional ByVal ColSel As Long = -1, ByVal Value As Variant)
If (Row < -1 Or Row > (PropRows - 1)) Or (Col < -1 Or Col > (PropCols - 1)) Or (RowSel < -1 Or RowSel > (PropRows - 1)) Or (ColSel < -1 Or ColSel > (PropCols - 1)) Then Err.Raise Number:=381, Description:="Subscript out of range"
Dim OldRow As Long, OldCol As Long, OldRowSel As Long, OldColSel As Long, OldNoRedraw As Boolean
OldRow = VBFlexGridRow
OldCol = VBFlexGridCol
OldRowSel = VBFlexGridRowSel
OldColSel = VBFlexGridColSel
OldNoRedraw = VBFlexGridNoRedraw
If Row > -1 Then VBFlexGridRow = Row
If Col > -1 Then VBFlexGridCol = Col
If RowSel > -1 Then VBFlexGridRowSel = RowSel Else VBFlexGridRowSel = VBFlexGridRow
If ColSel > -1 Then VBFlexGridColSel = ColSel Else VBFlexGridColSel = VBFlexGridCol
VBFlexGridNoRedraw = True
VBFlexGridIndirectCellRef.InProc = True
VBFlexGridIndirectCellRef.SetRCP = False
On Error GoTo Cancel
Select Case Setting
    Case FlexCellText
        Me.Text = Value
    Case FlexCellClip
        Me.Clip = Value
    Case FlexCellTextStyle
        Me.CellTextStyle = Value
    Case FlexCellAlignment
        Me.CellAlignment = Value
    Case FlexCellPicture
        Me.CellPicture = Value
    Case FlexCellPictureAlignment
        Me.CellPictureAlignment = Value
    Case FlexCellBackColor
        Me.CellBackColor = Value
    Case FlexCellForeColor
        Me.CellForeColor = Value
    Case FlexCellToolTipText
        Me.CellToolTipText = Value
    Case FlexCellComboCue
        Me.CellComboCue = Value
    Case FlexCellChecked
        Me.CellChecked = Value
    Case FlexCellFloodPercent
        Me.CellFloodPercent = Value
    Case FlexCellFloodColor
        Me.CellFloodColor = Value
    Case FlexCellFontName
        Me.CellFontName = Value
    Case FlexCellFontSize
        Me.CellFontSize = Value
    Case FlexCellFontBold
        Me.CellFontBold = Value
    Case FlexCellFontItalic
        Me.CellFontItalic = Value
    Case FlexCellFontStrikeThrough
        Me.CellFontStrikeThrough = Value
    Case FlexCellFontUnderline
        Me.CellFontUnderline = Value
    Case FlexCellFontCharset
        Me.CellFontCharset = Value
    Case FlexCellLeft
        Err.Raise Number:=383, Description:="Property is read-only"
    Case FlexCellTop
        Err.Raise Number:=383, Description:="Property is read-only"
    Case FlexCellWidth
        Err.Raise Number:=383, Description:="Property is read-only"
    Case FlexCellHeight
        Err.Raise Number:=383, Description:="Property is read-only"
    Case FlexCellSort
        Me.Sort = Value
    Case FlexCellTextDisplay
        Err.Raise Number:=383, Description:="Property is read-only"
    Case FlexCellTextHidden
        Err.Raise Number:=383, Description:="Property is read-only"
    Case FlexCellHasCustomFormatting
        Me.CellHasCustomFormatting = Value
    Case FlexCellHasTag
        Me.CellHasTag = Value
    Case FlexCellTag
        Me.CellTag = Value
    Case Else
        Err.Raise 380
End Select
Cancel:
VBFlexGridRow = OldRow
VBFlexGridCol = OldCol
VBFlexGridRowSel = OldRowSel
VBFlexGridColSel = OldColSel
VBFlexGridNoRedraw = OldNoRedraw
VBFlexGridIndirectCellRef.InProc = False
If Err.Number = 0 Then
    If VBFlexGridIndirectCellRef.SetRCP = False Then
        Call RedrawGrid
    Else
        Dim RCP As TROWCOLPARAMS
        LSet RCP = VBFlexGridIndirectCellRef.RCP
        VBFlexGridIndirectCellRef.SetRCP = False
        Call SetRowColParams(RCP)
    End If
Else
    Err.Raise Number:=Err.Number, Description:=Err.Description
End If
End Property

Public Property Set Cell(ByVal Setting As FlexCellSettings, Optional ByVal Row As Long = -1, Optional ByVal Col As Long = -1, Optional ByVal RowSel As Long = -1, Optional ByVal ColSel As Long = -1, ByVal Value As Variant)
If (Row < -1 Or Row > (PropRows - 1)) Or (Col < -1 Or Col > (PropCols - 1)) Or (RowSel < -1 Or RowSel > (PropRows - 1)) Or (ColSel < -1 Or ColSel > (PropCols - 1)) Then Err.Raise Number:=381, Description:="Subscript out of range"
Dim OldRow As Long, OldCol As Long, OldRowSel As Long, OldColSel As Long, OldNoRedraw As Boolean
OldRow = VBFlexGridRow
OldCol = VBFlexGridCol
OldRowSel = VBFlexGridRowSel
OldColSel = VBFlexGridColSel
OldNoRedraw = VBFlexGridNoRedraw
If Row > -1 Then VBFlexGridRow = Row
If Col > -1 Then VBFlexGridCol = Col
If RowSel > -1 Then VBFlexGridRowSel = RowSel Else VBFlexGridRowSel = VBFlexGridRow
If ColSel > -1 Then VBFlexGridColSel = ColSel Else VBFlexGridColSel = VBFlexGridCol
VBFlexGridNoRedraw = True
On Error GoTo Cancel
Select Case Setting
    Case FlexCellPicture
        Set Me.CellPicture = Value
    Case FlexCellTag
        Set Me.CellTag = Value
    Case Else
        Err.Raise 380
End Select
Cancel:
VBFlexGridRow = OldRow
VBFlexGridCol = OldCol
VBFlexGridRowSel = OldRowSel
VBFlexGridColSel = OldColSel
VBFlexGridNoRedraw = OldNoRedraw
If Err.Number = 0 Then
    Call RedrawGrid
Else
    Err.Raise Number:=Err.Number, Description:=Err.Description
End If
End Property

Public Property Get Text() As String
Attribute Text.VB_Description = "Returns/sets the text contents of a cell or range of cells."
Attribute Text.VB_UserMemId = 0
Attribute Text.VB_MemberFlags = "400"
If VBFlexGridRow > -1 And VBFlexGridCol > -1 Then Call GetCellText(VBFlexGridRow, VBFlexGridCol, Text)
End Property

Public Property Let Text(ByVal Value As String)
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
If PropFillStyle = FlexFillStyleSingle Then
    Call SetCellText(VBFlexGridRow, VBFlexGridCol, Value)
ElseIf PropFillStyle = FlexFillStyleRepeat Then
    Dim i As Long, j As Long, SelRange As TCELLRANGE
    Call GetSelRangeStruct(SelRange)
    For i = SelRange.TopRow To SelRange.BottomRow
        For j = SelRange.LeftCol To SelRange.RightCol
            Call SetCellText(i, j, Value)
        Next j
    Next i
End If
Call RedrawGrid
End Property

Public Property Get TextArray(ByVal Index As Long) As String
Attribute TextArray.VB_Description = "Returns/sets the text contents of an arbitrary cell (single subscript)."
Attribute TextArray.VB_MemberFlags = "400"
If (Index < 0 Or Index > ((PropRows * PropCols) - 1)) Then Err.Raise Number:=381, Description:="Subscript out of range"
Dim RetVal As Long
RetVal = Index \ PropCols
Call GetCellText(RetVal, Index - (RetVal * PropCols), TextArray)
End Property

Public Property Let TextArray(ByVal Index As Long, ByVal Value As String)
If (Index < 0 Or Index > ((PropRows * PropCols) - 1)) Then Err.Raise Number:=381, Description:="Subscript out of range"
Dim RetVal As Long
RetVal = Index \ PropCols
Call SetCellText(RetVal, Index - (RetVal * PropCols), Value)
Call RedrawGrid
End Property

Public Property Get TextMatrix(ByVal Row As Long, ByVal Col As Long) As String
Attribute TextMatrix.VB_Description = "Returns/sets the text contents of an arbitrary cell (row/col subscripts)."
Attribute TextMatrix.VB_MemberFlags = "400"
If (Row < 0 Or Row > (PropRows - 1)) Or (Col < 0 Or Col > (PropCols - 1)) Then Err.Raise Number:=381, Description:="Subscript out of range"
Call GetCellText(Row, Col, TextMatrix)
End Property

Public Property Let TextMatrix(ByVal Row As Long, ByVal Col As Long, ByVal Value As String)
If (Row < 0 Or Row > (PropRows - 1)) Or (Col < 0 Or Col > (PropCols - 1)) Then Err.Raise Number:=381, Description:="Subscript out of range"
Call SetCellText(Row, Col, Value)
Call RedrawGrid
End Property

Public Property Get Clip() As String
Attribute Clip.VB_Description = "Returns/sets the contents of the cells in a selected region."
Attribute Clip.VB_MemberFlags = "400"
If VBFlexGridRow < 0 Or VBFlexGridCol < 0 Then Err.Raise 7
Dim iRow As Long, iCol As Long, iSelRow As Long, SelRange As TCELLRANGE, Buffer As String, Hash As Long, i As Long
Dim UBoundRows As Long, UBoundCols As Long
Dim StrArr() As String, StrSize As Long
Dim CSCol As String, CSColLen As Long, CSRow As String, CSRowLen As Long
Call GetSelRangeStruct(SelRange)
If PropClipMode = FlexClipModeNormal Or PropClipMode = FlexClipModeLookupConv Then
    If PropClipCopyMode < FlexClipCopyModeExtended Then
        UBoundRows = (SelRange.BottomRow - SelRange.TopRow)
        UBoundCols = (SelRange.RightCol - SelRange.LeftCol)
    Else
        Select Case PropSelectionMode
            Case FlexSelectionModeFreeByRow
                If SelRange.LeftCol > PropFixedCols Then SelRange.LeftCol = PropFixedCols
                SelRange.RightCol = PropCols - 1
            Case FlexSelectionModeFreeByColumn
                If SelRange.TopRow > PropFixedRows Then SelRange.TopRow = PropFixedRows
                SelRange.BottomRow = PropRows - 1
        End Select
        If PropAllowMultiSelection = False Then
            UBoundRows = (SelRange.BottomRow - SelRange.TopRow)
        Else
            UBoundRows = Me.SelectedRows - 1
        End If
        UBoundCols = (SelRange.RightCol - SelRange.LeftCol)
    End If
    Select Case PropClipCopyMode
        Case FlexClipCopyModeIncludeFixedRows, FlexClipCopyModeExtendedFixedRows
            UBoundRows = UBoundRows + PropFixedRows
        Case FlexClipCopyModeIncludeFixedColumns, FlexClipCopyModeExtendedFixedColumns
            UBoundCols = UBoundCols + PropFixedCols
        Case FlexClipCopyModeIncludeFixedAll, FlexClipCopyModeExtendedFixedAll
            UBoundRows = UBoundRows + PropFixedRows
            UBoundCols = UBoundCols + PropFixedCols
    End Select
ElseIf PropClipMode = FlexClipModeExcludeHidden Or PropClipMode = FlexClipModeLookupConvExcludeHidden Then
    UBoundRows = -1
    UBoundCols = -1
    If PropClipCopyMode < FlexClipCopyModeExtended Then
        For iRow = SelRange.TopRow To SelRange.BottomRow
            If (VBFlexGridCells.Rows(iRow).RowInfo.State And RWIS_HIDDEN) = 0 Then UBoundRows = UBoundRows + 1
        Next iRow
        For iCol = SelRange.LeftCol To SelRange.RightCol
            If (VBFlexGridColsInfo(iCol).State And CLIS_HIDDEN) = 0 Then UBoundCols = UBoundCols + 1
        Next iCol
    Else
        Select Case PropSelectionMode
            Case FlexSelectionModeFreeByRow
                If SelRange.LeftCol > PropFixedCols Then SelRange.LeftCol = PropFixedCols
                SelRange.RightCol = PropCols - 1
            Case FlexSelectionModeFreeByColumn
                If SelRange.TopRow > PropFixedRows Then SelRange.TopRow = PropFixedRows
                SelRange.BottomRow = PropRows - 1
        End Select
        If PropAllowMultiSelection = False Then
            For iRow = SelRange.TopRow To SelRange.BottomRow
                If (VBFlexGridCells.Rows(iRow).RowInfo.State And RWIS_HIDDEN) = 0 Then UBoundRows = UBoundRows + 1
            Next iRow
        Else
            For iRow = 0 To Me.SelectedRows - 1
                If (VBFlexGridCells.Rows(Me.SelectedRow(iRow)).RowInfo.State And RWIS_HIDDEN) = 0 Then UBoundRows = UBoundRows + 1
            Next iRow
        End If
        For iCol = SelRange.LeftCol To SelRange.RightCol
            If (VBFlexGridColsInfo(iCol).State And CLIS_HIDDEN) = 0 Then UBoundCols = UBoundCols + 1
        Next iCol
    End If
    Select Case PropClipCopyMode
        Case FlexClipCopyModeIncludeFixedRows, FlexClipCopyModeExtendedFixedRows
            For iRow = 0 To PropFixedRows - 1
                If (VBFlexGridCells.Rows(iRow).RowInfo.State And RWIS_HIDDEN) = 0 Then UBoundRows = UBoundRows + 1
            Next iRow
        Case FlexClipCopyModeIncludeFixedColumns, FlexClipCopyModeExtendedFixedColumns
            For iCol = 0 To PropFixedCols - 1
                If (VBFlexGridColsInfo(iCol).State And CLIS_HIDDEN) = 0 Then UBoundCols = UBoundCols + 1
            Next iCol
        Case FlexClipCopyModeIncludeFixedAll, FlexClipCopyModeExtendedFixedAll
            For iRow = 0 To PropFixedRows - 1
                If (VBFlexGridCells.Rows(iRow).RowInfo.State And RWIS_HIDDEN) = 0 Then UBoundRows = UBoundRows + 1
            Next iRow
            For iCol = 0 To PropFixedCols - 1
                If (VBFlexGridColsInfo(iCol).State And CLIS_HIDDEN) = 0 Then UBoundCols = UBoundCols + 1
            Next iCol
    End Select
End If
If UBoundRows > -1 And UBoundCols > -1 Then ReDim StrArr(0 To UBoundRows, 0 To UBoundCols) As String
CSCol = GetClipSeparatorCol()
CSColLen = Len(CSCol)
CSRow = GetClipSeparatorRow()
CSRowLen = Len(CSRow)
If PropClipMode = FlexClipModeNormal Or PropClipMode = FlexClipModeLookupConv Then
    Select Case PropClipCopyMode
        Case FlexClipCopyModeNormal, FlexClipCopyModeExtended
            If PropAllowMultiSelection = False Or PropClipCopyMode = FlexClipCopyModeNormal Then
                For iRow = SelRange.TopRow To SelRange.BottomRow
                    For iCol = SelRange.LeftCol To SelRange.RightCol
                        Call GetCellText(iRow, iCol, Buffer)
                        If PropClipMode = FlexClipModeLookupConv Then
                            If VBFlexGridColsInfo(iCol).Lookup.Count > 0 Then
                                Hash = CalcHash(Buffer)
                                For i = 0 To (VBFlexGridColsInfo(iCol).Lookup.Count - 1)
                                    If VBFlexGridColsInfo(iCol).Lookup.Items(i).Hash = Hash Then
                                        If StrComp(VBFlexGridColsInfo(iCol).Lookup.Items(i).Key, Buffer, vbTextCompare) = 0 Then
                                            Buffer = VBFlexGridColsInfo(iCol).Lookup.Items(i).Value
                                            Exit For
                                        End If
                                    End If
                                Next i
                            End If
                        End If
                        If iCol < SelRange.RightCol Then
                            StrArr(iRow + (0 - SelRange.TopRow), iCol + (0 - SelRange.LeftCol)) = Buffer & CSCol
                        ElseIf iRow < SelRange.BottomRow Then
                            StrArr(iRow + (0 - SelRange.TopRow), iCol + (0 - SelRange.LeftCol)) = Buffer & CSRow
                        Else
                            StrArr(iRow + (0 - SelRange.TopRow), iCol + (0 - SelRange.LeftCol)) = Buffer
                        End If
                    Next iCol
                Next iRow
            Else
                For iRow = 0 To Me.SelectedRows - 1
                    iSelRow = Me.SelectedRow(iRow)
                    For iCol = SelRange.LeftCol To SelRange.RightCol
                        Call GetCellText(iSelRow, iCol, Buffer)
                        If PropClipMode = FlexClipModeLookupConv Then
                            If VBFlexGridColsInfo(iCol).Lookup.Count > 0 Then
                                Hash = CalcHash(Buffer)
                                For i = 0 To (VBFlexGridColsInfo(iCol).Lookup.Count - 1)
                                    If VBFlexGridColsInfo(iCol).Lookup.Items(i).Hash = Hash Then
                                        If StrComp(VBFlexGridColsInfo(iCol).Lookup.Items(i).Key, Buffer, vbTextCompare) = 0 Then
                                            Buffer = VBFlexGridColsInfo(iCol).Lookup.Items(i).Value
                                            Exit For
                                        End If
                                    End If
                                Next i
                            End If
                        End If
                        If iCol < SelRange.RightCol Then
                            StrArr(iRow, iCol + (0 - SelRange.LeftCol)) = Buffer & CSCol
                        ElseIf iSelRow < SelRange.BottomRow Then
                            StrArr(iRow, iCol + (0 - SelRange.LeftCol)) = Buffer & CSRow
                        Else
                            StrArr(iRow, iCol + (0 - SelRange.LeftCol)) = Buffer
                        End If
                    Next iCol
                Next iRow
            End If
        Case FlexClipCopyModeIncludeFixedRows, FlexClipCopyModeExtendedFixedRows
            For iCol = SelRange.LeftCol To SelRange.RightCol
                For iRow = 0 To PropFixedRows - 1
                    Call GetCellText(iRow, iCol, Buffer)
                    If PropClipMode = FlexClipModeLookupConv Then
                        If VBFlexGridColsInfo(iCol).Lookup.Count > 0 Then
                            Hash = CalcHash(Buffer)
                            For i = 0 To (VBFlexGridColsInfo(iCol).Lookup.Count - 1)
                                If VBFlexGridColsInfo(iCol).Lookup.Items(i).Hash = Hash Then
                                    If StrComp(VBFlexGridColsInfo(iCol).Lookup.Items(i).Key, Buffer, vbTextCompare) = 0 Then
                                        Buffer = VBFlexGridColsInfo(iCol).Lookup.Items(i).Value
                                        Exit For
                                    End If
                                End If
                            Next i
                        End If
                    End If
                    If iCol < SelRange.RightCol Then
                        StrArr(iRow, iCol + (0 - SelRange.LeftCol)) = Buffer & CSCol
                    ElseIf iRow < SelRange.BottomRow Then
                        StrArr(iRow, iCol + (0 - SelRange.LeftCol)) = Buffer & CSRow
                    Else
                        StrArr(iRow, iCol + (0 - SelRange.LeftCol)) = Buffer
                    End If
                Next iRow
            Next iCol
            If PropAllowMultiSelection = False Or PropClipCopyMode = FlexClipCopyModeIncludeFixedRows Then
                For iRow = SelRange.TopRow To SelRange.BottomRow
                    For iCol = SelRange.LeftCol To SelRange.RightCol
                        Call GetCellText(iRow, iCol, Buffer)
                        If PropClipMode = FlexClipModeLookupConv Then
                            If VBFlexGridColsInfo(iCol).Lookup.Count > 0 Then
                                Hash = CalcHash(Buffer)
                                For i = 0 To (VBFlexGridColsInfo(iCol).Lookup.Count - 1)
                                    If VBFlexGridColsInfo(iCol).Lookup.Items(i).Hash = Hash Then
                                        If StrComp(VBFlexGridColsInfo(iCol).Lookup.Items(i).Key, Buffer, vbTextCompare) = 0 Then
                                            Buffer = VBFlexGridColsInfo(iCol).Lookup.Items(i).Value
                                            Exit For
                                        End If
                                    End If
                                Next i
                            End If
                        End If
                        If iCol < SelRange.RightCol Then
                            StrArr(iRow + (PropFixedRows - SelRange.TopRow), iCol + (0 - SelRange.LeftCol)) = Buffer & CSCol
                        ElseIf iRow < SelRange.BottomRow Then
                            StrArr(iRow + (PropFixedRows - SelRange.TopRow), iCol + (0 - SelRange.LeftCol)) = Buffer & CSRow
                        Else
                            StrArr(iRow + (PropFixedRows - SelRange.TopRow), iCol + (0 - SelRange.LeftCol)) = Buffer
                        End If
                    Next iCol
                Next iRow
            Else
                For iRow = 0 To Me.SelectedRows - 1
                    iSelRow = Me.SelectedRow(iRow)
                    For iCol = SelRange.LeftCol To SelRange.RightCol
                        Call GetCellText(iSelRow, iCol, Buffer)
                        If PropClipMode = FlexClipModeLookupConv Then
                            If VBFlexGridColsInfo(iCol).Lookup.Count > 0 Then
                                Hash = CalcHash(Buffer)
                                For i = 0 To (VBFlexGridColsInfo(iCol).Lookup.Count - 1)
                                    If VBFlexGridColsInfo(iCol).Lookup.Items(i).Hash = Hash Then
                                        If StrComp(VBFlexGridColsInfo(iCol).Lookup.Items(i).Key, Buffer, vbTextCompare) = 0 Then
                                            Buffer = VBFlexGridColsInfo(iCol).Lookup.Items(i).Value
                                            Exit For
                                        End If
                                    End If
                                Next i
                            End If
                        End If
                        If iCol < SelRange.RightCol Then
                            StrArr(iRow + PropFixedRows, iCol + (0 - SelRange.LeftCol)) = Buffer & CSCol
                        ElseIf iSelRow < SelRange.BottomRow Then
                            StrArr(iRow + PropFixedRows, iCol + (0 - SelRange.LeftCol)) = Buffer & CSRow
                        Else
                            StrArr(iRow + PropFixedRows, iCol + (0 - SelRange.LeftCol)) = Buffer
                        End If
                    Next iCol
                Next iRow
            End If
        Case FlexClipCopyModeIncludeFixedColumns, FlexClipCopyModeExtendedFixedColumns
            If PropAllowMultiSelection = False Or PropClipCopyMode = FlexClipCopyModeIncludeFixedColumns Then
                For iRow = SelRange.TopRow To SelRange.BottomRow
                    For iCol = 0 To PropFixedCols - 1
                        Call GetCellText(iRow, iCol, Buffer)
                        If PropClipMode = FlexClipModeLookupConv Then
                            If VBFlexGridColsInfo(iCol).Lookup.Count > 0 Then
                                Hash = CalcHash(Buffer)
                                For i = 0 To (VBFlexGridColsInfo(iCol).Lookup.Count - 1)
                                    If VBFlexGridColsInfo(iCol).Lookup.Items(i).Hash = Hash Then
                                        If StrComp(VBFlexGridColsInfo(iCol).Lookup.Items(i).Key, Buffer, vbTextCompare) = 0 Then
                                            Buffer = VBFlexGridColsInfo(iCol).Lookup.Items(i).Value
                                            Exit For
                                        End If
                                    End If
                                Next i
                            End If
                        End If
                        If iCol < SelRange.RightCol Then
                            StrArr(iRow + (0 - SelRange.TopRow), iCol) = Buffer & CSCol
                        ElseIf iRow < SelRange.BottomRow Then
                            StrArr(iRow + (0 - SelRange.TopRow), iCol) = Buffer & CSRow
                        Else
                            StrArr(iRow + (0 - SelRange.TopRow), iCol) = Buffer
                        End If
                    Next iCol
                    For iCol = SelRange.LeftCol To SelRange.RightCol
                        Call GetCellText(iRow, iCol, Buffer)
                        If PropClipMode = FlexClipModeLookupConv Then
                            If VBFlexGridColsInfo(iCol).Lookup.Count > 0 Then
                                Hash = CalcHash(Buffer)
                                For i = 0 To (VBFlexGridColsInfo(iCol).Lookup.Count - 1)
                                    If VBFlexGridColsInfo(iCol).Lookup.Items(i).Hash = Hash Then
                                        If StrComp(VBFlexGridColsInfo(iCol).Lookup.Items(i).Key, Buffer, vbTextCompare) = 0 Then
                                            Buffer = VBFlexGridColsInfo(iCol).Lookup.Items(i).Value
                                            Exit For
                                        End If
                                    End If
                                Next i
                            End If
                        End If
                        If iCol < SelRange.RightCol Then
                            StrArr(iRow + (0 - SelRange.TopRow), iCol + (PropFixedCols - SelRange.LeftCol)) = Buffer & CSCol
                        ElseIf iRow < SelRange.BottomRow Then
                            StrArr(iRow + (0 - SelRange.TopRow), iCol + (PropFixedCols - SelRange.LeftCol)) = Buffer & CSRow
                        Else
                            StrArr(iRow + (0 - SelRange.TopRow), iCol + (PropFixedCols - SelRange.LeftCol)) = Buffer
                        End If
                    Next iCol
                Next iRow
            Else
                For iRow = 0 To Me.SelectedRows - 1
                    iSelRow = Me.SelectedRow(iRow)
                    For iCol = 0 To PropFixedCols - 1
                        Call GetCellText(iSelRow, iCol, Buffer)
                        If PropClipMode = FlexClipModeLookupConv Then
                            If VBFlexGridColsInfo(iCol).Lookup.Count > 0 Then
                                Hash = CalcHash(Buffer)
                                For i = 0 To (VBFlexGridColsInfo(iCol).Lookup.Count - 1)
                                    If VBFlexGridColsInfo(iCol).Lookup.Items(i).Hash = Hash Then
                                        If StrComp(VBFlexGridColsInfo(iCol).Lookup.Items(i).Key, Buffer, vbTextCompare) = 0 Then
                                            Buffer = VBFlexGridColsInfo(iCol).Lookup.Items(i).Value
                                            Exit For
                                        End If
                                    End If
                                Next i
                            End If
                        End If
                        If iCol < SelRange.RightCol Then
                            StrArr(iRow, iCol) = Buffer & CSCol
                        ElseIf iSelRow < SelRange.BottomRow Then
                            StrArr(iRow, iCol) = Buffer & CSRow
                        Else
                            StrArr(iRow, iCol) = Buffer
                        End If
                    Next iCol
                    For iCol = SelRange.LeftCol To SelRange.RightCol
                        Call GetCellText(iSelRow, iCol, Buffer)
                        If PropClipMode = FlexClipModeLookupConv Then
                            If VBFlexGridColsInfo(iCol).Lookup.Count > 0 Then
                                Hash = CalcHash(Buffer)
                                For i = 0 To (VBFlexGridColsInfo(iCol).Lookup.Count - 1)
                                    If VBFlexGridColsInfo(iCol).Lookup.Items(i).Hash = Hash Then
                                        If StrComp(VBFlexGridColsInfo(iCol).Lookup.Items(i).Key, Buffer, vbTextCompare) = 0 Then
                                            Buffer = VBFlexGridColsInfo(iCol).Lookup.Items(i).Value
                                            Exit For
                                        End If
                                    End If
                                Next i
                            End If
                        End If
                        If iCol < SelRange.RightCol Then
                            StrArr(iRow, iCol + (PropFixedCols - SelRange.LeftCol)) = Buffer & CSCol
                        ElseIf iSelRow < SelRange.BottomRow Then
                            StrArr(iRow, iCol + (PropFixedCols - SelRange.LeftCol)) = Buffer & CSRow
                        Else
                            StrArr(iRow, iCol + (PropFixedCols - SelRange.LeftCol)) = Buffer
                        End If
                    Next iCol
                Next iRow
            End If
        Case FlexClipCopyModeIncludeFixedAll, FlexClipCopyModeExtendedFixedAll
            For iRow = 0 To PropFixedRows - 1
                For iCol = 0 To PropFixedCols - 1
                    Call GetCellText(iRow, iCol, Buffer)
                    If PropClipMode = FlexClipModeLookupConv Then
                        If VBFlexGridColsInfo(iCol).Lookup.Count > 0 Then
                            Hash = CalcHash(Buffer)
                            For i = 0 To (VBFlexGridColsInfo(iCol).Lookup.Count - 1)
                                If VBFlexGridColsInfo(iCol).Lookup.Items(i).Hash = Hash Then
                                    If StrComp(VBFlexGridColsInfo(iCol).Lookup.Items(i).Key, Buffer, vbTextCompare) = 0 Then
                                        Buffer = VBFlexGridColsInfo(iCol).Lookup.Items(i).Value
                                        Exit For
                                    End If
                                End If
                            Next i
                        End If
                    End If
                    If iCol < SelRange.RightCol Then
                        StrArr(iRow, iCol) = Buffer & CSCol
                    ElseIf iRow < SelRange.BottomRow Then
                        StrArr(iRow, iCol) = Buffer & CSRow
                    Else
                        StrArr(iRow, iCol) = Buffer
                    End If
                Next iCol
                For iCol = SelRange.LeftCol To SelRange.RightCol
                    Call GetCellText(iRow, iCol, Buffer)
                    If PropClipMode = FlexClipModeLookupConv Then
                        If VBFlexGridColsInfo(iCol).Lookup.Count > 0 Then
                            Hash = CalcHash(Buffer)
                            For i = 0 To (VBFlexGridColsInfo(iCol).Lookup.Count - 1)
                                If VBFlexGridColsInfo(iCol).Lookup.Items(i).Hash = Hash Then
                                    If StrComp(VBFlexGridColsInfo(iCol).Lookup.Items(i).Key, Buffer, vbTextCompare) = 0 Then
                                        Buffer = VBFlexGridColsInfo(iCol).Lookup.Items(i).Value
                                        Exit For
                                    End If
                                End If
                            Next i
                        End If
                    End If
                    If iCol < SelRange.RightCol Then
                        StrArr(iRow, iCol + (PropFixedCols - SelRange.LeftCol)) = Buffer & CSCol
                    ElseIf iRow < SelRange.BottomRow Then
                        StrArr(iRow, iCol + (PropFixedCols - SelRange.LeftCol)) = Buffer & CSRow
                    Else
                        StrArr(iRow, iCol + (PropFixedCols - SelRange.LeftCol)) = Buffer
                    End If
                Next iCol
            Next iRow
            If PropAllowMultiSelection = False Or PropClipCopyMode = FlexClipCopyModeIncludeFixedAll Then
                For iRow = SelRange.TopRow To SelRange.BottomRow
                    For iCol = 0 To PropFixedCols - 1
                        Call GetCellText(iRow, iCol, Buffer)
                        If PropClipMode = FlexClipModeLookupConv Then
                            If VBFlexGridColsInfo(iCol).Lookup.Count > 0 Then
                                Hash = CalcHash(Buffer)
                                For i = 0 To (VBFlexGridColsInfo(iCol).Lookup.Count - 1)
                                    If VBFlexGridColsInfo(iCol).Lookup.Items(i).Hash = Hash Then
                                        If StrComp(VBFlexGridColsInfo(iCol).Lookup.Items(i).Key, Buffer, vbTextCompare) = 0 Then
                                            Buffer = VBFlexGridColsInfo(iCol).Lookup.Items(i).Value
                                            Exit For
                                        End If
                                    End If
                                Next i
                            End If
                        End If
                        If iCol < SelRange.RightCol Then
                            StrArr(iRow + (PropFixedRows - SelRange.TopRow), iCol) = Buffer & CSCol
                        ElseIf iRow < SelRange.BottomRow Then
                            StrArr(iRow + (PropFixedRows - SelRange.TopRow), iCol) = Buffer & CSRow
                        Else
                            StrArr(iRow + (PropFixedRows - SelRange.TopRow), iCol) = Buffer
                        End If
                    Next iCol
                    For iCol = SelRange.LeftCol To SelRange.RightCol
                        Call GetCellText(iRow, iCol, Buffer)
                        If PropClipMode = FlexClipModeLookupConv Then
                            If VBFlexGridColsInfo(iCol).Lookup.Count > 0 Then
                                Hash = CalcHash(Buffer)
                                For i = 0 To (VBFlexGridColsInfo(iCol).Lookup.Count - 1)
                                    If VBFlexGridColsInfo(iCol).Lookup.Items(i).Hash = Hash Then
                                        If StrComp(VBFlexGridColsInfo(iCol).Lookup.Items(i).Key, Buffer, vbTextCompare) = 0 Then
                                            Buffer = VBFlexGridColsInfo(iCol).Lookup.Items(i).Value
                                            Exit For
                                        End If
                                    End If
                                Next i
                            End If
                        End If
                        If iCol < SelRange.RightCol Then
                            StrArr(iRow + (PropFixedRows - SelRange.TopRow), iCol + (PropFixedCols - SelRange.LeftCol)) = Buffer & CSCol
                        ElseIf iRow < SelRange.BottomRow Then
                            StrArr(iRow + (PropFixedRows - SelRange.TopRow), iCol + (PropFixedCols - SelRange.LeftCol)) = Buffer & CSRow
                        Else
                            StrArr(iRow + (PropFixedRows - SelRange.TopRow), iCol + (PropFixedCols - SelRange.LeftCol)) = Buffer
                        End If
                    Next iCol
                Next iRow
            Else
                For iRow = 0 To Me.SelectedRows - 1
                    iSelRow = Me.SelectedRow(iRow)
                    For iCol = 0 To PropFixedCols - 1
                        Call GetCellText(iSelRow, iCol, Buffer)
                        If PropClipMode = FlexClipModeLookupConv Then
                            If VBFlexGridColsInfo(iCol).Lookup.Count > 0 Then
                                Hash = CalcHash(Buffer)
                                For i = 0 To (VBFlexGridColsInfo(iCol).Lookup.Count - 1)
                                    If VBFlexGridColsInfo(iCol).Lookup.Items(i).Hash = Hash Then
                                        If StrComp(VBFlexGridColsInfo(iCol).Lookup.Items(i).Key, Buffer, vbTextCompare) = 0 Then
                                            Buffer = VBFlexGridColsInfo(iCol).Lookup.Items(i).Value
                                            Exit For
                                        End If
                                    End If
                                Next i
                            End If
                        End If
                        If iCol < SelRange.RightCol Then
                            StrArr(iRow + PropFixedRows, iCol) = Buffer & CSCol
                        ElseIf iSelRow < SelRange.BottomRow Then
                            StrArr(iRow + PropFixedRows, iCol) = Buffer & CSRow
                        Else
                            StrArr(iRow + PropFixedRows, iCol) = Buffer
                        End If
                    Next iCol
                    For iCol = SelRange.LeftCol To SelRange.RightCol
                        Call GetCellText(iSelRow, iCol, Buffer)
                        If PropClipMode = FlexClipModeLookupConv Then
                            If VBFlexGridColsInfo(iCol).Lookup.Count > 0 Then
                                Hash = CalcHash(Buffer)
                                For i = 0 To (VBFlexGridColsInfo(iCol).Lookup.Count - 1)
                                    If VBFlexGridColsInfo(iCol).Lookup.Items(i).Hash = Hash Then
                                        If StrComp(VBFlexGridColsInfo(iCol).Lookup.Items(i).Key, Buffer, vbTextCompare) = 0 Then
                                            Buffer = VBFlexGridColsInfo(iCol).Lookup.Items(i).Value
                                            Exit For
                                        End If
                                    End If
                                Next i
                            End If
                        End If
                        If iCol < SelRange.RightCol Then
                            StrArr(iRow + PropFixedRows, iCol + (PropFixedCols - SelRange.LeftCol)) = Buffer & CSCol
                        ElseIf iSelRow < SelRange.BottomRow Then
                            StrArr(iRow + PropFixedRows, iCol + (PropFixedCols - SelRange.LeftCol)) = Buffer & CSRow
                        Else
                            StrArr(iRow + PropFixedRows, iCol + (PropFixedCols - SelRange.LeftCol)) = Buffer
                        End If
                    Next iCol
                Next iRow
            End If
    End Select
ElseIf PropClipMode = FlexClipModeExcludeHidden Or PropClipMode = FlexClipModeLookupConvExcludeHidden Then
    Dim FixedRowsAdj As Long, FixedColsAdj As Long
    For iRow = 0 To PropFixedRows - 1
        If (VBFlexGridCells.Rows(iRow).RowInfo.State And RWIS_HIDDEN) = 0 Then FixedRowsAdj = FixedRowsAdj + 1
    Next iRow
    For iCol = 0 To PropFixedCols - 1
        If (VBFlexGridColsInfo(iCol).State And CLIS_HIDDEN) = 0 Then FixedColsAdj = FixedColsAdj + 1
    Next iCol
    ' Adjust bottom row and right col so the separators are placed correctly.
    For iRow = SelRange.BottomRow To SelRange.TopRow Step -1
        If (VBFlexGridCells.Rows(iRow).RowInfo.State And RWIS_HIDDEN) = RWIS_HIDDEN Then SelRange.BottomRow = SelRange.BottomRow - 1 Else Exit For
    Next iRow
    For iCol = SelRange.RightCol To SelRange.LeftCol Step -1
        If (VBFlexGridColsInfo(iCol).State And CLIS_HIDDEN) = CLIS_HIDDEN Then SelRange.RightCol = SelRange.RightCol - 1 Else Exit For
    Next iCol
    Dim ArrRowAdj As Long, ArrColAdj As Long
    Select Case PropClipCopyMode
        Case FlexClipCopyModeNormal, FlexClipCopyModeExtended
            If PropAllowMultiSelection = False Or PropClipCopyMode = FlexClipCopyModeNormal Then
                For iRow = SelRange.TopRow To SelRange.BottomRow
                    If (VBFlexGridCells.Rows(iRow).RowInfo.State And RWIS_HIDDEN) = 0 Then
                        For iCol = SelRange.LeftCol To SelRange.RightCol
                            If (VBFlexGridColsInfo(iCol).State And CLIS_HIDDEN) = 0 Then
                                Call GetCellText(iRow, iCol, Buffer)
                                If PropClipMode = FlexClipModeLookupConvExcludeHidden Then
                                    If VBFlexGridColsInfo(iCol).Lookup.Count > 0 Then
                                        Hash = CalcHash(Buffer)
                                        For i = 0 To (VBFlexGridColsInfo(iCol).Lookup.Count - 1)
                                            If VBFlexGridColsInfo(iCol).Lookup.Items(i).Hash = Hash Then
                                                If StrComp(VBFlexGridColsInfo(iCol).Lookup.Items(i).Key, Buffer, vbTextCompare) = 0 Then
                                                    Buffer = VBFlexGridColsInfo(iCol).Lookup.Items(i).Value
                                                    Exit For
                                                End If
                                            End If
                                        Next i
                                    End If
                                End If
                                If iCol < SelRange.RightCol Then
                                    StrArr(iRow + (0 - SelRange.TopRow) - ArrRowAdj, iCol + (0 - SelRange.LeftCol) - ArrColAdj) = Buffer & CSCol
                                ElseIf iRow < SelRange.BottomRow Then
                                    StrArr(iRow + (0 - SelRange.TopRow) - ArrRowAdj, iCol + (0 - SelRange.LeftCol) - ArrColAdj) = Buffer & CSRow
                                Else
                                    StrArr(iRow + (0 - SelRange.TopRow) - ArrRowAdj, iCol + (0 - SelRange.LeftCol) - ArrColAdj) = Buffer
                                End If
                            Else
                                ArrColAdj = ArrColAdj + 1
                            End If
                        Next iCol
                    Else
                        ArrRowAdj = ArrRowAdj + 1
                    End If
                    ArrColAdj = 0
                Next iRow
            Else
                For iRow = 0 To Me.SelectedRows - 1
                    iSelRow = Me.SelectedRow(iRow)
                    If (VBFlexGridCells.Rows(iSelRow).RowInfo.State And RWIS_HIDDEN) = 0 Then
                        For iCol = SelRange.LeftCol To SelRange.RightCol
                            If (VBFlexGridColsInfo(iCol).State And CLIS_HIDDEN) = 0 Then
                                Call GetCellText(iSelRow, iCol, Buffer)
                                If PropClipMode = FlexClipModeLookupConvExcludeHidden Then
                                    If VBFlexGridColsInfo(iCol).Lookup.Count > 0 Then
                                        Hash = CalcHash(Buffer)
                                        For i = 0 To (VBFlexGridColsInfo(iCol).Lookup.Count - 1)
                                            If VBFlexGridColsInfo(iCol).Lookup.Items(i).Hash = Hash Then
                                                If StrComp(VBFlexGridColsInfo(iCol).Lookup.Items(i).Key, Buffer, vbTextCompare) = 0 Then
                                                    Buffer = VBFlexGridColsInfo(iCol).Lookup.Items(i).Value
                                                    Exit For
                                                End If
                                            End If
                                        Next i
                                    End If
                                End If
                                If iCol < SelRange.RightCol Then
                                    StrArr(iRow - ArrRowAdj, iCol + (0 - SelRange.LeftCol) - ArrColAdj) = Buffer & CSCol
                                ElseIf iSelRow < SelRange.BottomRow Then
                                    StrArr(iRow - ArrRowAdj, iCol + (0 - SelRange.LeftCol) - ArrColAdj) = Buffer & CSRow
                                Else
                                    StrArr(iRow - ArrRowAdj, iCol + (0 - SelRange.LeftCol) - ArrColAdj) = Buffer
                                End If
                            Else
                                ArrColAdj = ArrColAdj + 1
                            End If
                        Next iCol
                    Else
                        ArrRowAdj = ArrRowAdj + 1
                    End If
                    ArrColAdj = 0
                Next iRow
            End If
        Case FlexClipCopyModeIncludeFixedRows, FlexClipCopyModeExtendedFixedRows
            For iCol = SelRange.LeftCol To SelRange.RightCol
                If (VBFlexGridColsInfo(iCol).State And CLIS_HIDDEN) = 0 Then
                    For iRow = 0 To PropFixedRows - 1
                        If (VBFlexGridCells.Rows(iRow).RowInfo.State And RWIS_HIDDEN) = 0 Then
                            Call GetCellText(iRow, iCol, Buffer)
                            If PropClipMode = FlexClipModeLookupConvExcludeHidden Then
                                If VBFlexGridColsInfo(iCol).Lookup.Count > 0 Then
                                    Hash = CalcHash(Buffer)
                                    For i = 0 To (VBFlexGridColsInfo(iCol).Lookup.Count - 1)
                                        If VBFlexGridColsInfo(iCol).Lookup.Items(i).Hash = Hash Then
                                            If StrComp(VBFlexGridColsInfo(iCol).Lookup.Items(i).Key, Buffer, vbTextCompare) = 0 Then
                                                Buffer = VBFlexGridColsInfo(iCol).Lookup.Items(i).Value
                                                Exit For
                                            End If
                                        End If
                                    Next i
                                End If
                            End If
                            If iCol < SelRange.RightCol Then
                                StrArr(iRow - ArrRowAdj, iCol + (0 - SelRange.LeftCol) - ArrColAdj) = Buffer & CSCol
                            ElseIf iRow < SelRange.BottomRow Then
                                StrArr(iRow - ArrRowAdj, iCol + (0 - SelRange.LeftCol) - ArrColAdj) = Buffer & CSRow
                            Else
                                StrArr(iRow - ArrRowAdj, iCol + (0 - SelRange.LeftCol) - ArrColAdj) = Buffer
                            End If
                        Else
                            ArrRowAdj = ArrRowAdj + 1
                        End If
                    Next iRow
                Else
                    ArrColAdj = ArrColAdj + 1
                End If
                ArrRowAdj = 0
            Next iCol
            ArrRowAdj = 0
            ArrColAdj = 0
            If PropAllowMultiSelection = False Or PropClipCopyMode = FlexClipCopyModeIncludeFixedRows Then
                For iRow = SelRange.TopRow To SelRange.BottomRow
                    If (VBFlexGridCells.Rows(iRow).RowInfo.State And RWIS_HIDDEN) = 0 Then
                        For iCol = SelRange.LeftCol To SelRange.RightCol
                            If (VBFlexGridColsInfo(iCol).State And CLIS_HIDDEN) = 0 Then
                                Call GetCellText(iRow, iCol, Buffer)
                                If PropClipMode = FlexClipModeLookupConvExcludeHidden Then
                                    If VBFlexGridColsInfo(iCol).Lookup.Count > 0 Then
                                        Hash = CalcHash(Buffer)
                                        For i = 0 To (VBFlexGridColsInfo(iCol).Lookup.Count - 1)
                                            If VBFlexGridColsInfo(iCol).Lookup.Items(i).Hash = Hash Then
                                                If StrComp(VBFlexGridColsInfo(iCol).Lookup.Items(i).Key, Buffer, vbTextCompare) = 0 Then
                                                    Buffer = VBFlexGridColsInfo(iCol).Lookup.Items(i).Value
                                                    Exit For
                                                End If
                                            End If
                                        Next i
                                    End If
                                End If
                                If iCol < SelRange.RightCol Then
                                    StrArr(iRow + (FixedRowsAdj - SelRange.TopRow) - ArrRowAdj, iCol + (0 - SelRange.LeftCol) - ArrColAdj) = Buffer & CSCol
                                ElseIf iRow < SelRange.BottomRow Then
                                    StrArr(iRow + (FixedRowsAdj - SelRange.TopRow) - ArrRowAdj, iCol + (0 - SelRange.LeftCol) - ArrColAdj) = Buffer & CSRow
                                Else
                                    StrArr(iRow + (FixedRowsAdj - SelRange.TopRow) - ArrRowAdj, iCol + (0 - SelRange.LeftCol) - ArrColAdj) = Buffer
                                End If
                            Else
                                ArrColAdj = ArrColAdj + 1
                            End If
                        Next iCol
                    Else
                        ArrRowAdj = ArrRowAdj + 1
                    End If
                    ArrColAdj = 0
                Next iRow
            Else
                For iRow = 0 To Me.SelectedRows - 1
                    iSelRow = Me.SelectedRow(iRow)
                    If (VBFlexGridCells.Rows(iSelRow).RowInfo.State And RWIS_HIDDEN) = 0 Then
                        For iCol = SelRange.LeftCol To SelRange.RightCol
                            If (VBFlexGridColsInfo(iCol).State And CLIS_HIDDEN) = 0 Then
                                Call GetCellText(iSelRow, iCol, Buffer)
                                If PropClipMode = FlexClipModeLookupConvExcludeHidden Then
                                    If VBFlexGridColsInfo(iCol).Lookup.Count > 0 Then
                                        Hash = CalcHash(Buffer)
                                        For i = 0 To (VBFlexGridColsInfo(iCol).Lookup.Count - 1)
                                            If VBFlexGridColsInfo(iCol).Lookup.Items(i).Hash = Hash Then
                                                If StrComp(VBFlexGridColsInfo(iCol).Lookup.Items(i).Key, Buffer, vbTextCompare) = 0 Then
                                                    Buffer = VBFlexGridColsInfo(iCol).Lookup.Items(i).Value
                                                    Exit For
                                                End If
                                            End If
                                        Next i
                                    End If
                                End If
                                If iCol < SelRange.RightCol Then
                                    StrArr(iRow + FixedRowsAdj - ArrRowAdj, iCol + (0 - SelRange.LeftCol) - ArrColAdj) = Buffer & CSCol
                                ElseIf iSelRow < SelRange.BottomRow Then
                                    StrArr(iRow + FixedRowsAdj - ArrRowAdj, iCol + (0 - SelRange.LeftCol) - ArrColAdj) = Buffer & CSRow
                                Else
                                    StrArr(iRow + FixedRowsAdj - ArrRowAdj, iCol + (0 - SelRange.LeftCol) - ArrColAdj) = Buffer
                                End If
                            Else
                                ArrColAdj = ArrColAdj + 1
                            End If
                        Next iCol
                    Else
                        ArrRowAdj = ArrRowAdj + 1
                    End If
                    ArrColAdj = 0
                Next iRow
            End If
        Case FlexClipCopyModeIncludeFixedColumns, FlexClipCopyModeExtendedFixedColumns
            If PropAllowMultiSelection = False Or PropClipCopyMode = FlexClipCopyModeIncludeFixedColumns Then
                For iRow = SelRange.TopRow To SelRange.BottomRow
                    If (VBFlexGridCells.Rows(iRow).RowInfo.State And RWIS_HIDDEN) = 0 Then
                        For iCol = 0 To PropFixedCols - 1
                            If (VBFlexGridColsInfo(iCol).State And CLIS_HIDDEN) = 0 Then
                                Call GetCellText(iRow, iCol, Buffer)
                                If PropClipMode = FlexClipModeLookupConvExcludeHidden Then
                                    If VBFlexGridColsInfo(iCol).Lookup.Count > 0 Then
                                        Hash = CalcHash(Buffer)
                                        For i = 0 To (VBFlexGridColsInfo(iCol).Lookup.Count - 1)
                                            If VBFlexGridColsInfo(iCol).Lookup.Items(i).Hash = Hash Then
                                                If StrComp(VBFlexGridColsInfo(iCol).Lookup.Items(i).Key, Buffer, vbTextCompare) = 0 Then
                                                    Buffer = VBFlexGridColsInfo(iCol).Lookup.Items(i).Value
                                                    Exit For
                                                End If
                                            End If
                                        Next i
                                    End If
                                End If
                                If iCol < SelRange.RightCol Then
                                    StrArr(iRow + (0 - SelRange.TopRow) - ArrRowAdj, iCol - ArrColAdj) = Buffer & CSCol
                                ElseIf iRow < SelRange.BottomRow Then
                                    StrArr(iRow + (0 - SelRange.TopRow) - ArrRowAdj, iCol - ArrColAdj) = Buffer & CSRow
                                Else
                                    StrArr(iRow + (0 - SelRange.TopRow) - ArrRowAdj, iCol - ArrColAdj) = Buffer
                                End If
                            Else
                                ArrColAdj = ArrColAdj + 1
                            End If
                        Next iCol
                        ArrColAdj = 0
                        For iCol = SelRange.LeftCol To SelRange.RightCol
                            If (VBFlexGridColsInfo(iCol).State And CLIS_HIDDEN) = 0 Then
                                Call GetCellText(iRow, iCol, Buffer)
                                If PropClipMode = FlexClipModeLookupConvExcludeHidden Then
                                    If VBFlexGridColsInfo(iCol).Lookup.Count > 0 Then
                                        Hash = CalcHash(Buffer)
                                        For i = 0 To (VBFlexGridColsInfo(iCol).Lookup.Count - 1)
                                            If VBFlexGridColsInfo(iCol).Lookup.Items(i).Hash = Hash Then
                                                If StrComp(VBFlexGridColsInfo(iCol).Lookup.Items(i).Key, Buffer, vbTextCompare) = 0 Then
                                                    Buffer = VBFlexGridColsInfo(iCol).Lookup.Items(i).Value
                                                    Exit For
                                                End If
                                            End If
                                        Next i
                                    End If
                                End If
                                If iCol < SelRange.RightCol Then
                                    StrArr(iRow + (0 - SelRange.TopRow) - ArrRowAdj, iCol + (FixedColsAdj - SelRange.LeftCol) - ArrColAdj) = Buffer & CSCol
                                ElseIf iRow < SelRange.BottomRow Then
                                    StrArr(iRow + (0 - SelRange.TopRow) - ArrRowAdj, iCol + (FixedColsAdj - SelRange.LeftCol) - ArrColAdj) = Buffer & CSRow
                                Else
                                    StrArr(iRow + (0 - SelRange.TopRow) - ArrRowAdj, iCol + (FixedColsAdj - SelRange.LeftCol) - ArrColAdj) = Buffer
                                End If
                            Else
                                ArrColAdj = ArrColAdj + 1
                            End If
                        Next iCol
                    Else
                        ArrRowAdj = ArrRowAdj + 1
                    End If
                    ArrColAdj = 0
                Next iRow
            Else
                For iRow = 0 To Me.SelectedRows - 1
                    iSelRow = Me.SelectedRow(iRow)
                    If (VBFlexGridCells.Rows(iSelRow).RowInfo.State And RWIS_HIDDEN) = 0 Then
                        For iCol = 0 To PropFixedCols - 1
                            If (VBFlexGridColsInfo(iCol).State And CLIS_HIDDEN) = 0 Then
                                Call GetCellText(iSelRow, iCol, Buffer)
                                If PropClipMode = FlexClipModeLookupConvExcludeHidden Then
                                    If VBFlexGridColsInfo(iCol).Lookup.Count > 0 Then
                                        Hash = CalcHash(Buffer)
                                        For i = 0 To (VBFlexGridColsInfo(iCol).Lookup.Count - 1)
                                            If VBFlexGridColsInfo(iCol).Lookup.Items(i).Hash = Hash Then
                                                If StrComp(VBFlexGridColsInfo(iCol).Lookup.Items(i).Key, Buffer, vbTextCompare) = 0 Then
                                                    Buffer = VBFlexGridColsInfo(iCol).Lookup.Items(i).Value
                                                    Exit For
                                                End If
                                            End If
                                        Next i
                                    End If
                                End If
                                If iCol < SelRange.RightCol Then
                                    StrArr(iRow - ArrRowAdj, iCol - ArrColAdj) = Buffer & CSCol
                                ElseIf iSelRow < SelRange.BottomRow Then
                                    StrArr(iRow - ArrRowAdj, iCol - ArrColAdj) = Buffer & CSRow
                                Else
                                    StrArr(iRow - ArrRowAdj, iCol - ArrColAdj) = Buffer
                                End If
                            Else
                                ArrColAdj = ArrColAdj + 1
                            End If
                        Next iCol
                        ArrColAdj = 0
                        For iCol = SelRange.LeftCol To SelRange.RightCol
                            If (VBFlexGridColsInfo(iCol).State And CLIS_HIDDEN) = 0 Then
                                Call GetCellText(iSelRow, iCol, Buffer)
                                If PropClipMode = FlexClipModeLookupConvExcludeHidden Then
                                    If VBFlexGridColsInfo(iCol).Lookup.Count > 0 Then
                                        Hash = CalcHash(Buffer)
                                        For i = 0 To (VBFlexGridColsInfo(iCol).Lookup.Count - 1)
                                            If VBFlexGridColsInfo(iCol).Lookup.Items(i).Hash = Hash Then
                                                If StrComp(VBFlexGridColsInfo(iCol).Lookup.Items(i).Key, Buffer, vbTextCompare) = 0 Then
                                                    Buffer = VBFlexGridColsInfo(iCol).Lookup.Items(i).Value
                                                    Exit For
                                                End If
                                            End If
                                        Next i
                                    End If
                                End If
                                If iCol < SelRange.RightCol Then
                                    StrArr(iRow - ArrRowAdj, iCol + (FixedColsAdj - SelRange.LeftCol) - ArrColAdj) = Buffer & CSCol
                                ElseIf iSelRow < SelRange.BottomRow Then
                                    StrArr(iRow - ArrRowAdj, iCol + (FixedColsAdj - SelRange.LeftCol) - ArrColAdj) = Buffer & CSRow
                                Else
                                    StrArr(iRow - ArrRowAdj, iCol + (FixedColsAdj - SelRange.LeftCol) - ArrColAdj) = Buffer
                                End If
                            Else
                                ArrColAdj = ArrColAdj + 1
                            End If
                        Next iCol
                    Else
                        ArrRowAdj = ArrRowAdj + 1
                    End If
                    ArrColAdj = 0
                Next iRow
            End If
        Case FlexClipCopyModeIncludeFixedAll, FlexClipCopyModeExtendedFixedAll
            For iRow = 0 To PropFixedRows - 1
                If (VBFlexGridCells.Rows(iRow).RowInfo.State And RWIS_HIDDEN) = 0 Then
                    For iCol = 0 To PropFixedCols - 1
                        If (VBFlexGridColsInfo(iCol).State And CLIS_HIDDEN) = 0 Then
                            Call GetCellText(iRow, iCol, Buffer)
                            If PropClipMode = FlexClipModeLookupConvExcludeHidden Then
                                If VBFlexGridColsInfo(iCol).Lookup.Count > 0 Then
                                    Hash = CalcHash(Buffer)
                                    For i = 0 To (VBFlexGridColsInfo(iCol).Lookup.Count - 1)
                                        If VBFlexGridColsInfo(iCol).Lookup.Items(i).Hash = Hash Then
                                            If StrComp(VBFlexGridColsInfo(iCol).Lookup.Items(i).Key, Buffer, vbTextCompare) = 0 Then
                                                Buffer = VBFlexGridColsInfo(iCol).Lookup.Items(i).Value
                                                Exit For
                                            End If
                                        End If
                                    Next i
                                End If
                            End If
                            If iCol < SelRange.RightCol Then
                                StrArr(iRow - ArrRowAdj, iCol - ArrColAdj) = Buffer & CSCol
                            ElseIf iRow < SelRange.BottomRow Then
                                StrArr(iRow - ArrRowAdj, iCol - ArrColAdj) = Buffer & CSRow
                            Else
                                StrArr(iRow - ArrRowAdj, iCol - ArrColAdj) = Buffer
                            End If
                        Else
                            ArrColAdj = ArrColAdj + 1
                        End If
                    Next iCol
                    ArrColAdj = 0
                    For iCol = SelRange.LeftCol To SelRange.RightCol
                        If (VBFlexGridColsInfo(iCol).State And CLIS_HIDDEN) = 0 Then
                            Call GetCellText(iRow, iCol, Buffer)
                            If PropClipMode = FlexClipModeLookupConvExcludeHidden Then
                                If VBFlexGridColsInfo(iCol).Lookup.Count > 0 Then
                                    Hash = CalcHash(Buffer)
                                    For i = 0 To (VBFlexGridColsInfo(iCol).Lookup.Count - 1)
                                        If VBFlexGridColsInfo(iCol).Lookup.Items(i).Hash = Hash Then
                                            If StrComp(VBFlexGridColsInfo(iCol).Lookup.Items(i).Key, Buffer, vbTextCompare) = 0 Then
                                                Buffer = VBFlexGridColsInfo(iCol).Lookup.Items(i).Value
                                                Exit For
                                            End If
                                        End If
                                    Next i
                                End If
                            End If
                            If iCol < SelRange.RightCol Then
                                StrArr(iRow - ArrRowAdj, iCol + (FixedColsAdj - SelRange.LeftCol) - ArrColAdj) = Buffer & CSCol
                            ElseIf iRow < SelRange.BottomRow Then
                                StrArr(iRow - ArrRowAdj, iCol + (FixedColsAdj - SelRange.LeftCol) - ArrColAdj) = Buffer & CSRow
                            Else
                                StrArr(iRow - ArrRowAdj, iCol + (FixedColsAdj - SelRange.LeftCol) - ArrColAdj) = Buffer
                            End If
                        Else
                            ArrColAdj = ArrColAdj + 1
                        End If
                    Next iCol
                Else
                    ArrRowAdj = ArrRowAdj + 1
                End If
                ArrColAdj = 0
            Next iRow
            ArrRowAdj = 0
            ArrColAdj = 0
            If PropAllowMultiSelection = False Or PropClipCopyMode = FlexClipCopyModeIncludeFixedAll Then
                For iRow = SelRange.TopRow To SelRange.BottomRow
                    If (VBFlexGridCells.Rows(iRow).RowInfo.State And RWIS_HIDDEN) = 0 Then
                        For iCol = 0 To PropFixedCols - 1
                            If (VBFlexGridColsInfo(iCol).State And CLIS_HIDDEN) = 0 Then
                                Call GetCellText(iRow, iCol, Buffer)
                                If PropClipMode = FlexClipModeLookupConvExcludeHidden Then
                                    If VBFlexGridColsInfo(iCol).Lookup.Count > 0 Then
                                        Hash = CalcHash(Buffer)
                                        For i = 0 To (VBFlexGridColsInfo(iCol).Lookup.Count - 1)
                                            If VBFlexGridColsInfo(iCol).Lookup.Items(i).Hash = Hash Then
                                                If StrComp(VBFlexGridColsInfo(iCol).Lookup.Items(i).Key, Buffer, vbTextCompare) = 0 Then
                                                    Buffer = VBFlexGridColsInfo(iCol).Lookup.Items(i).Value
                                                    Exit For
                                                End If
                                            End If
                                        Next i
                                    End If
                                End If
                                If iCol < SelRange.RightCol Then
                                    StrArr(iRow + (FixedRowsAdj - SelRange.TopRow) - ArrRowAdj, iCol - ArrColAdj) = Buffer & CSCol
                                ElseIf iRow < SelRange.BottomRow Then
                                    StrArr(iRow + (FixedRowsAdj - SelRange.TopRow) - ArrRowAdj, iCol - ArrColAdj) = Buffer & CSRow
                                Else
                                    StrArr(iRow + (FixedRowsAdj - SelRange.TopRow) - ArrRowAdj, iCol - ArrColAdj) = Buffer
                                End If
                            Else
                                ArrColAdj = ArrColAdj + 1
                            End If
                        Next iCol
                        ArrColAdj = 0
                        For iCol = SelRange.LeftCol To SelRange.RightCol
                            If (VBFlexGridColsInfo(iCol).State And CLIS_HIDDEN) = 0 Then
                                Call GetCellText(iRow, iCol, Buffer)
                                If PropClipMode = FlexClipModeLookupConvExcludeHidden Then
                                    If VBFlexGridColsInfo(iCol).Lookup.Count > 0 Then
                                        Hash = CalcHash(Buffer)
                                        For i = 0 To (VBFlexGridColsInfo(iCol).Lookup.Count - 1)
                                            If VBFlexGridColsInfo(iCol).Lookup.Items(i).Hash = Hash Then
                                                If StrComp(VBFlexGridColsInfo(iCol).Lookup.Items(i).Key, Buffer, vbTextCompare) = 0 Then
                                                    Buffer = VBFlexGridColsInfo(iCol).Lookup.Items(i).Value
                                                    Exit For
                                                End If
                                            End If
                                        Next i
                                    End If
                                End If
                                If iCol < SelRange.RightCol Then
                                    StrArr(iRow + (FixedRowsAdj - SelRange.TopRow) - ArrRowAdj, iCol + (FixedColsAdj - SelRange.LeftCol) - ArrColAdj) = Buffer & CSCol
                                ElseIf iRow < SelRange.BottomRow Then
                                    StrArr(iRow + (FixedRowsAdj - SelRange.TopRow) - ArrRowAdj, iCol + (FixedColsAdj - SelRange.LeftCol) - ArrColAdj) = Buffer & CSRow
                                Else
                                    StrArr(iRow + (FixedRowsAdj - SelRange.TopRow) - ArrRowAdj, iCol + (FixedColsAdj - SelRange.LeftCol) - ArrColAdj) = Buffer
                                End If
                            Else
                                ArrColAdj = ArrColAdj + 1
                            End If
                        Next iCol
                    Else
                        ArrRowAdj = ArrRowAdj + 1
                    End If
                    ArrColAdj = 0
                Next iRow
            Else
                For iRow = 0 To Me.SelectedRows - 1
                    iSelRow = Me.SelectedRow(iRow)
                    If (VBFlexGridCells.Rows(iSelRow).RowInfo.State And RWIS_HIDDEN) = 0 Then
                        For iCol = 0 To PropFixedCols - 1
                            If (VBFlexGridColsInfo(iCol).State And CLIS_HIDDEN) = 0 Then
                                Call GetCellText(iSelRow, iCol, Buffer)
                                If PropClipMode = FlexClipModeLookupConvExcludeHidden Then
                                    If VBFlexGridColsInfo(iCol).Lookup.Count > 0 Then
                                        Hash = CalcHash(Buffer)
                                        For i = 0 To (VBFlexGridColsInfo(iCol).Lookup.Count - 1)
                                            If VBFlexGridColsInfo(iCol).Lookup.Items(i).Hash = Hash Then
                                                If StrComp(VBFlexGridColsInfo(iCol).Lookup.Items(i).Key, Buffer, vbTextCompare) = 0 Then
                                                    Buffer = VBFlexGridColsInfo(iCol).Lookup.Items(i).Value
                                                    Exit For
                                                End If
                                            End If
                                        Next i
                                    End If
                                End If
                                If iCol < SelRange.RightCol Then
                                    StrArr(iRow + FixedRowsAdj - ArrRowAdj, iCol - ArrColAdj) = Buffer & CSCol
                                ElseIf iSelRow < SelRange.BottomRow Then
                                    StrArr(iRow + FixedRowsAdj - ArrRowAdj, iCol - ArrColAdj) = Buffer & CSRow
                                Else
                                    StrArr(iRow + FixedRowsAdj - ArrRowAdj, iCol - ArrColAdj) = Buffer
                                End If
                            Else
                                ArrColAdj = ArrColAdj + 1
                            End If
                        Next iCol
                        ArrColAdj = 0
                        For iCol = SelRange.LeftCol To SelRange.RightCol
                            If (VBFlexGridColsInfo(iCol).State And CLIS_HIDDEN) = 0 Then
                                Call GetCellText(iSelRow, iCol, Buffer)
                                If PropClipMode = FlexClipModeLookupConvExcludeHidden Then
                                    If VBFlexGridColsInfo(iCol).Lookup.Count > 0 Then
                                        Hash = CalcHash(Buffer)
                                        For i = 0 To (VBFlexGridColsInfo(iCol).Lookup.Count - 1)
                                            If VBFlexGridColsInfo(iCol).Lookup.Items(i).Hash = Hash Then
                                                If StrComp(VBFlexGridColsInfo(iCol).Lookup.Items(i).Key, Buffer, vbTextCompare) = 0 Then
                                                    Buffer = VBFlexGridColsInfo(iCol).Lookup.Items(i).Value
                                                    Exit For
                                                End If
                                            End If
                                        Next i
                                    End If
                                End If
                                If iCol < SelRange.RightCol Then
                                    StrArr(iRow + FixedRowsAdj - ArrRowAdj, iCol + (FixedColsAdj - SelRange.LeftCol) - ArrColAdj) = Buffer & CSCol
                                ElseIf iSelRow < SelRange.BottomRow Then
                                    StrArr(iRow + FixedRowsAdj - ArrRowAdj, iCol + (FixedColsAdj - SelRange.LeftCol) - ArrColAdj) = Buffer & CSRow
                                Else
                                    StrArr(iRow + FixedRowsAdj - ArrRowAdj, iCol + (FixedColsAdj - SelRange.LeftCol) - ArrColAdj) = Buffer
                                End If
                            Else
                                ArrColAdj = ArrColAdj + 1
                            End If
                        Next iCol
                    Else
                        ArrRowAdj = ArrRowAdj + 1
                    End If
                    ArrColAdj = 0
                Next iRow
            End If
    End Select
End If
For iRow = 0 To UBoundRows
    For iCol = 0 To UBoundCols
        StrSize = StrSize + Len(StrArr(iRow, iCol))
    Next iCol
Next iRow
If StrSize > 0 Then
    Clip = String$(StrSize, vbNullChar)
    StrSize = 1
    For iRow = 0 To UBoundRows
        For iCol = 0 To UBoundCols
            If StrSize <= Len(Clip) Then Mid$(Clip, StrSize, Len(StrArr(iRow, iCol))) = StrArr(iRow, iCol)
            StrSize = StrSize + Len(StrArr(iRow, iCol))
        Next iCol
    Next iRow
End If
End Property

Public Property Let Clip(ByVal Value As String)
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
Dim iRow As Long, iCol As Long, iSelRow As Long, SelRange As TCELLRANGE, Temp As String, Text As String, i As Long
Dim Pos1 As Long, Pos2 As Long, Pos3 As Long, Pos4 As Long
Dim CSCol As String, CSColLen As Long, CSRow As String, CSRowLen As Long
Call GetSelRangeStruct(SelRange)
Select Case PropClipPasteMode
    Case FlexClipPasteModeAutoSelection
        SelRange.RightCol = SelRange.LeftCol
        SelRange.BottomRow = SelRange.TopRow
    Case FlexClipPasteModeExtended
        Select Case PropSelectionMode
            Case FlexSelectionModeFreeByRow
                If SelRange.LeftCol > PropFixedCols Then SelRange.LeftCol = PropFixedCols
                SelRange.RightCol = PropCols - 1
            Case FlexSelectionModeFreeByColumn
                If SelRange.TopRow > PropFixedRows Then SelRange.TopRow = PropFixedRows
                SelRange.BottomRow = PropRows - 1
        End Select
    Case FlexClipPasteModeExtendedAutoSelection
        Select Case PropSelectionMode
            Case FlexSelectionModeFreeByRow
                SelRange.BottomRow = SelRange.TopRow
                If SelRange.LeftCol > PropFixedCols Then SelRange.LeftCol = PropFixedCols
                SelRange.RightCol = PropCols - 1
            Case FlexSelectionModeFreeByColumn
                SelRange.RightCol = SelRange.LeftCol
                If SelRange.TopRow > PropFixedRows Then SelRange.TopRow = PropFixedRows
                SelRange.BottomRow = PropRows - 1
        End Select
End Select
CSCol = GetClipSeparatorCol()
CSColLen = Len(CSCol)
CSRow = GetClipSeparatorRow()
CSRowLen = Len(CSRow)
With VBFlexGridCells
If PropClipMode = FlexClipModeNormal Or PropClipMode = FlexClipModeLookupConv Then
    If PropAllowMultiSelection = False Or PropClipPasteMode <> FlexClipPasteModeExtended Then
        Do
            Pos1 = InStr(Pos1 + 1, Value, CSRow)
            If Pos1 > 0 Then Pos1 = Pos1 + CSRowLen - 1
            If PropClipPasteMode = FlexClipPasteModeAutoSelection Or PropClipPasteMode = FlexClipPasteModeExtendedAutoSelection Then
                If (SelRange.TopRow + iRow) <= (PropRows - 1) And (SelRange.TopRow + iRow) > SelRange.BottomRow Then SelRange.BottomRow = SelRange.TopRow + iRow
            End If
            If (SelRange.TopRow + iRow) <= SelRange.BottomRow Then
                If Pos1 > 0 Then Temp = Mid$(Value, Pos2 + 1, Pos1 - Pos2 - CSRowLen) Else Temp = Mid$(Value, Pos2 + 1)
                Do
                    Pos3 = InStr(Pos3 + 1, Temp, CSCol)
                    If PropClipPasteMode = FlexClipPasteModeAutoSelection Or PropClipPasteMode = FlexClipPasteModeExtendedAutoSelection Then
                        If (SelRange.LeftCol + iCol) <= (PropCols - 1) And (SelRange.LeftCol + iCol) > SelRange.RightCol Then SelRange.RightCol = SelRange.LeftCol + iCol
                    End If
                    If Pos3 > 0 Then
                        Pos3 = Pos3 + CSColLen - 1
                        If (SelRange.LeftCol + iCol) <= SelRange.RightCol Then
                            If PropClipMode = FlexClipModeNormal Then
                                Call SetCellText(SelRange.TopRow + iRow, SelRange.LeftCol + iCol, Mid$(Temp, Pos4 + 1, Pos3 - Pos4 - CSColLen))
                            ElseIf PropClipMode = FlexClipModeLookupConv Then
                                Text = Mid$(Temp, Pos4 + 1, Pos3 - Pos4 - CSColLen)
                                If VBFlexGridColsInfo(SelRange.LeftCol + iCol).Lookup.Count > 0 Then
                                    For i = 0 To (VBFlexGridColsInfo(SelRange.LeftCol + iCol).Lookup.Count - 1)
                                        If StrComp(VBFlexGridColsInfo(SelRange.LeftCol + iCol).Lookup.Items(i).Value, Text) = 0 Then
                                            Text = VBFlexGridColsInfo(SelRange.LeftCol + iCol).Lookup.Items(i).Key
                                            Exit For
                                        End If
                                    Next i
                                End If
                                Call SetCellText(SelRange.TopRow + iRow, SelRange.LeftCol + iCol, Text)
                            End If
                        End If
                    Else
                        If (SelRange.LeftCol + iCol) <= SelRange.RightCol Then
                            If PropClipMode = FlexClipModeNormal Then
                                Call SetCellText(SelRange.TopRow + iRow, SelRange.LeftCol + iCol, Mid$(Temp, Pos4 + 1))
                            ElseIf PropClipMode = FlexClipModeLookupConv Then
                                Text = Mid$(Temp, Pos4 + 1)
                                If VBFlexGridColsInfo(SelRange.LeftCol + iCol).Lookup.Count > 0 Then
                                    For i = 0 To (VBFlexGridColsInfo(SelRange.LeftCol + iCol).Lookup.Count - 1)
                                        If StrComp(VBFlexGridColsInfo(SelRange.LeftCol + iCol).Lookup.Items(i).Value, Text) = 0 Then
                                            Text = VBFlexGridColsInfo(SelRange.LeftCol + iCol).Lookup.Items(i).Key
                                            Exit For
                                        End If
                                    Next i
                                End If
                                Call SetCellText(SelRange.TopRow + iRow, SelRange.LeftCol + iCol, Text)
                            End If
                        End If
                    End If
                    Pos4 = Pos3
                    iCol = iCol + 1
                Loop Until Pos3 = 0
            End If
            Pos2 = Pos1
            Pos4 = 0
            iRow = iRow + 1
            iCol = 0
        Loop Until Pos1 = 0
    Else
        Do
            iSelRow = Me.SelectedRow(iRow)
            If iSelRow > -1 Then
                Pos1 = InStr(Pos1 + 1, Value, CSRow)
                If Pos1 > 0 Then
                    Pos1 = Pos1 + CSRowLen - 1
                    Temp = Mid$(Value, Pos2 + 1, Pos1 - Pos2 - CSRowLen)
                Else
                    Temp = Mid$(Value, Pos2 + 1)
                End If
                Do
                    Pos3 = InStr(Pos3 + 1, Temp, CSCol)
                    If Pos3 > 0 Then
                        Pos3 = Pos3 + CSColLen - 1
                        If (SelRange.LeftCol + iCol) <= SelRange.RightCol Then
                            If PropClipMode = FlexClipModeNormal Then
                                Call SetCellText(iSelRow, SelRange.LeftCol + iCol, Mid$(Temp, Pos4 + 1, Pos3 - Pos4 - CSColLen))
                            ElseIf PropClipMode = FlexClipModeLookupConv Then
                                Text = Mid$(Temp, Pos4 + 1, Pos3 - Pos4 - CSColLen)
                                If VBFlexGridColsInfo(SelRange.LeftCol + iCol).Lookup.Count > 0 Then
                                    For i = 0 To (VBFlexGridColsInfo(SelRange.LeftCol + iCol).Lookup.Count - 1)
                                        If StrComp(VBFlexGridColsInfo(SelRange.LeftCol + iCol).Lookup.Items(i).Value, Text) = 0 Then
                                            Text = VBFlexGridColsInfo(SelRange.LeftCol + iCol).Lookup.Items(i).Key
                                            Exit For
                                        End If
                                    Next i
                                End If
                                Call SetCellText(iSelRow, SelRange.LeftCol + iCol, Text)
                            End If
                        End If
                    Else
                        If (SelRange.LeftCol + iCol) <= SelRange.RightCol Then
                            If PropClipMode = FlexClipModeNormal Then
                                Call SetCellText(iSelRow, SelRange.LeftCol + iCol, Mid$(Temp, Pos4 + 1))
                            ElseIf PropClipMode = FlexClipModeLookupConv Then
                                Text = Mid$(Temp, Pos4 + 1)
                                If VBFlexGridColsInfo(SelRange.LeftCol + iCol).Lookup.Count > 0 Then
                                    For i = 0 To (VBFlexGridColsInfo(SelRange.LeftCol + iCol).Lookup.Count - 1)
                                        If StrComp(VBFlexGridColsInfo(SelRange.LeftCol + iCol).Lookup.Items(i).Value, Text) = 0 Then
                                            Text = VBFlexGridColsInfo(SelRange.LeftCol + iCol).Lookup.Items(i).Key
                                            Exit For
                                        End If
                                    Next i
                                End If
                                Call SetCellText(iSelRow, SelRange.LeftCol + iCol, Text)
                            End If
                        End If
                    End If
                    Pos4 = Pos3
                    iCol = iCol + 1
                Loop Until Pos3 = 0
                Pos2 = Pos1
                Pos4 = 0
                iRow = iRow + 1
                iCol = 0
            Else
                Pos1 = 0
            End If
        Loop Until Pos1 = 0
    End If
ElseIf PropClipMode = FlexClipModeExcludeHidden Or PropClipMode = FlexClipModeLookupConvExcludeHidden Then
    Dim RowLoop As Boolean, ColLoop As Boolean
    If PropAllowMultiSelection = False Or PropClipPasteMode <> FlexClipPasteModeExtended Then
        Do
            If (.Rows(SelRange.TopRow + iRow).RowInfo.State And RWIS_HIDDEN) = 0 Then
                Pos1 = InStr(Pos1 + 1, Value, CSRow)
                If Pos1 > 0 Then Pos1 = Pos1 + CSRowLen - 1
                If PropClipPasteMode = FlexClipPasteModeAutoSelection Or PropClipPasteMode = FlexClipPasteModeExtendedAutoSelection Then
                    If (SelRange.TopRow + iRow) <= (PropRows - 1) And (SelRange.TopRow + iRow) > SelRange.BottomRow Then SelRange.BottomRow = SelRange.TopRow + iRow
                End If
                If (SelRange.TopRow + iRow) <= SelRange.BottomRow Then
                    If Pos1 > 0 Then Temp = Mid$(Value, Pos2 + 1, Pos1 - Pos2 - CSRowLen) Else Temp = Mid$(Value, Pos2 + 1)
                    Do
                        If (VBFlexGridColsInfo(SelRange.LeftCol + iCol).State And CLIS_HIDDEN) = 0 Then
                            Pos3 = InStr(Pos3 + 1, Temp, CSCol)
                            If PropClipPasteMode = FlexClipPasteModeAutoSelection Or PropClipPasteMode = FlexClipPasteModeExtendedAutoSelection Then
                                If (SelRange.LeftCol + iCol) <= (PropCols - 1) And (SelRange.LeftCol + iCol) > SelRange.RightCol Then SelRange.RightCol = SelRange.LeftCol + iCol
                            End If
                            If Pos3 > 0 Then
                                Pos3 = Pos3 + CSColLen - 1
                                If (SelRange.LeftCol + iCol) <= SelRange.RightCol Then
                                    If PropClipMode = FlexClipModeExcludeHidden Then
                                        Call SetCellText(SelRange.TopRow + iRow, SelRange.LeftCol + iCol, Mid$(Temp, Pos4 + 1, Pos3 - Pos4 - CSColLen))
                                    ElseIf PropClipMode = FlexClipModeLookupConvExcludeHidden Then
                                        Text = Mid$(Temp, Pos4 + 1, Pos3 - Pos4 - CSColLen)
                                        If VBFlexGridColsInfo(SelRange.LeftCol + iCol).Lookup.Count > 0 Then
                                            For i = 0 To (VBFlexGridColsInfo(SelRange.LeftCol + iCol).Lookup.Count - 1)
                                                If StrComp(VBFlexGridColsInfo(SelRange.LeftCol + iCol).Lookup.Items(i).Value, Text) = 0 Then
                                                    Text = VBFlexGridColsInfo(SelRange.LeftCol + iCol).Lookup.Items(i).Key
                                                    Exit For
                                                End If
                                            Next i
                                        End If
                                        Call SetCellText(SelRange.TopRow + iRow, SelRange.LeftCol + iCol, Text)
                                    End If
                                End If
                            Else
                                If (SelRange.LeftCol + iCol) <= SelRange.RightCol Then
                                    If PropClipMode = FlexClipModeExcludeHidden Then
                                        Call SetCellText(SelRange.TopRow + iRow, SelRange.LeftCol + iCol, Mid$(Temp, Pos4 + 1))
                                    ElseIf PropClipMode = FlexClipModeLookupConvExcludeHidden Then
                                        Text = Mid$(Temp, Pos4 + 1)
                                        If VBFlexGridColsInfo(SelRange.LeftCol + iCol).Lookup.Count > 0 Then
                                            For i = 0 To (VBFlexGridColsInfo(SelRange.LeftCol + iCol).Lookup.Count - 1)
                                                If StrComp(VBFlexGridColsInfo(SelRange.LeftCol + iCol).Lookup.Items(i).Value, Text) = 0 Then
                                                    Text = VBFlexGridColsInfo(SelRange.LeftCol + iCol).Lookup.Items(i).Key
                                                    Exit For
                                                End If
                                            Next i
                                        End If
                                        Call SetCellText(SelRange.TopRow + iRow, SelRange.LeftCol + iCol, Text)
                                    End If
                                End If
                            End If
                            Pos4 = Pos3
                            iCol = iCol + 1
                            If PropClipPasteMode = FlexClipPasteModeAutoSelection Or PropClipPasteMode = FlexClipPasteModeExtendedAutoSelection Then
                                ColLoop = CBool(Pos3 <> 0 And (SelRange.LeftCol + iCol) <= (PropCols - 1))
                            Else
                                ColLoop = CBool(Pos3 <> 0 And (SelRange.LeftCol + iCol) <= SelRange.RightCol)
                            End If
                        Else
                            iCol = iCol + 1
                            If PropClipPasteMode = FlexClipPasteModeAutoSelection Or PropClipPasteMode = FlexClipPasteModeExtendedAutoSelection Then
                                ColLoop = CBool((SelRange.LeftCol + iCol) <= (PropCols - 1))
                            Else
                                ColLoop = CBool((SelRange.LeftCol + iCol) <= SelRange.RightCol)
                            End If
                        End If
                    Loop Until ColLoop = False
                End If
                Pos2 = Pos1
                Pos4 = 0
                iRow = iRow + 1
                iCol = 0
                If PropClipPasteMode = FlexClipPasteModeAutoSelection Or PropClipPasteMode = FlexClipPasteModeExtendedAutoSelection Then
                    RowLoop = CBool(Pos1 <> 0 And (SelRange.TopRow + iRow) <= (PropRows - 1))
                Else
                    RowLoop = CBool(Pos1 <> 0 And (SelRange.TopRow + iRow) <= SelRange.BottomRow)
                End If
            Else
                iRow = iRow + 1
                iCol = 0
                If PropClipPasteMode = FlexClipPasteModeAutoSelection Or PropClipPasteMode = FlexClipPasteModeExtendedAutoSelection Then
                    RowLoop = CBool((SelRange.TopRow + iRow) <= (PropRows - 1))
                Else
                    RowLoop = CBool((SelRange.TopRow + iRow) <= SelRange.BottomRow)
                End If
            End If
        Loop Until RowLoop = False
    Else
        Do
            iSelRow = Me.SelectedRow(iRow)
            If iSelRow > -1 Then
                If (.Rows(iSelRow).RowInfo.State And RWIS_HIDDEN) = 0 Then
                    Pos1 = InStr(Pos1 + 1, Value, CSRow)
                    If Pos1 > 0 Then
                        Pos1 = Pos1 + CSRowLen - 1
                        Temp = Mid$(Value, Pos2 + 1, Pos1 - Pos2 - CSRowLen)
                    Else
                        Temp = Mid$(Value, Pos2 + 1)
                    End If
                    Do
                        If (VBFlexGridColsInfo(SelRange.LeftCol + iCol).State And CLIS_HIDDEN) = 0 Then
                            Pos3 = InStr(Pos3 + 1, Temp, CSCol)
                            If Pos3 > 0 Then
                                Pos3 = Pos3 + CSColLen - 1
                                If (SelRange.LeftCol + iCol) <= SelRange.RightCol Then
                                    If PropClipMode = FlexClipModeExcludeHidden Then
                                        Call SetCellText(iSelRow, SelRange.LeftCol + iCol, Mid$(Temp, Pos4 + 1, Pos3 - Pos4 - CSColLen))
                                    ElseIf PropClipMode = FlexClipModeLookupConvExcludeHidden Then
                                        Text = Mid$(Temp, Pos4 + 1, Pos3 - Pos4 - CSColLen)
                                        If VBFlexGridColsInfo(SelRange.LeftCol + iCol).Lookup.Count > 0 Then
                                            For i = 0 To (VBFlexGridColsInfo(SelRange.LeftCol + iCol).Lookup.Count - 1)
                                                If StrComp(VBFlexGridColsInfo(SelRange.LeftCol + iCol).Lookup.Items(i).Value, Text) = 0 Then
                                                    Text = VBFlexGridColsInfo(SelRange.LeftCol + iCol).Lookup.Items(i).Key
                                                    Exit For
                                                End If
                                            Next i
                                        End If
                                        Call SetCellText(iSelRow, SelRange.LeftCol + iCol, Text)
                                    End If
                                End If
                            Else
                                If (SelRange.LeftCol + iCol) <= SelRange.RightCol Then
                                    If PropClipMode = FlexClipModeExcludeHidden Then
                                        Call SetCellText(iSelRow, SelRange.LeftCol + iCol, Mid$(Temp, Pos4 + 1))
                                    ElseIf PropClipMode = FlexClipModeLookupConvExcludeHidden Then
                                        Text = Mid$(Temp, Pos4 + 1)
                                        If VBFlexGridColsInfo(SelRange.LeftCol + iCol).Lookup.Count > 0 Then
                                            For i = 0 To (VBFlexGridColsInfo(SelRange.LeftCol + iCol).Lookup.Count - 1)
                                                If StrComp(VBFlexGridColsInfo(SelRange.LeftCol + iCol).Lookup.Items(i).Value, Text) = 0 Then
                                                    Text = VBFlexGridColsInfo(SelRange.LeftCol + iCol).Lookup.Items(i).Key
                                                    Exit For
                                                End If
                                            Next i
                                        End If
                                        Call SetCellText(iSelRow, SelRange.LeftCol + iCol, Text)
                                    End If
                                End If
                            End If
                            Pos4 = Pos3
                            iCol = iCol + 1
                            ColLoop = CBool(Pos3 <> 0 And (SelRange.LeftCol + iCol) <= SelRange.RightCol)
                        Else
                            iCol = iCol + 1
                            ColLoop = CBool((SelRange.LeftCol + iCol) <= SelRange.RightCol)
                        End If
                    Loop Until ColLoop = False
                    Pos2 = Pos1
                    Pos4 = 0
                    iRow = iRow + 1
                    iCol = 0
                    RowLoop = CBool(Pos1 <> 0)
                Else
                    iRow = iRow + 1
                    iCol = 0
                    RowLoop = True
                End If
            Else
                RowLoop = False
            End If
        Loop Until RowLoop = False
    End If
End If
End With
If PropClipPasteMode = FlexClipPasteModeAutoSelection Or PropClipPasteMode = FlexClipPasteModeExtendedAutoSelection Then
    Dim RCP As TROWCOLPARAMS
    With RCP
    .Mask = RCPM_ROW Or RCPM_COL Or RCPM_ROWSEL Or RCPM_COLSEL
    .Row = SelRange.TopRow
    .Col = SelRange.LeftCol
    .RowSel = SelRange.BottomRow
    .ColSel = SelRange.RightCol
    If PropClipPasteMode = FlexClipPasteModeExtendedAutoSelection Then
        Select Case PropSelectionMode
            Case FlexSelectionModeFreeByRow
                .Mask = .Mask And Not (RCPM_COL Or RCPM_COLSEL)
                .Row = SelRange.TopRow
                .RowSel = SelRange.BottomRow
            Case FlexSelectionModeFreeByColumn
                .Mask = .Mask And Not (RCPM_ROW Or RCPM_ROWSEL)
                .Col = SelRange.LeftCol
                .ColSel = SelRange.RightCol
        End Select
    End If
    End With
    If VBFlexGridIndirectCellRef.InProc = False Then
        Call SetRowColParams(RCP)
    Else
        ' The clip command was called for an arbitrary cell or range of cells.
        ' Thus the current selection was already ignored and it is not necessary to select the new range.
    End If
End If
Call RedrawGrid
End Property

Public Property Get ClipSeparatorCol() As String
Attribute ClipSeparatorCol.VB_Description = "Returns/sets the default column separator in clip strings. The initial value is vbTab."
Attribute ClipSeparatorCol.VB_MemberFlags = "400"
ClipSeparatorCol = VBFlexGridClipSeparatorCol
End Property

Public Property Let ClipSeparatorCol(ByVal Value As String)
If Len(Value) = 0 Then
    Err.Raise 380
ElseIf StrComp(Value, VBFlexGridClipSeparatorRow) = 0 Then
    Err.Raise 380
End If
VBFlexGridClipSeparatorCol = Value
End Property

Public Property Get ClipSeparatorRow() As String
Attribute ClipSeparatorRow.VB_Description = "Returns/sets the default row separator in clip strings. The initial value is vbCr."
Attribute ClipSeparatorRow.VB_MemberFlags = "400"
ClipSeparatorRow = VBFlexGridClipSeparatorRow
End Property

Public Property Let ClipSeparatorRow(ByVal Value As String)
If Len(Value) = 0 Then
    Err.Raise 380
ElseIf StrComp(VBFlexGridClipSeparatorCol, Value) = 0 Then
    Err.Raise 380
End If
VBFlexGridClipSeparatorRow = Value
End Property

Public Function ParseClip(ByRef Text As String, Optional ByVal Rows As Long = -1, Optional ByVal Cols As Long = -1) As Variant
Attribute ParseClip.VB_Description = "Parses a clip string into an two-dimensional array indexed by row/col subscripts."
Dim StrArr() As String, UBoundRows As Long, UBoundCols As Long
Dim Temp As String, iRow As Long, iCol As Long
Dim Pos1 As Long, Pos2 As Long, Pos3 As Long, Pos4 As Long
Dim CSCol As String, CSColLen As Long, CSRow As String, CSRowLen As Long
UBoundRows = -1
UBoundCols = -1
CSCol = GetClipSeparatorCol()
CSColLen = Len(CSCol)
CSRow = GetClipSeparatorRow()
CSRowLen = Len(CSRow)
Do
    Pos1 = InStr(Pos1 + 1, Text, CSRow)
    If Pos1 > 0 Then
        Pos1 = Pos1 + CSRowLen - 1
        Temp = Mid$(Text, Pos2 + 1, Pos1 - Pos2 - CSRowLen)
    Else
        Temp = Mid$(Text, Pos2 + 1)
    End If
    Do
        Pos3 = InStr(Pos3 + 1, Temp, CSCol)
        If Pos3 > 0 Then Pos3 = Pos3 + CSColLen - 1
        Pos4 = Pos3
        iCol = iCol + 1
    Loop Until Pos3 = 0
    If (iCol - 1) > UBoundCols Then UBoundCols = (iCol - 1)
    Pos2 = Pos1
    Pos4 = 0
    iRow = iRow + 1
    iCol = 0
Loop Until Pos1 = 0
UBoundRows = iRow - 1
iRow = 0
iCol = 0
If Rows > -1 Then
    If UBoundRows > (Rows - 1) Then UBoundRows = (Rows - 1)
End If
If Cols > -1 Then
    If UBoundCols > (Cols - 1) Then UBoundCols = (Cols - 1)
End If
If UBoundRows > -1 And UBoundCols > -1 Then
    ReDim StrArr(0 To UBoundRows, 0 To UBoundCols) As String
    Do
        Pos1 = InStr(Pos1 + 1, Text, CSRow)
        If Pos1 > 0 Then
            Pos1 = Pos1 + CSRowLen - 1
            Temp = Mid$(Text, Pos2 + 1, Pos1 - Pos2 - CSRowLen)
        Else
            Temp = Mid$(Text, Pos2 + 1)
        End If
        Do
            Pos3 = InStr(Pos3 + 1, Temp, CSCol)
            If Pos3 > 0 Then
                Pos3 = Pos3 + CSColLen - 1
                StrArr(iRow, iCol) = Mid$(Temp, Pos4 + 1, Pos3 - Pos4 - CSColLen)
            Else
                StrArr(iRow, iCol) = Mid$(Temp, Pos4 + 1)
            End If
            Pos4 = Pos3
            iCol = iCol + 1
            If iCol > UBoundCols Then Pos3 = 0
        Loop Until Pos3 = 0
        Pos2 = Pos1
        Pos4 = 0
        iRow = iRow + 1
        iCol = 0
        If iRow > UBoundRows Then Pos1 = 0
    Loop Until Pos1 = 0
    ParseClip = StrArr()
End If
End Function

Public Function ConstructClip(ByRef ArrRows As Variant) As String
Attribute ConstructClip.VB_Description = "Constructs a clip string from a two-dimensional array indexed by row/col subscripts."
If IsEmpty(ArrRows) Then Exit Function
If IsArray(ArrRows) Then
    Dim LBoundRows As Long, UBoundRows As Long, LBoundCols As Long, UBoundCols As Long
    UBoundRows = -1
    UBoundCols = -1
    Dim Ptr As LongPtr
    CopyMemory Ptr, ByVal UnsignedAdd(VarPtr(ArrRows), 8), PTR_SIZE
    Const VT_BYREF As Integer = &H4000
    Dim VT As Integer
    CopyMemory VT, ByVal VarPtr(ArrRows), 2
    If (VT And VT_BYREF) = VT_BYREF Then CopyMemory Ptr, ByVal Ptr, PTR_SIZE
    If Ptr <> NULL_PTR Then
        Dim DimensionCount As Integer
        CopyMemory DimensionCount, ByVal Ptr, 2
        If DimensionCount = 2 Then
            Select Case VarType(ArrRows)
                Case (vbArray + vbString), (vbArray + vbVariant)
                    LBoundRows = LBound(ArrRows, 1)
                    UBoundRows = UBound(ArrRows, 1)
                    LBoundCols = LBound(ArrRows, 2)
                    UBoundCols = UBound(ArrRows, 2)
                Case Else
                    Err.Raise 13
            End Select
        Else
            Err.Raise Number:=5, Description:="Array must be double dimensioned"
        End If
    Else
        Err.Raise Number:=91, Description:="Array is not allocated"
    End If
    If (UBoundRows - LBoundRows) > -1 And (UBoundCols - LBoundCols) > -1 Then
        Dim StrArr() As String, StrSize As Long
        ReDim StrArr(0 To (UBoundRows - LBoundRows), 0 To (UBoundCols - LBoundCols)) As String
        Dim CSCol As String, CSRow As String
        CSCol = GetClipSeparatorCol()
        CSRow = GetClipSeparatorRow()
        Dim iRow As Long, iCol As Long
        Select Case VarType(ArrRows)
            Case (vbArray + vbString)
                For iRow = LBoundRows To UBoundRows
                    For iCol = LBoundCols To UBoundCols
                        If iCol < UBoundCols Then
                            StrArr(iRow + (0 - LBoundRows), iCol + (0 - LBoundCols)) = ArrRows(iRow, iCol) & CSCol
                        ElseIf iRow < UBoundRows Then
                            StrArr(iRow + (0 - LBoundRows), iCol + (0 - LBoundCols)) = ArrRows(iRow, iCol) & CSRow
                        Else
                            StrArr(iRow + (0 - LBoundRows), iCol + (0 - LBoundCols)) = ArrRows(iRow, iCol)
                        End If
                    Next iCol
                Next iRow
            Case (vbArray + vbVariant)
                For iRow = LBoundRows To UBoundRows
                    For iCol = LBoundCols To UBoundCols
                        If iCol < UBoundCols Then
                            If Not IsNull(ArrRows(iRow, iCol)) Then
                                StrArr(iRow + (0 - LBoundRows), iCol + (0 - LBoundCols)) = ArrRows(iRow, iCol) & CSCol
                            Else
                                StrArr(iRow + (0 - LBoundRows), iCol + (0 - LBoundCols)) = vbNullString & CSCol
                            End If
                        ElseIf iRow < UBoundRows Then
                            If Not IsNull(ArrRows(iRow, iCol)) Then
                                StrArr(iRow + (0 - LBoundRows), iCol + (0 - LBoundCols)) = ArrRows(iRow, iCol) & CSRow
                            Else
                                StrArr(iRow + (0 - LBoundRows), iCol + (0 - LBoundCols)) = vbNullString & CSRow
                            End If
                        Else
                            If Not IsNull(ArrRows(iRow, iCol)) Then
                                StrArr(iRow + (0 - LBoundRows), iCol + (0 - LBoundCols)) = ArrRows(iRow, iCol)
                            Else
                                StrArr(iRow + (0 - LBoundRows), iCol + (0 - LBoundCols)) = vbNullString
                            End If
                        End If
                    Next iCol
                Next iRow
        End Select
        For iRow = 0 To (UBoundRows - LBoundRows)
            For iCol = 0 To (UBoundCols - LBoundCols)
                StrSize = StrSize + Len(StrArr(iRow, iCol))
            Next iCol
        Next iRow
        If StrSize > 0 Then
            ConstructClip = String$(StrSize, vbNullChar)
            StrSize = 1
            For iRow = 0 To (UBoundRows - LBoundRows)
                For iCol = 0 To (UBoundCols - LBoundCols)
                    If StrSize <= Len(ConstructClip) Then Mid$(ConstructClip, StrSize, Len(StrArr(iRow, iCol))) = StrArr(iRow, iCol)
                    StrSize = StrSize + Len(StrArr(iRow, iCol))
                Next iCol
            Next iRow
        End If
    End If
Else
    Err.Raise 380
End If
End Function

Public Property Get CellTextStyle() As FlexTextStyleConstants
Attribute CellTextStyle.VB_Description = "Returns/sets 3D effects for text on a specific cell or range of cells."
Attribute CellTextStyle.VB_MemberFlags = "400"
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
Dim CellFmtg As TCELLFMTG
Call GetCellFmtg(VBFlexGridRow, VBFlexGridCol, CFM_TEXTSTYLE, CellFmtg)
If CellFmtg.TextStyle = -1 Then
    If VBFlexGridRow > (PropFixedRows - 1) And VBFlexGridCol > (PropFixedCols - 1) Then
        CellTextStyle = PropTextStyle
    Else
        CellTextStyle = PropTextStyleFixed
    End If
Else
    CellTextStyle = CellFmtg.TextStyle
End If
End Property

Public Property Let CellTextStyle(ByVal Value As FlexTextStyleConstants)
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
Select Case Value
    Case -1, FlexTextStyleFlat, FlexTextStyleRaised, FlexTextStyleInset, FlexTextStyleRaisedLight, FlexTextStyleInsetLight
    Case Else
        Err.Raise 380
End Select
Dim CellFmtg As TCELLFMTG
CellFmtg.TextStyle = Value
If PropFillStyle = FlexFillStyleSingle Then
    Call SetCellFmtg(VBFlexGridRow, VBFlexGridCol, CFM_TEXTSTYLE, CellFmtg)
ElseIf PropFillStyle = FlexFillStyleRepeat Then
    Dim i As Long, j As Long, SelRange As TCELLRANGE
    Call GetSelRangeStruct(SelRange)
    For i = SelRange.TopRow To SelRange.BottomRow
        For j = SelRange.LeftCol To SelRange.RightCol
            Call SetCellFmtg(VBFlexGridRow, VBFlexGridCol, CFM_TEXTSTYLE, CellFmtg)
        Next j
    Next i
End If
Call RedrawGrid
End Property

Public Property Get CellAlignment() As FlexAlignmentConstants
Attribute CellAlignment.VB_Description = "Returns/sets the alignment of data in a cell or range of selected cells."
Attribute CellAlignment.VB_MemberFlags = "400"
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
Dim CellFmtg As TCELLFMTG
Call GetCellFmtg(VBFlexGridRow, VBFlexGridCol, CFM_ALIGNMENT, CellFmtg)
If CellFmtg.Alignment = -1 Then
    If VBFlexGridRow > (PropFixedRows - 1) And VBFlexGridCol > (PropFixedCols - 1) Then
        CellAlignment = VBFlexGridColsInfo(VBFlexGridCol).Alignment
    Else
        If VBFlexGridColsInfo(VBFlexGridCol).FixedAlignment = -1 Then
            CellAlignment = VBFlexGridColsInfo(VBFlexGridCol).Alignment
        Else
            CellAlignment = VBFlexGridColsInfo(VBFlexGridCol).FixedAlignment
        End If
    End If
Else
    CellAlignment = CellFmtg.Alignment
End If
End Property

Public Property Let CellAlignment(ByVal Value As FlexAlignmentConstants)
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
Select Case Value
    Case -1, FlexAlignmentLeftTop, FlexAlignmentLeftCenter, FlexAlignmentLeftBottom, FlexAlignmentCenterTop, FlexAlignmentCenterCenter, FlexAlignmentCenterBottom, FlexAlignmentRightTop, FlexAlignmentRightCenter, FlexAlignmentRightBottom, FlexAlignmentGeneral, FlexAlignmentGeneralTop, FlexAlignmentGeneralCenter, FlexAlignmentGeneralBottom
    Case Else
        Err.Raise Number:=30005, Description:="Invalid Alignment value"
End Select
Dim CellFmtg As TCELLFMTG
CellFmtg.Alignment = Value
If PropFillStyle = FlexFillStyleSingle Then
    Call SetCellFmtg(VBFlexGridRow, VBFlexGridCol, CFM_ALIGNMENT, CellFmtg)
ElseIf PropFillStyle = FlexFillStyleRepeat Then
    Dim i As Long, j As Long, SelRange As TCELLRANGE
    Call GetSelRangeStruct(SelRange)
    For i = SelRange.TopRow To SelRange.BottomRow
        For j = SelRange.LeftCol To SelRange.RightCol
            Call SetCellFmtg(i, j, CFM_ALIGNMENT, CellFmtg)
        Next j
    Next i
End If
Call RedrawGrid
End Property

Public Property Get CellPicture() As IPictureDisp
Attribute CellPicture.VB_Description = "Returns/sets an picture to be displayed in the current cell or in a range of cells."
Attribute CellPicture.VB_MemberFlags = "400"
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
Dim CellFmtg As TCELLFMTG
Call GetCellFmtg(VBFlexGridRow, VBFlexGridCol, CFM_PICTURE, CellFmtg)
Set CellPicture = CellFmtg.Picture
End Property

Public Property Let CellPicture(ByVal Value As IPictureDisp)
Set Me.CellPicture = Value
End Property

Public Property Set CellPicture(ByVal Value As IPictureDisp)
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
Dim CellFmtg As TCELLFMTG
Set UserControl.Picture = Value
Set CellFmtg.Picture = UserControl.Picture
Set UserControl.Picture = Nothing
CellFmtg.PictureRenderFlag = 0
If PropFillStyle = FlexFillStyleSingle Then
    Call SetCellFmtg(VBFlexGridRow, VBFlexGridCol, CFM_PICTURE Or CFM_PICTURERENDERFLAG, CellFmtg)
ElseIf PropFillStyle = FlexFillStyleRepeat Then
    Dim i As Long, j As Long, SelRange As TCELLRANGE
    Call GetSelRangeStruct(SelRange)
    For i = SelRange.TopRow To SelRange.BottomRow
        For j = SelRange.LeftCol To SelRange.RightCol
            Call SetCellFmtg(i, j, CFM_PICTURE Or CFM_PICTURERENDERFLAG, CellFmtg)
        Next j
    Next i
End If
Call RedrawGrid
End Property

Public Property Get CellPictureAlignment() As FlexPictureAlignmentConstants
Attribute CellPictureAlignment.VB_Description = "Returns/sets the alignment of pictures in a cell or range of selected cells."
Attribute CellPictureAlignment.VB_MemberFlags = "400"
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
Dim CellFmtg As TCELLFMTG
Call GetCellFmtg(VBFlexGridRow, VBFlexGridCol, CFM_PICTUREALIGNMENT, CellFmtg)
CellPictureAlignment = CellFmtg.PictureAlignment
End Property

Public Property Let CellPictureAlignment(ByVal Value As FlexPictureAlignmentConstants)
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
Select Case Value
    Case FlexPictureAlignmentLeftTop, FlexPictureAlignmentLeftCenter, FlexPictureAlignmentLeftBottom, FlexPictureAlignmentCenterTop, FlexPictureAlignmentCenterCenter, FlexPictureAlignmentCenterBottom, FlexPictureAlignmentRightTop, FlexPictureAlignmentRightCenter, FlexPictureAlignmentRightBottom, FlexPictureAlignmentStretch, FlexPictureAlignmentTile, FlexPictureAlignmentLeftTopNoOverlap, FlexPictureAlignmentLeftCenterNoOverlap, FlexPictureAlignmentLeftBottomNoOverlap, FlexPictureAlignmentRightTopNoOverlap, FlexPictureAlignmentRightCenterNoOverlap, FlexPictureAlignmentRightBottomNoOverlap
    Case Else
        Err.Raise Number:=30005, Description:="Invalid Alignment value"
End Select
Dim CellFmtg As TCELLFMTG
CellFmtg.PictureAlignment = Value
If PropFillStyle = FlexFillStyleSingle Then
    Call SetCellFmtg(VBFlexGridRow, VBFlexGridCol, CFM_PICTUREALIGNMENT, CellFmtg)
ElseIf PropFillStyle = FlexFillStyleRepeat Then
    Dim i As Long, j As Long, SelRange As TCELLRANGE
    Call GetSelRangeStruct(SelRange)
    For i = SelRange.TopRow To SelRange.BottomRow
        For j = SelRange.LeftCol To SelRange.RightCol
            Call SetCellFmtg(i, j, CFM_PICTUREALIGNMENT, CellFmtg)
        Next j
    Next i
End If
Call RedrawGrid
End Property

Public Property Get CellBackColor() As Long
Attribute CellBackColor.VB_Description = "Returns/sets the background and foreground colors of individual cells or ranges of cells."
Attribute CellBackColor.VB_MemberFlags = "400"
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
Dim CellFmtg As TCELLFMTG
Call GetCellFmtg(VBFlexGridRow, VBFlexGridCol, CFM_BACKCOLOR, CellFmtg)
If CellFmtg.BackColor = -1 Then
    If VBFlexGridRow > (PropFixedRows - 1) And VBFlexGridCol > (PropFixedCols - 1) Then
        CellBackColor = PropBackColor
    Else
        CellBackColor = PropBackColorFixed
    End If
Else
    CellBackColor = CellFmtg.BackColor
End If
End Property

Public Property Let CellBackColor(ByVal Value As Long)
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
Dim CellFmtg As TCELLFMTG
CellFmtg.BackColor = Value
If PropFillStyle = FlexFillStyleSingle Then
    Call SetCellFmtg(VBFlexGridRow, VBFlexGridCol, CFM_BACKCOLOR, CellFmtg)
ElseIf PropFillStyle = FlexFillStyleRepeat Then
    Dim i As Long, j As Long, SelRange As TCELLRANGE
    Call GetSelRangeStruct(SelRange)
    For i = SelRange.TopRow To SelRange.BottomRow
        For j = SelRange.LeftCol To SelRange.RightCol
            Call SetCellFmtg(i, j, CFM_BACKCOLOR, CellFmtg)
        Next j
    Next i
End If
Call RedrawGrid
End Property

Public Property Get CellForeColor() As Long
Attribute CellForeColor.VB_Description = "Returns/sets the background and foreground colors of individual cells or ranges of cells."
Attribute CellForeColor.VB_MemberFlags = "400"
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
Dim CellFmtg As TCELLFMTG
Call GetCellFmtg(VBFlexGridRow, VBFlexGridCol, CFM_FORECOLOR, CellFmtg)
If CellFmtg.ForeColor = -1 Then
    If VBFlexGridRow > (PropFixedRows - 1) And VBFlexGridCol > (PropFixedCols - 1) Then
        CellForeColor = PropForeColor
    Else
        CellForeColor = PropForeColorFixed
    End If
Else
    CellForeColor = CellFmtg.ForeColor
End If
End Property

Public Property Let CellForeColor(ByVal Value As Long)
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
Dim CellFmtg As TCELLFMTG
CellFmtg.ForeColor = Value
If PropFillStyle = FlexFillStyleSingle Then
    Call SetCellFmtg(VBFlexGridRow, VBFlexGridCol, CFM_FORECOLOR, CellFmtg)
ElseIf PropFillStyle = FlexFillStyleRepeat Then
    Dim i As Long, j As Long, SelRange As TCELLRANGE
    Call GetSelRangeStruct(SelRange)
    For i = SelRange.TopRow To SelRange.BottomRow
        For j = SelRange.LeftCol To SelRange.RightCol
            Call SetCellFmtg(i, j, CFM_FORECOLOR, CellFmtg)
        Next j
    Next i
End If
Call RedrawGrid
End Property

Public Property Get CellToolTipText() As String
Attribute CellToolTipText.VB_Description = "Returns/sets the tool tip text in a cell or in a range of selected cells. Requires that the show tips property is set to true."
Attribute CellToolTipText.VB_MemberFlags = "400"
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
Call GetCellToolTipText(VBFlexGridRow, VBFlexGridCol, CellToolTipText)
End Property

Public Property Let CellToolTipText(ByVal Value As String)
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
If PropFillStyle = FlexFillStyleSingle Then
    Call SetCellToolTipText(VBFlexGridRow, VBFlexGridCol, Value)
ElseIf PropFillStyle = FlexFillStyleRepeat Then
    Dim i As Long, j As Long, SelRange As TCELLRANGE
    Call GetSelRangeStruct(SelRange)
    For i = SelRange.TopRow To SelRange.BottomRow
        For j = SelRange.LeftCol To SelRange.RightCol
            Call SetCellToolTipText(i, j, Value)
        Next j
    Next i
End If
End Property

Public Property Get CellComboCue() As FlexComboCueConstants
Attribute CellComboCue.VB_Description = "Returns/sets the combo cue in a cell or range of selected cells."
Attribute CellComboCue.VB_MemberFlags = "400"
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
Dim CellFmtg As TCELLFMTG
Call GetCellFmtg(VBFlexGridRow, VBFlexGridCol, CFM_COMBOCUE, CellFmtg)
CellComboCue = CellFmtg.ComboCue
End Property

Public Property Let CellComboCue(ByVal Value As FlexComboCueConstants)
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
Select Case Value
    Case FlexComboCueHidden, FlexComboCueNone, FlexComboCueDropDown, FlexComboCueButton, FlexComboCueDisabledDropDown, FlexComboCueDisabledButton
    Case Else
        Err.Raise 380
End Select
Dim CellFmtg As TCELLFMTG
CellFmtg.ComboCue = Value
If PropFillStyle = FlexFillStyleSingle Then
    Call SetCellFmtg(VBFlexGridRow, VBFlexGridCol, CFM_COMBOCUE, CellFmtg)
ElseIf PropFillStyle = FlexFillStyleRepeat Then
    Dim i As Long, j As Long, SelRange As TCELLRANGE
    Call GetSelRangeStruct(SelRange)
    For i = SelRange.TopRow To SelRange.BottomRow
        For j = SelRange.LeftCol To SelRange.RightCol
            Call SetCellFmtg(i, j, CFM_COMBOCUE, CellFmtg)
        Next j
    Next i
End If
Call RedrawGrid
End Property

Public Property Get CellChecked() As FlexCheckBoxConstants
Attribute CellChecked.VB_Description = "Returns/sets the check mark in a cell or range of selected cells."
Attribute CellChecked.VB_MemberFlags = "400"
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
CellChecked = GetCellChecked(VBFlexGridRow, VBFlexGridCol)
End Property

Public Property Let CellChecked(ByVal Value As FlexCheckBoxConstants)
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
Select Case Value
    Case FlexNoCheckBoxEver, FlexNoCheckBox, FlexUnchecked, FlexChecked, FlexGrayed, FlexTextAsCheckBox, FlexDisabledUnchecked, FlexDisabledChecked, FlexDisabledGrayed, FlexDisabledTextAsCheckBox
    Case Else
        Err.Raise 380
End Select
If PropFillStyle = FlexFillStyleSingle Then
    Call SetCellChecked(VBFlexGridRow, VBFlexGridCol, Value)
ElseIf PropFillStyle = FlexFillStyleRepeat Then
    Dim i As Long, j As Long, SelRange As TCELLRANGE
    Call GetSelRangeStruct(SelRange)
    For i = SelRange.TopRow To SelRange.BottomRow
        For j = SelRange.LeftCol To SelRange.RightCol
            Call SetCellChecked(i, j, Value)
        Next j
    Next i
End If
Call RedrawGrid
End Property

Public Property Get CellFloodPercent() As Integer
Attribute CellFloodPercent.VB_Description = "Returns/sets the percentage of flooding in a cell or range of selected cells."
Attribute CellFloodPercent.VB_MemberFlags = "400"
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
Dim CellFmtg As TCELLFMTG
Call GetCellFmtg(VBFlexGridRow, VBFlexGridCol, CFM_FLOODPERCENT, CellFmtg)
CellFloodPercent = CellFmtg.FloodPercent
End Property

Public Property Let CellFloodPercent(ByVal Value As Integer)
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
Select Case Value
    Case -100 To 100
    Case Else
        Err.Raise 380
End Select
Dim CellFmtg As TCELLFMTG
CellFmtg.FloodPercent = Value
If PropFillStyle = FlexFillStyleSingle Then
    Call SetCellFmtg(VBFlexGridRow, VBFlexGridCol, CFM_FLOODPERCENT, CellFmtg)
ElseIf PropFillStyle = FlexFillStyleRepeat Then
    Dim i As Long, j As Long, SelRange As TCELLRANGE
    Call GetSelRangeStruct(SelRange)
    For i = SelRange.TopRow To SelRange.BottomRow
        For j = SelRange.LeftCol To SelRange.RightCol
            Call SetCellFmtg(i, j, CFM_FLOODPERCENT, CellFmtg)
        Next j
    Next i
End If
Call RedrawGrid
End Property

Public Property Get CellFloodColor() As Long
Attribute CellFloodColor.VB_Description = "Returns/sets the color to be used for flooding in a cell or range of selected cells."
Attribute CellFloodColor.VB_MemberFlags = "400"
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
Dim CellFmtg As TCELLFMTG
Call GetCellFmtg(VBFlexGridRow, VBFlexGridCol, CFM_FLOODCOLOR, CellFmtg)
If CellFmtg.FloodColor = -1 Then
    CellFloodColor = PropFloodColor
Else
    CellFloodColor = CellFmtg.FloodColor
End If
End Property

Public Property Let CellFloodColor(ByVal Value As Long)
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
Dim CellFmtg As TCELLFMTG
CellFmtg.FloodColor = Value
If PropFillStyle = FlexFillStyleSingle Then
    Call SetCellFmtg(VBFlexGridRow, VBFlexGridCol, CFM_FLOODCOLOR, CellFmtg)
ElseIf PropFillStyle = FlexFillStyleRepeat Then
    Dim i As Long, j As Long, SelRange As TCELLRANGE
    Call GetSelRangeStruct(SelRange)
    For i = SelRange.TopRow To SelRange.BottomRow
        For j = SelRange.LeftCol To SelRange.RightCol
            Call SetCellFmtg(i, j, CFM_FLOODCOLOR, CellFmtg)
        Next j
    Next i
End If
Call RedrawGrid
End Property

Public Property Get CellFontName() As String
Attribute CellFontName.VB_Description = "Returns/sets the font name to be used for individual cells or ranges of cells."
Attribute CellFontName.VB_MemberFlags = "400"
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
Dim CellFmtg As TCELLFMTG
Call GetCellFmtg(VBFlexGridRow, VBFlexGridCol, CFM_FONT, CellFmtg)
If CellFmtg.FontName = vbNullString Then
    If PropFontFixed Is Nothing Or (VBFlexGridRow > (PropFixedRows - 1) And VBFlexGridCol > (PropFixedCols - 1)) Then
        CellFontName = PropFont.Name
    Else
        CellFontName = PropFontFixed.Name
    End If
Else
    CellFontName = CellFmtg.FontName
End If
End Property

Public Property Let CellFontName(ByVal Value As String)
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
Dim CellFmtg As TCELLFMTG, TempFont As StdFont
If PropFillStyle = FlexFillStyleSingle Then
    Call GetCellFmtg(VBFlexGridRow, VBFlexGridCol, CFM_FONT, CellFmtg)
    With CellFmtg
    If Not Value = vbNullString Then
        If .FontName = vbNullString Then
            If PropFontFixed Is Nothing Or (VBFlexGridRow > (PropFixedRows - 1) And VBFlexGridCol > (PropFixedCols - 1)) Then
                .FontSize = PropFont.Size
                .FontStyle = 0
                If PropFont.Bold = True Then .FontStyle = .FontStyle Or FS_BOLD
                If PropFont.Italic = True Then .FontStyle = .FontStyle Or FS_ITALIC
                If PropFont.Strikethrough = True Then .FontStyle = .FontStyle Or FS_STRIKEOUT
                If PropFont.Underline = True Then .FontStyle = .FontStyle Or FS_UNDERLINE
            Else
                .FontSize = PropFontFixed.Size
                .FontStyle = 0
                If PropFontFixed.Bold = True Then .FontStyle = .FontStyle Or FS_BOLD
                If PropFontFixed.Italic = True Then .FontStyle = .FontStyle Or FS_ITALIC
                If PropFontFixed.Strikethrough = True Then .FontStyle = .FontStyle Or FS_STRIKEOUT
                If PropFontFixed.Underline = True Then .FontStyle = .FontStyle Or FS_UNDERLINE
            End If
        End If
        Set TempFont = New StdFont
        TempFont.Name = Value
        .FontName = TempFont.Name
        .FontCharset = TempFont.Charset
    Else
        .FontName = vbNullString
    End If
    End With
    Call SetCellFmtg(VBFlexGridRow, VBFlexGridCol, CFM_FONT, CellFmtg)
ElseIf PropFillStyle = FlexFillStyleRepeat Then
    Dim i As Long, j As Long, SelRange As TCELLRANGE
    Call GetSelRangeStruct(SelRange)
    For i = SelRange.TopRow To SelRange.BottomRow
        For j = SelRange.LeftCol To SelRange.RightCol
            Call GetCellFmtg(i, j, CFM_FONT, CellFmtg)
            With CellFmtg
            If Not Value = vbNullString Then
                If .FontName = vbNullString Then
                    If PropFontFixed Is Nothing Or (i > (PropFixedRows - 1) And j > (PropFixedCols - 1)) Then
                        .FontSize = PropFont.Size
                        .FontStyle = 0
                        If PropFont.Bold = True Then .FontStyle = .FontStyle Or FS_BOLD
                        If PropFont.Italic = True Then .FontStyle = .FontStyle Or FS_ITALIC
                        If PropFont.Strikethrough = True Then .FontStyle = .FontStyle Or FS_STRIKEOUT
                        If PropFont.Underline = True Then .FontStyle = .FontStyle Or FS_UNDERLINE
                    Else
                        .FontSize = PropFontFixed.Size
                        .FontStyle = 0
                        If PropFontFixed.Bold = True Then .FontStyle = .FontStyle Or FS_BOLD
                        If PropFontFixed.Italic = True Then .FontStyle = .FontStyle Or FS_ITALIC
                        If PropFontFixed.Strikethrough = True Then .FontStyle = .FontStyle Or FS_STRIKEOUT
                        If PropFontFixed.Underline = True Then .FontStyle = .FontStyle Or FS_UNDERLINE
                    End If
                End If
                Set TempFont = New StdFont
                TempFont.Name = Value
                .FontName = TempFont.Name
                .FontCharset = TempFont.Charset
            Else
                .FontName = vbNullString
            End If
            End With
            Call SetCellFmtg(i, j, CFM_FONT, CellFmtg)
        Next j
    Next i
End If
Call RedrawGrid
End Property

Public Property Get CellFontSize() As Single
Attribute CellFontSize.VB_Description = "Returns/sets the font size (in points) to be used for individual cells or ranges of cells."
Attribute CellFontSize.VB_MemberFlags = "400"
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
Dim CellFmtg As TCELLFMTG
Call GetCellFmtg(VBFlexGridRow, VBFlexGridCol, CFM_FONT, CellFmtg)
If CellFmtg.FontName = vbNullString Then
    If PropFontFixed Is Nothing Or (VBFlexGridRow > (PropFixedRows - 1) And VBFlexGridCol > (PropFixedCols - 1)) Then
        CellFontSize = PropFont.Size
    Else
        CellFontSize = PropFontFixed.Size
    End If
Else
    CellFontSize = CellFmtg.FontSize
End If
End Property

Public Property Let CellFontSize(ByVal Value As Single)
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
Dim CellFmtg As TCELLFMTG
If PropFillStyle = FlexFillStyleSingle Then
    Call GetCellFmtg(VBFlexGridRow, VBFlexGridCol, CFM_FONT, CellFmtg)
    With CellFmtg
    If .FontName = vbNullString Then
        If PropFontFixed Is Nothing Or (VBFlexGridRow > (PropFixedRows - 1) And VBFlexGridCol > (PropFixedCols - 1)) Then
            .FontName = PropFont.Name
            .FontStyle = 0
            If PropFont.Bold = True Then .FontStyle = .FontStyle Or FS_BOLD
            If PropFont.Italic = True Then .FontStyle = .FontStyle Or FS_ITALIC
            If PropFont.Strikethrough = True Then .FontStyle = .FontStyle Or FS_STRIKEOUT
            If PropFont.Underline = True Then .FontStyle = .FontStyle Or FS_UNDERLINE
            .FontCharset = PropFont.Charset
        Else
            .FontName = PropFontFixed.Name
            .FontStyle = 0
            If PropFontFixed.Bold = True Then .FontStyle = .FontStyle Or FS_BOLD
            If PropFontFixed.Italic = True Then .FontStyle = .FontStyle Or FS_ITALIC
            If PropFontFixed.Strikethrough = True Then .FontStyle = .FontStyle Or FS_STRIKEOUT
            If PropFontFixed.Underline = True Then .FontStyle = .FontStyle Or FS_UNDERLINE
            .FontCharset = PropFontFixed.Charset
        End If
    End If
    .FontSize = Value
    End With
    Call SetCellFmtg(VBFlexGridRow, VBFlexGridCol, CFM_FONT, CellFmtg)
ElseIf PropFillStyle = FlexFillStyleRepeat Then
    Dim i As Long, j As Long, SelRange As TCELLRANGE
    Call GetSelRangeStruct(SelRange)
    For i = SelRange.TopRow To SelRange.BottomRow
        For j = SelRange.LeftCol To SelRange.RightCol
            Call GetCellFmtg(i, j, CFM_FONT, CellFmtg)
            With CellFmtg
            If .FontName = vbNullString Then
                If PropFontFixed Is Nothing Or (i > (PropFixedRows - 1) And j > (PropFixedCols - 1)) Then
                    .FontName = PropFont.Name
                    .FontStyle = 0
                    If PropFont.Bold = True Then .FontStyle = .FontStyle Or FS_BOLD
                    If PropFont.Italic = True Then .FontStyle = .FontStyle Or FS_ITALIC
                    If PropFont.Strikethrough = True Then .FontStyle = .FontStyle Or FS_STRIKEOUT
                    If PropFont.Underline = True Then .FontStyle = .FontStyle Or FS_UNDERLINE
                    .FontCharset = PropFont.Charset
                Else
                    .FontName = PropFontFixed.Name
                    .FontStyle = 0
                    If PropFontFixed.Bold = True Then .FontStyle = .FontStyle Or FS_BOLD
                    If PropFontFixed.Italic = True Then .FontStyle = .FontStyle Or FS_ITALIC
                    If PropFontFixed.Strikethrough = True Then .FontStyle = .FontStyle Or FS_STRIKEOUT
                    If PropFontFixed.Underline = True Then .FontStyle = .FontStyle Or FS_UNDERLINE
                    .FontCharset = PropFontFixed.Charset
                End If
            End If
            .FontSize = Value
            End With
            Call SetCellFmtg(i, j, CFM_FONT, CellFmtg)
        Next j
    Next i
End If
Call RedrawGrid
End Property

Public Property Get CellFontBold() As Boolean
Attribute CellFontBold.VB_Description = "Returns/sets the font bold style to be used for individual cells or ranges of cells."
Attribute CellFontBold.VB_MemberFlags = "400"
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
Dim CellFmtg As TCELLFMTG
Call GetCellFmtg(VBFlexGridRow, VBFlexGridCol, CFM_FONT, CellFmtg)
If CellFmtg.FontName = vbNullString Then
    If PropFontFixed Is Nothing Or (VBFlexGridRow > (PropFixedRows - 1) And VBFlexGridCol > (PropFixedCols - 1)) Then
        CellFontBold = PropFont.Bold
    Else
        CellFontBold = PropFontFixed.Bold
    End If
Else
    CellFontBold = CBool((CellFmtg.FontStyle And FS_BOLD) = FS_BOLD)
End If
End Property

Public Property Let CellFontBold(ByVal Value As Boolean)
If VBFlexGridRow < 0 Then
    Err.Raise 30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise 30010, Description:="Invalid Col value"
End If
Dim CellFmtg As TCELLFMTG
If PropFillStyle = FlexFillStyleSingle Then
    Call GetCellFmtg(VBFlexGridRow, VBFlexGridCol, CFM_FONT, CellFmtg)
    With CellFmtg
    If .FontName = vbNullString Then
        If PropFontFixed Is Nothing Or (VBFlexGridRow > (PropFixedRows - 1) And VBFlexGridCol > (PropFixedCols - 1)) Then
            .FontName = PropFont.Name
            .FontSize = PropFont.Size
            .FontStyle = 0
            If PropFont.Italic = True Then .FontStyle = .FontStyle Or FS_ITALIC
            If PropFont.Strikethrough = True Then .FontStyle = .FontStyle Or FS_STRIKEOUT
            If PropFont.Underline = True Then .FontStyle = .FontStyle Or FS_UNDERLINE
            .FontCharset = PropFont.Charset
        Else
            .FontName = PropFontFixed.Name
            .FontSize = PropFontFixed.Size
            .FontStyle = 0
            If PropFontFixed.Italic = True Then .FontStyle = .FontStyle Or FS_ITALIC
            If PropFontFixed.Strikethrough = True Then .FontStyle = .FontStyle Or FS_STRIKEOUT
            If PropFontFixed.Underline = True Then .FontStyle = .FontStyle Or FS_UNDERLINE
            .FontCharset = PropFontFixed.Charset
        End If
    End If
    If Value = True Then
        If Not (.FontStyle And FS_BOLD) = FS_BOLD Then .FontStyle = .FontStyle Or FS_BOLD
    Else
        If (.FontStyle And FS_BOLD) = FS_BOLD Then .FontStyle = .FontStyle And Not FS_BOLD
    End If
    End With
    Call SetCellFmtg(VBFlexGridRow, VBFlexGridCol, CFM_FONT, CellFmtg)
ElseIf PropFillStyle = FlexFillStyleRepeat Then
    Dim i As Long, j As Long, SelRange As TCELLRANGE
    Call GetSelRangeStruct(SelRange)
    For i = SelRange.TopRow To SelRange.BottomRow
        For j = SelRange.LeftCol To SelRange.RightCol
            Call GetCellFmtg(i, j, CFM_FONT, CellFmtg)
            With CellFmtg
            If .FontName = vbNullString Then
                If PropFontFixed Is Nothing Or (i > (PropFixedRows - 1) And j > (PropFixedCols - 1)) Then
                    .FontName = PropFont.Name
                    .FontSize = PropFont.Size
                    .FontStyle = 0
                    If PropFont.Italic = True Then .FontStyle = .FontStyle Or FS_ITALIC
                    If PropFont.Strikethrough = True Then .FontStyle = .FontStyle Or FS_STRIKEOUT
                    If PropFont.Underline = True Then .FontStyle = .FontStyle Or FS_UNDERLINE
                    .FontCharset = PropFont.Charset
                Else
                    .FontName = PropFontFixed.Name
                    .FontSize = PropFontFixed.Size
                    .FontStyle = 0
                    If PropFontFixed.Italic = True Then .FontStyle = .FontStyle Or FS_ITALIC
                    If PropFontFixed.Strikethrough = True Then .FontStyle = .FontStyle Or FS_STRIKEOUT
                    If PropFontFixed.Underline = True Then .FontStyle = .FontStyle Or FS_UNDERLINE
                    .FontCharset = PropFontFixed.Charset
                End If
            End If
            If Value = True Then
                If Not (.FontStyle And FS_BOLD) = FS_BOLD Then .FontStyle = .FontStyle Or FS_BOLD
            Else
                If (.FontStyle And FS_BOLD) = FS_BOLD Then .FontStyle = .FontStyle And Not FS_BOLD
            End If
            End With
            Call SetCellFmtg(i, j, CFM_FONT, CellFmtg)
        Next j
    Next i
End If
Call RedrawGrid
End Property

Public Property Get CellFontItalic() As Boolean
Attribute CellFontItalic.VB_Description = "Returns/sets the font italic style to be used for individual cells or ranges of cells."
Attribute CellFontItalic.VB_MemberFlags = "400"
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
Dim CellFmtg As TCELLFMTG
Call GetCellFmtg(VBFlexGridRow, VBFlexGridCol, CFM_FONT, CellFmtg)
If CellFmtg.FontName = vbNullString Then
    If PropFontFixed Is Nothing Or (VBFlexGridRow > (PropFixedRows - 1) And VBFlexGridCol > (PropFixedCols - 1)) Then
        CellFontItalic = PropFont.Italic
    Else
        CellFontItalic = PropFontFixed.Italic
    End If
Else
    CellFontItalic = CBool((CellFmtg.FontStyle And FS_ITALIC) = FS_ITALIC)
End If
End Property

Public Property Let CellFontItalic(ByVal Value As Boolean)
If VBFlexGridRow < 0 Then
    Err.Raise 30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise 30010, Description:="Invalid Col value"
End If
Dim CellFmtg As TCELLFMTG
If PropFillStyle = FlexFillStyleSingle Then
    Call GetCellFmtg(VBFlexGridRow, VBFlexGridCol, CFM_FONT, CellFmtg)
    With CellFmtg
    If .FontName = vbNullString Then
        If PropFontFixed Is Nothing Or (VBFlexGridRow > (PropFixedRows - 1) And VBFlexGridCol > (PropFixedCols - 1)) Then
            .FontName = PropFont.Name
            .FontSize = PropFont.Size
            .FontStyle = 0
            If PropFont.Bold = True Then .FontStyle = .FontStyle Or FS_BOLD
            If PropFont.Strikethrough = True Then .FontStyle = .FontStyle Or FS_STRIKEOUT
            If PropFont.Underline = True Then .FontStyle = .FontStyle Or FS_UNDERLINE
            .FontCharset = PropFont.Charset
        Else
            .FontName = PropFontFixed.Name
            .FontSize = PropFontFixed.Size
            .FontStyle = 0
            If PropFontFixed.Bold = True Then .FontStyle = .FontStyle Or FS_BOLD
            If PropFontFixed.Strikethrough = True Then .FontStyle = .FontStyle Or FS_STRIKEOUT
            If PropFontFixed.Underline = True Then .FontStyle = .FontStyle Or FS_UNDERLINE
            .FontCharset = PropFontFixed.Charset
        End If
    End If
    If Value = True Then
        If Not (.FontStyle And FS_ITALIC) = FS_ITALIC Then .FontStyle = .FontStyle Or FS_ITALIC
    Else
        If (.FontStyle And FS_ITALIC) = FS_ITALIC Then .FontStyle = .FontStyle And Not FS_ITALIC
    End If
    End With
    Call SetCellFmtg(VBFlexGridRow, VBFlexGridCol, CFM_FONT, CellFmtg)
ElseIf PropFillStyle = FlexFillStyleRepeat Then
    Dim i As Long, j As Long, SelRange As TCELLRANGE
    Call GetSelRangeStruct(SelRange)
    For i = SelRange.TopRow To SelRange.BottomRow
        For j = SelRange.LeftCol To SelRange.RightCol
            Call GetCellFmtg(i, j, CFM_FONT, CellFmtg)
            With CellFmtg
            If .FontName = vbNullString Then
                If PropFontFixed Is Nothing Or (i > (PropFixedRows - 1) And j > (PropFixedCols - 1)) Then
                    .FontName = PropFont.Name
                    .FontSize = PropFont.Size
                    .FontStyle = 0
                    If PropFont.Bold = True Then .FontStyle = .FontStyle Or FS_BOLD
                    If PropFont.Strikethrough = True Then .FontStyle = .FontStyle Or FS_STRIKEOUT
                    If PropFont.Underline = True Then .FontStyle = .FontStyle Or FS_UNDERLINE
                    .FontCharset = PropFont.Charset
                Else
                    .FontName = PropFontFixed.Name
                    .FontSize = PropFontFixed.Size
                    .FontStyle = 0
                    If PropFontFixed.Bold = True Then .FontStyle = .FontStyle Or FS_BOLD
                    If PropFontFixed.Strikethrough = True Then .FontStyle = .FontStyle Or FS_STRIKEOUT
                    If PropFontFixed.Underline = True Then .FontStyle = .FontStyle Or FS_UNDERLINE
                    .FontCharset = PropFontFixed.Charset
                End If
            End If
            If Value = True Then
                If Not (.FontStyle And FS_ITALIC) = FS_ITALIC Then .FontStyle = .FontStyle Or FS_ITALIC
            Else
                If (.FontStyle And FS_ITALIC) = FS_ITALIC Then .FontStyle = .FontStyle And Not FS_ITALIC
            End If
            End With
            Call SetCellFmtg(i, j, CFM_FONT, CellFmtg)
        Next j
    Next i
End If
Call RedrawGrid
End Property

Public Property Get CellFontStrikeThrough() As Boolean
Attribute CellFontStrikeThrough.VB_Description = "Returns/sets the font strikethrough style to be used for individual cells or ranges of cells."
Attribute CellFontStrikeThrough.VB_MemberFlags = "400"
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
Dim CellFmtg As TCELLFMTG
Call GetCellFmtg(VBFlexGridRow, VBFlexGridCol, CFM_FONT, CellFmtg)
If CellFmtg.FontName = vbNullString Then
    If PropFontFixed Is Nothing Or (VBFlexGridRow > (PropFixedRows - 1) And VBFlexGridCol > (PropFixedCols - 1)) Then
        CellFontStrikeThrough = PropFont.Strikethrough
    Else
        CellFontStrikeThrough = PropFontFixed.Strikethrough
    End If
Else
    CellFontStrikeThrough = CBool((CellFmtg.FontStyle And FS_STRIKEOUT) = FS_STRIKEOUT)
End If
End Property

Public Property Let CellFontStrikeThrough(ByVal Value As Boolean)
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
Dim CellFmtg As TCELLFMTG
If PropFillStyle = FlexFillStyleSingle Then
    Call GetCellFmtg(VBFlexGridRow, VBFlexGridCol, CFM_FONT, CellFmtg)
    With CellFmtg
    If .FontName = vbNullString Then
        If PropFontFixed Is Nothing Or (VBFlexGridRow > (PropFixedRows - 1) And VBFlexGridCol > (PropFixedCols - 1)) Then
            .FontName = PropFont.Name
            .FontSize = PropFont.Size
            .FontStyle = 0
            If PropFont.Bold = True Then .FontStyle = .FontStyle Or FS_BOLD
            If PropFont.Italic = True Then .FontStyle = .FontStyle Or FS_ITALIC
            If PropFont.Underline = True Then .FontStyle = .FontStyle Or FS_UNDERLINE
            .FontCharset = PropFont.Charset
        Else
            .FontName = PropFontFixed.Name
            .FontSize = PropFontFixed.Size
            .FontStyle = 0
            If PropFontFixed.Bold = True Then .FontStyle = .FontStyle Or FS_BOLD
            If PropFontFixed.Italic = True Then .FontStyle = .FontStyle Or FS_ITALIC
            If PropFontFixed.Underline = True Then .FontStyle = .FontStyle Or FS_UNDERLINE
            .FontCharset = PropFontFixed.Charset
        End If
    End If
    If Value = True Then
        If Not (.FontStyle And FS_STRIKEOUT) = FS_STRIKEOUT Then .FontStyle = .FontStyle Or FS_STRIKEOUT
    Else
        If (.FontStyle And FS_STRIKEOUT) = FS_STRIKEOUT Then .FontStyle = .FontStyle And Not FS_STRIKEOUT
    End If
    End With
    Call SetCellFmtg(VBFlexGridRow, VBFlexGridCol, CFM_FONT, CellFmtg)
ElseIf PropFillStyle = FlexFillStyleRepeat Then
    Dim i As Long, j As Long, SelRange As TCELLRANGE
    Call GetSelRangeStruct(SelRange)
    For i = SelRange.TopRow To SelRange.BottomRow
        For j = SelRange.LeftCol To SelRange.RightCol
            Call GetCellFmtg(i, j, CFM_FONT, CellFmtg)
            With CellFmtg
            If .FontName = vbNullString Then
                If PropFontFixed Is Nothing Or (i > (PropFixedRows - 1) And j > (PropFixedCols - 1)) Then
                    .FontName = PropFont.Name
                    .FontSize = PropFont.Size
                    .FontStyle = 0
                    If PropFont.Bold = True Then .FontStyle = .FontStyle Or FS_BOLD
                    If PropFont.Italic = True Then .FontStyle = .FontStyle Or FS_ITALIC
                    If PropFont.Underline = True Then .FontStyle = .FontStyle Or FS_UNDERLINE
                    .FontCharset = PropFont.Charset
                Else
                    .FontName = PropFontFixed.Name
                    .FontSize = PropFontFixed.Size
                    .FontStyle = 0
                    If PropFontFixed.Bold = True Then .FontStyle = .FontStyle Or FS_BOLD
                    If PropFontFixed.Italic = True Then .FontStyle = .FontStyle Or FS_ITALIC
                    If PropFontFixed.Underline = True Then .FontStyle = .FontStyle Or FS_UNDERLINE
                    .FontCharset = PropFontFixed.Charset
                End If
            End If
            If Value = True Then
                If Not (.FontStyle And FS_STRIKEOUT) = FS_STRIKEOUT Then .FontStyle = .FontStyle Or FS_STRIKEOUT
            Else
                If (.FontStyle And FS_STRIKEOUT) = FS_STRIKEOUT Then .FontStyle = .FontStyle And Not FS_STRIKEOUT
            End If
            End With
            Call SetCellFmtg(i, j, CFM_FONT, CellFmtg)
        Next j
    Next i
End If
Call RedrawGrid
End Property

Public Property Get CellFontUnderline() As Boolean
Attribute CellFontUnderline.VB_Description = "Returns/sets the font underline style to be used for individual cells or ranges of cells."
Attribute CellFontUnderline.VB_MemberFlags = "400"
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
Dim CellFmtg As TCELLFMTG
Call GetCellFmtg(VBFlexGridRow, VBFlexGridCol, CFM_FONT, CellFmtg)
If CellFmtg.FontName = vbNullString Then
    If PropFontFixed Is Nothing Or (VBFlexGridRow > (PropFixedRows - 1) And VBFlexGridCol > (PropFixedCols - 1)) Then
        CellFontUnderline = PropFont.Underline
    Else
        CellFontUnderline = PropFontFixed.Underline
    End If
Else
    CellFontUnderline = CBool((CellFmtg.FontStyle And FS_UNDERLINE) = FS_UNDERLINE)
End If
End Property

Public Property Let CellFontUnderline(ByVal Value As Boolean)
If VBFlexGridRow < 0 Then
    Err.Raise 30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise 30010, Description:="Invalid Col value"
End If
Dim CellFmtg As TCELLFMTG
If PropFillStyle = FlexFillStyleSingle Then
    Call GetCellFmtg(VBFlexGridRow, VBFlexGridCol, CFM_FONT, CellFmtg)
    With CellFmtg
    If .FontName = vbNullString Then
        If PropFontFixed Is Nothing Or (VBFlexGridRow > (PropFixedRows - 1) And VBFlexGridCol > (PropFixedCols - 1)) Then
            .FontName = PropFont.Name
            .FontSize = PropFont.Size
            .FontStyle = 0
            If PropFont.Bold = True Then .FontStyle = .FontStyle Or FS_BOLD
            If PropFont.Italic = True Then .FontStyle = .FontStyle Or FS_ITALIC
            If PropFont.Strikethrough = True Then .FontStyle = .FontStyle Or FS_STRIKEOUT
            .FontCharset = PropFont.Charset
        Else
            .FontName = PropFontFixed.Name
            .FontSize = PropFontFixed.Size
            .FontStyle = 0
            If PropFontFixed.Bold = True Then .FontStyle = .FontStyle Or FS_BOLD
            If PropFontFixed.Italic = True Then .FontStyle = .FontStyle Or FS_ITALIC
            If PropFontFixed.Strikethrough = True Then .FontStyle = .FontStyle Or FS_STRIKEOUT
            .FontCharset = PropFontFixed.Charset
        End If
    End If
    If Value = True Then
        If Not (.FontStyle And FS_UNDERLINE) = FS_UNDERLINE Then .FontStyle = .FontStyle Or FS_UNDERLINE
    Else
        If (.FontStyle And FS_UNDERLINE) = FS_UNDERLINE Then .FontStyle = .FontStyle And Not FS_UNDERLINE
    End If
    End With
    Call SetCellFmtg(VBFlexGridRow, VBFlexGridCol, CFM_FONT, CellFmtg)
ElseIf PropFillStyle = FlexFillStyleRepeat Then
    Dim i As Long, j As Long, SelRange As TCELLRANGE
    Call GetSelRangeStruct(SelRange)
    For i = SelRange.TopRow To SelRange.BottomRow
        For j = SelRange.LeftCol To SelRange.RightCol
            Call GetCellFmtg(i, j, CFM_FONT, CellFmtg)
            With CellFmtg
            If .FontName = vbNullString Then
                If PropFontFixed Is Nothing Or (i > (PropFixedRows - 1) And j > (PropFixedCols - 1)) Then
                    .FontName = PropFont.Name
                    .FontSize = PropFont.Size
                    .FontStyle = 0
                    If PropFont.Bold = True Then .FontStyle = .FontStyle Or FS_BOLD
                    If PropFont.Italic = True Then .FontStyle = .FontStyle Or FS_ITALIC
                    If PropFont.Strikethrough = True Then .FontStyle = .FontStyle Or FS_STRIKEOUT
                    .FontCharset = PropFont.Charset
                Else
                    .FontName = PropFontFixed.Name
                    .FontSize = PropFontFixed.Size
                    .FontStyle = 0
                    If PropFontFixed.Bold = True Then .FontStyle = .FontStyle Or FS_BOLD
                    If PropFontFixed.Italic = True Then .FontStyle = .FontStyle Or FS_ITALIC
                    If PropFontFixed.Strikethrough = True Then .FontStyle = .FontStyle Or FS_STRIKEOUT
                    .FontCharset = PropFontFixed.Charset
                End If
            End If
            If Value = True Then
                If Not (.FontStyle And FS_UNDERLINE) = FS_UNDERLINE Then .FontStyle = .FontStyle Or FS_UNDERLINE
            Else
                If (.FontStyle And FS_UNDERLINE) = FS_UNDERLINE Then .FontStyle = .FontStyle And Not FS_UNDERLINE
            End If
            End With
            Call SetCellFmtg(i, j, CFM_FONT, CellFmtg)
        Next j
    Next i
End If
Call RedrawGrid
End Property

Public Property Get CellFontCharset() As Integer
Attribute CellFontCharset.VB_Description = "Returns/sets the font charset to be used for individual cells or ranges of cells."
Attribute CellFontCharset.VB_MemberFlags = "400"
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
Dim CellFmtg As TCELLFMTG
Call GetCellFmtg(VBFlexGridRow, VBFlexGridCol, CFM_FONT, CellFmtg)
If CellFmtg.FontName = vbNullString Then
    If PropFontFixed Is Nothing Or (VBFlexGridRow > (PropFixedRows - 1) And VBFlexGridCol > (PropFixedCols - 1)) Then
        CellFontCharset = PropFont.Charset
    Else
        CellFontCharset = PropFontFixed.Charset
    End If
Else
    CellFontCharset = CellFmtg.FontCharset
End If
End Property

Public Property Let CellFontCharset(ByVal Value As Integer)
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
Dim CellFmtg As TCELLFMTG
If PropFillStyle = FlexFillStyleSingle Then
    Call GetCellFmtg(VBFlexGridRow, VBFlexGridCol, CFM_FONT, CellFmtg)
    With CellFmtg
    If .FontName = vbNullString Then
        If PropFontFixed Is Nothing Or (VBFlexGridRow > (PropFixedRows - 1) And VBFlexGridCol > (PropFixedCols - 1)) Then
            .FontName = PropFont.Name
            .FontSize = PropFont.Size
            .FontStyle = 0
            If PropFont.Bold = True Then .FontStyle = .FontStyle Or FS_BOLD
            If PropFont.Italic = True Then .FontStyle = .FontStyle Or FS_ITALIC
            If PropFont.Strikethrough = True Then .FontStyle = .FontStyle Or FS_STRIKEOUT
            If PropFont.Underline = True Then .FontStyle = .FontStyle Or FS_UNDERLINE
        Else
            .FontName = PropFontFixed.Name
            .FontSize = PropFontFixed.Size
            .FontStyle = 0
            If PropFontFixed.Bold = True Then .FontStyle = .FontStyle Or FS_BOLD
            If PropFontFixed.Italic = True Then .FontStyle = .FontStyle Or FS_ITALIC
            If PropFontFixed.Strikethrough = True Then .FontStyle = .FontStyle Or FS_STRIKEOUT
            If PropFontFixed.Underline = True Then .FontStyle = .FontStyle Or FS_UNDERLINE
        End If
    End If
    .FontCharset = Value
    End With
    Call SetCellFmtg(VBFlexGridRow, VBFlexGridCol, CFM_FONT, CellFmtg)
ElseIf PropFillStyle = FlexFillStyleRepeat Then
    Dim i As Long, j As Long, SelRange As TCELLRANGE
    Call GetSelRangeStruct(SelRange)
    For i = SelRange.TopRow To SelRange.BottomRow
        For j = SelRange.LeftCol To SelRange.RightCol
            Call GetCellFmtg(i, j, CFM_FONT, CellFmtg)
            With CellFmtg
            If .FontName = vbNullString Then
                If PropFontFixed Is Nothing Or (i > (PropFixedRows - 1) And j > (PropFixedCols - 1)) Then
                    .FontName = PropFont.Name
                    .FontSize = PropFont.Size
                    .FontStyle = 0
                    If PropFont.Bold = True Then .FontStyle = .FontStyle Or FS_BOLD
                    If PropFont.Italic = True Then .FontStyle = .FontStyle Or FS_ITALIC
                    If PropFont.Strikethrough = True Then .FontStyle = .FontStyle Or FS_STRIKEOUT
                    If PropFont.Underline = True Then .FontStyle = .FontStyle Or FS_UNDERLINE
                Else
                    .FontName = PropFontFixed.Name
                    .FontSize = PropFontFixed.Size
                    .FontStyle = 0
                    If PropFontFixed.Bold = True Then .FontStyle = .FontStyle Or FS_BOLD
                    If PropFontFixed.Italic = True Then .FontStyle = .FontStyle Or FS_ITALIC
                    If PropFontFixed.Strikethrough = True Then .FontStyle = .FontStyle Or FS_STRIKEOUT
                    If PropFontFixed.Underline = True Then .FontStyle = .FontStyle Or FS_UNDERLINE
                End If
            End If
            .FontCharset = Value
            End With
            Call SetCellFmtg(i, j, CFM_FONT, CellFmtg)
        Next j
    Next i
End If
Call RedrawGrid
End Property

Public Property Get CellHasCustomFormatting() As Boolean
Attribute CellHasCustomFormatting.VB_Description = "Returns/sets a value indicating if the cell has custom formatting."
Attribute CellHasCustomFormatting.VB_MemberFlags = "400"
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
CellHasCustomFormatting = CBool(VBFlexGridCells.Rows(VBFlexGridRow).Cols(VBFlexGridCol).lpFmtg <> NULL_PTR)
End Property

Public Property Let CellHasCustomFormatting(ByVal Value As Boolean)
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
If PropFillStyle = FlexFillStyleSingle Then
    If Value = True Then
        If VBFlexGridCells.Rows(VBFlexGridRow).Cols(VBFlexGridCol).lpFmtg = NULL_PTR Then Call AllocCellFmtg(VBFlexGridCells.Rows(VBFlexGridRow).Cols(VBFlexGridCol).lpFmtg)
    Else
        If VBFlexGridCells.Rows(VBFlexGridRow).Cols(VBFlexGridCol).lpFmtg <> NULL_PTR Then Call FreeCellFmtg(VBFlexGridCells.Rows(VBFlexGridRow).Cols(VBFlexGridCol).lpFmtg)
    End If
ElseIf PropFillStyle = FlexFillStyleRepeat Then
    Dim i As Long, j As Long, SelRange As TCELLRANGE
    Call GetSelRangeStruct(SelRange)
    For i = SelRange.TopRow To SelRange.BottomRow
        With VBFlexGridCells.Rows(i)
        For j = SelRange.LeftCol To SelRange.RightCol
            If Value = True Then
                If .Cols(j).lpFmtg = NULL_PTR Then Call AllocCellFmtg(.Cols(j).lpFmtg)
            Else
                If .Cols(j).lpFmtg <> NULL_PTR Then Call FreeCellFmtg(.Cols(j).lpFmtg)
            End If
        Next j
        End With
    Next i
End If
Call RedrawGrid
End Property

Public Property Get CellHasTag() As Boolean
Attribute CellHasTag.VB_Description = "Returns/sets a value indicating if the cell has a tag associated with it."
Attribute CellHasTag.VB_MemberFlags = "400"
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
CellHasTag = CBool(VBFlexGridCells.Rows(VBFlexGridRow).Cols(VBFlexGridCol).lpTag <> NULL_PTR)
End Property

Public Property Let CellHasTag(ByVal Value As Boolean)
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
If PropFillStyle = FlexFillStyleSingle Then
    If Value = True Then
        If VBFlexGridCells.Rows(VBFlexGridRow).Cols(VBFlexGridCol).lpTag = NULL_PTR Then Call AllocCellTag(VBFlexGridCells.Rows(VBFlexGridRow).Cols(VBFlexGridCol).lpTag)
    Else
        If VBFlexGridCells.Rows(VBFlexGridRow).Cols(VBFlexGridCol).lpTag <> NULL_PTR Then Call FreeCellTag(VBFlexGridCells.Rows(VBFlexGridRow).Cols(VBFlexGridCol).lpTag)
    End If
ElseIf PropFillStyle = FlexFillStyleRepeat Then
    Dim i As Long, j As Long, SelRange As TCELLRANGE
    Call GetSelRangeStruct(SelRange)
    For i = SelRange.TopRow To SelRange.BottomRow
        With VBFlexGridCells.Rows(i)
        For j = SelRange.LeftCol To SelRange.RightCol
            If Value = True Then
                If .Cols(j).lpTag = NULL_PTR Then Call AllocCellTag(.Cols(j).lpTag)
            Else
                If .Cols(j).lpTag <> NULL_PTR Then Call FreeCellTag(.Cols(j).lpTag)
            End If
        Next j
        End With
    Next i
End If
End Property

Public Property Get CellTag() As Variant
Attribute CellTag.VB_Description = "Returns/sets the user-defined tag to be used for individual cells or ranges of cells."
Attribute CellTag.VB_MemberFlags = "400"
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
Call GetCellTag(VBFlexGridRow, VBFlexGridCol, CellTag)
End Property

Public Property Let CellTag(ByVal Value As Variant)
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
Dim VarValue As Variant
VarValue = Value
If PropFillStyle = FlexFillStyleSingle Then
    Call SetCellTag(VBFlexGridRow, VBFlexGridCol, VarValue)
ElseIf PropFillStyle = FlexFillStyleRepeat Then
    Dim i As Long, j As Long, SelRange As TCELLRANGE
    Call GetSelRangeStruct(SelRange)
    For i = SelRange.TopRow To SelRange.BottomRow
        For j = SelRange.LeftCol To SelRange.RightCol
            Call SetCellTag(i, j, VarValue)
        Next j
    Next i
End If
End Property

Public Property Set CellTag(ByVal Value As Variant)
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
If PropFillStyle = FlexFillStyleSingle Then
    Call SetCellTag(VBFlexGridRow, VBFlexGridCol, Value)
ElseIf PropFillStyle = FlexFillStyleRepeat Then
    Dim i As Long, j As Long, SelRange As TCELLRANGE
    Call GetSelRangeStruct(SelRange)
    For i = SelRange.TopRow To SelRange.BottomRow
        For j = SelRange.LeftCol To SelRange.RightCol
            Call SetCellTag(i, j, Value)
        Next j
    Next i
End If
End Property

Public Sub CellEnsureVisible(Optional ByVal Visibility As FlexVisibilityConstants = FlexVisibilityCompleteOnly, Optional ByVal Row As Long = -1, Optional ByVal Col As Long = -1)
Attribute CellEnsureVisible.VB_Description = "Ensures that the current or an arbitrary cell (row/col subscripts) is visible, scrolling the control if necessary."
Select Case Visibility
    Case FlexVisibilityPartialOK, FlexVisibilityCompleteOnly
    Case Else
        Err.Raise 380
End Select
If Row < -1 Then Err.Raise 380
If Col < -1 Then Err.Raise 380
If PropRows < 1 Or PropCols < 1 Then Exit Sub
If Row = -1 Then Row = VBFlexGridRow
If Col = -1 Then Col = VBFlexGridCol
If (Row < 0 Or Row > (PropRows - 1)) Or (Col < 0 Or Col > (PropCols - 1)) Then Err.Raise Number:=381, Description:="Subscript out of range"
If Visibility = FlexVisibilityPartialOK Then
    If Me.RowIsVisible(Row, FlexVisibilityPartialOK) = True And Me.ColIsVisible(Col, FlexVisibilityPartialOK) = True Then Exit Sub
End If
Dim RCP As TROWCOLPARAMS
With RCP
.Mask = RCPM_TOPROW Or RCPM_LEFTCOL
.TopRow = VBFlexGridTopRow
.LeftCol = VBFlexGridLeftCol
If .TopRow > Row Then
    If Row >= (PropFixedRows + PropFrozenRows) Then .TopRow = Row
ElseIf Row > (.TopRow + GetRowsPerPage(.TopRow) - 1) Then
    .TopRow = Row - GetRowsPerPageRev(Row) + 1
End If
If .LeftCol > Col Then
    If Col >= (PropFixedCols + PropFrozenCols) Then .LeftCol = Col
ElseIf Col > (.LeftCol + GetColsPerPage(.LeftCol) - 1) Then
    .LeftCol = Col - GetColsPerPageRev(Col) + 1
End If
Call SetRowColParams(RCP)
End With
End Sub

Public Property Get CellLeft() As Long
Attribute CellLeft.VB_Description = "Returns the left coordinate in twips of the current cell."
Attribute CellLeft.VB_MemberFlags = "400"
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
Me.CellEnsureVisible
Dim CellRect As RECT, GridLineOffsets As TGRIDLINEOFFSETS, RC As RECT
Call GetCellRect(VBFlexGridRow, VBFlexGridCol, CellRect)
Call GetGridLineOffsetsStruct(VBFlexGridRow, VBFlexGridCol, GridLineOffsets)
SetRect RC, 0, 0, UserControl.ScaleWidth, UserControl.ScaleHeight
If VBFlexGridRTLLayout Xor CBool((GetWindowLong(UserControl.ContainerHwnd, GWL_EXSTYLE) And WS_EX_LAYOUTRTL) = WS_EX_LAYOUTRTL) Then
    Dim Swap As Long
    Swap = GridLineOffsets.LeftTop.CX
    GridLineOffsets.LeftTop.CX = GridLineOffsets.RightBottom.CX
    GridLineOffsets.RightBottom.CX = Swap
End If
If VBFlexGridHandle <> NULL_PTR Then
    MapWindowPoints VBFlexGridHandle, UserControl.ContainerHwnd, CellRect, 2
    MapWindowPoints UserControl.hWnd, UserControl.ContainerHwnd, RC, 2
End If
CellLeft = UserControl.ScaleX((CellRect.Left - RC.Left) + GridLineOffsets.LeftTop.CX, vbPixels, vbTwips)
End Property

Public Property Get CellTop() As Long
Attribute CellTop.VB_Description = "Returns the top coordinate in twips of the current cell."
Attribute CellTop.VB_MemberFlags = "400"
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
Me.CellEnsureVisible
Dim CellRect As RECT, GridLineOffsets As TGRIDLINEOFFSETS
Call GetCellRect(VBFlexGridRow, VBFlexGridCol, CellRect)
Call GetGridLineOffsetsStruct(VBFlexGridRow, VBFlexGridCol, GridLineOffsets)
If VBFlexGridHandle <> NULL_PTR Then MapWindowPoints VBFlexGridHandle, UserControl.hWnd, CellRect, 2
CellTop = UserControl.ScaleY(CellRect.Top + GridLineOffsets.LeftTop.CY, vbPixels, vbTwips)
End Property

Public Property Get CellWidth() As Long
Attribute CellWidth.VB_Description = "Returns the width in twips of the current cell."
Attribute CellWidth.VB_MemberFlags = "400"
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
Me.CellEnsureVisible
Dim CellRect As RECT, GridLineOffsets As TGRIDLINEOFFSETS
Call GetCellRect(VBFlexGridRow, VBFlexGridCol, CellRect)
Call GetGridLineOffsetsStruct(VBFlexGridRow, VBFlexGridCol, GridLineOffsets)
CellWidth = UserControl.ScaleX((CellRect.Right - CellRect.Left) - (GridLineOffsets.LeftTop.CX + GridLineOffsets.RightBottom.CX), vbPixels, vbTwips)
End Property

Public Property Get CellHeight() As Long
Attribute CellHeight.VB_Description = "Returns the height in twips of the current cell."
Attribute CellHeight.VB_MemberFlags = "400"
If VBFlexGridRow < 0 Then
    Err.Raise Number:=30009, Description:="Invalid Row value"
ElseIf VBFlexGridCol < 0 Then
    Err.Raise Number:=30010, Description:="Invalid Col value"
End If
Me.CellEnsureVisible
Dim CellRect As RECT, GridLineOffsets As TGRIDLINEOFFSETS
Call GetCellRect(VBFlexGridRow, VBFlexGridCol, CellRect)
Call GetGridLineOffsetsStruct(VBFlexGridRow, VBFlexGridCol, GridLineOffsets)
CellHeight = UserControl.ScaleY((CellRect.Bottom - CellRect.Top) - (GridLineOffsets.LeftTop.CY + GridLineOffsets.RightBottom.CY), vbPixels, vbTwips)
End Property

Public Sub GetGridLineOffsets(ByRef Left As Long, ByRef Top As Long, ByRef Right As Long, ByRef Bottom As Long, Optional ByVal Row As Long = -1, Optional ByVal Col As Long = -1)
Attribute GetGridLineOffsets.VB_Description = "Retrieves the grid line offsets between cells."
If Row < -1 Then Err.Raise 380
If Col < -1 Then Err.Raise 380
If Row = -1 Then Row = VBFlexGridRow
If Col = -1 Then Col = VBFlexGridCol
If (Row < 0 Or Row > (PropRows - 1)) Or (Col < 0 Or Col > (PropCols - 1)) Then Err.Raise Number:=381, Description:="Subscript out of range"
Dim GridLineOffsets As TGRIDLINEOFFSETS
Call GetGridLineOffsetsStruct(Row, Col, GridLineOffsets)
With GridLineOffsets
Left = UserControl.ScaleX(.LeftTop.CX, vbPixels, vbTwips)
Top = UserControl.ScaleY(.LeftTop.CY, vbPixels, vbTwips)
Right = UserControl.ScaleX(.RightBottom.CX, vbPixels, vbTwips)
Bottom = UserControl.ScaleY(.RightBottom.CY, vbPixels, vbTwips)
End With
End Sub

Public Sub GetMetrics(ByVal Metric As FlexMetricConstants, ByRef CX As Long, ByRef CY As Long)
Attribute GetMetrics.VB_Description = "Retrieves the metrics in twips of the flex grid control."
Select Case Metric
    Case FlexMetricDividerSpacing
        CX = UserControl.ScaleX(VBFlexGridPixelMetrics.DividerSpacing.CX, vbPixels, vbTwips)
        CY = UserControl.ScaleY(VBFlexGridPixelMetrics.DividerSpacing.CY, vbPixels, vbTwips)
    Case FlexMetricTextPadding
        CX = UserControl.ScaleX(VBFlexGridPixelMetrics.TextPadding.CX, vbPixels, vbTwips)
        CY = UserControl.ScaleY(VBFlexGridPixelMetrics.TextPadding.CY, vbPixels, vbTwips)
    Case FlexMetricCellSpacing
        CX = UserControl.ScaleX(VBFlexGridPixelMetrics.CellSpacing.CX, vbPixels, vbTwips)
        CY = UserControl.ScaleY(VBFlexGridPixelMetrics.CellSpacing.CY, vbPixels, vbTwips)
    Case FlexMetricScrollBarSize
        CX = UserControl.ScaleX(VBFlexGridPixelMetrics.ScrollBarSize, vbPixels, vbTwips)
        CY = UserControl.ScaleY(VBFlexGridPixelMetrics.ScrollBarSize, vbPixels, vbTwips)
    Case FlexMetricCheckBoxSize
        CX = UserControl.ScaleX(VBFlexGridPixelMetrics.CheckBoxSize, vbPixels, vbTwips)
        CY = UserControl.ScaleY(VBFlexGridPixelMetrics.CheckBoxSize, vbPixels, vbTwips)
    Case Else
        Err.Raise 380
End Select
End Sub

Public Sub HitTest(ByVal X As Single, ByVal Y As Single)
Attribute HitTest.VB_Description = "A method that returns a value which indicates the element located at the specified X and Y coordinates."
Dim HTI As THITTESTINFO
With HTI
.PT.X = UserControl.ScaleX(X, vbContainerPosition, vbPixels)
.PT.Y = UserControl.ScaleY(Y, vbContainerPosition, vbPixels)
Call GetHitTestInfo(HTI)
VBFlexGridHitRow = .HitRow
VBFlexGridHitCol = .HitCol
VBFlexGridHitRowDivider = .HitRowDivider
VBFlexGridHitColDivider = .HitColDivider
VBFlexGridHitResult = .HitResult
End With
End Sub

Public Function HitTestInsertMark(ByVal X As Single, ByVal Y As Single, Optional ByRef After As Boolean) As Long
Attribute HitTestInsertMark.VB_Description = "Returns the insert mark row or column located at the specified X and Y coordinates."
Dim P As POINTAPI
P.X = UserControl.ScaleX(X, vbContainerPosition, vbPixels)
P.Y = UserControl.ScaleY(Y, vbContainerPosition, vbPixels)
If (PropRows < 1 Or PropCols < 1) Or (P.X < 0 And P.Y < 0) Then Exit Function
Dim CellRect As RECT, i As Long
With CellRect
If VBFlexGridInsertMarkMode = FlexDropTargetModeByRow Then
    If P.Y >= 0 Then
        For i = 0 To (PropRows - 1)
            If i >= VBFlexGridTopRow Or i < (PropFixedRows + PropFrozenRows) Then
                .Top = .Bottom
                .Bottom = .Top + GetRowHeight(i)
                If P.Y >= .Top Then
                    HitTestInsertMark = i
                    If P.Y < .Bottom Then Exit For
                End If
            End If
        Next i
        If HitTestInsertMark <= (PropRows - 1) Then After = CBool(P.Y > (.Top + (GetRowHeight(HitTestInsertMark) \ 2)))
    End If
ElseIf VBFlexGridInsertMarkMode = FlexDropTargetModeByColumn Then
    If P.X >= 0 Then
        For i = 0 To (PropCols - 1)
            If i >= VBFlexGridLeftCol Or i < (PropFixedCols + PropFrozenCols) Then
                .Left = .Right
                .Right = .Left + GetColWidth(i)
                If P.X >= .Left Then
                    HitTestInsertMark = i
                    If P.X < .Right Then Exit For
                End If
            End If
        Next i
        If HitTestInsertMark <= (PropCols - 1) Then After = CBool(P.X > (.Left + (GetColWidth(HitTestInsertMark) \ 2)))
    End If
End If
End With
End Function

Public Function FindItem(ByVal Text As String, Optional ByVal Row As Long = -1, Optional ByVal Col As Long = -1, Optional ByVal Match As FlexFindMatchConstants, Optional ByVal CaseSensitive As Boolean, Optional ByVal ExcludeHidden As Boolean, Optional ByVal Wrap As Boolean, Optional ByVal Direction As FlexFindDirectionConstants, Optional ByVal TextDisplay As Boolean) As Long
Attribute FindItem.VB_Description = "Finds an item in the flex grid and returns the index of that item."
If Row < -1 Then Err.Raise 380
If Col < -1 Then Err.Raise 380
Select Case Match
    Case FlexFindMatchExact, FlexFindMatchPartial, FlexFindMatchStartsWith, FlexFindMatchEndsWith
    Case vbTrue ' Compatibility
        Match = FlexFindMatchPartial
    Case Else
        Err.Raise 380
End Select
Select Case Direction
    Case FlexFindDirectionDown, FlexFindDirectionUp, FlexFindDirectionRight, FlexFindDirectionLeft
    Case Else
        Err.Raise 380
End Select
If Direction <= FlexFindDirectionUp Then
    If Row = -1 Then Row = IIf(Direction = FlexFindDirectionDown, PropFixedRows, (PropRows - 1))
    If Col = -1 Then Col = PropFixedCols
Else
    If Row = -1 Then Row = PropFixedRows
    If Col = -1 Then Col = IIf(Direction = FlexFindDirectionRight, PropFixedCols, (PropCols - 1))
End If
If (Row < 0 Or Row > (PropRows - 1)) Or (Col < 0 Or Col > (PropCols - 1)) Then Err.Raise Number:=381, Description:="Subscript out of range"
If Direction <= FlexFindDirectionUp Then
    If Row < PropFixedRows Then Err.Raise Number:=30003, Description:="Cannot use FindItem on a fixed row"
Else
    If Col < PropFixedCols Then Err.Raise Number:=30003, Description:="Cannot use FindItem on a fixed column"
End If
Dim iRowOrCol As Long, iRowOrColTo As Long, Compare As VbCompareMethod, Length As Long, Buffer As String
FindItem = -1
If Direction <= FlexFindDirectionUp Then
    If Direction = FlexFindDirectionDown Then iRowOrColTo = (PropRows - 1) Else iRowOrColTo = PropFixedRows
Else
    If Direction = FlexFindDirectionRight Then iRowOrColTo = (PropCols - 1) Else iRowOrColTo = PropFixedCols
End If
If CaseSensitive = False Then Compare = vbTextCompare Else Compare = vbBinaryCompare
Length = Len(Text)
Select Case Match
    Case FlexFindMatchExact
        If Direction <= FlexFindDirectionUp Then
            For iRowOrCol = Row To iRowOrColTo Step IIf(Direction = FlexFindDirectionDown, 1, -1)
                If (CBool((VBFlexGridCells.Rows(iRowOrCol).RowInfo.State And RWIS_HIDDEN) = RWIS_HIDDEN) Xor ExcludeHidden) Or ExcludeHidden = False Then
                    Call GetCellText(iRowOrCol, Col, Buffer)
                    If TextDisplay = True Then Call GetTextDisplay(iRowOrCol, Col, Buffer)
                    If StrComp(Buffer, Text, Compare) = 0 Then
                        FindItem = iRowOrCol
                        Exit For
                    End If
                End If
            Next iRowOrCol
        Else
            For iRowOrCol = Col To iRowOrColTo Step IIf(Direction = FlexFindDirectionRight, 1, -1)
                If (CBool((VBFlexGridColsInfo(iRowOrCol).State And CLIS_HIDDEN) = CLIS_HIDDEN) Xor ExcludeHidden) Or ExcludeHidden = False Then
                    Call GetCellText(Row, iRowOrCol, Buffer)
                    If TextDisplay = True Then Call GetTextDisplay(Row, iRowOrCol, Buffer)
                    If StrComp(Buffer, Text, Compare) = 0 Then
                        FindItem = iRowOrCol
                        Exit For
                    End If
                End If
            Next iRowOrCol
        End If
    Case FlexFindMatchPartial
        If Direction <= FlexFindDirectionUp Then
            For iRowOrCol = Row To iRowOrColTo Step IIf(Direction = FlexFindDirectionDown, 1, -1)
                If (CBool((VBFlexGridCells.Rows(iRowOrCol).RowInfo.State And RWIS_HIDDEN) = RWIS_HIDDEN) Xor ExcludeHidden) Or ExcludeHidden = False Then
                    Call GetCellText(iRowOrCol, Col, Buffer)
                    If TextDisplay = True Then Call GetTextDisplay(iRowOrCol, Col, Buffer)
                    If InStr(1, Buffer, Text, Compare) > 0 Then
                        FindItem = iRowOrCol
                        Exit For
                    End If
                End If
            Next iRowOrCol
        Else
            For iRowOrCol = Col To iRowOrColTo Step IIf(Direction = FlexFindDirectionRight, 1, -1)
                If (CBool((VBFlexGridColsInfo(iRowOrCol).State And CLIS_HIDDEN) = CLIS_HIDDEN) Xor ExcludeHidden) Or ExcludeHidden = False Then
                    Call GetCellText(Row, iRowOrCol, Buffer)
                    If TextDisplay = True Then Call GetTextDisplay(Row, iRowOrCol, Buffer)
                    If InStr(1, Buffer, Text, Compare) > 0 Then
                        FindItem = iRowOrCol
                        Exit For
                    End If
                End If
            Next iRowOrCol
        End If
    Case FlexFindMatchStartsWith
        If Direction <= FlexFindDirectionUp Then
            For iRowOrCol = Row To iRowOrColTo Step IIf(Direction = FlexFindDirectionDown, 1, -1)
                If (CBool((VBFlexGridCells.Rows(iRowOrCol).RowInfo.State And RWIS_HIDDEN) = RWIS_HIDDEN) Xor ExcludeHidden) Or ExcludeHidden = False Then
                    Call GetCellText(iRowOrCol, Col, Buffer)
                    If TextDisplay = True Then Call GetTextDisplay(iRowOrCol, Col, Buffer)
                    If StrComp(Left$(Buffer, Length), Text, Compare) = 0 Then
                        FindItem = iRowOrCol
                        Exit For
                    End If
                End If
            Next iRowOrCol
        Else
            For iRowOrCol = Col To iRowOrColTo Step IIf(Direction = FlexFindDirectionRight, 1, -1)
                If (CBool((VBFlexGridColsInfo(iRowOrCol).State And CLIS_HIDDEN) = CLIS_HIDDEN) Xor ExcludeHidden) Or ExcludeHidden = False Then
                    Call GetCellText(Row, iRowOrCol, Buffer)
                    If TextDisplay = True Then Call GetTextDisplay(Row, iRowOrCol, Buffer)
                    If StrComp(Left$(Buffer, Length), Text, Compare) = 0 Then
                        FindItem = iRowOrCol
                        Exit For
                    End If
                End If
            Next iRowOrCol
        End If
    Case FlexFindMatchEndsWith
        If Direction <= FlexFindDirectionUp Then
            For iRowOrCol = Row To iRowOrColTo Step IIf(Direction = FlexFindDirectionDown, 1, -1)
                If (CBool((VBFlexGridCells.Rows(iRowOrCol).RowInfo.State And RWIS_HIDDEN) = RWIS_HIDDEN) Xor ExcludeHidden) Or ExcludeHidden = False Then
                    Call GetCellText(iRowOrCol, Col, Buffer)
                    If TextDisplay = True Then Call GetTextDisplay(iRowOrCol, Col, Buffer)
                    If StrComp(Right$(Buffer, Length), Text, Compare) = 0 Then
                        FindItem = iRowOrCol
                        Exit For
                    End If
                End If
            Next iRowOrCol
        Else
            For iRowOrCol = Col To iRowOrColTo Step IIf(Direction = FlexFindDirectionRight, 1, -1)
                If (CBool((VBFlexGridColsInfo(iRowOrCol).State And CLIS_HIDDEN) = CLIS_HIDDEN) Xor ExcludeHidden) Or ExcludeHidden = False Then
                    Call GetCellText(Row, iRowOrCol, Buffer)
                    If TextDisplay = True Then Call GetTextDisplay(Row, iRowOrCol, Buffer)
                    If StrComp(Right$(Buffer, Length), Text, Compare) = 0 Then
                        FindItem = iRowOrCol
                        Exit For
                    End If
                End If
            Next iRowOrCol
        End If
End Select
If Wrap = True And FindItem = -1 Then
    If Direction <= FlexFindDirectionUp Then
        If Direction = FlexFindDirectionDown Then iRowOrColTo = PropFixedRows Else iRowOrColTo = (PropRows - 1)
    Else
        If Direction = FlexFindDirectionRight Then iRowOrColTo = PropFixedCols Else iRowOrColTo = (PropCols - 1)
    End If
    Select Case Match
        Case FlexFindMatchExact
            If Direction <= FlexFindDirectionUp Then
                For iRowOrCol = iRowOrColTo To (Row - IIf(Direction = FlexFindDirectionDown, 1, -1)) Step IIf(Direction = FlexFindDirectionDown, 1, -1)
                    If (CBool((VBFlexGridCells.Rows(iRowOrCol).RowInfo.State And RWIS_HIDDEN) = RWIS_HIDDEN) Xor ExcludeHidden) Or ExcludeHidden = False Then
                        Call GetCellText(iRowOrCol, Col, Buffer)
                        If TextDisplay = True Then Call GetTextDisplay(iRowOrCol, Col, Buffer)
                        If StrComp(Buffer, Text, Compare) = 0 Then
                            FindItem = iRowOrCol
                            Exit For
                        End If
                    End If
                Next iRowOrCol
            Else
                For iRowOrCol = iRowOrColTo To (Col - IIf(Direction = FlexFindDirectionRight, 1, -1)) Step IIf(Direction = FlexFindDirectionRight, 1, -1)
                    If (CBool((VBFlexGridColsInfo(iRowOrCol).State And CLIS_HIDDEN) = CLIS_HIDDEN) Xor ExcludeHidden) Or ExcludeHidden = False Then
                        Call GetCellText(Row, iRowOrCol, Buffer)
                        If TextDisplay = True Then Call GetTextDisplay(Row, iRowOrCol, Buffer)
                        If StrComp(Buffer, Text, Compare) = 0 Then
                            FindItem = iRowOrCol
                            Exit For
                        End If
                    End If
                Next iRowOrCol
            End If
        Case FlexFindMatchPartial
            If Direction <= FlexFindDirectionUp Then
                For iRowOrCol = iRowOrColTo To (Row - IIf(Direction = FlexFindDirectionDown, 1, -1)) Step IIf(Direction = FlexFindDirectionDown, 1, -1)
                    If (CBool((VBFlexGridCells.Rows(iRowOrCol).RowInfo.State And RWIS_HIDDEN) = RWIS_HIDDEN) Xor ExcludeHidden) Or ExcludeHidden = False Then
                        Call GetCellText(iRowOrCol, Col, Buffer)
                        If TextDisplay = True Then Call GetTextDisplay(iRowOrCol, Col, Buffer)
                        If InStr(1, Buffer, Text, Compare) > 0 Then
                            FindItem = iRowOrCol
                            Exit For
                        End If
                    End If
                Next iRowOrCol
            Else
                For iRowOrCol = iRowOrColTo To (Col - IIf(Direction = FlexFindDirectionRight, 1, -1)) Step IIf(Direction = FlexFindDirectionRight, 1, -1)
                    If (CBool((VBFlexGridColsInfo(iRowOrCol).State And CLIS_HIDDEN) = CLIS_HIDDEN) Xor ExcludeHidden) Or ExcludeHidden = False Then
                        Call GetCellText(Row, iRowOrCol, Buffer)
                        If TextDisplay = True Then Call GetTextDisplay(Row, iRowOrCol, Buffer)
                        If InStr(1, Buffer, Text, Compare) > 0 Then
                            FindItem = iRowOrCol
                            Exit For
                        End If
                    End If
                Next iRowOrCol
            End If
        Case FlexFindMatchStartsWith
            If Direction <= FlexFindDirectionUp Then
                For iRowOrCol = iRowOrColTo To (Row - IIf(Direction = FlexFindDirectionDown, 1, -1)) Step IIf(Direction = FlexFindDirectionDown, 1, -1)
                    If (CBool((VBFlexGridCells.Rows(iRowOrCol).RowInfo.State And RWIS_HIDDEN) = RWIS_HIDDEN) Xor ExcludeHidden) Or ExcludeHidden = False Then
                        Call GetCellText(iRowOrCol, Col, Buffer)
                        If TextDisplay = True Then Call GetTextDisplay(iRowOrCol, Col, Buffer)
                        If StrComp(Left$(Buffer, Length), Text, Compare) = 0 Then
                            FindItem = iRowOrCol
                            Exit For
                        End If
                    End If
                Next iRowOrCol
            Else
                For iRowOrCol = iRowOrColTo To (Col - IIf(Direction = FlexFindDirectionRight, 1, -1)) Step IIf(Direction = FlexFindDirectionRight, 1, -1)
                    If (CBool((VBFlexGridColsInfo(iRowOrCol).State And CLIS_HIDDEN) = CLIS_HIDDEN) Xor ExcludeHidden) Or ExcludeHidden = False Then
                        Call GetCellText(Row, iRowOrCol, Buffer)
                        If TextDisplay = True Then Call GetTextDisplay(Row, iRowOrCol, Buffer)
                        If StrComp(Left$(Buffer, Length), Text, Compare) = 0 Then
                            FindItem = iRowOrCol
                            Exit For
                        End If
                    End If
                Next iRowOrCol
            End If
        Case FlexFindMatchEndsWith
            If Direction <= FlexFindDirectionUp Then
                For iRowOrCol = iRowOrColTo To (Row - IIf(Direction = FlexFindDirectionDown, 1, -1)) Step IIf(Direction = FlexFindDirectionDown, 1, -1)
                    If (CBool((VBFlexGridCells.Rows(iRowOrCol).RowInfo.State And RWIS_HIDDEN) = RWIS_HIDDEN) Xor ExcludeHidden) Or ExcludeHidden = False Then
                        Call GetCellText(iRowOrCol, Col, Buffer)
                        If TextDisplay = True Then Call GetTextDisplay(iRowOrCol, Col, Buffer)
                        If StrComp(Right$(Buffer, Length), Text, Compare) = 0 Then
                            FindItem = iRowOrCol
                            Exit For
                        End If
                    End If
                Next iRowOrCol
            Else
                For iRowOrCol = iRowOrColTo To (Col - IIf(Direction = FlexFindDirectionRight, 1, -1)) Step IIf(Direction = FlexFindDirectionRight, 1, -1)
                    If (CBool((VBFlexGridColsInfo(iRowOrCol).State And CLIS_HIDDEN) = CLIS_HIDDEN) Xor ExcludeHidden) Or ExcludeHidden = False Then
                        Call GetCellText(Row, iRowOrCol, Buffer)
                        If TextDisplay = True Then Call GetTextDisplay(Row, iRowOrCol, Buffer)
                        If StrComp(Right$(Buffer, Length), Text, Compare) = 0 Then
                            FindItem = iRowOrCol
                            Exit For
                        End If
                    End If
                Next iRowOrCol
            End If
    End Select
End If
End Function

Public Sub AutoSize(ByVal RowOrCol1 As Long, Optional ByVal RowOrCol2 As Long = -1, Optional ByVal Mode As FlexAutoSizeModeConstants, Optional ByVal Scope As FlexAutoSizeScopeConstants, Optional ByVal Equal As Boolean, Optional ByVal ExtraSpace As Long, Optional ByVal ExcludeHidden As Boolean)
Attribute AutoSize.VB_Description = "Automatically sizes column widths or row heights to fit cell contents."
If VBFlexGridHandle = NULL_PTR Or (PropRows < 1 Or PropCols < 1) Then Exit Sub
If RowOrCol2 < -1 Then Err.Raise 380
If RowOrCol2 = -1 Then RowOrCol2 = RowOrCol1
Select Case Mode
    Case FlexAutoSizeModeColWidth, FlexAutoSizeModeRowHeight
    Case Else
        Err.Raise 380
End Select
Select Case Scope
    Case FlexAutoSizeScopeAll, FlexAutoSizeScopeFixed, FlexAutoSizeScopeScrollable, FlexAutoSizeScopeMovable, FlexAutoSizeScopeFrozen
    Case Else
        Err.Raise 380
End Select
If Mode = FlexAutoSizeModeColWidth Then
    If (RowOrCol1 < 0 Or RowOrCol1 > (PropCols - 1)) Or (RowOrCol2 < 0 Or RowOrCol2 > (PropCols - 1)) Then Err.Raise Number:=381, Description:="Subscript out of range"
ElseIf Mode = FlexAutoSizeModeRowHeight Then
    If (RowOrCol1 < 0 Or RowOrCol1 > (PropRows - 1)) Or (RowOrCol2 < 0 Or RowOrCol2 > (PropRows - 1)) Then Err.Raise Number:=381, Description:="Subscript out of range"
End If
Dim hDC As LongPtr
hDC = GetDC(VBFlexGridHandle)
Dim iRow As Long, iCol As Long, Text As String, Spacing As Long, Size As SIZEAPI, EqualSize As SIZEAPI
Dim RowOrColScope1 As Long, RowOrColScope2 As Long
If Mode = FlexAutoSizeModeColWidth Then
    Spacing = VBFlexGridPixelMetrics.CellSpacing.CX + CLng(UserControl.ScaleX(ExtraSpace, vbTwips, vbPixels))
    EqualSize.CX = -1
    Select Case Scope
        Case FlexAutoSizeScopeAll
            RowOrColScope1 = 0
            RowOrColScope2 = PropRows - 1
        Case FlexAutoSizeScopeFixed
            RowOrColScope1 = 0
            RowOrColScope2 = PropFixedRows - 1
        Case FlexAutoSizeScopeScrollable
            RowOrColScope1 = PropFixedRows + PropFrozenRows
            RowOrColScope2 = PropRows - 1
        Case FlexAutoSizeScopeMovable
            RowOrColScope1 = PropFixedRows
            RowOrColScope2 = PropRows - 1
        Case FlexAutoSizeScopeFrozen
            RowOrColScope1 = PropFixedRows
            RowOrColScope2 = (PropFixedRows + PropFrozenRows) - 1
    End Select
    For iCol = RowOrCol1 To RowOrCol2 Step IIf(RowOrCol2 >= RowOrCol1, 1, -1)
        With VBFlexGridColsInfo(iCol)
        If (CBool((.State And CLIS_HIDDEN) = CLIS_HIDDEN) Xor ExcludeHidden) Or ExcludeHidden = False Then
            .Width = -1
            For iRow = RowOrColScope1 To RowOrColScope2
                If (CBool((VBFlexGridCells.Rows(iRow).RowInfo.State And RWIS_HIDDEN) = RWIS_HIDDEN) Xor ExcludeHidden) Or ExcludeHidden = False Then
                    Call GetCellText(iRow, iCol, Text)
                    Call GetTextDisplay(iRow, iCol, Text)
                    Size.CX = GetBestWidth(iRow, iCol, Text, hDC)
                    If Size.CX > 0 Then
                        Size.CX = Size.CX + Spacing
                        If Size.CX > .Width Then .Width = Size.CX
                        If Size.CX > EqualSize.CX Then EqualSize.CX = Size.CX
                    End If
                End If
            Next iRow
        End If
        End With
    Next iCol
    If Equal = True Then
        For iCol = RowOrCol1 To RowOrCol2 Step IIf(RowOrCol2 >= RowOrCol1, 1, -1)
            With VBFlexGridColsInfo(iCol)
            If (CBool((.State And CLIS_HIDDEN) = CLIS_HIDDEN) Xor ExcludeHidden) Or ExcludeHidden = False Then .Width = EqualSize.CX
            End With
        Next iCol
    End If
ElseIf Mode = FlexAutoSizeModeRowHeight Then
    Spacing = VBFlexGridPixelMetrics.CellSpacing.CY + CLng(UserControl.ScaleY(ExtraSpace, vbTwips, vbPixels))
    EqualSize.CY = -1
    Select Case Scope
        Case FlexAutoSizeScopeAll
            RowOrColScope1 = 0
            RowOrColScope2 = PropCols - 1
        Case FlexAutoSizeScopeFixed
            RowOrColScope1 = 0
            RowOrColScope2 = PropFixedCols - 1
        Case FlexAutoSizeScopeScrollable
            RowOrColScope1 = PropFixedCols + PropFrozenCols
            RowOrColScope2 = PropCols - 1
        Case FlexAutoSizeScopeMovable
            RowOrColScope1 = PropFixedCols
            RowOrColScope2 = PropCols - 1
        Case FlexAutoSizeScopeFrozen
            RowOrColScope1 = PropFixedCols
            RowOrColScope2 = (PropFixedCols + PropFrozenCols) - 1
    End Select
    For iRow = RowOrCol1 To RowOrCol2 Step IIf(RowOrCol2 >= RowOrCol1, 1, -1)
        With VBFlexGridCells.Rows(iRow).RowInfo
        If (CBool((.State And RWIS_HIDDEN) = RWIS_HIDDEN) Xor ExcludeHidden) Or ExcludeHidden = False Then
            .Height = -1
            For iCol = RowOrColScope1 To RowOrColScope2
                If (CBool((VBFlexGridColsInfo(iCol).State And CLIS_HIDDEN) = CLIS_HIDDEN) Xor ExcludeHidden) Or ExcludeHidden = False Then
                    Call GetCellText(iRow, iCol, Text)
                    Call GetTextDisplay(iRow, iCol, Text)
                    Size.CY = GetBestHeight(iRow, iCol, Text, hDC)
                    If Size.CY > 0 Then
                        Size.CY = Size.CY + Spacing
                        If Size.CY > .Height Then .Height = Size.CY
                        If Size.CY > EqualSize.CY Then EqualSize.CY = Size.CY
                    End If
                End If
            Next iCol
        End If
        End With
    Next iRow
    If Equal = True Then
        For iRow = RowOrCol1 To RowOrCol2 Step IIf(RowOrCol2 >= RowOrCol1, 1, -1)
            With VBFlexGridCells.Rows(iRow).RowInfo
            If (CBool((.State And RWIS_HIDDEN) = RWIS_HIDDEN) Xor ExcludeHidden) Or ExcludeHidden = False Then .Height = EqualSize.CY
            End With
        Next iRow
    End If
End If
If hDC <> NULL_PTR Then
    ReleaseDC VBFlexGridHandle, hDC
    hDC = NULL_PTR
End If
Dim RCP As TROWCOLPARAMS
With RCP
If Mode = FlexAutoSizeModeColWidth Then
    .Mask = RCPM_LEFTCOL
    .Flags = RCPF_CHECKLEFTCOL Or RCPF_FORCELEFTCOLMASK
    .LeftCol = VBFlexGridLeftCol
ElseIf Mode = FlexAutoSizeModeRowHeight Then
    .Mask = RCPM_TOPROW
    .Flags = RCPF_CHECKTOPROW Or RCPF_FORCETOPROWMASK
    .TopRow = VBFlexGridTopRow
End If
.Flags = .Flags Or RCPF_SETSCROLLBARS Or RCPF_FORCEREDRAW
Call SetRowColParams(RCP)
End With
End Sub

Public Function TextWidth(ByVal Text As String, Optional ByVal Row As Long = -1, Optional ByVal Col As Long = -1) As Long
Attribute TextWidth.VB_Description = "Returns the text width of the given string using the font of the current or an arbitrary cell (row/col subscripts)."
If Row < -1 Then Err.Raise 380
If Col < -1 Then Err.Raise 380
If Row = -1 Then Row = VBFlexGridRow
If Col = -1 Then Col = VBFlexGridCol
If (Row < 0 Or Row > (PropRows - 1)) Or (Col < 0 Or Col > (PropCols - 1)) Then Err.Raise Number:=381, Description:="Subscript out of range"
Dim Pixels As Long
Pixels = GetTextSize(Row, Col, Text).CX
If Pixels > 0 Then TextWidth = UserControl.ScaleX(Pixels, vbPixels, vbTwips)
End Function

Public Function TextHeight(ByVal Text As String, Optional ByVal Row As Long = -1, Optional ByVal Col As Long = -1) As Long
Attribute TextHeight.VB_Description = "Returns the text height of the given string using the font of the current or an arbitrary cell (row/col subscripts)."
If Row < -1 Then Err.Raise 380
If Col < -1 Then Err.Raise 380
If Row = -1 Then Row = VBFlexGridRow
If Col = -1 Then Col = VBFlexGridCol
If (Row < 0 Or Row > (PropRows - 1)) Or (Col < 0 Or Col > (PropCols - 1)) Then Err.Raise Number:=381, Description:="Subscript out of range"
Dim Pixels As Long
Pixels = GetTextSize(Row, Col, Text).CY
If Pixels > 0 Then TextHeight = UserControl.ScaleY(Pixels, vbPixels, vbTwips)
End Function

Public Function LookupConv(ByVal Text As String, ByVal Conversion As FlexLookupConvConstants, Optional ByVal Col As Long = -1) As String
Attribute LookupConv.VB_Description = "Returns a converted lookup of the current or a specified column."
Select Case Conversion
    Case FlexLookupConvValue, FlexLookupConvKey
    Case Else
        Err.Raise 380
End Select
If Col < -1 Then Err.Raise 380
If Col = -1 Then Col = VBFlexGridCol
If Col < 0 Or Col > (PropCols - 1) Then Err.Raise Number:=381, Description:="Subscript out of range"
With VBFlexGridColsInfo(Col)
If .Lookup.Count > 0 Then
    Dim i As Long
    If Conversion = FlexLookupConvValue Then
        Dim Hash As Long
        Hash = CalcHash(Text)
        For i = 0 To (.Lookup.Count - 1)
            If .Lookup.Items(i).Hash = Hash Then
                If StrComp(.Lookup.Items(i).Key, Text, vbTextCompare) = 0 Then
                    LookupConv = .Lookup.Items(i).Value
                    Exit For
                End If
            End If
        Next i
    ElseIf Conversion = FlexLookupConvKey Then
        For i = 0 To (.Lookup.Count - 1)
            If StrComp(.Lookup.Items(i).Value, Text) = 0 Then
                LookupConv = .Lookup.Items(i).Key
                Exit For
            End If
        Next i
    End If
End If
End With
End Function

Public Property Get Picture() As IPictureDisp
Attribute Picture.VB_Description = "Returns a picture of the flex grid control, suitable for printing, saving to disk, copying to the clipboard, or assigning to a different control."
Attribute Picture.VB_MemberFlags = "400"
If VBFlexGridHandle <> NULL_PTR Then
    Dim hDC As LongPtr
    hDC = GetDC(VBFlexGridHandle)
    If hDC <> NULL_PTR Then
        Dim RC As RECT, iRow As Long, iCol As Long
        With RC
        .Top = 0
        For iRow = 0 To ((PropFixedRows + PropFrozenRows) - 1)
            .Bottom = .Bottom + GetRowHeight(iRow)
        Next iRow
        For iRow = VBFlexGridTopRow To (PropRows - 1)
            .Bottom = .Bottom + GetRowHeight(iRow)
        Next iRow
        .Left = 0
        For iCol = 0 To ((PropFixedCols + PropFrozenCols) - 1)
            .Right = .Right + GetColWidth(iCol)
        Next iCol
        For iCol = VBFlexGridLeftCol To (PropCols - 1)
            .Right = .Right + GetColWidth(iCol)
        Next iCol
        End With
        If PropPictureType <> FlexPictureTypeEnhMetafile Then
            Dim hDCBmp As LongPtr
            Dim hBmp As LongPtr, hBmpOld As LongPtr
            hDCBmp = CreateCompatibleDC(hDC)
            If hDCBmp <> NULL_PTR Then
                If PropPictureType = FlexPictureTypeColor Then
                    hBmp = CreateCompatibleBitmap(hDC, RC.Right - RC.Left, RC.Bottom - RC.Top)
                ElseIf PropPictureType = FlexPictureTypeMonochrome Then
                    hBmp = CreateCompatibleBitmap(hDCBmp, RC.Right - RC.Left, RC.Bottom - RC.Top)
                End If
                If hBmp <> NULL_PTR Then
                    hBmpOld = SelectObject(hDCBmp, hBmp)
                    Call DrawGrid(hDCBmp, NULL_PTR, True, True)
                    Set Picture = PictureFromHandle(hBmp, vbPicTypeBitmap)
                    SelectObject hDCBmp, hBmpOld
                End If
                DeleteDC hDCBmp
            End If
        Else
            Dim EnhMetaRect As RECT, EnhMetaDC As LongPtr, hEMF As LongPtr
            EnhMetaRect.Left = (RC.Left * GetDeviceCaps(hDC, HORZSIZE) * 100) / GetDeviceCaps(hDC, HORZRES)
            EnhMetaRect.Top = (RC.Top * GetDeviceCaps(hDC, VERTSIZE) * 100) / GetDeviceCaps(hDC, VERTRES)
            EnhMetaRect.Right = (RC.Right * GetDeviceCaps(hDC, HORZSIZE) * 100) / GetDeviceCaps(hDC, HORZRES)
            EnhMetaRect.Bottom = (RC.Bottom * GetDeviceCaps(hDC, VERTSIZE) * 100) / GetDeviceCaps(hDC, VERTRES)
            EnhMetaDC = CreateEnhMetaFile(hDC, NULL_PTR, EnhMetaRect, NULL_PTR)
            If EnhMetaDC <> NULL_PTR Then
                Call DrawGrid(EnhMetaDC, NULL_PTR, True, True)
                hEMF = CloseEnhMetaFile(EnhMetaDC)
            End If
            If hEMF <> NULL_PTR Then Set Picture = PictureFromHandle(hEMF, vbPicTypeEMetafile)
        End If
        ReleaseDC VBFlexGridHandle, hDC
    End If
End If
End Property

Public Property Get ScrollTipText() As String
Attribute ScrollTipText.VB_Description = "Returns/sets the text contained in an object."
Attribute ScrollTipText.VB_MemberFlags = "400"
If VBFlexGridHandle <> NULL_PTR And VBFlexGridScrollTipHandle <> NULL_PTR Then
    Dim TI As TOOLINFO, Buffer As String
    With TI
    Buffer = String(INFOTIPSIZE, vbNullChar) & vbNullChar
    .cbSize = LenB(TI)
    .hWnd = VBFlexGridHandle
    .uId = 0
    .lpszText = StrPtr(Buffer)
    End With
    ' wParam is only ignored and limited to a length of 80 by the ANSI version of TTM_GETTEXT.
    SendMessage VBFlexGridScrollTipHandle, TTM_GETTEXT, INFOTIPSIZE + 1, ByVal VarPtr(TI)
    ScrollTipText = Left$(Buffer, InStr(Buffer, vbNullChar) - 1)
Else
    Err.Raise 5
End If
End Property

Public Property Let ScrollTipText(ByVal Value As String)
If VBFlexGridHandle <> NULL_PTR And VBFlexGridScrollTipHandle <> NULL_PTR Then
    Dim TI As TOOLINFO
    With TI
    .cbSize = LenB(TI)
    .hWnd = VBFlexGridHandle
    .uId = 0
    .lpszText = StrPtr(Value)
    End With
    SendMessage VBFlexGridScrollTipHandle, TTM_UPDATETIPTEXT, 0, ByVal VarPtr(TI)
Else
    Err.Raise 5
End If
End Property

Public Function StartEdit(Optional ByVal Row As Long = -1, Optional ByVal Col As Long = -1) As Boolean
Attribute StartEdit.VB_Description = "Begins a text editing operation on the current or an arbitrary cell (row/col subscripts)."
If Row < -1 Then Err.Raise 380
If Col < -1 Then Err.Raise 380
If Row = -1 Then Row = VBFlexGridRow
If Col = -1 Then Col = VBFlexGridCol
If (Row < 0 Or Row > (PropRows - 1)) Or (Col < 0 Or Col > (PropCols - 1)) Then Err.Raise Number:=381, Description:="Subscript out of range"
StartEdit = CreateEdit(FlexEditReasonCode, Row, Col)
End Function

Public Function CancelEdit() As Boolean
Attribute CancelEdit.VB_Description = "Ends the text editing operation and discards the changes."
Call ComboShowDropDown(False, FlexComboDropDownReasonCode)
CancelEdit = DestroyEdit(True, FlexEditCloseModeCode)
End Function

Public Function CommitEdit() As Boolean
Attribute CommitEdit.VB_Description = "Ends the text editing operation and saves the changes."
Call ComboShowDropDown(False, FlexComboDropDownReasonCode)
CommitEdit = DestroyEdit(False, FlexEditCloseModeCode)
End Function

Public Property Get EditRow() As Long
Attribute EditRow.VB_Description = "Returns the row bound to a text editing operation."
Attribute EditRow.VB_MemberFlags = "400"
EditRow = VBFlexGridEditRow
End Property

Public Property Get EditCol() As Long
Attribute EditCol.VB_Description = "Returns the column bound to a text editing operation."
Attribute EditCol.VB_MemberFlags = "400"
EditCol = VBFlexGridEditCol
End Property

Public Property Get EditReason() As FlexEditReasonConstants
Attribute EditReason.VB_Description = "Returns a value indicating how the last text editing operation began."
Attribute EditReason.VB_MemberFlags = "400"
EditReason = VBFlexGridEditReason
End Property

Public Property Get EditCloseMode() As FlexEditCloseModeConstants
Attribute EditCloseMode.VB_Description = "Returns a value indicating how the last text editing operation was closed."
Attribute EditCloseMode.VB_MemberFlags = "400"
EditCloseMode = VBFlexGridEditCloseMode
End Property

Public Property Get EditText() As String
Attribute EditText.VB_Description = "Returns/sets the text contained in an object."
Attribute EditText.VB_MemberFlags = "400"
If VBFlexGridEditHandle <> NULL_PTR Then
    EditText = String(CLng(SendMessage(VBFlexGridEditHandle, WM_GETTEXTLENGTH, 0, ByVal 0&)), vbNullChar)
    SendMessage VBFlexGridEditHandle, WM_GETTEXT, Len(EditText) + 1, ByVal StrPtr(EditText)
Else
    Err.Raise 5
End If
End Property

Public Property Let EditText(ByVal Value As String)
If VBFlexGridEditHandle <> NULL_PTR Then
    Dim MaxLength As Long
    MaxLength = Me.EditMaxLength
    If MaxLength > 0 Then Value = Left$(Value, MaxLength)
    Dim Changed As Boolean
    Changed = CBool(Me.EditText <> Value)
    VBFlexGridEditChangeFrozen = True
    SendMessage VBFlexGridEditHandle, WM_SETTEXT, 0, ByVal StrPtr(Value)
    VBFlexGridEditChangeFrozen = False
    If Changed = True Then
        VBFlexGridEditTextChanged = True
        VBFlexGridEditAlreadyValidated = False
        RaiseEvent EditChange
    End If
Else
    Err.Raise 5
End If
End Property

Public Property Get EditLocked() As Boolean
Attribute EditLocked.VB_Description = "Returns/sets a value indicating whether the contents can be edited."
Attribute EditLocked.VB_MemberFlags = "400"
If VBFlexGridEditHandle <> NULL_PTR Then
    EditLocked = CBool((GetWindowLong(VBFlexGridEditHandle, GWL_STYLE) And ES_READONLY) <> 0)
Else
    Err.Raise 5
End If
End Property

Public Property Let EditLocked(ByVal Value As Boolean)
If VBFlexGridEditHandle <> NULL_PTR Then
    SendMessage VBFlexGridEditHandle, EM_SETREADONLY, IIf(Value = True, 1, 0), ByVal 0&
Else
    Err.Raise 5
End If
End Property

Public Property Get EditMaxLength() As Long
Attribute EditMaxLength.VB_Description = "Returns/sets the maximum number of characters that can be entered in a control."
Attribute EditMaxLength.VB_MemberFlags = "400"
If VBFlexGridEditHandle <> NULL_PTR Then
    EditMaxLength = CLng(SendMessage(VBFlexGridEditHandle, EM_GETLIMITTEXT, 0, ByVal 0&))
Else
    Err.Raise 5
End If
End Property

Public Property Let EditMaxLength(ByVal Value As Long)
If Value < 0 Then Err.Raise 380
If VBFlexGridEditHandle <> NULL_PTR Then
    SendMessage VBFlexGridEditHandle, EM_SETLIMITTEXT, Value, ByVal 0&
Else
    Err.Raise 5
End If
End Property

Public Property Get EditSelStart() As Long
Attribute EditSelStart.VB_Description = "Returns/sets the starting point of text selected; indicates the position of the insertion point if no text is selected."
Attribute EditSelStart.VB_MemberFlags = "400"
If VBFlexGridEditHandle <> NULL_PTR Then
    SendMessage VBFlexGridEditHandle, EM_GETSEL, VarPtr(EditSelStart), ByVal 0&
Else
    Err.Raise 5
End If
End Property

Public Property Let EditSelStart(ByVal Value As Long)
If VBFlexGridEditHandle <> NULL_PTR Then
    If Value >= 0 Then
        SendMessage VBFlexGridEditHandle, EM_SETSEL, Value, ByVal Value
    Else
        Err.Raise 380
    End If
Else
    Err.Raise 5
End If
End Property

Public Property Get EditSelLength() As Long
Attribute EditSelLength.VB_Description = "Returns/sets the number of characters selected."
Attribute EditSelLength.VB_MemberFlags = "400"
If VBFlexGridEditHandle <> NULL_PTR Then
    Dim SelStart As Long, SelEnd As Long
    SendMessage VBFlexGridEditHandle, EM_GETSEL, VarPtr(SelStart), ByVal VarPtr(SelEnd)
    EditSelLength = SelEnd - SelStart
Else
    Err.Raise 5
End If
End Property

Public Property Let EditSelLength(ByVal Value As Long)
If VBFlexGridEditHandle <> NULL_PTR Then
    If Value >= 0 Then
        Dim SelStart As Long
        SendMessage VBFlexGridEditHandle, EM_GETSEL, VarPtr(SelStart), ByVal 0&
        SendMessage VBFlexGridEditHandle, EM_SETSEL, SelStart, ByVal SelStart + Value
    Else
        Err.Raise 380
    End If
Else
    Err.Raise 5
End If
End Property

Public Property Get EditSelText() As String
Attribute EditSelText.VB_Description = "Returns/sets the string containing the currently selected text."
Attribute EditSelText.VB_MemberFlags = "400"
If VBFlexGridEditHandle <> NULL_PTR Then
    Dim SelStart As Long, SelEnd As Long
    SendMessage VBFlexGridEditHandle, EM_GETSEL, VarPtr(SelStart), ByVal VarPtr(SelEnd)
    On Error Resume Next
    EditSelText = Mid$(Me.EditText, SelStart + 1, (SelEnd - SelStart))
    On Error GoTo 0
Else
    Err.Raise 5
End If
End Property

Public Property Let EditSelText(ByVal Value As String)
If VBFlexGridEditHandle <> NULL_PTR Then
    If StrPtr(Value) = NULL_PTR Then Value = ""
    SendMessage VBFlexGridEditHandle, EM_REPLACESEL, 1, ByVal StrPtr(Value)
Else
    Err.Raise 5
End If
End Property

Public Property Get ComboCue() As FlexComboCueConstants
Attribute ComboCue.VB_Description = "Returns/sets the combo cue to visually indicate a combo functionality."
Attribute ComboCue.VB_MemberFlags = "400"
ComboCue = VBFlexGridComboCue
End Property

Public Property Let ComboCue(ByVal Value As FlexComboCueConstants)
Select Case Value
    Case FlexComboCueHidden, FlexComboCueNone, FlexComboCueDropDown, FlexComboCueButton, FlexComboCueDisabledDropDown, FlexComboCueDisabledButton
        VBFlexGridComboCue = Value
    Case Else
        Err.Raise 380
End Select
Call RedrawGrid
End Property

Public Property Get ComboCueRow() As Long
Attribute ComboCueRow.VB_Description = "Returns/sets the row where the combo cue is displayed."
Attribute ComboCueRow.VB_MemberFlags = "400"
ComboCueRow = GetComboCueRow()
End Property

Public Property Let ComboCueRow(ByVal Value As Long)
If Value <> -1 And (Value < 0 Or Value > (PropRows - 1)) Then Err.Raise Number:=30009, Description:="Invalid Row value"
VBFlexGridComboCueRow = Value
Call RedrawGrid
End Property

Public Property Get ComboCueCol() As Long
Attribute ComboCueCol.VB_Description = "Returns/sets the column where the combo cue is displayed."
Attribute ComboCueCol.VB_MemberFlags = "400"
ComboCueCol = GetComboCueCol()
End Property

Public Property Let ComboCueCol(ByVal Value As Long)
If Value <> -1 And (Value < 0 Or Value > (PropCols - 1)) Then Err.Raise Number:=30010, Description:="Invalid Col value"
VBFlexGridComboCueCol = Value
Call RedrawGrid
End Property

Public Property Get ComboMode() As FlexComboModeConstants
Attribute ComboMode.VB_Description = "Returns/sets the combo functionality mode when editing a cell."
Attribute ComboMode.VB_MemberFlags = "400"
ComboMode = VBFlexGridComboMode
End Property

Public Property Let ComboMode(ByVal Value As FlexComboModeConstants)
Select Case Value
    Case FlexComboModeNone, FlexComboModeDropDown, FlexComboModeEditable, FlexComboModeButton, FlexComboModeCalendar
        VBFlexGridComboMode = Value
    Case Else
        Err.Raise 380
End Select
End Property

Public Property Get ComboButtonValue() As FlexComboButtonValueConstants
Attribute ComboButtonValue.VB_Description = "Returns/sets the value of the combo button."
Attribute ComboButtonValue.VB_MemberFlags = "400"
If VBFlexGridComboButtonHandle <> NULL_PTR Then
    If IsWindowEnabled(VBFlexGridComboButtonHandle) <> 0 Then
        If ComboButtonGetState(ODS_SELECTED) = False Then
            ComboButtonValue = FlexComboButtonValueUnpressed
        Else
            ComboButtonValue = FlexComboButtonValuePressed
        End If
    Else
        ComboButtonValue = FlexComboButtonValueDisabled
    End If
Else
    Err.Raise 5
End If
End Property

Public Property Let ComboButtonValue(ByVal Value As FlexComboButtonValueConstants)
Select Case Value
    Case FlexComboButtonValueUnpressed, FlexComboButtonValuePressed, FlexComboButtonValueDisabled
    Case Else
        Err.Raise 380
End Select
If VBFlexGridComboButtonHandle <> NULL_PTR Then
    Select Case Value
        Case FlexComboButtonValueUnpressed
            If IsWindowEnabled(VBFlexGridComboButtonHandle) = 0 Then EnableWindow VBFlexGridComboButtonHandle, 1
            If VBFlexGridComboListHandle <> NULL_PTR Or VBFlexGridComboCalendarHandle <> NULL_PTR Then
                Call ComboShowDropDown(False, FlexComboDropDownReasonCode)
            Else
                Call ComboButtonSetState(ODS_SELECTED, False)
            End If
        Case FlexComboButtonValuePressed
            If IsWindowEnabled(VBFlexGridComboButtonHandle) = 0 Then EnableWindow VBFlexGridComboButtonHandle, 1
            If VBFlexGridComboListHandle <> NULL_PTR Or VBFlexGridComboCalendarHandle <> NULL_PTR Then
                Call ComboShowDropDown(True, FlexComboDropDownReasonCode)
            Else
                Call ComboButtonPerformClick
            End If
        Case FlexComboButtonValueDisabled
            If VBFlexGridComboListHandle <> NULL_PTR Or VBFlexGridComboCalendarHandle <> NULL_PTR Then
                Call ComboShowDropDown(False, FlexComboDropDownReasonCode)
            Else
                Call ComboButtonSetState(ODS_SELECTED, False)
            End If
            EnableWindow VBFlexGridComboButtonHandle, 0
    End Select
Else
    Err.Raise 5
End If
End Property

Public Property Get ComboButtonPicture() As IPictureDisp
Attribute ComboButtonPicture.VB_Description = "Returns/sets the combo button picture. Only applicable if the combo button draw mode property is set to normal and the combo mode property is set to button."
Attribute ComboButtonPicture.VB_MemberFlags = "400"
Set ComboButtonPicture = VBFlexGridComboButtonPicture
End Property

Public Property Let ComboButtonPicture(ByVal Value As IPictureDisp)
Set Me.ComboButtonPicture = Value
End Property

Public Property Set ComboButtonPicture(ByVal Value As IPictureDisp)
If Value Is Nothing Then
    Set VBFlexGridComboButtonPicture = Nothing
Else
    Set UserControl.Picture = Value
    Set VBFlexGridComboButtonPicture = UserControl.Picture
    Set UserControl.Picture = Nothing
End If
VBFlexGridComboButtonPictureRenderFlag = 0
If VBFlexGridComboButtonHandle <> NULL_PTR Then InvalidateRect VBFlexGridComboButtonHandle, ByVal NULL_PTR, 0
Call RedrawGrid
End Property

Public Property Get ComboButtonAlignment() As FlexLeftRightAlignmentConstants
Attribute ComboButtonAlignment.VB_Description = "Returns/sets the combo button alignment. This may be useful for right-to-left reading-order properties."
Attribute ComboButtonAlignment.VB_MemberFlags = "400"
ComboButtonAlignment = VBFlexGridComboButtonAlignment
End Property

Public Property Let ComboButtonAlignment(ByVal Value As FlexLeftRightAlignmentConstants)
Select Case Value
    Case FlexLeftRightAlignmentLeft, FlexLeftRightAlignmentRight
        VBFlexGridComboButtonAlignment = Value
    Case Else
        Err.Raise 380
End Select
End Property

Public Property Get ComboButtonDrawMode() As FlexComboButtonDrawModeConstants
Attribute ComboButtonDrawMode.VB_Description = "Returns/sets a value indicating whether your code or the flex grid will handle drawing of the combo button."
Attribute ComboButtonDrawMode.VB_MemberFlags = "400"
ComboButtonDrawMode = VBFlexGridComboButtonDrawMode
End Property

Public Property Let ComboButtonDrawMode(ByVal Value As FlexComboButtonDrawModeConstants)
Select Case Value
    Case FlexComboButtonDrawModeNormal, FlexComboButtonDrawModeOwnerDraw
        VBFlexGridComboButtonDrawMode = Value
    Case Else
        Err.Raise 380
End Select
End Property

Public Property Get ComboButtonWidth() As Long
Attribute ComboButtonWidth.VB_Description = "Returns/sets the combo button width in twips. Only applicable if the combo mode property is set to button."
Attribute ComboButtonWidth.VB_MemberFlags = "400"
If VBFlexGridComboButtonWidth = -1 Then
    ComboButtonWidth = UserControl.ScaleX(VBFlexGridPixelMetrics.ScrollBarSize, vbPixels, vbTwips)
Else
    ComboButtonWidth = UserControl.ScaleX(VBFlexGridComboButtonWidth, vbPixels, vbTwips)
End If
End Property

Public Property Let ComboButtonWidth(ByVal Value As Long)
If Value < -1 Then Err.Raise 380
If Value > -1 Then
    VBFlexGridComboButtonWidth = UserControl.ScaleX(Value, vbTwips, vbPixels)
Else
    VBFlexGridComboButtonWidth = -1
End If
End Property

Public Property Get ComboButtonClientWidth() As Long
Attribute ComboButtonClientWidth.VB_Description = "Returns the combo button client width in twips. Only applicable if the combo mode property is set to button."
Attribute ComboButtonClientWidth.VB_MemberFlags = "400"
If VBFlexGridHandle <> NULL_PTR Then
    Dim RC As RECT, Theme As LongPtr
    If VBFlexGridComboButtonWidth = -1 Then
        RC.Right = VBFlexGridPixelMetrics.ScrollBarSize
    Else
        RC.Right = VBFlexGridComboButtonWidth
    End If
    
    #If ImplementThemedControls = True Then
    
    If VBFlexGridEnabledVisualStyles = True And PropVisualStyles = True Then Theme = OpenThemeData(VBFlexGridHandle, StrPtr("Button"))
    If Theme <> NULL_PTR Then
        GetThemeBackgroundContentRect Theme, NULL_PTR, BP_PUSHBUTTON, PBS_NORMAL, RC, RC
        CloseThemeData Theme
    End If
    
    #End If
    
    If Theme = NULL_PTR Then DrawFrameControl NULL_PTR, RC, DFC_BUTTON, DFCS_BUTTONPUSH Or DFCS_ADJUSTRECT
    ComboButtonClientWidth = UserControl.ScaleX((RC.Right - RC.Left), vbPixels, vbTwips)
End If
End Property

Public Property Get ComboButtonNonClientWidth() As Long
Attribute ComboButtonNonClientWidth.VB_Description = "Returns the combo button non-client width in twips. Only applicable if the combo mode property is set to button."
Attribute ComboButtonNonClientWidth.VB_MemberFlags = "400"
If VBFlexGridHandle <> NULL_PTR Then
    Dim RC As RECT, Theme As LongPtr
    
    #If ImplementThemedControls = True Then
    
    If VBFlexGridEnabledVisualStyles = True And PropVisualStyles = True Then Theme = OpenThemeData(VBFlexGridHandle, StrPtr("Button"))
    If Theme <> NULL_PTR Then
        GetThemeBackgroundContentRect Theme, NULL_PTR, BP_PUSHBUTTON, PBS_NORMAL, RC, RC
        CloseThemeData Theme
    End If
    
    #End If
    
    If Theme = NULL_PTR Then DrawFrameControl NULL_PTR, RC, DFC_BUTTON, DFCS_BUTTONPUSH Or DFCS_ADJUSTRECT
    ComboButtonNonClientWidth = UserControl.ScaleX(0 - (RC.Right - RC.Left), vbPixels, vbTwips)
End If
End Property

Public Property Get ComboButtonNonClientHeight() As Long
Attribute ComboButtonNonClientHeight.VB_Description = "Returns the combo button non-client height in twips. Only applicable if the combo mode property is set to button."
Attribute ComboButtonNonClientHeight.VB_MemberFlags = "400"
If VBFlexGridHandle <> NULL_PTR Then
    Dim RC As RECT, Theme As LongPtr
    
    #If ImplementThemedControls = True Then
    
    If VBFlexGridEnabledVisualStyles = True And PropVisualStyles = True Then Theme = OpenThemeData(VBFlexGridHandle, StrPtr("Button"))
    If Theme <> NULL_PTR Then
        GetThemeBackgroundContentRect Theme, NULL_PTR, BP_PUSHBUTTON, PBS_NORMAL, RC, RC
        CloseThemeData Theme
    End If
    
    #End If
    
    If Theme = NULL_PTR Then DrawFrameControl NULL_PTR, RC, DFC_BUTTON, DFCS_BUTTONPUSH Or DFCS_ADJUSTRECT
    ComboButtonNonClientHeight = UserControl.ScaleX(0 - (RC.Bottom - RC.Top), vbPixels, vbTwips)
End If
End Property

Public Property Get ComboItems() As String
Attribute ComboItems.VB_Description = "Returns/sets the items to be used for the drop-down list when editing a cell. To define a multi-column list, seperate columns with tab characters."
Attribute ComboItems.VB_MemberFlags = "400"
ComboItems = VBFlexGridComboItems
End Property

Public Property Let ComboItems(ByVal Value As String)
VBFlexGridComboItems = Value
End Property

Public Property Get ComboHeader() As String
Attribute ComboHeader.VB_Description = "Returns/sets the header to be used for the multi-column drop-down list when editing a cell."
Attribute ComboHeader.VB_MemberFlags = "400"
ComboHeader = VBFlexGridComboHeader
End Property

Public Property Let ComboHeader(ByVal Value As String)
VBFlexGridComboHeader = Value
End Property

Public Property Get ComboBoundColumn() As Long
Attribute ComboBoundColumn.VB_Description = "Returns/sets the bound column to be used for the multi-column drop-down list when editing a cell."
Attribute ComboBoundColumn.VB_MemberFlags = "400"
ComboBoundColumn = VBFlexGridComboBoundColumn
End Property

Public Property Let ComboBoundColumn(ByVal Value As Long)
If Value < 0 Then Err.Raise 380
VBFlexGridComboBoundColumn = Value
End Property

Public Property Get ComboList(ByVal Index As Long) As String
Attribute ComboList.VB_Description = "Returns the items contained in a drop-down list."
Attribute ComboList.VB_MemberFlags = "400"
If VBFlexGridComboListHandle <> NULL_PTR Then
    Dim Length As Long
    Length = CLng(SendMessage(VBFlexGridComboListHandle, LB_GETTEXTLEN, Index, ByVal 0&))
    If Not Length = LB_ERR Then
        ComboList = String(Length, vbNullChar)
        SendMessage VBFlexGridComboListHandle, LB_GETTEXT, Index, ByVal StrPtr(ComboList)
    Else
        Err.Raise 5
    End If
Else
    Err.Raise 5
End If
End Property

Public Property Get ComboListCount() As Long
Attribute ComboListCount.VB_Description = "Returns the number of items in the drop-down list."
Attribute ComboListCount.VB_MemberFlags = "400"
If VBFlexGridComboListHandle <> NULL_PTR Then
    ComboListCount = CLng(SendMessage(VBFlexGridComboListHandle, LB_GETCOUNT, 0, ByVal 0&))
Else
    Err.Raise 5
End If
End Property

Public Property Get ComboListIndex() As Long
Attribute ComboListIndex.VB_Description = "Returns/sets the index of the currently selected item in the drop-down list."
Attribute ComboListIndex.VB_MemberFlags = "400"
If VBFlexGridComboListHandle <> NULL_PTR Then
    ComboListIndex = CLng(SendMessage(VBFlexGridComboListHandle, LB_GETCURSEL, 0, ByVal 0&))
Else
    Err.Raise 5
End If
End Property

Public Property Let ComboListIndex(ByVal Value As Long)
If VBFlexGridComboListHandle <> NULL_PTR Then
    If Not Value = -1 Then
        If SendMessage(VBFlexGridComboListHandle, LB_SETCURSEL, Value, ByVal 0&) = LB_ERR Then Err.Raise 380
    Else
        SendMessage VBFlexGridComboListHandle, LB_SETCURSEL, -1, ByVal 0&
    End If
    Call ComboListCommitSel
Else
    Err.Raise 5
End If
End Property

Public Property Get ComboCalendarMinDate() As Date
Attribute ComboCalendarMinDate.VB_Description = "Returns/sets the earliest date that can be displayed or accepted by the drop-down calendar."
Attribute ComboCalendarMinDate.VB_MemberFlags = "400"
If VBFlexGridComboCalendarHandle <> NULL_PTR Then
    Dim ST(0 To 1) As SYSTEMTIME
    If (SendMessage(VBFlexGridComboCalendarHandle, MCM_GETRANGE, 0, ByVal VarPtr(ST(0))) And GDTR_MIN) = GDTR_MIN Then
        ComboCalendarMinDate = DateSerial(ST(0).wYear, ST(0).wMonth, ST(0).wDay)
    Else
        ComboCalendarMinDate = #1/1/1900#
    End If
Else
    Err.Raise 5
End If
End Property

Public Property Let ComboCalendarMinDate(ByVal Value As Date)
Dim MaxDate As Date
MaxDate = Me.ComboCalendarMaxDate
Select Case Value
    Case #1/1/1900# To #12/31/9999 11:59:59 PM#
        If Fix(Value) > MaxDate Then Err.Raise 35775, Description:="A value was specified for the MinDate property that is higher than the current value of MaxDate"
    Case Else
        Err.Raise 380
End Select
If VBFlexGridComboCalendarHandle <> NULL_PTR Then
    Dim ST(0 To 1) As SYSTEMTIME
    ST(0).wYear = VBA.Year(Value)
    ST(0).wMonth = VBA.Month(Value)
    ST(0).wDay = VBA.Day(Value)
    ST(1).wYear = VBA.Year(MaxDate)
    ST(1).wMonth = VBA.Month(MaxDate)
    ST(1).wDay = VBA.Day(MaxDate)
    SendMessage VBFlexGridComboCalendarHandle, MCM_SETRANGE, GDTR_MIN Or GDTR_MAX, ByVal VarPtr(ST(0))
Else
    Err.Raise 5
End If
End Property

Public Property Get ComboCalendarMaxDate() As Date
Attribute ComboCalendarMaxDate.VB_Description = "Returns/sets the latest date that can be displayed or accepted by the drop-down calendar."
Attribute ComboCalendarMaxDate.VB_MemberFlags = "400"
If VBFlexGridComboCalendarHandle <> NULL_PTR Then
    Dim ST(0 To 1) As SYSTEMTIME
    If (SendMessage(VBFlexGridComboCalendarHandle, MCM_GETRANGE, 0, ByVal VarPtr(ST(0))) And GDTR_MAX) = GDTR_MAX Then
        ComboCalendarMaxDate = DateSerial(ST(1).wYear, ST(1).wMonth, ST(1).wDay)
    Else
        ComboCalendarMaxDate = #12/31/9999#
    End If
Else
    Err.Raise 5
End If
End Property

Public Property Let ComboCalendarMaxDate(ByVal Value As Date)
Dim MinDate As Date
MinDate = Me.ComboCalendarMinDate
Select Case Value
    Case #1/1/1900# To #12/31/9999 11:59:59 PM#
        If Fix(Value) < MinDate Then Err.Raise 35774, Description:="A value was specified for the MaxDate property that is lower than the current value of MinDate"
    Case Else
        Err.Raise 380
End Select
If VBFlexGridComboCalendarHandle <> NULL_PTR Then
    Dim ST(0 To 1) As SYSTEMTIME
    ST(0).wYear = VBA.Year(MinDate)
    ST(0).wMonth = VBA.Month(MinDate)
    ST(0).wDay = VBA.Day(MinDate)
    ST(1).wYear = VBA.Year(Value)
    ST(1).wMonth = VBA.Month(Value)
    ST(1).wDay = VBA.Day(Value)
    SendMessage VBFlexGridComboCalendarHandle, MCM_SETRANGE, GDTR_MIN Or GDTR_MAX, ByVal VarPtr(ST(0))
Else
    Err.Raise 5
End If
End Property

Public Property Get ComboCalendarValue() As Date
Attribute ComboCalendarValue.VB_Description = "Returns/sets the current date of the drop-down calendar."
Attribute ComboCalendarValue.VB_MemberFlags = "400"
If VBFlexGridComboCalendarHandle <> NULL_PTR Then
    Dim ST As SYSTEMTIME
    SendMessage VBFlexGridComboCalendarHandle, MCM_GETCURSEL, 0, ByVal VarPtr(ST)
    ComboCalendarValue = DateSerial(ST.wYear, ST.wMonth, ST.wDay)
Else
    Err.Raise 5
End If
End Property

Public Property Let ComboCalendarValue(ByVal Value As Date)
If VBFlexGridComboCalendarHandle <> NULL_PTR Then
    Dim ST As SYSTEMTIME
    With ST
    .wYear = VBA.Year(Value)
    .wMonth = VBA.Month(Value)
    .wDay = VBA.Day(Value)
    .wDayOfWeek = VBA.Weekday(Value)
    .wHour = 0
    .wMinute = 0
    .wSecond = 0
    .wMilliseconds = 0
    End With
    SendMessage VBFlexGridComboCalendarHandle, MCM_SETCURSEL, 0, ByVal VarPtr(ST)
Else
    Err.Raise 5
End If
End Property

Public Property Get CheckBoxDrawMode() As FlexCheckBoxDrawModeConstants
Attribute CheckBoxDrawMode.VB_Description = "Returns/sets a value indicating whether your code or the flex grid will handle drawing of the check box."
Attribute CheckBoxDrawMode.VB_MemberFlags = "400"
CheckBoxDrawMode = VBFlexGridCheckBoxDrawMode
End Property

Public Property Let CheckBoxDrawMode(ByVal Value As FlexCheckBoxDrawModeConstants)
Select Case Value
    Case FlexCheckBoxDrawModeNormal, FlexCheckBoxDrawModeOwnerDraw
        VBFlexGridCheckBoxDrawMode = Value
    Case Else
        Err.Raise 380
End Select
End Property

Public Property Get IncrementalSearchString() As String
Attribute IncrementalSearchString.VB_Description = "Returns the incremental search string, or an empty string if the flex grid is not in incremental search mode."
Attribute IncrementalSearchString.VB_MemberFlags = "400"
IncrementalSearchString = VBFlexGridIncrementalSearch.SearchString
End Property

Public Property Get IncrementalSearchRow() As Long
Attribute IncrementalSearchRow.VB_Description = "Returns the row where the incremental search highlight is displayed."
Attribute IncrementalSearchRow.VB_MemberFlags = "400"
IncrementalSearchRow = VBFlexGridIncrementalSearch.Row
End Property

Public Property Get IncrementalSearchCol() As Long
Attribute IncrementalSearchCol.VB_Description = "Returns the column where the incremental search highlight is displayed."
Attribute IncrementalSearchCol.VB_MemberFlags = "400"
IncrementalSearchCol = VBFlexGridIncrementalSearch.Col
End Property

Public Property Get IncrementalSearchTime() As Long
Attribute IncrementalSearchTime.VB_Description = "Returns/sets the incremental search time in milliseconds."
Attribute IncrementalSearchTime.VB_MemberFlags = "400"
IncrementalSearchTime = GetIncrementalSearchTime()
End Property

Public Property Let IncrementalSearchTime(ByVal Value As Long)
If (Value < 0 Or Value > 65535) And Not Value = -1 Then Err.Raise 380
VBFlexGridIncrementalSearch.Time = Value
End Property

Public Property Get Version() As Integer
Attribute Version.VB_Description = "Returns the version of the flex grid control currently loaded in memory."
Attribute Version.VB_MemberFlags = "400"
Version = 600
End Property

Private Sub InitFlexGridCells()
If VBFlexGridCellsInit = True Then Exit Sub
If PropRows < 1 Or PropCols < 1 Then
    VBFlexGridRow = -1
    VBFlexGridCol = -1
    VBFlexGridRowSel = -1
    VBFlexGridColSel = -1
    VBFlexGridTopRow = -1
    VBFlexGridLeftCol = -1
    VBFlexGridDropHighlight = -1
    VBFlexGridInsertMark = -1
    VBFlexGridInsertMarkAfter = False
    VBFlexGridCellClickRow = -1
    VBFlexGridCellClickCol = -1
    VBFlexGridComboCueRow = -1
    VBFlexGridComboCueCol = -1
    VBFlexGridComboCueClickRow = -1
    VBFlexGridComboCueClickCol = -1
    VBFlexGridExtendLastCol = -1
    VBFlexGridHotRow = -1
    VBFlexGridHotCol = -1
    VBFlexGridHotHitResult = FlexHitResultNoWhere
    Exit Sub
End If
Dim i As Long, j As Long
ReDim VBFlexGridCells.Rows(0 To (PropRows - 1)) As TCOLS: VBFlexGridCellsInit = True
ReDim VBFlexGridColsInfo(0 To (PropCols - 1)) As TCOLINFO
For i = 0 To (PropRows - 1)
    With VBFlexGridCells.Rows(i)
    ReDim .Cols(0 To (PropCols - 1)) As TCELL
    For j = 0 To (PropCols - 1)
        LSet .Cols(j) = VBFlexGridDefaultCell
    Next j
    LSet .RowInfo = VBFlexGridDefaultRowInfo
    End With
Next i
For i = 0 To (PropCols - 1)
    LSet VBFlexGridColsInfo(i) = VBFlexGridDefaultColInfo
Next i
LSet VBFlexGridDefaultCols = VBFlexGridCells.Rows(0)
VBFlexGridRow = PropFixedRows
If VBFlexGridRow > (PropRows - 1) Then VBFlexGridRow = (PropRows - 1)
VBFlexGridCol = PropFixedCols
If VBFlexGridCol > (PropCols - 1) Then VBFlexGridCol = (PropCols - 1)
Select Case PropSelectionMode
    Case FlexSelectionModeFree, FlexSelectionModeFreeByRow, FlexSelectionModeFreeByColumn
        VBFlexGridRowSel = VBFlexGridRow
        VBFlexGridColSel = VBFlexGridCol
    Case FlexSelectionModeByRow
        VBFlexGridRowSel = VBFlexGridRow
        VBFlexGridColSel = (PropCols - 1)
    Case FlexSelectionModeByColumn
        VBFlexGridRowSel = (PropRows - 1)
        VBFlexGridColSel = VBFlexGridCol
End Select
If PropAllowMultiSelection = True Then
    Select Case PropSelectionMode
        Case FlexSelectionModeByRow, FlexSelectionModeFreeByRow
            Call AddSelectedRow
    End Select
End If
VBFlexGridTopRow = PropFixedRows + PropFrozenRows
VBFlexGridLeftCol = PropFixedCols + PropFrozenCols
VBFlexGridDropHighlight = -1
VBFlexGridInsertMark = -1
VBFlexGridInsertMarkAfter = False
VBFlexGridCellClickRow = -1
VBFlexGridCellClickCol = -1
VBFlexGridComboCueRow = -1
VBFlexGridComboCueCol = -1
VBFlexGridComboCueClickRow = -1
VBFlexGridComboCueClickCol = -1
VBFlexGridExtendLastCol = GetExtendLastCol()
VBFlexGridHotRow = -1
VBFlexGridHotCol = -1
VBFlexGridHotHitResult = FlexHitResultNoWhere
End Sub

Private Sub EraseFlexGridCells()
If VBFlexGridCellsInit = False Then Exit Sub
Dim i As Long, j As Long
For i = 0 To (PropRows - 1)
    With VBFlexGridCells.Rows(i)
    For j = 0 To (PropCols - 1)
        Call FreeCellFmtg(.Cols(j).lpFmtg)
        Call FreeCellTag(.Cols(j).lpTag)
    Next j
    End With
Next i
Erase VBFlexGridCells.Rows(): VBFlexGridCellsInit = False
Erase VBFlexGridColsInfo()
Erase VBFlexGridDefaultCols.Cols()
VBFlexGridRow = -1
VBFlexGridCol = -1
VBFlexGridRowSel = -1
VBFlexGridColSel = -1
If PropAllowMultiSelection = True Then
    VBFlexGridInvertSelection = False
    VBFlexGridExpandSelectedRows = False
    If VBFlexGridMultiSelChangeTimer = True Then
        If VBFlexGridHandle <> NULL_PTR Then KillTimer VBFlexGridHandle, IDT_MULTISELCHANGE
        VBFlexGridMultiSelChangeTimer = False
    End If
    If VBFlexGridSelectedRows > 0 Then
        Erase VBFlexGridSelectedRowIndices()
        VBFlexGridSelectedRows = 0
    End If
End If
VBFlexGridTopRow = -1
VBFlexGridLeftCol = -1
VBFlexGridDropHighlight = -1
VBFlexGridInsertMark = -1
VBFlexGridInsertMarkAfter = False
VBFlexGridCellClickRow = -1
VBFlexGridCellClickCol = -1
VBFlexGridComboCueRow = -1
VBFlexGridComboCueCol = -1
VBFlexGridComboCueClickRow = -1
VBFlexGridComboCueClickCol = -1
VBFlexGridExtendLastCol = -1
VBFlexGridHotRow = -1
VBFlexGridHotCol = -1
VBFlexGridHotHitResult = FlexHitResultNoWhere
End Sub

Private Sub RedrawGrid(Optional ByVal UpdateNow As Boolean)
If VBFlexGridHandle <> NULL_PTR And VBFlexGridNoRedraw = False Then
    If VBFlexGridDesignMode = False Then
        InvalidateRect VBFlexGridHandle, ByVal NULL_PTR, 1
        If UpdateNow = True Then UpdateWindow VBFlexGridHandle
    Else
        UserControl.Refresh
    End If
End If
End Sub

Private Sub DrawGrid(ByVal hDC As LongPtr, ByRef hRgn As LongPtr, ByVal NoRgn As Boolean, Optional ByVal NoClip As Boolean, Optional ByVal lpCellRange As LongPtr)
If VBFlexGridNoRedraw = True And hDC <> NULL_PTR Then
    If NoRgn = False Then hRgn = CreateRectRgn(0, 0, 0, 0)
    Exit Sub
ElseIf hDC = NULL_PTR Then
    Exit Sub
End If
If VBFlexGridHandle = NULL_PTR Or (PropRows < 1 Or PropCols < 1) Then Exit Sub
Dim iRow As Long, iCol As Long, FixedCX As Long, FixedCY As Long, FrozenCX As Long, FrozenCY As Long
Dim CellRange As TCELLRANGE, CellRect As RECT, GridRect As RECT
Dim OldBkMode As Long, hFontOld As LongPtr, Brush As LongPtr, hRgnOld As LongPtr
Call GetSelRangeStruct(VBFlexGridDrawInfo.SelRange)
VBFlexGridDrawInfo.Flags = 0
For iCol = 0 To (PropFixedCols - 1)
    FixedCX = FixedCX + GetColWidth(iCol)
Next iCol
For iRow = 0 To (PropFixedRows - 1)
    FixedCY = FixedCY + GetRowHeight(iRow)
Next iRow
For iCol = PropFixedCols To ((PropFixedCols + PropFrozenCols) - 1)
    FrozenCX = FrozenCX + GetColWidth(iCol)
Next iCol
For iRow = PropFixedRows To ((PropFixedRows + PropFrozenRows) - 1)
    FrozenCY = FrozenCY + GetRowHeight(iRow)
Next iRow
If lpCellRange = NULL_PTR Then
    With CellRange
    .LeftCol = VBFlexGridLeftCol
    .TopRow = VBFlexGridTopRow
    .RightCol = PropCols - 1
    .BottomRow = PropRows - 1
    End With
Else
    CopyMemory ByVal VarPtr(CellRange), ByVal lpCellRange, LenB(CellRange)
    With CellRange
    If .LeftCol < (PropFixedCols + PropFrozenCols) Then .LeftCol = PropFixedCols + PropFrozenCols
    If .TopRow < (PropFixedRows + PropFrozenRows) Then .TopRow = PropFixedRows + PropFrozenRows
    If .RightCol > (PropCols - 1) Then .RightCol = (PropCols - 1)
    If .BottomRow > (PropRows - 1) Then .BottomRow = (PropRows - 1)
    End With
End If
OldBkMode = SetBkMode(hDC, 1)
If Not PropWallPaper Is Nothing Then
    If PropWallPaper.Handle <> NULL_PTR Then
        Dim WallPaperBackgroundRect As RECT, WallPaperNoClipRect As RECT
        With WallPaperBackgroundRect
        .Left = 0
        .Top = 0
        .Right = FixedCX
        For iCol = CellRange.LeftCol To CellRange.RightCol
            .Right = .Right + GetColWidth(iCol)
        Next iCol
        .Bottom = FixedCY
        For iRow = CellRange.TopRow To CellRange.BottomRow
            .Bottom = .Bottom + GetRowHeight(iRow)
        Next iRow
        SetRect WallPaperNoClipRect, FixedCX, FixedCY, .Right, .Bottom
        If .Right < VBFlexGridClientRect.Right Then .Right = VBFlexGridClientRect.Right
        If .Bottom < VBFlexGridClientRect.Bottom Then .Bottom = VBFlexGridClientRect.Bottom
        End With
        FillRect hDC, WallPaperBackgroundRect, VBFlexGridBackColorBrush
        Dim WallPaperRect As RECT, WallPaperWidth As Long, WallPaperHeight As Long
        Dim WallPaperLeft As Long, WallPaperTop As Long, WallPaperOffsetX As Long, WallPaperOffsetY As Long
        If NoClip = False Then
            SetRect WallPaperRect, FixedCX, FixedCY, VBFlexGridClientRect.Right, VBFlexGridClientRect.Bottom
        Else
            LSet WallPaperRect = WallPaperNoClipRect
        End If
        If PropWallPaperAlignment <> FlexWallPaperAlignmentStretch Then
            WallPaperWidth = CHimetricToPixel_X(PropWallPaper.Width)
            WallPaperHeight = CHimetricToPixel_Y(PropWallPaper.Height)
        Else
            WallPaperWidth = (WallPaperRect.Right - WallPaperRect.Left)
            WallPaperHeight = (WallPaperRect.Bottom - WallPaperRect.Top)
        End If
        WallPaperLeft = WallPaperRect.Left
        WallPaperTop = WallPaperRect.Top
        Select Case PropWallPaperAlignment
            Case FlexWallPaperAlignmentLeftCenter
                WallPaperOffsetY = (((WallPaperRect.Bottom - WallPaperRect.Top) - WallPaperHeight) \ 2)
            Case FlexWallPaperAlignmentLeftBottom
                WallPaperOffsetY = ((WallPaperRect.Bottom - WallPaperRect.Top) - WallPaperHeight)
            Case FlexWallPaperAlignmentCenterTop
                WallPaperOffsetX = (((WallPaperRect.Right - WallPaperRect.Left) - WallPaperWidth) \ 2)
            Case FlexWallPaperAlignmentCenterCenter
                WallPaperOffsetX = (((WallPaperRect.Right - WallPaperRect.Left) - WallPaperWidth) \ 2)
                WallPaperOffsetY = (((WallPaperRect.Bottom - WallPaperRect.Top) - WallPaperHeight) \ 2)
            Case FlexWallPaperAlignmentCenterBottom
                WallPaperOffsetX = (((WallPaperRect.Right - WallPaperRect.Left) - WallPaperWidth) \ 2)
                WallPaperOffsetY = ((WallPaperRect.Bottom - WallPaperRect.Top) - WallPaperHeight)
            Case FlexWallPaperAlignmentRightTop
                WallPaperOffsetX = ((WallPaperRect.Right - WallPaperRect.Left) - WallPaperWidth)
            Case FlexWallPaperAlignmentRightCenter
                WallPaperOffsetX = ((WallPaperRect.Right - WallPaperRect.Left) - WallPaperWidth)
                WallPaperOffsetY = (((WallPaperRect.Bottom - WallPaperRect.Top) - WallPaperHeight) \ 2)
            Case FlexWallPaperAlignmentRightBottom
                WallPaperOffsetX = ((WallPaperRect.Right - WallPaperRect.Left) - WallPaperWidth)
                WallPaperOffsetY = ((WallPaperRect.Bottom - WallPaperRect.Top) - WallPaperHeight)
        End Select
        If WallPaperOffsetX > 0 Then WallPaperLeft = WallPaperLeft + WallPaperOffsetX
        If WallPaperOffsetY > 0 Then WallPaperTop = WallPaperTop + WallPaperOffsetY
        hRgnOld = CreateRectRgn(0, 0, 0, 0)
        If hRgnOld <> NULL_PTR Then
            If GetClipRgn(hDC, hRgnOld) = 0 Then
                DeleteObject hRgnOld
                hRgnOld = NULL_PTR
            End If
        End If
        IntersectClipRect hDC, WallPaperRect.Left, WallPaperRect.Top, WallPaperRect.Right, WallPaperRect.Bottom
        If PropWallPaperAlignment <> FlexWallPaperAlignmentTile Then
            Call RenderPicture(PropWallPaper, hDC, WallPaperLeft, WallPaperTop, WallPaperWidth, WallPaperHeight, VBFlexGridWallPaperRenderFlag)
        Else
            Do
                Do
                    Call RenderPicture(PropWallPaper, hDC, WallPaperLeft, WallPaperTop, WallPaperWidth, WallPaperHeight, VBFlexGridWallPaperRenderFlag)
                    WallPaperTop = WallPaperTop + WallPaperHeight
                Loop While WallPaperTop < WallPaperRect.Bottom
                WallPaperLeft = WallPaperLeft + WallPaperWidth
                WallPaperTop = WallPaperRect.Top
            Loop While WallPaperLeft < WallPaperRect.Right
        End If
        If hRgnOld <> NULL_PTR Then
            ExtSelectClipRgn hDC, hRgnOld, RGN_COPY
            DeleteObject hRgnOld
            hRgnOld = NULL_PTR
        Else
            ExtSelectClipRgn hDC, NULL_PTR, RGN_COPY
        End If
        VBFlexGridDrawInfo.Flags = VBFlexGridDrawInfo.Flags Or DRAWINFO_FLAG_WALLPAPER
    End If
End If
With CellRect
If PropMergeCells = FlexMergeCellsNever Then
    If VBFlexGridFontFixedHandle = NULL_PTR Then
        hFontOld = SelectObject(hDC, VBFlexGridFontHandle)
    Else
        hFontOld = SelectObject(hDC, VBFlexGridFontFixedHandle)
    End If
    Brush = SelectObject(hDC, VBFlexGridBackColorFixedBrush)
    For iRow = 0 To (PropFixedRows - 1)
        .Bottom = .Top + GetRowHeight(iRow)
        If .Bottom > .Top Then
            VBFlexGridDrawInfo.GridLinePoints(0).Y = .Bottom - 1
            VBFlexGridDrawInfo.GridLinePoints(1).Y = .Bottom - 1
            VBFlexGridDrawInfo.GridLinePoints(2).Y = .Top - 1
            VBFlexGridDrawInfo.GridLinePoints(3).Y = .Top
            VBFlexGridDrawInfo.GridLinePoints(4).Y = .Top
            VBFlexGridDrawInfo.GridLinePoints(5).Y = .Bottom
            If PropFrozenCols > 0 Then
                .Left = FixedCX
                For iCol = PropFixedCols To ((PropFixedCols + PropFrozenCols) - 1)
                    .Right = .Left + GetColWidth(iCol)
                    If .Right > .Left Then
                        VBFlexGridDrawInfo.GridLinePoints(0).X = .Left
                        VBFlexGridDrawInfo.GridLinePoints(1).X = .Right - 1
                        VBFlexGridDrawInfo.GridLinePoints(2).X = .Right - 1
                        VBFlexGridDrawInfo.GridLinePoints(3).X = .Right - 2
                        VBFlexGridDrawInfo.GridLinePoints(4).X = .Left
                        VBFlexGridDrawInfo.GridLinePoints(5).X = .Left
                        Call DrawFixedCell(hDC, CellRect, iRow, iCol)
                    End If
                    .Left = .Right
                    If NoClip = False And .Right > VBFlexGridClientRect.Right Then Exit For
                Next iCol
            End If
            .Left = FixedCX + FrozenCX
            For iCol = CellRange.LeftCol To CellRange.RightCol
                .Right = .Left + GetColWidth(iCol)
                If .Right > .Left Then
                    VBFlexGridDrawInfo.GridLinePoints(0).X = .Left
                    VBFlexGridDrawInfo.GridLinePoints(1).X = .Right - 1
                    VBFlexGridDrawInfo.GridLinePoints(2).X = .Right - 1
                    VBFlexGridDrawInfo.GridLinePoints(3).X = .Right - 2
                    VBFlexGridDrawInfo.GridLinePoints(4).X = .Left
                    VBFlexGridDrawInfo.GridLinePoints(5).X = .Left
                    Call DrawFixedCell(hDC, CellRect, iRow, iCol)
                End If
                .Left = .Right
                If NoClip = False And .Right > VBFlexGridClientRect.Right Then Exit For
            Next iCol
            If .Right > GridRect.Right Then GridRect.Right = .Right
        End If
        .Top = .Bottom
        If NoClip = False And .Bottom > VBFlexGridClientRect.Bottom Then Exit For
    Next iRow
    If .Bottom > GridRect.Bottom Then GridRect.Bottom = .Bottom
    If PropFixedRows > 0 And PropFixedCols > 0 Then
        .Top = 0
        For iRow = 0 To (PropFixedRows - 1)
            .Bottom = .Top + GetRowHeight(iRow)
            If .Bottom > .Top Then
                VBFlexGridDrawInfo.GridLinePoints(0).Y = .Bottom - 1
                VBFlexGridDrawInfo.GridLinePoints(1).Y = .Bottom - 1
                VBFlexGridDrawInfo.GridLinePoints(2).Y = .Top - 1
                VBFlexGridDrawInfo.GridLinePoints(3).Y = .Top
                VBFlexGridDrawInfo.GridLinePoints(4).Y = .Top
                VBFlexGridDrawInfo.GridLinePoints(5).Y = .Bottom
                .Left = 0
                For iCol = 0 To (PropFixedCols - 1)
                    .Right = .Left + GetColWidth(iCol)
                    If .Right > .Left Then
                        VBFlexGridDrawInfo.GridLinePoints(0).X = .Left
                        VBFlexGridDrawInfo.GridLinePoints(1).X = .Right - 1
                        VBFlexGridDrawInfo.GridLinePoints(2).X = .Right - 1
                        VBFlexGridDrawInfo.GridLinePoints(3).X = .Right - 2
                        VBFlexGridDrawInfo.GridLinePoints(4).X = .Left
                        VBFlexGridDrawInfo.GridLinePoints(5).X = .Left
                        Call DrawFixedCell(hDC, CellRect, iRow, iCol)
                    End If
                    .Left = .Right
                    If NoClip = False And .Right > VBFlexGridClientRect.Right Then Exit For
                Next iCol
            End If
            .Top = .Bottom
            If NoClip = False And .Bottom > VBFlexGridClientRect.Bottom Then Exit For
        Next iRow
    End If
    If PropFixedCols > 0 Then
        .Top = FixedCY
        If PropFrozenRows > 0 Then
            For iRow = PropFixedRows To ((PropFixedRows + PropFrozenRows) - 1)
                .Bottom = .Top + GetRowHeight(iRow)
                If .Bottom > .Top Then
                    VBFlexGridDrawInfo.GridLinePoints(0).Y = .Bottom - 1
                    VBFlexGridDrawInfo.GridLinePoints(1).Y = .Bottom - 1
                    VBFlexGridDrawInfo.GridLinePoints(2).Y = .Top - 1
                    VBFlexGridDrawInfo.GridLinePoints(3).Y = .Top
                    VBFlexGridDrawInfo.GridLinePoints(4).Y = .Top
                    VBFlexGridDrawInfo.GridLinePoints(5).Y = .Bottom
                    .Left = 0
                    For iCol = 0 To (PropFixedCols - 1)
                        .Right = .Left + GetColWidth(iCol)
                        If .Right > .Left Then
                            VBFlexGridDrawInfo.GridLinePoints(0).X = .Left
                            VBFlexGridDrawInfo.GridLinePoints(1).X = .Right - 1
                            VBFlexGridDrawInfo.GridLinePoints(2).X = .Right - 1
                            VBFlexGridDrawInfo.GridLinePoints(3).X = .Right - 2
                            VBFlexGridDrawInfo.GridLinePoints(4).X = .Left
                            VBFlexGridDrawInfo.GridLinePoints(5).X = .Left
                            Call DrawFixedCell(hDC, CellRect, iRow, iCol)
                        End If
                        .Left = .Right
                        If NoClip = False And .Right > VBFlexGridClientRect.Right Then Exit For
                    Next iCol
                End If
                .Top = .Bottom
                If NoClip = False And .Bottom > VBFlexGridClientRect.Bottom Then Exit For
            Next iRow
        End If
        .Top = FixedCY + FrozenCY
        For iRow = CellRange.TopRow To CellRange.BottomRow
            .Bottom = .Top + GetRowHeight(iRow)
            If .Bottom > .Top Then
                VBFlexGridDrawInfo.GridLinePoints(0).Y = .Bottom - 1
                VBFlexGridDrawInfo.GridLinePoints(1).Y = .Bottom - 1
                VBFlexGridDrawInfo.GridLinePoints(2).Y = .Top - 1
                VBFlexGridDrawInfo.GridLinePoints(3).Y = .Top
                VBFlexGridDrawInfo.GridLinePoints(4).Y = .Top
                VBFlexGridDrawInfo.GridLinePoints(5).Y = .Bottom
                .Left = 0
                For iCol = 0 To (PropFixedCols - 1)
                    .Right = .Left + GetColWidth(iCol)
                    If .Right > .Left Then
                        VBFlexGridDrawInfo.GridLinePoints(0).X = .Left
                        VBFlexGridDrawInfo.GridLinePoints(1).X = .Right - 1
                        VBFlexGridDrawInfo.GridLinePoints(2).X = .Right - 1
                        VBFlexGridDrawInfo.GridLinePoints(3).X = .Right - 2
                        VBFlexGridDrawInfo.GridLinePoints(4).X = .Left
                        VBFlexGridDrawInfo.GridLinePoints(5).X = .Left
                        Call DrawFixedCell(hDC, CellRect, iRow, iCol)
                    End If
                    .Left = .Right
                    If NoClip = False And .Right > VBFlexGridClientRect.Right Then Exit For
                Next iCol
            End If
            .Top = .Bottom
            If NoClip = False And .Bottom > VBFlexGridClientRect.Bottom Then Exit For
        Next iRow
    End If
    If VBFlexGridFontFixedHandle <> NULL_PTR Then
        If hFontOld <> NULL_PTR Then
            SelectObject hDC, hFontOld
            hFontOld = NULL_PTR
        End If
        hFontOld = SelectObject(hDC, VBFlexGridFontHandle)
    End If
    SelectObject hDC, VBFlexGridBackColorBrush
    If PropFrozenRows > 0 Then
        .Top = FixedCY
        For iRow = PropFixedRows To ((PropFixedRows + PropFrozenRows) - 1)
            .Bottom = .Top + GetRowHeight(iRow)
            If .Bottom > .Top Then
                VBFlexGridDrawInfo.GridLinePoints(0).Y = .Bottom - 1
                VBFlexGridDrawInfo.GridLinePoints(1).Y = .Bottom - 1
                VBFlexGridDrawInfo.GridLinePoints(2).Y = .Top - 1
                VBFlexGridDrawInfo.GridLinePoints(3).Y = .Top
                VBFlexGridDrawInfo.GridLinePoints(4).Y = .Top
                VBFlexGridDrawInfo.GridLinePoints(5).Y = .Bottom
                If PropFrozenCols > 0 Then
                    .Left = FixedCX
                    For iCol = PropFixedCols To ((PropFixedCols + PropFrozenCols) - 1)
                        .Right = .Left + GetColWidth(iCol)
                        If .Right > .Left Then
                            VBFlexGridDrawInfo.GridLinePoints(0).X = .Left
                            VBFlexGridDrawInfo.GridLinePoints(1).X = .Right - 1
                            VBFlexGridDrawInfo.GridLinePoints(2).X = .Right - 1
                            VBFlexGridDrawInfo.GridLinePoints(3).X = .Right - 2
                            VBFlexGridDrawInfo.GridLinePoints(4).X = .Left
                            VBFlexGridDrawInfo.GridLinePoints(5).X = .Left
                            Call DrawCell(hDC, CellRect, iRow, iCol)
                        End If
                        .Left = .Right
                        If NoClip = False And .Right > VBFlexGridClientRect.Right Then Exit For
                    Next iCol
                End If
                .Left = FixedCX + FrozenCX
                For iCol = CellRange.LeftCol To CellRange.RightCol
                    .Right = .Left + GetColWidth(iCol)
                    If .Right > .Left Then
                        VBFlexGridDrawInfo.GridLinePoints(0).X = .Left
                        VBFlexGridDrawInfo.GridLinePoints(1).X = .Right - 1
                        VBFlexGridDrawInfo.GridLinePoints(2).X = .Right - 1
                        VBFlexGridDrawInfo.GridLinePoints(3).X = .Right - 2
                        VBFlexGridDrawInfo.GridLinePoints(4).X = .Left
                        VBFlexGridDrawInfo.GridLinePoints(5).X = .Left
                        Call DrawCell(hDC, CellRect, iRow, iCol)
                    End If
                    .Left = .Right
                    If NoClip = False And .Right > VBFlexGridClientRect.Right Then Exit For
                Next iCol
                If .Right > GridRect.Right Then GridRect.Right = .Right
            End If
            .Top = .Bottom
            If NoClip = False And .Bottom > VBFlexGridClientRect.Bottom Then Exit For
        Next iRow
    End If
    .Top = FixedCY + FrozenCY
    For iRow = CellRange.TopRow To CellRange.BottomRow
        .Bottom = .Top + GetRowHeight(iRow)
        If .Bottom > .Top Then
            VBFlexGridDrawInfo.GridLinePoints(0).Y = .Bottom - 1
            VBFlexGridDrawInfo.GridLinePoints(1).Y = .Bottom - 1
            VBFlexGridDrawInfo.GridLinePoints(2).Y = .Top - 1
            VBFlexGridDrawInfo.GridLinePoints(3).Y = .Top
            VBFlexGridDrawInfo.GridLinePoints(4).Y = .Top
            VBFlexGridDrawInfo.GridLinePoints(5).Y = .Bottom
            If PropFrozenCols > 0 Then
                .Left = FixedCX
                For iCol = PropFixedCols To ((PropFixedCols + PropFrozenCols) - 1)
                    .Right = .Left + GetColWidth(iCol)
                    If .Right > .Left Then
                        VBFlexGridDrawInfo.GridLinePoints(0).X = .Left
                        VBFlexGridDrawInfo.GridLinePoints(1).X = .Right - 1
                        VBFlexGridDrawInfo.GridLinePoints(2).X = .Right - 1
                        VBFlexGridDrawInfo.GridLinePoints(3).X = .Right - 2
                        VBFlexGridDrawInfo.GridLinePoints(4).X = .Left
                        VBFlexGridDrawInfo.GridLinePoints(5).X = .Left
                        Call DrawCell(hDC, CellRect, iRow, iCol)
                    End If
                    .Left = .Right
                    If NoClip = False And .Right > VBFlexGridClientRect.Right Then Exit For
                Next iCol
            End If
            .Left = FixedCX + FrozenCX
            For iCol = CellRange.LeftCol To CellRange.RightCol
                .Right = .Left + GetColWidth(iCol)
                If .Right > .Left Then
                    VBFlexGridDrawInfo.GridLinePoints(0).X = .Left
                    VBFlexGridDrawInfo.GridLinePoints(1).X = .Right - 1
                    VBFlexGridDrawInfo.GridLinePoints(2).X = .Right - 1
                    VBFlexGridDrawInfo.GridLinePoints(3).X = .Right - 2
                    VBFlexGridDrawInfo.GridLinePoints(4).X = .Left
                    VBFlexGridDrawInfo.GridLinePoints(5).X = .Left
                    Call DrawCell(hDC, CellRect, iRow, iCol)
                End If
                .Left = .Right
                If NoClip = False And .Right > VBFlexGridClientRect.Right Then Exit For
            Next iCol
            If .Right > GridRect.Right Then GridRect.Right = .Right
        End If
        .Top = .Bottom
        If NoClip = False And .Bottom > VBFlexGridClientRect.Bottom Then Exit For
    Next iRow
    If .Bottom > GridRect.Bottom Then GridRect.Bottom = .Bottom
    If hFontOld <> NULL_PTR Then
        SelectObject hDC, hFontOld
        hFontOld = NULL_PTR
    End If
    If Brush <> NULL_PTR Then
        SelectObject hDC, Brush
        Brush = NULL_PTR
    End If
Else
    If VBFlexGridFontFixedHandle = NULL_PTR Then
        hFontOld = SelectObject(hDC, VBFlexGridFontHandle)
    Else
        hFontOld = SelectObject(hDC, VBFlexGridFontFixedHandle)
    End If
    Brush = SelectObject(hDC, VBFlexGridBackColorFixedBrush)
    ReDim VBFlexGridMergeDrawInfo.Row.Cols(0 To (PropCols - 1)) As TMERGEDRAWCOLINFO
    For iRow = 0 To (PropFixedRows - 1)
        VBFlexGridMergeDrawInfo.Row.ColOffset = 0
        VBFlexGridMergeDrawInfo.Row.Width = 0
        .Bottom = .Top + GetRowHeight(iRow)
        If PropFrozenCols > 0 Then
            .Left = FixedCX
            For iCol = PropFixedCols To ((PropFixedCols + PropFrozenCols) - 1)
                .Right = .Left + GetColWidth(iCol)
                If (VBFlexGridCells.Rows(iRow).RowInfo.State And RWIS_MERGE) = RWIS_MERGE Then
                    If iCol > PropFixedCols Then
                        Select Case PropMergeCells
                            Case FlexMergeCellsFree, FlexMergeCellsRestrictRows, FlexMergeCellsFixedOnly
                                If MergeCompareFunction(iRow, iCol, iRow, iCol - 1) = True Then
                                    VBFlexGridMergeDrawInfo.Row.ColOffset = VBFlexGridMergeDrawInfo.Row.ColOffset + 1
                                    VBFlexGridMergeDrawInfo.Row.Width = VBFlexGridMergeDrawInfo.Row.Width + GetColWidth(iCol - 1)
                                Else
                                    VBFlexGridMergeDrawInfo.Row.ColOffset = 0
                                    VBFlexGridMergeDrawInfo.Row.Width = 0
                                End If
                            Case FlexMergeCellsRestrictColumns, FlexMergeCellsRestrictAll
                                If MergeCompareFunction(iRow, iCol, iRow, iCol - 1) = True Then
                                    If iRow > 0 Then
                                        If MergeCompareFunction(iRow - 1, iCol, iRow - 1, iCol - 1) = True Then
                                            VBFlexGridMergeDrawInfo.Row.ColOffset = VBFlexGridMergeDrawInfo.Row.ColOffset + 1
                                            VBFlexGridMergeDrawInfo.Row.Width = VBFlexGridMergeDrawInfo.Row.Width + GetColWidth(iCol - 1)
                                        Else
                                            VBFlexGridMergeDrawInfo.Row.ColOffset = 0
                                            VBFlexGridMergeDrawInfo.Row.Width = 0
                                        End If
                                    Else
                                        VBFlexGridMergeDrawInfo.Row.ColOffset = VBFlexGridMergeDrawInfo.Row.ColOffset + 1
                                        VBFlexGridMergeDrawInfo.Row.Width = VBFlexGridMergeDrawInfo.Row.Width + GetColWidth(iCol - 1)
                                    End If
                                Else
                                    VBFlexGridMergeDrawInfo.Row.ColOffset = 0
                                    VBFlexGridMergeDrawInfo.Row.Width = 0
                                End If
                        End Select
                    Else
                        VBFlexGridMergeDrawInfo.Row.ColOffset = 0
                        VBFlexGridMergeDrawInfo.Row.Width = 0
                    End If
                End If
                If (VBFlexGridColsInfo(iCol).State And CLIS_MERGE) = CLIS_MERGE Then
                    If iRow > 0 Then
                        Select Case PropMergeCells
                            Case FlexMergeCellsFree, FlexMergeCellsRestrictColumns, FlexMergeCellsFixedOnly
                                If MergeCompareFunction(iRow, iCol, iRow - 1, iCol) = True Then
                                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset + 1
                                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height + GetRowHeight(iRow - 1)
                                Else
                                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = 0
                                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = 0
                                End If
                            Case FlexMergeCellsRestrictRows, FlexMergeCellsRestrictAll
                                If MergeCompareFunction(iRow, iCol, iRow - 1, iCol) = True Then
                                    If iCol > PropFixedCols Then
                                        If MergeCompareFunction(iRow, iCol - 1, iRow - 1, iCol - 1) = True Then
                                            VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset + 1
                                            VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height + GetRowHeight(iRow - 1)
                                        Else
                                            VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = 0
                                            VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = 0
                                        End If
                                    Else
                                        VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset + 1
                                        VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height + GetRowHeight(iRow - 1)
                                    End If
                                Else
                                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = 0
                                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = 0
                                End If
                        End Select
                    Else
                        VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = 0
                        VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = 0
                    End If
                End If
                .Left = .Left - VBFlexGridMergeDrawInfo.Row.Width
                .Top = .Top - VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height
                If .Bottom > .Top And .Right > .Left Then
                    VBFlexGridDrawInfo.GridLinePoints(0).X = .Left
                    VBFlexGridDrawInfo.GridLinePoints(0).Y = .Bottom - 1
                    VBFlexGridDrawInfo.GridLinePoints(1).X = .Right - 1
                    VBFlexGridDrawInfo.GridLinePoints(1).Y = .Bottom - 1
                    VBFlexGridDrawInfo.GridLinePoints(2).X = .Right - 1
                    VBFlexGridDrawInfo.GridLinePoints(2).Y = .Top - 1
                    VBFlexGridDrawInfo.GridLinePoints(3).X = .Right - 2
                    VBFlexGridDrawInfo.GridLinePoints(3).Y = .Top
                    VBFlexGridDrawInfo.GridLinePoints(4).X = .Left
                    VBFlexGridDrawInfo.GridLinePoints(4).Y = .Top
                    VBFlexGridDrawInfo.GridLinePoints(5).X = .Left
                    VBFlexGridDrawInfo.GridLinePoints(5).Y = .Bottom
                    Call DrawFixedCell(hDC, CellRect, iRow, iCol)
                End If
                .Left = .Left + VBFlexGridMergeDrawInfo.Row.Width
                .Top = .Top + VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height
                .Left = .Right
                If NoClip = False And .Right > VBFlexGridClientRect.Right Then Exit For
            Next iCol
        End If
        .Left = FixedCX + FrozenCX
        For iCol = CellRange.LeftCol To CellRange.RightCol
            .Right = .Left + GetColWidth(iCol)
            If (VBFlexGridCells.Rows(iRow).RowInfo.State And RWIS_MERGE) = RWIS_MERGE Then
                If iCol > CellRange.LeftCol Then
                    Select Case PropMergeCells
                        Case FlexMergeCellsFree, FlexMergeCellsRestrictRows, FlexMergeCellsFixedOnly
                            If MergeCompareFunction(iRow, iCol, iRow, iCol - 1) = True Then
                                VBFlexGridMergeDrawInfo.Row.ColOffset = VBFlexGridMergeDrawInfo.Row.ColOffset + 1
                                VBFlexGridMergeDrawInfo.Row.Width = VBFlexGridMergeDrawInfo.Row.Width + GetColWidth(iCol - 1)
                            Else
                                VBFlexGridMergeDrawInfo.Row.ColOffset = 0
                                VBFlexGridMergeDrawInfo.Row.Width = 0
                            End If
                        Case FlexMergeCellsRestrictColumns, FlexMergeCellsRestrictAll
                            If MergeCompareFunction(iRow, iCol, iRow, iCol - 1) = True Then
                                If iRow > 0 Then
                                    If MergeCompareFunction(iRow - 1, iCol, iRow - 1, iCol - 1) = True Then
                                        VBFlexGridMergeDrawInfo.Row.ColOffset = VBFlexGridMergeDrawInfo.Row.ColOffset + 1
                                        VBFlexGridMergeDrawInfo.Row.Width = VBFlexGridMergeDrawInfo.Row.Width + GetColWidth(iCol - 1)
                                    Else
                                        VBFlexGridMergeDrawInfo.Row.ColOffset = 0
                                        VBFlexGridMergeDrawInfo.Row.Width = 0
                                    End If
                                Else
                                    VBFlexGridMergeDrawInfo.Row.ColOffset = VBFlexGridMergeDrawInfo.Row.ColOffset + 1
                                    VBFlexGridMergeDrawInfo.Row.Width = VBFlexGridMergeDrawInfo.Row.Width + GetColWidth(iCol - 1)
                                End If
                            Else
                                VBFlexGridMergeDrawInfo.Row.ColOffset = 0
                                VBFlexGridMergeDrawInfo.Row.Width = 0
                            End If
                    End Select
                Else
                    VBFlexGridMergeDrawInfo.Row.ColOffset = 0
                    VBFlexGridMergeDrawInfo.Row.Width = 0
                End If
            End If
            If (VBFlexGridColsInfo(iCol).State And CLIS_MERGE) = CLIS_MERGE Then
                If iRow > 0 Then
                    Select Case PropMergeCells
                        Case FlexMergeCellsFree, FlexMergeCellsRestrictColumns, FlexMergeCellsFixedOnly
                            If MergeCompareFunction(iRow, iCol, iRow - 1, iCol) = True Then
                                VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset + 1
                                VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height + GetRowHeight(iRow - 1)
                            Else
                                VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = 0
                                VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = 0
                            End If
                        Case FlexMergeCellsRestrictRows, FlexMergeCellsRestrictAll
                            If MergeCompareFunction(iRow, iCol, iRow - 1, iCol) = True Then
                                If iCol > CellRange.LeftCol Then
                                    If MergeCompareFunction(iRow, iCol - 1, iRow - 1, iCol - 1) = True Then
                                        VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset + 1
                                        VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height + GetRowHeight(iRow - 1)
                                    Else
                                        VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = 0
                                        VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = 0
                                    End If
                                Else
                                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset + 1
                                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height + GetRowHeight(iRow - 1)
                                End If
                            Else
                                VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = 0
                                VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = 0
                            End If
                    End Select
                Else
                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = 0
                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = 0
                End If
            End If
            .Left = .Left - VBFlexGridMergeDrawInfo.Row.Width
            .Top = .Top - VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height
            If .Bottom > .Top And .Right > .Left Then
                VBFlexGridDrawInfo.GridLinePoints(0).X = .Left
                VBFlexGridDrawInfo.GridLinePoints(0).Y = .Bottom - 1
                VBFlexGridDrawInfo.GridLinePoints(1).X = .Right - 1
                VBFlexGridDrawInfo.GridLinePoints(1).Y = .Bottom - 1
                VBFlexGridDrawInfo.GridLinePoints(2).X = .Right - 1
                VBFlexGridDrawInfo.GridLinePoints(2).Y = .Top - 1
                VBFlexGridDrawInfo.GridLinePoints(3).X = .Right - 2
                VBFlexGridDrawInfo.GridLinePoints(3).Y = .Top
                VBFlexGridDrawInfo.GridLinePoints(4).X = .Left
                VBFlexGridDrawInfo.GridLinePoints(4).Y = .Top
                VBFlexGridDrawInfo.GridLinePoints(5).X = .Left
                VBFlexGridDrawInfo.GridLinePoints(5).Y = .Bottom
                Call DrawFixedCell(hDC, CellRect, iRow, iCol)
            End If
            .Left = .Left + VBFlexGridMergeDrawInfo.Row.Width
            .Top = .Top + VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height
            .Left = .Right
            If NoClip = False And .Right > VBFlexGridClientRect.Right Then Exit For
        Next iCol
        If .Right > GridRect.Right Then GridRect.Right = .Right
        .Top = .Bottom
        If NoClip = False And .Bottom > VBFlexGridClientRect.Bottom Then Exit For
    Next iRow
    If .Bottom > GridRect.Bottom Then GridRect.Bottom = .Bottom
    If PropFixedRows > 0 And PropFixedCols > 0 Then
        ReDim VBFlexGridMergeDrawInfo.Row.Cols(0 To (PropFixedCols - 1)) As TMERGEDRAWCOLINFO
        .Top = 0
        For iRow = 0 To (PropFixedRows - 1)
            VBFlexGridMergeDrawInfo.Row.ColOffset = 0
            VBFlexGridMergeDrawInfo.Row.Width = 0
            .Bottom = .Top + GetRowHeight(iRow)
            .Left = 0
            For iCol = 0 To (PropFixedCols - 1)
                .Right = .Left + GetColWidth(iCol)
                If (VBFlexGridCells.Rows(iRow).RowInfo.State And RWIS_MERGE) = RWIS_MERGE Then
                    If iCol > 0 Then
                        Select Case PropMergeCells
                            Case FlexMergeCellsFree, FlexMergeCellsRestrictRows, FlexMergeCellsFixedOnly
                                If MergeCompareFunction(iRow, iCol, iRow, iCol - 1) = True Then
                                    VBFlexGridMergeDrawInfo.Row.ColOffset = VBFlexGridMergeDrawInfo.Row.ColOffset + 1
                                    VBFlexGridMergeDrawInfo.Row.Width = VBFlexGridMergeDrawInfo.Row.Width + GetColWidth(iCol - 1)
                                Else
                                    VBFlexGridMergeDrawInfo.Row.ColOffset = 0
                                    VBFlexGridMergeDrawInfo.Row.Width = 0
                                End If
                            Case FlexMergeCellsRestrictColumns, FlexMergeCellsRestrictAll
                                If MergeCompareFunction(iRow, iCol, iRow, iCol - 1) = True Then
                                    If iRow > 0 Then
                                        If MergeCompareFunction(iRow - 1, iCol, iRow - 1, iCol - 1) = True Then
                                            VBFlexGridMergeDrawInfo.Row.ColOffset = VBFlexGridMergeDrawInfo.Row.ColOffset + 1
                                            VBFlexGridMergeDrawInfo.Row.Width = VBFlexGridMergeDrawInfo.Row.Width + GetColWidth(iCol - 1)
                                        Else
                                            VBFlexGridMergeDrawInfo.Row.ColOffset = 0
                                            VBFlexGridMergeDrawInfo.Row.Width = 0
                                        End If
                                    Else
                                        VBFlexGridMergeDrawInfo.Row.ColOffset = VBFlexGridMergeDrawInfo.Row.ColOffset + 1
                                        VBFlexGridMergeDrawInfo.Row.Width = VBFlexGridMergeDrawInfo.Row.Width + GetColWidth(iCol - 1)
                                    End If
                                Else
                                    VBFlexGridMergeDrawInfo.Row.ColOffset = 0
                                    VBFlexGridMergeDrawInfo.Row.Width = 0
                                End If
                        End Select
                    Else
                        VBFlexGridMergeDrawInfo.Row.ColOffset = 0
                        VBFlexGridMergeDrawInfo.Row.Width = 0
                    End If
                End If
                If (VBFlexGridColsInfo(iCol).State And CLIS_MERGE) = CLIS_MERGE Then
                    If iRow > 0 Then
                        Select Case PropMergeCells
                            Case FlexMergeCellsFree, FlexMergeCellsRestrictColumns, FlexMergeCellsFixedOnly
                                If MergeCompareFunction(iRow, iCol, iRow - 1, iCol) = True Then
                                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset + 1
                                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height + GetRowHeight(iRow - 1)
                                Else
                                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = 0
                                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = 0
                                End If
                            Case FlexMergeCellsRestrictRows, FlexMergeCellsRestrictAll
                                If MergeCompareFunction(iRow, iCol, iRow - 1, iCol) = True Then
                                    If iCol > 0 Then
                                        If MergeCompareFunction(iRow, iCol - 1, iRow - 1, iCol - 1) = True Then
                                            VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset + 1
                                            VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height + GetRowHeight(iRow - 1)
                                        Else
                                            VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = 0
                                            VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = 0
                                        End If
                                    Else
                                        VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset + 1
                                        VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height + GetRowHeight(iRow - 1)
                                    End If
                                Else
                                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = 0
                                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = 0
                                End If
                        End Select
                    Else
                        VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = 0
                        VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = 0
                    End If
                End If
                .Left = .Left - VBFlexGridMergeDrawInfo.Row.Width
                .Top = .Top - VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height
                If .Bottom > .Top And .Right > .Left Then
                    VBFlexGridDrawInfo.GridLinePoints(0).X = .Left
                    VBFlexGridDrawInfo.GridLinePoints(0).Y = .Bottom - 1
                    VBFlexGridDrawInfo.GridLinePoints(1).X = .Right - 1
                    VBFlexGridDrawInfo.GridLinePoints(1).Y = .Bottom - 1
                    VBFlexGridDrawInfo.GridLinePoints(2).X = .Right - 1
                    VBFlexGridDrawInfo.GridLinePoints(2).Y = .Top - 1
                    VBFlexGridDrawInfo.GridLinePoints(3).X = .Right - 2
                    VBFlexGridDrawInfo.GridLinePoints(3).Y = .Top
                    VBFlexGridDrawInfo.GridLinePoints(4).X = .Left
                    VBFlexGridDrawInfo.GridLinePoints(4).Y = .Top
                    VBFlexGridDrawInfo.GridLinePoints(5).X = .Left
                    VBFlexGridDrawInfo.GridLinePoints(5).Y = .Bottom
                    Call DrawFixedCell(hDC, CellRect, iRow, iCol)
                End If
                .Left = .Left + VBFlexGridMergeDrawInfo.Row.Width
                .Top = .Top + VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height
                .Left = .Right
                If NoClip = False And .Right > VBFlexGridClientRect.Right Then Exit For
            Next iCol
            .Top = .Bottom
            If NoClip = False And .Bottom > VBFlexGridClientRect.Bottom Then Exit For
        Next iRow
    End If
    If PropFixedCols > 0 Then
        ReDim VBFlexGridMergeDrawInfo.Row.Cols(0 To (PropFixedCols - 1)) As TMERGEDRAWCOLINFO
        .Top = FixedCY
        For iRow = PropFixedRows To ((PropFixedRows + PropFrozenRows) - 1)
            VBFlexGridMergeDrawInfo.Row.ColOffset = 0
            VBFlexGridMergeDrawInfo.Row.Width = 0
            .Bottom = .Top + GetRowHeight(iRow)
            .Left = 0
            For iCol = 0 To (PropFixedCols - 1)
                .Right = .Left + GetColWidth(iCol)
                If (VBFlexGridCells.Rows(iRow).RowInfo.State And RWIS_MERGE) = RWIS_MERGE Then
                    If iCol > 0 Then
                        Select Case PropMergeCells
                            Case FlexMergeCellsFree, FlexMergeCellsRestrictRows, FlexMergeCellsFixedOnly
                                If MergeCompareFunction(iRow, iCol, iRow, iCol - 1) = True Then
                                    VBFlexGridMergeDrawInfo.Row.ColOffset = VBFlexGridMergeDrawInfo.Row.ColOffset + 1
                                    VBFlexGridMergeDrawInfo.Row.Width = VBFlexGridMergeDrawInfo.Row.Width + GetColWidth(iCol - 1)
                                Else
                                    VBFlexGridMergeDrawInfo.Row.ColOffset = 0
                                    VBFlexGridMergeDrawInfo.Row.Width = 0
                                End If
                            Case FlexMergeCellsRestrictColumns, FlexMergeCellsRestrictAll
                                If MergeCompareFunction(iRow, iCol, iRow, iCol - 1) = True Then
                                    If iRow > PropFixedRows Then
                                        If MergeCompareFunction(iRow - 1, iCol, iRow - 1, iCol - 1) = True Then
                                            VBFlexGridMergeDrawInfo.Row.ColOffset = VBFlexGridMergeDrawInfo.Row.ColOffset + 1
                                            VBFlexGridMergeDrawInfo.Row.Width = VBFlexGridMergeDrawInfo.Row.Width + GetColWidth(iCol - 1)
                                        Else
                                            VBFlexGridMergeDrawInfo.Row.ColOffset = 0
                                            VBFlexGridMergeDrawInfo.Row.Width = 0
                                        End If
                                    Else
                                        VBFlexGridMergeDrawInfo.Row.ColOffset = VBFlexGridMergeDrawInfo.Row.ColOffset + 1
                                        VBFlexGridMergeDrawInfo.Row.Width = VBFlexGridMergeDrawInfo.Row.Width + GetColWidth(iCol - 1)
                                    End If
                                Else
                                    VBFlexGridMergeDrawInfo.Row.ColOffset = 0
                                    VBFlexGridMergeDrawInfo.Row.Width = 0
                                End If
                        End Select
                    Else
                        VBFlexGridMergeDrawInfo.Row.ColOffset = 0
                        VBFlexGridMergeDrawInfo.Row.Width = 0
                    End If
                End If
                If (VBFlexGridColsInfo(iCol).State And CLIS_MERGE) = CLIS_MERGE Then
                    If iRow > PropFixedRows Then
                        Select Case PropMergeCells
                            Case FlexMergeCellsFree, FlexMergeCellsRestrictColumns, FlexMergeCellsFixedOnly
                                If MergeCompareFunction(iRow, iCol, iRow - 1, iCol) = True Then
                                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset + 1
                                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height + GetRowHeight(iRow - 1)
                                Else
                                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = 0
                                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = 0
                                End If
                            Case FlexMergeCellsRestrictRows, FlexMergeCellsRestrictAll
                                If MergeCompareFunction(iRow, iCol, iRow - 1, iCol) = True Then
                                    If iCol > 0 Then
                                        If MergeCompareFunction(iRow, iCol - 1, iRow - 1, iCol - 1) = True Then
                                            VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset + 1
                                            VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height + GetRowHeight(iRow - 1)
                                        Else
                                            VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = 0
                                            VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = 0
                                        End If
                                    Else
                                        VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset + 1
                                        VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height + GetRowHeight(iRow - 1)
                                    End If
                                Else
                                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = 0
                                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = 0
                                End If
                        End Select
                    Else
                        VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = 0
                        VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = 0
                    End If
                End If
                .Left = .Left - VBFlexGridMergeDrawInfo.Row.Width
                .Top = .Top - VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height
                If .Bottom > .Top And .Right > .Left Then
                    VBFlexGridDrawInfo.GridLinePoints(0).X = .Left
                    VBFlexGridDrawInfo.GridLinePoints(0).Y = .Bottom - 1
                    VBFlexGridDrawInfo.GridLinePoints(1).X = .Right - 1
                    VBFlexGridDrawInfo.GridLinePoints(1).Y = .Bottom - 1
                    VBFlexGridDrawInfo.GridLinePoints(2).X = .Right - 1
                    VBFlexGridDrawInfo.GridLinePoints(2).Y = .Top - 1
                    VBFlexGridDrawInfo.GridLinePoints(3).X = .Right - 2
                    VBFlexGridDrawInfo.GridLinePoints(3).Y = .Top
                    VBFlexGridDrawInfo.GridLinePoints(4).X = .Left
                    VBFlexGridDrawInfo.GridLinePoints(4).Y = .Top
                    VBFlexGridDrawInfo.GridLinePoints(5).X = .Left
                    VBFlexGridDrawInfo.GridLinePoints(5).Y = .Bottom
                    Call DrawFixedCell(hDC, CellRect, iRow, iCol)
                End If
                .Left = .Left + VBFlexGridMergeDrawInfo.Row.Width
                .Top = .Top + VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height
                .Left = .Right
                If NoClip = False And .Right > VBFlexGridClientRect.Right Then Exit For
            Next iCol
            .Top = .Bottom
            If NoClip = False And .Bottom > VBFlexGridClientRect.Bottom Then Exit For
        Next iRow
        ReDim VBFlexGridMergeDrawInfo.Row.Cols(0 To (PropFixedCols - 1)) As TMERGEDRAWCOLINFO
        .Top = FixedCY + FrozenCY
        For iRow = CellRange.TopRow To CellRange.BottomRow
            VBFlexGridMergeDrawInfo.Row.ColOffset = 0
            VBFlexGridMergeDrawInfo.Row.Width = 0
            .Bottom = .Top + GetRowHeight(iRow)
            .Left = 0
            For iCol = 0 To (PropFixedCols - 1)
                .Right = .Left + GetColWidth(iCol)
                If (VBFlexGridCells.Rows(iRow).RowInfo.State And RWIS_MERGE) = RWIS_MERGE Then
                    If iCol > 0 Then
                        Select Case PropMergeCells
                            Case FlexMergeCellsFree, FlexMergeCellsRestrictRows, FlexMergeCellsFixedOnly
                                If MergeCompareFunction(iRow, iCol, iRow, iCol - 1) = True Then
                                    VBFlexGridMergeDrawInfo.Row.ColOffset = VBFlexGridMergeDrawInfo.Row.ColOffset + 1
                                    VBFlexGridMergeDrawInfo.Row.Width = VBFlexGridMergeDrawInfo.Row.Width + GetColWidth(iCol - 1)
                                Else
                                    VBFlexGridMergeDrawInfo.Row.ColOffset = 0
                                    VBFlexGridMergeDrawInfo.Row.Width = 0
                                End If
                            Case FlexMergeCellsRestrictColumns, FlexMergeCellsRestrictAll
                                If MergeCompareFunction(iRow, iCol, iRow, iCol - 1) = True Then
                                    If iRow > CellRange.TopRow Then
                                        If MergeCompareFunction(iRow - 1, iCol, iRow - 1, iCol - 1) = True Then
                                            VBFlexGridMergeDrawInfo.Row.ColOffset = VBFlexGridMergeDrawInfo.Row.ColOffset + 1
                                            VBFlexGridMergeDrawInfo.Row.Width = VBFlexGridMergeDrawInfo.Row.Width + GetColWidth(iCol - 1)
                                        Else
                                            VBFlexGridMergeDrawInfo.Row.ColOffset = 0
                                            VBFlexGridMergeDrawInfo.Row.Width = 0
                                        End If
                                    Else
                                        VBFlexGridMergeDrawInfo.Row.ColOffset = VBFlexGridMergeDrawInfo.Row.ColOffset + 1
                                        VBFlexGridMergeDrawInfo.Row.Width = VBFlexGridMergeDrawInfo.Row.Width + GetColWidth(iCol - 1)
                                    End If
                                Else
                                    VBFlexGridMergeDrawInfo.Row.ColOffset = 0
                                    VBFlexGridMergeDrawInfo.Row.Width = 0
                                End If
                        End Select
                    Else
                        VBFlexGridMergeDrawInfo.Row.ColOffset = 0
                        VBFlexGridMergeDrawInfo.Row.Width = 0
                    End If
                End If
                If (VBFlexGridColsInfo(iCol).State And CLIS_MERGE) = CLIS_MERGE Then
                    If iRow > CellRange.TopRow Then
                        Select Case PropMergeCells
                            Case FlexMergeCellsFree, FlexMergeCellsRestrictColumns, FlexMergeCellsFixedOnly
                                If MergeCompareFunction(iRow, iCol, iRow - 1, iCol) = True Then
                                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset + 1
                                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height + GetRowHeight(iRow - 1)
                                Else
                                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = 0
                                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = 0
                                End If
                            Case FlexMergeCellsRestrictRows, FlexMergeCellsRestrictAll
                                If MergeCompareFunction(iRow, iCol, iRow - 1, iCol) = True Then
                                    If iCol > 0 Then
                                        If MergeCompareFunction(iRow, iCol - 1, iRow - 1, iCol - 1) = True Then
                                            VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset + 1
                                            VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height + GetRowHeight(iRow - 1)
                                        Else
                                            VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = 0
                                            VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = 0
                                        End If
                                    Else
                                        VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset + 1
                                        VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height + GetRowHeight(iRow - 1)
                                    End If
                                Else
                                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = 0
                                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = 0
                                End If
                        End Select
                    Else
                        VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = 0
                        VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = 0
                    End If
                End If
                .Left = .Left - VBFlexGridMergeDrawInfo.Row.Width
                .Top = .Top - VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height
                If .Bottom > .Top And .Right > .Left Then
                    VBFlexGridDrawInfo.GridLinePoints(0).X = .Left
                    VBFlexGridDrawInfo.GridLinePoints(0).Y = .Bottom - 1
                    VBFlexGridDrawInfo.GridLinePoints(1).X = .Right - 1
                    VBFlexGridDrawInfo.GridLinePoints(1).Y = .Bottom - 1
                    VBFlexGridDrawInfo.GridLinePoints(2).X = .Right - 1
                    VBFlexGridDrawInfo.GridLinePoints(2).Y = .Top - 1
                    VBFlexGridDrawInfo.GridLinePoints(3).X = .Right - 2
                    VBFlexGridDrawInfo.GridLinePoints(3).Y = .Top
                    VBFlexGridDrawInfo.GridLinePoints(4).X = .Left
                    VBFlexGridDrawInfo.GridLinePoints(4).Y = .Top
                    VBFlexGridDrawInfo.GridLinePoints(5).X = .Left
                    VBFlexGridDrawInfo.GridLinePoints(5).Y = .Bottom
                    Call DrawFixedCell(hDC, CellRect, iRow, iCol)
                End If
                .Left = .Left + VBFlexGridMergeDrawInfo.Row.Width
                .Top = .Top + VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height
                .Left = .Right
                If NoClip = False And .Right > VBFlexGridClientRect.Right Then Exit For
            Next iCol
            .Top = .Bottom
            If NoClip = False And .Bottom > VBFlexGridClientRect.Bottom Then Exit For
        Next iRow
    End If
    If VBFlexGridFontFixedHandle <> NULL_PTR Then
        If hFontOld <> NULL_PTR Then
            SelectObject hDC, hFontOld
            hFontOld = NULL_PTR
        End If
        hFontOld = SelectObject(hDC, VBFlexGridFontHandle)
    End If
    SelectObject hDC, VBFlexGridBackColorBrush
    ReDim VBFlexGridMergeDrawInfo.Row.Cols(0 To (PropCols - 1)) As TMERGEDRAWCOLINFO
    .Top = FixedCY
    For iRow = PropFixedRows To ((PropFixedRows + PropFrozenRows) - 1)
        VBFlexGridMergeDrawInfo.Row.ColOffset = 0
        VBFlexGridMergeDrawInfo.Row.Width = 0
        .Bottom = .Top + GetRowHeight(iRow)
        If PropFrozenCols > 0 Then
            .Left = FixedCX
            For iCol = PropFixedCols To ((PropFixedCols + PropFrozenCols) - 1)
                .Right = .Left + GetColWidth(iCol)
                If (VBFlexGridCells.Rows(iRow).RowInfo.State And RWIS_MERGE) = RWIS_MERGE Then
                    If iCol > PropFixedCols Then
                        Select Case PropMergeCells
                            Case FlexMergeCellsFree, FlexMergeCellsRestrictRows
                                If MergeCompareFunction(iRow, iCol, iRow, iCol - 1) = True Then
                                    VBFlexGridMergeDrawInfo.Row.ColOffset = VBFlexGridMergeDrawInfo.Row.ColOffset + 1
                                    VBFlexGridMergeDrawInfo.Row.Width = VBFlexGridMergeDrawInfo.Row.Width + GetColWidth(iCol - 1)
                                Else
                                    VBFlexGridMergeDrawInfo.Row.ColOffset = 0
                                    VBFlexGridMergeDrawInfo.Row.Width = 0
                                End If
                            Case FlexMergeCellsRestrictColumns, FlexMergeCellsRestrictAll
                                If MergeCompareFunction(iRow, iCol, iRow, iCol - 1) = True Then
                                    If iRow > PropFixedRows Then
                                        If MergeCompareFunction(iRow - 1, iCol, iRow - 1, iCol - 1) = True Then
                                            VBFlexGridMergeDrawInfo.Row.ColOffset = VBFlexGridMergeDrawInfo.Row.ColOffset + 1
                                            VBFlexGridMergeDrawInfo.Row.Width = VBFlexGridMergeDrawInfo.Row.Width + GetColWidth(iCol - 1)
                                        Else
                                            VBFlexGridMergeDrawInfo.Row.ColOffset = 0
                                            VBFlexGridMergeDrawInfo.Row.Width = 0
                                        End If
                                    Else
                                        VBFlexGridMergeDrawInfo.Row.ColOffset = VBFlexGridMergeDrawInfo.Row.ColOffset + 1
                                        VBFlexGridMergeDrawInfo.Row.Width = VBFlexGridMergeDrawInfo.Row.Width + GetColWidth(iCol - 1)
                                    End If
                                Else
                                    VBFlexGridMergeDrawInfo.Row.ColOffset = 0
                                    VBFlexGridMergeDrawInfo.Row.Width = 0
                                End If
                        End Select
                    Else
                        VBFlexGridMergeDrawInfo.Row.ColOffset = 0
                        VBFlexGridMergeDrawInfo.Row.Width = 0
                    End If
                End If
                If (VBFlexGridColsInfo(iCol).State And CLIS_MERGE) = CLIS_MERGE Then
                    If iRow > PropFixedRows Then
                        Select Case PropMergeCells
                            Case FlexMergeCellsFree, FlexMergeCellsRestrictColumns
                                If MergeCompareFunction(iRow, iCol, iRow - 1, iCol) = True Then
                                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset + 1
                                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height + GetRowHeight(iRow - 1)
                                Else
                                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = 0
                                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = 0
                                End If
                            Case FlexMergeCellsRestrictRows, FlexMergeCellsRestrictAll
                                If MergeCompareFunction(iRow, iCol, iRow - 1, iCol) = True Then
                                    If iCol > PropFixedCols Then
                                        If MergeCompareFunction(iRow, iCol - 1, iRow - 1, iCol - 1) = True Then
                                            VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset + 1
                                            VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height + GetRowHeight(iRow - 1)
                                        Else
                                            VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = 0
                                            VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = 0
                                        End If
                                    Else
                                        VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset + 1
                                        VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height + GetRowHeight(iRow - 1)
                                    End If
                                Else
                                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = 0
                                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = 0
                                End If
                        End Select
                    Else
                        VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = 0
                        VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = 0
                    End If
                End If
                .Left = .Left - VBFlexGridMergeDrawInfo.Row.Width
                .Top = .Top - VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height
                If .Bottom > .Top And .Right > .Left Then
                    VBFlexGridDrawInfo.GridLinePoints(0).X = .Left
                    VBFlexGridDrawInfo.GridLinePoints(0).Y = .Bottom - 1
                    VBFlexGridDrawInfo.GridLinePoints(1).X = .Right - 1
                    VBFlexGridDrawInfo.GridLinePoints(1).Y = .Bottom - 1
                    VBFlexGridDrawInfo.GridLinePoints(2).X = .Right - 1
                    VBFlexGridDrawInfo.GridLinePoints(2).Y = .Top - 1
                    VBFlexGridDrawInfo.GridLinePoints(3).X = .Right - 2
                    VBFlexGridDrawInfo.GridLinePoints(3).Y = .Top
                    VBFlexGridDrawInfo.GridLinePoints(4).X = .Left
                    VBFlexGridDrawInfo.GridLinePoints(4).Y = .Top
                    VBFlexGridDrawInfo.GridLinePoints(5).X = .Left
                    VBFlexGridDrawInfo.GridLinePoints(5).Y = .Bottom
                    Call DrawCell(hDC, CellRect, iRow, iCol)
                End If
                .Left = .Left + VBFlexGridMergeDrawInfo.Row.Width
                .Top = .Top + VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height
                .Left = .Right
                If NoClip = False And .Right > VBFlexGridClientRect.Right Then Exit For
            Next iCol
        End If
        .Left = FixedCX + FrozenCX
        For iCol = CellRange.LeftCol To CellRange.RightCol
            .Right = .Left + GetColWidth(iCol)
            If (VBFlexGridCells.Rows(iRow).RowInfo.State And RWIS_MERGE) = RWIS_MERGE Then
                If iCol > CellRange.LeftCol Then
                    Select Case PropMergeCells
                        Case FlexMergeCellsFree, FlexMergeCellsRestrictRows
                            If MergeCompareFunction(iRow, iCol, iRow, iCol - 1) = True Then
                                VBFlexGridMergeDrawInfo.Row.ColOffset = VBFlexGridMergeDrawInfo.Row.ColOffset + 1
                                VBFlexGridMergeDrawInfo.Row.Width = VBFlexGridMergeDrawInfo.Row.Width + GetColWidth(iCol - 1)
                            Else
                                VBFlexGridMergeDrawInfo.Row.ColOffset = 0
                                VBFlexGridMergeDrawInfo.Row.Width = 0
                            End If
                        Case FlexMergeCellsRestrictColumns, FlexMergeCellsRestrictAll
                            If MergeCompareFunction(iRow, iCol, iRow, iCol - 1) = True Then
                                If iRow > PropFixedRows Then
                                    If MergeCompareFunction(iRow - 1, iCol, iRow - 1, iCol - 1) = True Then
                                        VBFlexGridMergeDrawInfo.Row.ColOffset = VBFlexGridMergeDrawInfo.Row.ColOffset + 1
                                        VBFlexGridMergeDrawInfo.Row.Width = VBFlexGridMergeDrawInfo.Row.Width + GetColWidth(iCol - 1)
                                    Else
                                        VBFlexGridMergeDrawInfo.Row.ColOffset = 0
                                        VBFlexGridMergeDrawInfo.Row.Width = 0
                                    End If
                                Else
                                    VBFlexGridMergeDrawInfo.Row.ColOffset = VBFlexGridMergeDrawInfo.Row.ColOffset + 1
                                    VBFlexGridMergeDrawInfo.Row.Width = VBFlexGridMergeDrawInfo.Row.Width + GetColWidth(iCol - 1)
                                End If
                            Else
                                VBFlexGridMergeDrawInfo.Row.ColOffset = 0
                                VBFlexGridMergeDrawInfo.Row.Width = 0
                            End If
                    End Select
                Else
                    VBFlexGridMergeDrawInfo.Row.ColOffset = 0
                    VBFlexGridMergeDrawInfo.Row.Width = 0
                End If
            End If
            If (VBFlexGridColsInfo(iCol).State And CLIS_MERGE) = CLIS_MERGE Then
                If iRow > PropFixedRows Then
                    Select Case PropMergeCells
                        Case FlexMergeCellsFree, FlexMergeCellsRestrictColumns
                            If MergeCompareFunction(iRow, iCol, iRow - 1, iCol) = True Then
                                VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset + 1
                                VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height + GetRowHeight(iRow - 1)
                            Else
                                VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = 0
                                VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = 0
                            End If
                        Case FlexMergeCellsRestrictRows, FlexMergeCellsRestrictAll
                            If MergeCompareFunction(iRow, iCol, iRow - 1, iCol) = True Then
                                If iCol > CellRange.LeftCol Then
                                    If MergeCompareFunction(iRow, iCol - 1, iRow - 1, iCol - 1) = True Then
                                        VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset + 1
                                        VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height + GetRowHeight(iRow - 1)
                                    Else
                                        VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = 0
                                        VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = 0
                                    End If
                                Else
                                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset + 1
                                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height + GetRowHeight(iRow - 1)
                                End If
                            Else
                                VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = 0
                                VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = 0
                            End If
                    End Select
                Else
                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = 0
                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = 0
                End If
            End If
            .Left = .Left - VBFlexGridMergeDrawInfo.Row.Width
            .Top = .Top - VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height
            If .Bottom > .Top And .Right > .Left Then
                VBFlexGridDrawInfo.GridLinePoints(0).X = .Left
                VBFlexGridDrawInfo.GridLinePoints(0).Y = .Bottom - 1
                VBFlexGridDrawInfo.GridLinePoints(1).X = .Right - 1
                VBFlexGridDrawInfo.GridLinePoints(1).Y = .Bottom - 1
                VBFlexGridDrawInfo.GridLinePoints(2).X = .Right - 1
                VBFlexGridDrawInfo.GridLinePoints(2).Y = .Top - 1
                VBFlexGridDrawInfo.GridLinePoints(3).X = .Right - 2
                VBFlexGridDrawInfo.GridLinePoints(3).Y = .Top
                VBFlexGridDrawInfo.GridLinePoints(4).X = .Left
                VBFlexGridDrawInfo.GridLinePoints(4).Y = .Top
                VBFlexGridDrawInfo.GridLinePoints(5).X = .Left
                VBFlexGridDrawInfo.GridLinePoints(5).Y = .Bottom
                Call DrawCell(hDC, CellRect, iRow, iCol)
            End If
            .Left = .Left + VBFlexGridMergeDrawInfo.Row.Width
            .Top = .Top + VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height
            .Left = .Right
            If NoClip = False And .Right > VBFlexGridClientRect.Right Then Exit For
        Next iCol
        If .Right > GridRect.Right Then GridRect.Right = .Right
        .Top = .Bottom
        If NoClip = False And .Bottom > VBFlexGridClientRect.Bottom Then Exit For
    Next iRow
    ReDim VBFlexGridMergeDrawInfo.Row.Cols(0 To (PropCols - 1)) As TMERGEDRAWCOLINFO
    .Top = FixedCY + FrozenCY
    For iRow = CellRange.TopRow To CellRange.BottomRow
        VBFlexGridMergeDrawInfo.Row.ColOffset = 0
        VBFlexGridMergeDrawInfo.Row.Width = 0
        .Bottom = .Top + GetRowHeight(iRow)
        If PropFrozenCols > 0 Then
            .Left = FixedCX
            For iCol = PropFixedCols To ((PropFixedCols + PropFrozenCols) - 1)
                .Right = .Left + GetColWidth(iCol)
                If (VBFlexGridCells.Rows(iRow).RowInfo.State And RWIS_MERGE) = RWIS_MERGE Then
                    If iCol > PropFixedCols Then
                        Select Case PropMergeCells
                            Case FlexMergeCellsFree, FlexMergeCellsRestrictRows
                                If MergeCompareFunction(iRow, iCol, iRow, iCol - 1) = True Then
                                    VBFlexGridMergeDrawInfo.Row.ColOffset = VBFlexGridMergeDrawInfo.Row.ColOffset + 1
                                    VBFlexGridMergeDrawInfo.Row.Width = VBFlexGridMergeDrawInfo.Row.Width + GetColWidth(iCol - 1)
                                Else
                                    VBFlexGridMergeDrawInfo.Row.ColOffset = 0
                                    VBFlexGridMergeDrawInfo.Row.Width = 0
                                End If
                            Case FlexMergeCellsRestrictColumns, FlexMergeCellsRestrictAll
                                If MergeCompareFunction(iRow, iCol, iRow, iCol - 1) = True Then
                                    If iRow > CellRange.TopRow Then
                                        If MergeCompareFunction(iRow - 1, iCol, iRow - 1, iCol - 1) = True Then
                                            VBFlexGridMergeDrawInfo.Row.ColOffset = VBFlexGridMergeDrawInfo.Row.ColOffset + 1
                                            VBFlexGridMergeDrawInfo.Row.Width = VBFlexGridMergeDrawInfo.Row.Width + GetColWidth(iCol - 1)
                                        Else
                                            VBFlexGridMergeDrawInfo.Row.ColOffset = 0
                                            VBFlexGridMergeDrawInfo.Row.Width = 0
                                        End If
                                    Else
                                        VBFlexGridMergeDrawInfo.Row.ColOffset = VBFlexGridMergeDrawInfo.Row.ColOffset + 1
                                        VBFlexGridMergeDrawInfo.Row.Width = VBFlexGridMergeDrawInfo.Row.Width + GetColWidth(iCol - 1)
                                    End If
                                Else
                                    VBFlexGridMergeDrawInfo.Row.ColOffset = 0
                                    VBFlexGridMergeDrawInfo.Row.Width = 0
                                End If
                        End Select
                    Else
                        VBFlexGridMergeDrawInfo.Row.ColOffset = 0
                        VBFlexGridMergeDrawInfo.Row.Width = 0
                    End If
                End If
                If (VBFlexGridColsInfo(iCol).State And CLIS_MERGE) = CLIS_MERGE Then
                    If iRow > CellRange.TopRow Then
                        Select Case PropMergeCells
                            Case FlexMergeCellsFree, FlexMergeCellsRestrictColumns
                                If MergeCompareFunction(iRow, iCol, iRow - 1, iCol) = True Then
                                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset + 1
                                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height + GetRowHeight(iRow - 1)
                                Else
                                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = 0
                                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = 0
                                End If
                            Case FlexMergeCellsRestrictRows, FlexMergeCellsRestrictAll
                                If MergeCompareFunction(iRow, iCol, iRow - 1, iCol) = True Then
                                    If iCol > PropFixedCols Then
                                        If MergeCompareFunction(iRow, iCol - 1, iRow - 1, iCol - 1) = True Then
                                            VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset + 1
                                            VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height + GetRowHeight(iRow - 1)
                                        Else
                                            VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = 0
                                            VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = 0
                                        End If
                                    Else
                                        VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset + 1
                                        VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height + GetRowHeight(iRow - 1)
                                    End If
                                Else
                                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = 0
                                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = 0
                                End If
                        End Select
                    Else
                        VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = 0
                        VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = 0
                    End If
                End If
                .Left = .Left - VBFlexGridMergeDrawInfo.Row.Width
                .Top = .Top - VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height
                If .Bottom > .Top And .Right > .Left Then
                    VBFlexGridDrawInfo.GridLinePoints(0).X = .Left
                    VBFlexGridDrawInfo.GridLinePoints(0).Y = .Bottom - 1
                    VBFlexGridDrawInfo.GridLinePoints(1).X = .Right - 1
                    VBFlexGridDrawInfo.GridLinePoints(1).Y = .Bottom - 1
                    VBFlexGridDrawInfo.GridLinePoints(2).X = .Right - 1
                    VBFlexGridDrawInfo.GridLinePoints(2).Y = .Top - 1
                    VBFlexGridDrawInfo.GridLinePoints(3).X = .Right - 2
                    VBFlexGridDrawInfo.GridLinePoints(3).Y = .Top
                    VBFlexGridDrawInfo.GridLinePoints(4).X = .Left
                    VBFlexGridDrawInfo.GridLinePoints(4).Y = .Top
                    VBFlexGridDrawInfo.GridLinePoints(5).X = .Left
                    VBFlexGridDrawInfo.GridLinePoints(5).Y = .Bottom
                    Call DrawCell(hDC, CellRect, iRow, iCol)
                End If
                .Left = .Left + VBFlexGridMergeDrawInfo.Row.Width
                .Top = .Top + VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height
                .Left = .Right
                If NoClip = False And .Right > VBFlexGridClientRect.Right Then Exit For
            Next iCol
        End If
        .Left = FixedCX + FrozenCX
        For iCol = CellRange.LeftCol To CellRange.RightCol
            .Right = .Left + GetColWidth(iCol)
            If (VBFlexGridCells.Rows(iRow).RowInfo.State And RWIS_MERGE) = RWIS_MERGE Then
                If iCol > CellRange.LeftCol Then
                    Select Case PropMergeCells
                        Case FlexMergeCellsFree, FlexMergeCellsRestrictRows
                            If MergeCompareFunction(iRow, iCol, iRow, iCol - 1) = True Then
                                VBFlexGridMergeDrawInfo.Row.ColOffset = VBFlexGridMergeDrawInfo.Row.ColOffset + 1
                                VBFlexGridMergeDrawInfo.Row.Width = VBFlexGridMergeDrawInfo.Row.Width + GetColWidth(iCol - 1)
                            Else
                                VBFlexGridMergeDrawInfo.Row.ColOffset = 0
                                VBFlexGridMergeDrawInfo.Row.Width = 0
                            End If
                        Case FlexMergeCellsRestrictColumns, FlexMergeCellsRestrictAll
                            If MergeCompareFunction(iRow, iCol, iRow, iCol - 1) = True Then
                                If iRow > CellRange.TopRow Then
                                    If MergeCompareFunction(iRow - 1, iCol, iRow - 1, iCol - 1) = True Then
                                        VBFlexGridMergeDrawInfo.Row.ColOffset = VBFlexGridMergeDrawInfo.Row.ColOffset + 1
                                        VBFlexGridMergeDrawInfo.Row.Width = VBFlexGridMergeDrawInfo.Row.Width + GetColWidth(iCol - 1)
                                    Else
                                        VBFlexGridMergeDrawInfo.Row.ColOffset = 0
                                        VBFlexGridMergeDrawInfo.Row.Width = 0
                                    End If
                                Else
                                    VBFlexGridMergeDrawInfo.Row.ColOffset = VBFlexGridMergeDrawInfo.Row.ColOffset + 1
                                    VBFlexGridMergeDrawInfo.Row.Width = VBFlexGridMergeDrawInfo.Row.Width + GetColWidth(iCol - 1)
                                End If
                            Else
                                VBFlexGridMergeDrawInfo.Row.ColOffset = 0
                                VBFlexGridMergeDrawInfo.Row.Width = 0
                            End If
                    End Select
                Else
                    VBFlexGridMergeDrawInfo.Row.ColOffset = 0
                    VBFlexGridMergeDrawInfo.Row.Width = 0
                End If
            End If
            If (VBFlexGridColsInfo(iCol).State And CLIS_MERGE) = CLIS_MERGE Then
                If iRow > CellRange.TopRow Then
                    Select Case PropMergeCells
                        Case FlexMergeCellsFree, FlexMergeCellsRestrictColumns
                            If MergeCompareFunction(iRow, iCol, iRow - 1, iCol) = True Then
                                VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset + 1
                                VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height + GetRowHeight(iRow - 1)
                            Else
                                VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = 0
                                VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = 0
                            End If
                        Case FlexMergeCellsRestrictRows, FlexMergeCellsRestrictAll
                            If MergeCompareFunction(iRow, iCol, iRow - 1, iCol) = True Then
                                If iCol > CellRange.LeftCol Then
                                    If MergeCompareFunction(iRow, iCol - 1, iRow - 1, iCol - 1) = True Then
                                        VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset + 1
                                        VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height + GetRowHeight(iRow - 1)
                                    Else
                                        VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = 0
                                        VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = 0
                                    End If
                                Else
                                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset + 1
                                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height + GetRowHeight(iRow - 1)
                                End If
                            Else
                                VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = 0
                                VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = 0
                            End If
                    End Select
                Else
                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset = 0
                    VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height = 0
                End If
            End If
            .Left = .Left - VBFlexGridMergeDrawInfo.Row.Width
            .Top = .Top - VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height
            If .Bottom > .Top And .Right > .Left Then
                VBFlexGridDrawInfo.GridLinePoints(0).X = .Left
                VBFlexGridDrawInfo.GridLinePoints(0).Y = .Bottom - 1
                VBFlexGridDrawInfo.GridLinePoints(1).X = .Right - 1
                VBFlexGridDrawInfo.GridLinePoints(1).Y = .Bottom - 1
                VBFlexGridDrawInfo.GridLinePoints(2).X = .Right - 1
                VBFlexGridDrawInfo.GridLinePoints(2).Y = .Top - 1
                VBFlexGridDrawInfo.GridLinePoints(3).X = .Right - 2
                VBFlexGridDrawInfo.GridLinePoints(3).Y = .Top
                VBFlexGridDrawInfo.GridLinePoints(4).X = .Left
                VBFlexGridDrawInfo.GridLinePoints(4).Y = .Top
                VBFlexGridDrawInfo.GridLinePoints(5).X = .Left
                VBFlexGridDrawInfo.GridLinePoints(5).Y = .Bottom
                Call DrawCell(hDC, CellRect, iRow, iCol)
            End If
            .Left = .Left + VBFlexGridMergeDrawInfo.Row.Width
            .Top = .Top + VBFlexGridMergeDrawInfo.Row.Cols(iCol).Height
            .Left = .Right
            If NoClip = False And .Right > VBFlexGridClientRect.Right Then Exit For
        Next iCol
        If .Right > GridRect.Right Then GridRect.Right = .Right
        .Top = .Bottom
        If NoClip = False And .Bottom > VBFlexGridClientRect.Bottom Then Exit For
    Next iRow
    If .Bottom > GridRect.Bottom Then GridRect.Bottom = .Bottom
    If hFontOld <> NULL_PTR Then
        SelectObject hDC, hFontOld
        hFontOld = NULL_PTR
    End If
    If Brush <> NULL_PTR Then
        SelectObject hDC, Brush
        Brush = NULL_PTR
    End If
    Erase VBFlexGridMergeDrawInfo.Row.Cols()
    VBFlexGridMergeDrawInfo.Row.ColOffset = 0
    VBFlexGridMergeDrawInfo.Row.Width = 0
End If
End With
With GridRect
Dim hPenOld As LongPtr
If PropSheetBorder = True Then
    hPenOld = SelectObject(hDC, VBFlexGridGridLineFixedPen)
    VBFlexGridDrawInfo.GridLinePoints(0).X = .Left
    VBFlexGridDrawInfo.GridLinePoints(0).Y = .Bottom - 1
    VBFlexGridDrawInfo.GridLinePoints(1).X = .Right - 1
    VBFlexGridDrawInfo.GridLinePoints(1).Y = .Bottom - 1
    VBFlexGridDrawInfo.GridLinePoints(2).X = .Right - 1
    VBFlexGridDrawInfo.GridLinePoints(2).Y = .Top - 1
    Polyline hDC, VBFlexGridDrawInfo.GridLinePoints(0), 3
End If
If hPenOld <> NULL_PTR Then
    SelectObject hDC, hPenOld
    hPenOld = NULL_PTR
End If
If PropFrozenRows > 0 Or PropFrozenCols > 0 Then
    Select Case PropGridLinesFrozen
        Case FlexGridLineFlat, FlexGridLineDashes, FlexGridLineDots
            hPenOld = SelectObject(hDC, VBFlexGridGridLineFrozenPen)
            If PropFrozenRows > 0 Then
                VBFlexGridDrawInfo.GridLinePoints(0).X = .Left
                VBFlexGridDrawInfo.GridLinePoints(0).Y = (FixedCY + FrozenCY) - 1
                VBFlexGridDrawInfo.GridLinePoints(1).X = .Right
                VBFlexGridDrawInfo.GridLinePoints(1).Y = (FixedCY + FrozenCY) - 1
                Polyline hDC, VBFlexGridDrawInfo.GridLinePoints(0), 2
            End If
            If PropFrozenCols > 0 Then
                VBFlexGridDrawInfo.GridLinePoints(0).X = (FixedCX + FrozenCX) - 1
                VBFlexGridDrawInfo.GridLinePoints(0).Y = .Top
                VBFlexGridDrawInfo.GridLinePoints(1).X = (FixedCX + FrozenCX) - 1
                VBFlexGridDrawInfo.GridLinePoints(1).Y = .Bottom
                Polyline hDC, VBFlexGridDrawInfo.GridLinePoints(0), 2
            End If
        Case FlexGridLineInset, FlexGridLineRaised
            If PropFrozenRows > 0 Then
                If PropGridLinesFrozen = FlexGridLineInset Then
                    hPenOld = SelectObject(hDC, VBFlexGridGridLineBlackPen)
                ElseIf PropGridLinesFrozen = FlexGridLineRaised Then
                    hPenOld = SelectObject(hDC, VBFlexGridGridLineWhitePen)
                End If
                VBFlexGridDrawInfo.GridLinePoints(0).X = .Left
                VBFlexGridDrawInfo.GridLinePoints(0).Y = (FixedCY + FrozenCY) - 1
                VBFlexGridDrawInfo.GridLinePoints(1).X = .Right
                VBFlexGridDrawInfo.GridLinePoints(1).Y = (FixedCY + FrozenCY) - 1
                Polyline hDC, VBFlexGridDrawInfo.GridLinePoints(0), 2
                If PropGridLinesFrozen = FlexGridLineInset Then
                    SelectObject hDC, VBFlexGridGridLineWhitePen
                ElseIf PropGridLinesFrozen = FlexGridLineRaised Then
                    SelectObject hDC, VBFlexGridGridLineBlackPen
                End If
                VBFlexGridDrawInfo.GridLinePoints(0).Y = VBFlexGridDrawInfo.GridLinePoints(0).Y + 1
                VBFlexGridDrawInfo.GridLinePoints(1).Y = VBFlexGridDrawInfo.GridLinePoints(1).Y + 1
                Polyline hDC, VBFlexGridDrawInfo.GridLinePoints(0), 2
            End If
            If hPenOld <> NULL_PTR Then
                SelectObject hDC, hPenOld
                hPenOld = NULL_PTR
            End If
            If PropFrozenCols > 0 Then
                If PropGridLinesFrozen = FlexGridLineInset Then
                    hPenOld = SelectObject(hDC, VBFlexGridGridLineBlackPen)
                ElseIf PropGridLinesFrozen = FlexGridLineRaised Then
                    hPenOld = SelectObject(hDC, VBFlexGridGridLineWhitePen)
                End If
                VBFlexGridDrawInfo.GridLinePoints(0).X = (FixedCX + FrozenCX) - 1
                VBFlexGridDrawInfo.GridLinePoints(0).Y = .Top
                VBFlexGridDrawInfo.GridLinePoints(1).X = (FixedCX + FrozenCX) - 1
                VBFlexGridDrawInfo.GridLinePoints(1).Y = .Bottom
                Polyline hDC, VBFlexGridDrawInfo.GridLinePoints(0), 2
                If PropGridLinesFrozen = FlexGridLineInset Then
                    SelectObject hDC, VBFlexGridGridLineWhitePen
                ElseIf PropGridLinesFrozen = FlexGridLineRaised Then
                    SelectObject hDC, VBFlexGridGridLineBlackPen
                End If
                VBFlexGridDrawInfo.GridLinePoints(0).X = VBFlexGridDrawInfo.GridLinePoints(0).X + 1
                VBFlexGridDrawInfo.GridLinePoints(1).X = VBFlexGridDrawInfo.GridLinePoints(1).X + 1
                Polyline hDC, VBFlexGridDrawInfo.GridLinePoints(0), 2
            End If
        Case FlexGridLineFlatHorz, FlexGridLineDashesHorz, FlexGridLineDotsHorz
            If PropFrozenRows > 0 Then
                hPenOld = SelectObject(hDC, VBFlexGridGridLineFrozenPen)
                VBFlexGridDrawInfo.GridLinePoints(0).X = .Left
                VBFlexGridDrawInfo.GridLinePoints(0).Y = (FixedCY + FrozenCY) - 1
                VBFlexGridDrawInfo.GridLinePoints(1).X = .Right
                VBFlexGridDrawInfo.GridLinePoints(1).Y = (FixedCY + FrozenCY) - 1
                Polyline hDC, VBFlexGridDrawInfo.GridLinePoints(0), 2
            End If
        Case FlexGridLineInsetHorz, FlexGridLineRaisedHorz
            If PropFrozenRows > 0 Then
                If PropGridLinesFrozen = FlexGridLineInsetHorz Then
                    hPenOld = SelectObject(hDC, VBFlexGridGridLineBlackPen)
                ElseIf PropGridLinesFrozen = FlexGridLineRaisedHorz Then
                    hPenOld = SelectObject(hDC, VBFlexGridGridLineWhitePen)
                End If
                VBFlexGridDrawInfo.GridLinePoints(0).X = .Left
                VBFlexGridDrawInfo.GridLinePoints(0).Y = (FixedCY + FrozenCY) - 1
                VBFlexGridDrawInfo.GridLinePoints(1).X = .Right
                VBFlexGridDrawInfo.GridLinePoints(1).Y = (FixedCY + FrozenCY) - 1
                Polyline hDC, VBFlexGridDrawInfo.GridLinePoints(0), 2
                If PropGridLinesFrozen = FlexGridLineInsetHorz Then
                    SelectObject hDC, VBFlexGridGridLineWhitePen
                ElseIf PropGridLinesFrozen = FlexGridLineRaisedHorz Then
                    SelectObject hDC, VBFlexGridGridLineBlackPen
                End If
                VBFlexGridDrawInfo.GridLinePoints(0).Y = VBFlexGridDrawInfo.GridLinePoints(0).Y + 1
                VBFlexGridDrawInfo.GridLinePoints(1).Y = VBFlexGridDrawInfo.GridLinePoints(1).Y + 1
                Polyline hDC, VBFlexGridDrawInfo.GridLinePoints(0), 2
            End If
        Case FlexGridLineFlatVert, FlexGridLineDashesVert, FlexGridLineDotsVert
            If PropFrozenCols > 0 Then
                hPenOld = SelectObject(hDC, VBFlexGridGridLineFrozenPen)
                VBFlexGridDrawInfo.GridLinePoints(0).X = (FixedCX + FrozenCX) - 1
                VBFlexGridDrawInfo.GridLinePoints(0).Y = .Top
                VBFlexGridDrawInfo.GridLinePoints(1).X = (FixedCX + FrozenCX) - 1
                VBFlexGridDrawInfo.GridLinePoints(1).Y = .Bottom
                Polyline hDC, VBFlexGridDrawInfo.GridLinePoints(0), 2
            End If
        Case FlexGridLineInsetVert, FlexGridLineRaisedVert
            If PropFrozenCols > 0 Then
                If PropGridLinesFrozen = FlexGridLineInsetVert Then
                    hPenOld = SelectObject(hDC, VBFlexGridGridLineBlackPen)
                ElseIf PropGridLinesFrozen = FlexGridLineRaisedVert Then
                    hPenOld = SelectObject(hDC, VBFlexGridGridLineWhitePen)
                End If
                VBFlexGridDrawInfo.GridLinePoints(0).X = (FixedCX + FrozenCX) - 1
                VBFlexGridDrawInfo.GridLinePoints(0).Y = .Top
                VBFlexGridDrawInfo.GridLinePoints(1).X = (FixedCX + FrozenCX) - 1
                VBFlexGridDrawInfo.GridLinePoints(1).Y = .Bottom
                Polyline hDC, VBFlexGridDrawInfo.GridLinePoints(0), 2
                If PropGridLinesFrozen = FlexGridLineInsetVert Then
                    SelectObject hDC, VBFlexGridGridLineWhitePen
                ElseIf PropGridLinesFrozen = FlexGridLineRaisedVert Then
                    SelectObject hDC, VBFlexGridGridLineBlackPen
                End If
                VBFlexGridDrawInfo.GridLinePoints(0).X = VBFlexGridDrawInfo.GridLinePoints(0).X + 1
                VBFlexGridDrawInfo.GridLinePoints(1).X = VBFlexGridDrawInfo.GridLinePoints(1).X + 1
                Polyline hDC, VBFlexGridDrawInfo.GridLinePoints(0), 2
            End If
    End Select
End If
If hPenOld <> NULL_PTR Then
    SelectObject hDC, hPenOld
    hPenOld = NULL_PTR
End If
If VBFlexGridInsertMark > -1 Then
    Dim RC As RECT
    If VBFlexGridInsertMarkBrush = NULL_PTR Then VBFlexGridInsertMarkBrush = CreateSolidBrush(WinColor(PropInsertMarkColor))
    If VBFlexGridInsertMarkBrush <> NULL_PTR Then Brush = SelectObject(hDC, VBFlexGridInsertMarkBrush)
    If VBFlexGridInsertMarkMode = FlexDropTargetModeByRow Then
        If VBFlexGridInsertMark > -1 And VBFlexGridInsertMark <= (PropRows - 1) And (VBFlexGridInsertMark <= ((PropFixedRows + PropFrozenRows) - 1) Or VBFlexGridInsertMark >= CellRange.TopRow) Then
            RC.Left = 0
            RC.Top = 0
            RC.Right = VBFlexGridClientRect.Right
            RC.Bottom = 0
            For iRow = 0 To VBFlexGridInsertMark
                If iRow >= CellRange.TopRow Or iRow < (PropFixedRows + PropFrozenRows) Then
                    RC.Top = RC.Bottom
                    RC.Bottom = RC.Bottom + GetRowHeight(iRow)
                End If
            Next iRow
            If VBFlexGridInsertMarkAfter = False Then
                RC.Bottom = RC.Top + 1
                RC.Top = RC.Top - 1
            Else
                RC.Top = RC.Bottom - 1
                RC.Bottom = RC.Bottom + 1
            End If
            PatBlt hDC, RC.Left, RC.Top - 2, 1, 6, vbPatCopy
            PatBlt hDC, RC.Left + 1, RC.Top - 1, 1, 4, vbPatCopy
            PatBlt hDC, RC.Left + 2, RC.Top, RC.Right - RC.Left - 4, RC.Bottom - RC.Top, vbPatCopy
            PatBlt hDC, RC.Right - 2, RC.Top - 1, 1, 4, vbPatCopy
            PatBlt hDC, RC.Right - 1, RC.Top - 2, 1, 6, vbPatCopy
        End If
    ElseIf VBFlexGridInsertMarkMode = FlexDropTargetModeByColumn Then
        If VBFlexGridInsertMark > -1 And VBFlexGridInsertMark <= (PropCols - 1) And (VBFlexGridInsertMark <= ((PropFixedCols + PropFrozenCols) - 1) Or VBFlexGridInsertMark >= CellRange.LeftCol) Then
            RC.Left = 0
            RC.Top = 0
            RC.Right = 0
            RC.Bottom = VBFlexGridClientRect.Bottom
            For iCol = 0 To VBFlexGridInsertMark
                If iCol >= CellRange.LeftCol Or iCol < (PropFixedCols + PropFrozenCols) Then
                    RC.Left = RC.Right
                    RC.Right = RC.Right + GetColWidth(iCol)
                End If
            Next iCol
            If VBFlexGridInsertMarkAfter = False Then
                RC.Right = RC.Left + 1
                RC.Left = RC.Left - 1
            Else
                RC.Left = RC.Right - 1
                RC.Right = RC.Right + 1
            End If
            PatBlt hDC, RC.Left - 2, RC.Top, 6, 1, vbPatCopy
            PatBlt hDC, RC.Left - 1, RC.Top + 1, 4, 1, vbPatCopy
            PatBlt hDC, RC.Left, RC.Top + 2, RC.Right - RC.Left, RC.Bottom - RC.Top - 4, vbPatCopy
            PatBlt hDC, RC.Left - 1, RC.Bottom - 2, 4, 1, vbPatCopy
            PatBlt hDC, RC.Left - 2, RC.Bottom - 1, 6, 1, vbPatCopy
        End If
    End If
    If Brush <> NULL_PTR Then
        SelectObject hDC, Brush
        Brush = NULL_PTR
    End If
End If
If NoRgn = False Then
    If (VBFlexGridDrawInfo.Flags And DRAWINFO_FLAG_WALLPAPER) = 0 Then hRgn = CreateRectRgn(.Left, .Top, .Right, .Bottom)
End If
End With
SetBkMode hDC, OldBkMode
End Sub

Private Sub DrawFixedCell(ByRef hDC As LongPtr, ByRef CellRect As RECT, ByVal iRow As Long, ByVal iCol As Long)
Dim ItemState As Long
If PropMergeCells <> FlexMergeCellsNever Then
    If (VBFlexGridRow >= (iRow - VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset) And VBFlexGridRow <= iRow) And (VBFlexGridCol >= (iCol - VBFlexGridMergeDrawInfo.Row.ColOffset) And VBFlexGridCol <= iCol) Then
        iRow = VBFlexGridRow
        iCol = VBFlexGridCol
    Else
        iRow = iRow - VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset
        iCol = iCol - VBFlexGridMergeDrawInfo.Row.ColOffset
    End If
End If
With VBFlexGridDrawInfo.SelRange
If PropAllowMultiSelection = False Then
    Select Case PropHighLight
        Case FlexHighLightAlways, FlexHighLightAlwaysFocusRect
            If (iCol >= .LeftCol And iCol <= .RightCol) And (iRow >= .TopRow And iRow <= .BottomRow) Then ItemState = ItemState Or ODS_SELECTED
        Case FlexHighLightWithFocus
            If VBFlexGridFocused = True Then
                If (iCol >= .LeftCol And iCol <= .RightCol) And (iRow >= .TopRow And iRow <= .BottomRow) Then ItemState = ItemState Or ODS_SELECTED
            End If
    End Select
    If iCol > (PropFixedCols - 1) Then
        Select Case PropHighLight
            Case FlexHighLightAlways, FlexHighLightAlwaysFocusRect
                If (VBFlexGridCells.Rows(iRow).RowInfo.State And RWIS_SELECTED) = RWIS_SELECTED Then
                    If Not (ItemState And ODS_SELECTED) = ODS_SELECTED Then ItemState = ItemState Or ODS_SELECTED
                End If
            Case FlexHighLightWithFocus
                If VBFlexGridFocused = True Then
                    If (VBFlexGridCells.Rows(iRow).RowInfo.State And RWIS_SELECTED) = RWIS_SELECTED Then
                        If Not (ItemState And ODS_SELECTED) = ODS_SELECTED Then ItemState = ItemState Or ODS_SELECTED
                    End If
                End If
        End Select
    End If
Else
    If iCol > (PropFixedCols - 1) Then
        Select Case PropHighLight
            Case FlexHighLightAlways, FlexHighLightAlwaysFocusRect
                If (VBFlexGridCells.Rows(iRow).RowInfo.State And RWIS_SELECTED) = RWIS_SELECTED Then ItemState = ItemState Or ODS_SELECTED
            Case FlexHighLightWithFocus
                If VBFlexGridFocused = True Then
                    If (VBFlexGridCells.Rows(iRow).RowInfo.State And RWIS_SELECTED) = RWIS_SELECTED Then ItemState = ItemState Or ODS_SELECTED
                End If
        End Select
    End If
    If VBFlexGridCaptureRow > -1 And VBFlexGridCaptureCol > -1 Then
        Select Case PropHighLight
            Case FlexHighLightAlways, FlexHighLightAlwaysFocusRect
                If (iCol >= .LeftCol And iCol <= .RightCol) And (iRow >= .TopRow And iRow <= .BottomRow) Then
                    If VBFlexGridInvertSelection = False Then
                        If Not (ItemState And ODS_SELECTED) = ODS_SELECTED Then ItemState = ItemState Or ODS_SELECTED
                    Else
                        If (ItemState And ODS_SELECTED) = ODS_SELECTED Then ItemState = ItemState And Not ODS_SELECTED
                    End If
                End If
            Case FlexHighLightWithFocus
                If VBFlexGridFocused = True Then
                    If (iCol >= .LeftCol And iCol <= .RightCol) And (iRow >= .TopRow And iRow <= .BottomRow) Then
                        If VBFlexGridInvertSelection = False Then
                            If Not (ItemState And ODS_SELECTED) = ODS_SELECTED Then ItemState = ItemState Or ODS_SELECTED
                        Else
                            If (ItemState And ODS_SELECTED) = ODS_SELECTED Then ItemState = ItemState And Not ODS_SELECTED
                        End If
                    End If
                End If
        End Select
    End If
End If
End With
If PropFocusRect <> FlexFocusRectNone Then
    If (iRow = VBFlexGridRow And iCol = VBFlexGridCol) Then
        If PropHighLight <> FlexHighLightAlwaysFocusRect Or VBFlexGridFocused = True Then ItemState = ItemState Or ODS_FOCUS
    End If
End If
If VBFlexGridFocused = False Then ItemState = ItemState Or ODS_NOFOCUSRECT
If VBFlexGridDropHighlight > -1 Then
    If VBFlexGridDropHighlightMode = FlexDropTargetModeByRow Then
        If iRow = VBFlexGridDropHighlight Then
            If iCol >= PropFixedCols Then
                If Not (ItemState And ODS_SELECTED) = ODS_SELECTED Then ItemState = ItemState Or ODS_SELECTED
            Else
                If (ItemState And ODS_SELECTED) = ODS_SELECTED Then ItemState = ItemState And Not ODS_SELECTED
            End If
            If (ItemState And ODS_FOCUS) = ODS_FOCUS Then ItemState = ItemState And Not ODS_FOCUS
        End If
    ElseIf VBFlexGridDropHighlightMode = FlexDropTargetModeByColumn Then
        If iCol = VBFlexGridDropHighlight Then
            If iRow >= PropFixedRows Then
                If Not (ItemState And ODS_SELECTED) = ODS_SELECTED Then ItemState = ItemState Or ODS_SELECTED
            Else
                If (ItemState And ODS_SELECTED) = ODS_SELECTED Then ItemState = ItemState And Not ODS_SELECTED
            End If
            If (ItemState And ODS_FOCUS) = ODS_FOCUS Then ItemState = ItemState And Not ODS_FOCUS
        End If
    End If
End If
Call GetGridLineOffsetsStruct(iRow, iCol, VBFlexGridDrawInfo.GridLineOffsets)
Dim CellFmtg As TCELLFMTG
Call GetCellFmtg(iRow, iCol, CFM_TEXTSTYLE Or CFM_ALIGNMENT Or CFM_PICTURE Or CFM_PICTURERENDERFLAG Or CFM_PICTUREALIGNMENT Or CFM_BACKCOLOR Or CFM_FORECOLOR Or CFM_FLOODPERCENT Or CFM_FLOODCOLOR Or CFM_FONT, CellFmtg)
With CellFmtg
Dim ComboCue As FlexComboCueConstants, ComboCueWidth As Long, ComboCueAlignment As FlexLeftRightAlignmentConstants, ComboCueCtlType As Long, ComboCueItemState As Long
If PropAllowUserEditing = True Or PropAlwaysAllowComboCues = True Then
    ComboCue = GetComboCueActive(iRow, iCol)
    If ComboCue > FlexComboCueNone Then
        ComboCueWidth = GetComboButtonWidth(iRow, iCol, ComboCue)
        If (((CellRect.Right - CellRect.Left) - (VBFlexGridDrawInfo.GridLineOffsets.LeftTop.CX + VBFlexGridDrawInfo.GridLineOffsets.RightBottom.CX)) - ComboCueWidth) < 0 Then ComboCueWidth = ((CellRect.Right - CellRect.Left) - (VBFlexGridDrawInfo.GridLineOffsets.LeftTop.CX + VBFlexGridDrawInfo.GridLineOffsets.RightBottom.CX))
        If VBFlexGridColsInfo(iCol).ComboButtonAlignment = -1 Then
            ComboCueAlignment = VBFlexGridComboButtonAlignment
        Else
            ComboCueAlignment = VBFlexGridColsInfo(iCol).ComboButtonAlignment
        End If
        Select Case ComboCue
            Case FlexComboCueDropDown, FlexComboCueDisabledDropDown
                ComboCueCtlType = ODT_COMBOBOX
            Case FlexComboCueButton, FlexComboCueDisabledButton
                ComboCueCtlType = ODT_BUTTON
        End Select
        Select Case ComboCue
            Case FlexComboCueDropDown, FlexComboCueButton
                If VBFlexGridHotRow = iRow And VBFlexGridHotCol = iCol And VBFlexGridHotHitResult = FlexHitResultComboCue Then ComboCueItemState = ODS_HOTLIGHT
            Case FlexComboCueDisabledDropDown, FlexComboCueDisabledButton
                ComboCueItemState = ODS_DISABLED
        End Select
        If PropAlwaysAllowComboCues = True Then
            If VBFlexGridComboCueClickRow = iRow And VBFlexGridComboCueClickCol = iCol Then ComboCueItemState = ComboCueItemState Or ODS_SELECTED
        End If
    End If
End If
Dim TextIndent As TTEXTINDENT
If (VBFlexGridColsInfo(iCol).State And CLIS_TEXTINDENT) = CLIS_TEXTINDENT Then
    With TextIndent
    RaiseEvent CellTextIndent(iRow, iCol, .Left, .Right)
    If .Left > 0 Then .Left = UserControl.ScaleX(.Left, vbTwips, vbPixels) Else .Left = 0
    If .Right > 0 Then .Right = UserControl.ScaleX(.Right, vbTwips, vbPixels) Else .Right = 0
    End With
End If
Dim Text As String, TextRect As RECT, HiddenText As Boolean
Call GetCellText(iRow, iCol, Text)
Call GetTextDisplay(iRow, iCol, Text)
With TextRect
.Left = CellRect.Left + VBFlexGridPixelMetrics.TextPadding.CX + TextIndent.Left
.Top = CellRect.Top + VBFlexGridPixelMetrics.TextPadding.CY
.Right = CellRect.Right - VBFlexGridPixelMetrics.TextPadding.CX - TextIndent.Right
If ComboCueWidth > 0 Then
    If ComboCueAlignment = FlexLeftRightAlignmentRight Then
        .Right = .Right - ComboCueWidth
    ElseIf ComboCueAlignment = FlexLeftRightAlignmentLeft Then
        .Left = .Left + ComboCueWidth
    End If
End If
.Bottom = CellRect.Bottom - VBFlexGridPixelMetrics.TextPadding.CY
End With
Dim hFontTemp As LongPtr, hFontOld As LongPtr
If Not .FontName = vbNullString Then
    Dim TempFont As StdFont
    Set TempFont = New StdFont
    TempFont.Name = .FontName
    TempFont.Size = .FontSize
    TempFont.Bold = CBool((.FontStyle And FS_BOLD) = FS_BOLD)
    TempFont.Italic = CBool((.FontStyle And FS_ITALIC) = FS_ITALIC)
    TempFont.Strikethrough = CBool((.FontStyle And FS_STRIKEOUT) = FS_STRIKEOUT)
    TempFont.Underline = CBool((.FontStyle And FS_UNDERLINE) = FS_UNDERLINE)
    TempFont.Charset = .FontCharset
    hFontTemp = CreateGDIFontFromOLEFont(TempFont, PropFontQuality)
    hFontOld = SelectObject(hDC, hFontTemp)
    Set TempFont = Nothing
End If
Dim Brush As LongPtr, Color As Long
If Not (ItemState And ODS_SELECTED) = ODS_SELECTED Or (ItemState And ODS_FOCUS) = ODS_FOCUS Then
    If .BackColor = -1 Then
        PatBlt hDC, CellRect.Left, CellRect.Top, CellRect.Right - CellRect.Left, CellRect.Bottom - CellRect.Top, vbPatCopy
    Else
        Color = SetBkColor(hDC, WinColor(.BackColor))
        ExtTextOut hDC, 0, 0, ETO_OPAQUE, CellRect, NULL_PTR, 0, NULL_PTR
        SetBkColor hDC, Color
    End If
Else
    Brush = SelectObject(hDC, VBFlexGridBackColorSelBrush)
    PatBlt hDC, CellRect.Left, CellRect.Top, CellRect.Right - CellRect.Left, CellRect.Bottom - CellRect.Top, vbPatCopy
    SelectObject hDC, Brush
End If
If .FloodPercent <> 0 Then
    If .FloodColor = -1 Then Color = WinColor(PropFloodColor) Else Color = WinColor(.FloodColor)
    Call DrawCellFlooding(hDC, CellRect, .FloodPercent, Color)
End If
Dim hRgnOld As LongPtr
If Not .Picture Is Nothing Then
    If .Picture.Handle <> NULL_PTR Then
        Dim PictureRect As RECT, PictureWidth As Long, PictureHeight As Long
        Dim PictureLeft As Long, PictureTop As Long, PictureOffsetX As Long, PictureOffsetY As Long
        LSet PictureRect = CellRect
        If ComboCueWidth > 0 Then
            If ComboCueAlignment = FlexLeftRightAlignmentRight Then
                PictureRect.Right = PictureRect.Right - ComboCueWidth
            ElseIf ComboCueAlignment = FlexLeftRightAlignmentLeft Then
                PictureRect.Left = PictureRect.Left + ComboCueWidth
            End If
        End If
        If .PictureAlignment <> FlexPictureAlignmentStretch Then
            PictureWidth = CHimetricToPixel_X(.Picture.Width)
            PictureHeight = CHimetricToPixel_Y(.Picture.Height)
        Else
            PictureWidth = (PictureRect.Right - PictureRect.Left)
            PictureHeight = (PictureRect.Bottom - PictureRect.Top)
        End If
        PictureLeft = PictureRect.Left
        PictureTop = PictureRect.Top
        Select Case .PictureAlignment
            Case FlexPictureAlignmentLeftCenter, FlexPictureAlignmentLeftCenterNoOverlap
                PictureOffsetY = (((PictureRect.Bottom - PictureRect.Top) - PictureHeight) \ 2)
            Case FlexPictureAlignmentLeftBottom, FlexPictureAlignmentLeftBottomNoOverlap
                PictureOffsetY = ((PictureRect.Bottom - PictureRect.Top) - PictureHeight)
            Case FlexPictureAlignmentCenterTop
                PictureOffsetX = (((PictureRect.Right - PictureRect.Left) - PictureWidth) \ 2)
            Case FlexPictureAlignmentCenterCenter
                PictureOffsetX = (((PictureRect.Right - PictureRect.Left) - PictureWidth) \ 2)
                PictureOffsetY = (((PictureRect.Bottom - PictureRect.Top) - PictureHeight) \ 2)
            Case FlexPictureAlignmentCenterBottom
                PictureOffsetX = (((PictureRect.Right - PictureRect.Left) - PictureWidth) \ 2)
                PictureOffsetY = ((PictureRect.Bottom - PictureRect.Top) - PictureHeight)
            Case FlexPictureAlignmentRightTop, FlexPictureAlignmentRightTopNoOverlap
                PictureOffsetX = ((PictureRect.Right - PictureRect.Left) - PictureWidth)
            Case FlexPictureAlignmentRightCenter, FlexPictureAlignmentRightCenterNoOverlap
                PictureOffsetX = ((PictureRect.Right - PictureRect.Left) - PictureWidth)
                PictureOffsetY = (((PictureRect.Bottom - PictureRect.Top) - PictureHeight) \ 2)
            Case FlexPictureAlignmentRightBottom, FlexPictureAlignmentRightBottomNoOverlap
                PictureOffsetX = ((PictureRect.Right - PictureRect.Left) - PictureWidth)
                PictureOffsetY = ((PictureRect.Bottom - PictureRect.Top) - PictureHeight)
        End Select
        If PictureOffsetX > 0 Then PictureLeft = PictureLeft + PictureOffsetX
        If PictureOffsetY > 0 Then PictureTop = PictureTop + PictureOffsetY
        hRgnOld = CreateRectRgn(0, 0, 0, 0)
        If hRgnOld <> NULL_PTR Then
            If GetClipRgn(hDC, hRgnOld) = 0 Then
                DeleteObject hRgnOld
                hRgnOld = NULL_PTR
            End If
        End If
        IntersectClipRect hDC, PictureRect.Left, PictureRect.Top, PictureRect.Right, PictureRect.Bottom
        If .PictureAlignment <> FlexPictureAlignmentTile Then
            If .PictureRenderFlag = 0 Then
                Call RenderPicture(.Picture, hDC, PictureLeft, PictureTop, PictureWidth, PictureHeight, .PictureRenderFlag)
                Call SetCellFmtg(iRow, iCol, CFM_PICTURERENDERFLAG, CellFmtg)
            Else
                Call RenderPicture(.Picture, hDC, PictureLeft, PictureTop, PictureWidth, PictureHeight, .PictureRenderFlag)
            End If
        Else
            Do
                Do
                    If .PictureRenderFlag = 0 Then
                        Call RenderPicture(.Picture, hDC, PictureLeft, PictureTop, PictureWidth, PictureHeight, .PictureRenderFlag)
                        Call SetCellFmtg(iRow, iCol, CFM_PICTURERENDERFLAG, CellFmtg)
                    Else
                        Call RenderPicture(.Picture, hDC, PictureLeft, PictureTop, PictureWidth, PictureHeight, .PictureRenderFlag)
                    End If
                    PictureTop = PictureTop + PictureHeight
                Loop While PictureTop < PictureRect.Bottom
                PictureLeft = PictureLeft + PictureWidth
                PictureTop = PictureRect.Top
            Loop While PictureLeft < PictureRect.Right
        End If
        If hRgnOld <> NULL_PTR Then
            ExtSelectClipRgn hDC, hRgnOld, RGN_COPY
            DeleteObject hRgnOld
            hRgnOld = NULL_PTR
        Else
            ExtSelectClipRgn hDC, NULL_PTR, RGN_COPY
        End If
        Select Case .PictureAlignment
            Case FlexPictureAlignmentLeftTopNoOverlap, FlexPictureAlignmentLeftCenterNoOverlap, FlexPictureAlignmentLeftBottomNoOverlap
                TextRect.Left = TextRect.Left + PictureWidth
            Case FlexPictureAlignmentRightTopNoOverlap, FlexPictureAlignmentRightCenterNoOverlap, FlexPictureAlignmentRightBottomNoOverlap
                TextRect.Right = TextRect.Right - PictureWidth
        End Select
    End If
End If
If VBFlexGridColsInfo(iCol).ImageList.Handle <> NULL_PTR Then
    Dim ImageIndex As Long
    ImageIndex = GetImageIndex(iRow, iCol, Text)
    If ImageIndex > 0 Then
        Dim ImageRect As RECT, ImageAlignment As FlexAlignmentConstants, ImageWidth As Long, ImageHeight As Long
        Dim ImageLeft As Long, ImageTop As Long, ImageOffsetX As Long, ImageOffsetY As Long
        LSet ImageRect = CellRect
        If ComboCueWidth > 0 Then
            If ComboCueAlignment = FlexLeftRightAlignmentRight Then
                ImageRect.Right = ImageRect.Right - ComboCueWidth
            ElseIf ComboCueAlignment = FlexLeftRightAlignmentLeft Then
                ImageRect.Left = ImageRect.Left + ComboCueWidth
            End If
        End If
        If .Alignment = -1 Then
            If VBFlexGridColsInfo(iCol).FixedAlignment = -1 Then
                ImageAlignment = VBFlexGridColsInfo(iCol).Alignment
            Else
                ImageAlignment = VBFlexGridColsInfo(iCol).FixedAlignment
            End If
        Else
            ImageAlignment = .Alignment
        End If
        ImageWidth = VBFlexGridColsInfo(iCol).ImageList.Size.CX
        ImageHeight = VBFlexGridColsInfo(iCol).ImageList.Size.CY
        ImageLeft = ImageRect.Left
        ImageTop = ImageRect.Top
        Select Case ImageAlignment
            Case FlexAlignmentLeftCenter
                ImageOffsetY = (((ImageRect.Bottom - ImageRect.Top) - ImageHeight) \ 2)
            Case FlexAlignmentLeftBottom
                ImageOffsetY = ((ImageRect.Bottom - ImageRect.Top) - ImageHeight)
            Case FlexAlignmentCenterTop, FlexAlignmentGeneralTop
                ImageOffsetX = (((ImageRect.Right - ImageRect.Left) - ImageWidth) \ 2)
            Case FlexAlignmentCenterCenter, FlexAlignmentGeneral, FlexAlignmentGeneralCenter
                ImageOffsetX = (((ImageRect.Right - ImageRect.Left) - ImageWidth) \ 2)
                ImageOffsetY = (((ImageRect.Bottom - ImageRect.Top) - ImageHeight) \ 2)
            Case FlexAlignmentCenterBottom, FlexAlignmentGeneralBottom
                ImageOffsetX = (((ImageRect.Right - ImageRect.Left) - ImageWidth) \ 2)
                ImageOffsetY = ((ImageRect.Bottom - ImageRect.Top) - ImageHeight)
            Case FlexAlignmentRightTop
                ImageOffsetX = ((ImageRect.Right - ImageRect.Left) - ImageWidth)
            Case FlexAlignmentRightCenter
                ImageOffsetX = ((ImageRect.Right - ImageRect.Left) - ImageWidth)
                ImageOffsetY = (((ImageRect.Bottom - ImageRect.Top) - ImageHeight) \ 2)
            Case FlexAlignmentRightBottom
                ImageOffsetX = ((ImageRect.Right - ImageRect.Left) - ImageWidth)
                ImageOffsetY = ((ImageRect.Bottom - ImageRect.Top) - ImageHeight)
        End Select
        If ImageOffsetX > 0 Then ImageLeft = ImageLeft + ImageOffsetX
        If ImageOffsetY > 0 Then ImageTop = ImageTop + ImageOffsetY
        hRgnOld = CreateRectRgn(0, 0, 0, 0)
        If hRgnOld <> NULL_PTR Then
            If GetClipRgn(hDC, hRgnOld) = 0 Then
                DeleteObject hRgnOld
                hRgnOld = NULL_PTR
            End If
        End If
        IntersectClipRect hDC, ImageRect.Left, ImageRect.Top, ImageRect.Right, ImageRect.Bottom
        ImageList_Draw VBFlexGridColsInfo(iCol).ImageList.Handle, ImageIndex - 1, hDC, ImageLeft, ImageTop, ILD_TRANSPARENT
        If hRgnOld <> NULL_PTR Then
            ExtSelectClipRgn hDC, hRgnOld, RGN_COPY
            DeleteObject hRgnOld
            hRgnOld = NULL_PTR
        Else
            ExtSelectClipRgn hDC, NULL_PTR, RGN_COPY
        End If
        HiddenText = True
    End If
End If
Dim Checked As Integer
Checked = GetCellChecked(iRow, iCol)
If Checked > -1 Then
    Dim CheckBoxRect As RECT, CheckBoxAlignment As FlexCheckBoxAlignmentConstants, CheckBoxOffsetX As Long, CheckBoxOffsetY As Long
    LSet CheckBoxRect = TextRect
    If VBFlexGridColsInfo(iCol).FixedCheckBoxAlignment = -1 Then
        CheckBoxAlignment = VBFlexGridColsInfo(iCol).CheckBoxAlignment
    Else
        CheckBoxAlignment = VBFlexGridColsInfo(iCol).FixedCheckBoxAlignment
    End If
    If CheckBoxAlignment = FlexCheckBoxAlignmentUsePictureAlignment Then
        Select Case .PictureAlignment
            Case FlexPictureAlignmentLeftTop, FlexPictureAlignmentLeftCenter, FlexPictureAlignmentLeftBottom, FlexPictureAlignmentLeftTopNoOverlap, FlexPictureAlignmentLeftCenterNoOverlap, FlexPictureAlignmentLeftBottomNoOverlap
                CheckBoxAlignment = FlexCheckBoxAlignmentLeftCenter
            Case FlexPictureAlignmentCenterTop, FlexPictureAlignmentCenterCenter, FlexPictureAlignmentCenterBottom, FlexPictureAlignmentStretch, FlexPictureAlignmentTile
                CheckBoxAlignment = FlexCheckBoxAlignmentCenterCenter
            Case FlexPictureAlignmentRightTop, FlexPictureAlignmentRightCenter, FlexPictureAlignmentRightBottom, FlexPictureAlignmentRightTopNoOverlap, FlexPictureAlignmentRightCenterNoOverlap, FlexPictureAlignmentRightBottomNoOverlap
                CheckBoxAlignment = FlexCheckBoxAlignmentRightCenter
        End Select
    End If
    Select Case CheckBoxAlignment
        Case FlexCheckBoxAlignmentLeftCenter
            CheckBoxOffsetY = (((CheckBoxRect.Bottom - CheckBoxRect.Top) - VBFlexGridPixelMetrics.CheckBoxSize) \ 2)
        Case FlexCheckBoxAlignmentLeftBottom
            CheckBoxOffsetY = ((CheckBoxRect.Bottom - CheckBoxRect.Top) - VBFlexGridPixelMetrics.CheckBoxSize)
        Case FlexCheckBoxAlignmentCenterTop
            CheckBoxOffsetX = (((CheckBoxRect.Right - CheckBoxRect.Left) - VBFlexGridPixelMetrics.CheckBoxSize) \ 2)
        Case FlexCheckBoxAlignmentCenterCenter
            CheckBoxOffsetX = (((CheckBoxRect.Right - CheckBoxRect.Left) - VBFlexGridPixelMetrics.CheckBoxSize) \ 2)
            CheckBoxOffsetY = (((CheckBoxRect.Bottom - CheckBoxRect.Top) - VBFlexGridPixelMetrics.CheckBoxSize) \ 2)
        Case FlexCheckBoxAlignmentCenterBottom
            CheckBoxOffsetX = (((CheckBoxRect.Right - CheckBoxRect.Left) - VBFlexGridPixelMetrics.CheckBoxSize) \ 2)
            CheckBoxOffsetY = ((CheckBoxRect.Bottom - CheckBoxRect.Top) - VBFlexGridPixelMetrics.CheckBoxSize)
        Case FlexCheckBoxAlignmentRightTop
            CheckBoxOffsetX = ((CheckBoxRect.Right - CheckBoxRect.Left) - VBFlexGridPixelMetrics.CheckBoxSize)
        Case FlexCheckBoxAlignmentRightCenter
            CheckBoxOffsetX = ((CheckBoxRect.Right - CheckBoxRect.Left) - VBFlexGridPixelMetrics.CheckBoxSize)
            CheckBoxOffsetY = (((CheckBoxRect.Bottom - CheckBoxRect.Top) - VBFlexGridPixelMetrics.CheckBoxSize) \ 2)
        Case FlexCheckBoxAlignmentRightBottom
            CheckBoxOffsetX = ((CheckBoxRect.Right - CheckBoxRect.Left) - VBFlexGridPixelMetrics.CheckBoxSize)
            CheckBoxOffsetY = ((CheckBoxRect.Bottom - CheckBoxRect.Top) - VBFlexGridPixelMetrics.CheckBoxSize)
    End Select
    If CheckBoxOffsetX > 0 Then CheckBoxRect.Left = CheckBoxRect.Left + CheckBoxOffsetX
    If CheckBoxOffsetY > 0 Then CheckBoxRect.Top = CheckBoxRect.Top + CheckBoxOffsetY
    CheckBoxRect.Right = CheckBoxRect.Left + VBFlexGridPixelMetrics.CheckBoxSize
    CheckBoxRect.Bottom = CheckBoxRect.Top + VBFlexGridPixelMetrics.CheckBoxSize
    Call DrawCellCheckBox(hDC, CheckBoxRect, CellRect, Text, iRow, iCol, Checked)
    Select Case CheckBoxAlignment
        Case FlexCheckBoxAlignmentLeftTop, FlexCheckBoxAlignmentLeftCenter, FlexCheckBoxAlignmentLeftBottom
            TextRect.Left = TextRect.Left + VBFlexGridPixelMetrics.CheckBoxSize + VBFlexGridPixelMetrics.TextPadding.CX
        Case FlexCheckBoxAlignmentRightTop, FlexCheckBoxAlignmentRightCenter, FlexCheckBoxAlignmentRightBottom
            TextRect.Right = TextRect.Right - VBFlexGridPixelMetrics.CheckBoxSize - VBFlexGridPixelMetrics.TextPadding.CX
    End Select
    Select Case Checked
        Case FlexTextAsCheckBox, FlexDisabledTextAsCheckBox
            HiddenText = True
    End Select
End If
Dim OldTextColor As Long
If Not (ItemState And ODS_SELECTED) = ODS_SELECTED Or (ItemState And ODS_FOCUS) = ODS_FOCUS Then
    If Not Text = vbNullString Then
        If .ForeColor = -1 Then
            OldTextColor = SetTextColor(hDC, WinColor(PropForeColorFixed))
        Else
            OldTextColor = SetTextColor(hDC, WinColor(.ForeColor))
        End If
    Else
        OldTextColor = SetTextColor(hDC, GetSysColor(COLOR_BTNTEXT))
    End If
Else
    OldTextColor = SetTextColor(hDC, WinColor(PropForeColorSel))
End If
Dim hPenOld As LongPtr
Select Case PropGridLinesFixed
    Case FlexGridLineFlat, FlexGridLineDashes, FlexGridLineDots
        hPenOld = SelectObject(hDC, VBFlexGridGridLineFixedPen)
        Polyline hDC, VBFlexGridDrawInfo.GridLinePoints(0), 3
    Case FlexGridLineInset, FlexGridLineRaised
        If PropGridLinesFixed = FlexGridLineInset Then
            hPenOld = SelectObject(hDC, VBFlexGridGridLineBlackPen)
        ElseIf PropGridLinesFixed = FlexGridLineRaised Then
            hPenOld = SelectObject(hDC, VBFlexGridGridLineWhitePen)
        End If
        Polyline hDC, VBFlexGridDrawInfo.GridLinePoints(0), 3
        If PropGridLinesFixed = FlexGridLineInset Then
            SelectObject hDC, VBFlexGridGridLineWhitePen
        ElseIf PropGridLinesFixed = FlexGridLineRaised Then
            SelectObject hDC, VBFlexGridGridLineBlackPen
        End If
        Polyline hDC, VBFlexGridDrawInfo.GridLinePoints(3), 3
    Case FlexGridLineFlatHorz, FlexGridLineDashesHorz, FlexGridLineDotsHorz
        hPenOld = SelectObject(hDC, VBFlexGridGridLineFixedPen)
        VBFlexGridDrawInfo.GridLinePoints(1).X = VBFlexGridDrawInfo.GridLinePoints(1).X + 1
        Polyline hDC, VBFlexGridDrawInfo.GridLinePoints(0), 2
        VBFlexGridDrawInfo.GridLinePoints(1).X = VBFlexGridDrawInfo.GridLinePoints(1).X - 1
    Case FlexGridLineInsetHorz, FlexGridLineRaisedHorz
        If PropGridLinesFixed = FlexGridLineInsetHorz Then
            hPenOld = SelectObject(hDC, VBFlexGridGridLineBlackPen)
        ElseIf PropGridLinesFixed = FlexGridLineRaisedHorz Then
            hPenOld = SelectObject(hDC, VBFlexGridGridLineWhitePen)
        End If
        VBFlexGridDrawInfo.GridLinePoints(1).X = VBFlexGridDrawInfo.GridLinePoints(1).X + 1
        Polyline hDC, VBFlexGridDrawInfo.GridLinePoints(0), 2
        VBFlexGridDrawInfo.GridLinePoints(1).X = VBFlexGridDrawInfo.GridLinePoints(1).X - 1
        If PropGridLinesFixed = FlexGridLineInsetHorz Then
            SelectObject hDC, VBFlexGridGridLineWhitePen
        ElseIf PropGridLinesFixed = FlexGridLineRaisedHorz Then
            SelectObject hDC, VBFlexGridGridLineBlackPen
        End If
        VBFlexGridDrawInfo.GridLinePoints(3).X = VBFlexGridDrawInfo.GridLinePoints(3).X + 1
        VBFlexGridDrawInfo.GridLinePoints(4).X = VBFlexGridDrawInfo.GridLinePoints(4).X - 1
        Polyline hDC, VBFlexGridDrawInfo.GridLinePoints(3), 2
        VBFlexGridDrawInfo.GridLinePoints(3).X = VBFlexGridDrawInfo.GridLinePoints(3).X - 1
        VBFlexGridDrawInfo.GridLinePoints(4).X = VBFlexGridDrawInfo.GridLinePoints(4).X + 1
    Case FlexGridLineFlatVert, FlexGridLineDashesVert, FlexGridLineDotsVert
        hPenOld = SelectObject(hDC, VBFlexGridGridLineFixedPen)
        Polyline hDC, VBFlexGridDrawInfo.GridLinePoints(1), 2
    Case FlexGridLineInsetVert, FlexGridLineRaisedVert
        If PropGridLinesFixed = FlexGridLineInsetVert Then
            hPenOld = SelectObject(hDC, VBFlexGridGridLineBlackPen)
        ElseIf PropGridLinesFixed = FlexGridLineRaisedVert Then
            hPenOld = SelectObject(hDC, VBFlexGridGridLineWhitePen)
        End If
        Polyline hDC, VBFlexGridDrawInfo.GridLinePoints(1), 2
        If PropGridLinesFixed = FlexGridLineInsetVert Then
            SelectObject hDC, VBFlexGridGridLineWhitePen
        ElseIf PropGridLinesFixed = FlexGridLineRaisedVert Then
            SelectObject hDC, VBFlexGridGridLineBlackPen
        End If
        Polyline hDC, VBFlexGridDrawInfo.GridLinePoints(4), 2
End Select
If hPenOld <> NULL_PTR Then
    SelectObject hDC, hPenOld
    hPenOld = NULL_PTR
End If
If (ItemState And ODS_FOCUS) = ODS_FOCUS And Not (ItemState And ODS_NOFOCUSRECT) = ODS_NOFOCUSRECT Then
    Dim FocusRect As RECT
    With FocusRect
    .Left = CellRect.Left + VBFlexGridDrawInfo.GridLineOffsets.LeftTop.CX
    .Top = CellRect.Top + VBFlexGridDrawInfo.GridLineOffsets.LeftTop.CY
    .Right = CellRect.Right - VBFlexGridDrawInfo.GridLineOffsets.RightBottom.CX
    .Bottom = CellRect.Bottom - VBFlexGridDrawInfo.GridLineOffsets.RightBottom.CY
    Select Case PropFocusRect
        Case FlexFocusRectLight, FlexFocusRectHeavy
            If (.Right - VBFlexGridFocusBorder.CX) <= .Left Then .Right = CellRect.Right + 1
            If (.Bottom - VBFlexGridFocusBorder.CY) <= .Top Then .Bottom = CellRect.Bottom + 1
            If ComboCueWidth > 0 Then
                If ComboCueAlignment = FlexLeftRightAlignmentRight Then
                    .Right = .Right - ComboCueWidth
                ElseIf ComboCueAlignment = FlexLeftRightAlignmentLeft Then
                    .Left = .Left + ComboCueWidth
                End If
            End If
            DrawFocusRect hDC, FocusRect
            If PropFocusRect = FlexFocusRectHeavy Then
                If (.Right - VBFlexGridFocusBorder.CX) > (.Left + VBFlexGridFocusBorder.CX) And (.Bottom - VBFlexGridFocusBorder.CY) > (.Top + VBFlexGridFocusBorder.CY) Then
                    .Left = .Left + VBFlexGridFocusBorder.CX
                    .Right = .Right - VBFlexGridFocusBorder.CX
                    .Top = .Top + VBFlexGridFocusBorder.CY
                    .Bottom = .Bottom - VBFlexGridFocusBorder.CY
                    DrawFocusRect hDC, FocusRect
                End If
            End If
        Case FlexFocusRectFlat
            If (.Right - GetFocusRectWidth()) <= .Left Then .Right = CellRect.Right + 1
            If (.Bottom - GetFocusRectWidth()) <= .Top Then .Bottom = CellRect.Bottom + 1
            If ComboCueWidth > 0 Then
                If ComboCueAlignment = FlexLeftRightAlignmentRight Then
                    .Right = .Right - ComboCueWidth
                ElseIf ComboCueAlignment = FlexLeftRightAlignmentLeft Then
                    .Left = .Left + ComboCueWidth
                End If
            End If
            hPenOld = SelectObject(hDC, VBFlexGridFocusRectPen)
            Brush = SelectObject(hDC, GetStockObject(NULL_BRUSH))
            Rectangle hDC, .Left, .Top, .Right, .Bottom
            SelectObject hDC, Brush
            If hPenOld <> NULL_PTR Then
                SelectObject hDC, hPenOld
                hPenOld = NULL_PTR
            End If
    End Select
    End With
End If
Dim Alignment As FlexAlignmentConstants
If .Alignment = -1 Then
    If VBFlexGridColsInfo(iCol).FixedAlignment = -1 Then
        Alignment = VBFlexGridColsInfo(iCol).Alignment
    Else
        Alignment = VBFlexGridColsInfo(iCol).FixedAlignment
    End If
Else
    Alignment = .Alignment
End If
If VBFlexGridColsInfo(iCol).SortArrow <> FlexSortArrowNone And iRow = PropRowSortArrows Then
    Dim SortArrowMetrics As TSORTARROWMETRICS
    Call GetSortArrowMetrics(hDC, SortArrowMetrics)
    If (TextRect.Right - TextRect.Left) >= SortArrowMetrics.DrawSize.CX And TextRect.Bottom >= TextRect.Top Then
        Dim SortArrowVSpace As Long
        Select Case Alignment
            Case FlexAlignmentLeftCenter, FlexAlignmentCenterCenter, FlexAlignmentRightCenter, FlexAlignmentGeneral, FlexAlignmentGeneralCenter
                SortArrowVSpace = (((TextRect.Bottom - TextRect.Top) - SortArrowMetrics.ClientSize.CY) \ 2)
            Case FlexAlignmentLeftBottom, FlexAlignmentCenterBottom, FlexAlignmentRightBottom, FlexAlignmentGeneralBottom
                SortArrowVSpace = ((TextRect.Bottom - TextRect.Top) - SortArrowMetrics.ClientSize.CY)
        End Select
        Dim SortArrowPoints(0 To 2) As POINTAPI
        Select Case VBFlexGridColsInfo(iCol).SortArrow
            Case FlexSortArrowAscending
                If VBFlexGridColsInfo(iCol).SortArrowAlignment = FlexLeftRightAlignmentRight Then
                    SortArrowPoints(0).X = (TextRect.Right - 1) - (SortArrowMetrics.CalcSize.CX \ 2)
                    SortArrowPoints(0).Y = TextRect.Top + ((SortArrowMetrics.ClientSize.CY - SortArrowMetrics.CalcSize.CY) \ 2)
                    SortArrowPoints(1).X = (TextRect.Right - 1) - SortArrowMetrics.CalcSize.CX
                    SortArrowPoints(1).Y = SortArrowPoints(0).Y + SortArrowMetrics.CalcSize.CY
                    SortArrowPoints(2).X = (TextRect.Right - 1)
                    SortArrowPoints(2).Y = SortArrowPoints(0).Y + SortArrowMetrics.CalcSize.CY
                ElseIf VBFlexGridColsInfo(iCol).SortArrowAlignment = FlexLeftRightAlignmentLeft Then
                    SortArrowPoints(0).X = TextRect.Left + (SortArrowMetrics.CalcSize.CX \ 2)
                    SortArrowPoints(0).Y = TextRect.Top + ((SortArrowMetrics.ClientSize.CY - SortArrowMetrics.CalcSize.CY) \ 2)
                    SortArrowPoints(1).X = TextRect.Left + SortArrowMetrics.CalcSize.CX
                    SortArrowPoints(1).Y = SortArrowPoints(0).Y + SortArrowMetrics.CalcSize.CY
                    SortArrowPoints(2).X = TextRect.Left
                    SortArrowPoints(2).Y = SortArrowPoints(0).Y + SortArrowMetrics.CalcSize.CY
                End If
            Case FlexSortArrowDescending
                If VBFlexGridColsInfo(iCol).SortArrowAlignment = FlexLeftRightAlignmentRight Then
                    SortArrowPoints(0).X = (TextRect.Right - 1) - (SortArrowMetrics.CalcSize.CX \ 2)
                    SortArrowPoints(0).Y = TextRect.Top + SortArrowMetrics.CalcSize.CY + ((SortArrowMetrics.ClientSize.CY - SortArrowMetrics.CalcSize.CY) \ 2)
                    SortArrowPoints(1).X = (TextRect.Right - 1) - SortArrowMetrics.CalcSize.CX
                    SortArrowPoints(1).Y = SortArrowPoints(0).Y - SortArrowMetrics.CalcSize.CY
                    SortArrowPoints(2).X = (TextRect.Right - 1)
                    SortArrowPoints(2).Y = SortArrowPoints(0).Y - SortArrowMetrics.CalcSize.CY
                ElseIf VBFlexGridColsInfo(iCol).SortArrowAlignment = FlexLeftRightAlignmentLeft Then
                    SortArrowPoints(0).X = TextRect.Left + (SortArrowMetrics.CalcSize.CX \ 2)
                    SortArrowPoints(0).Y = TextRect.Top + SortArrowMetrics.CalcSize.CY + ((SortArrowMetrics.ClientSize.CY - SortArrowMetrics.CalcSize.CY) \ 2)
                    SortArrowPoints(1).X = TextRect.Left + SortArrowMetrics.CalcSize.CX
                    SortArrowPoints(1).Y = SortArrowPoints(0).Y - SortArrowMetrics.CalcSize.CY
                    SortArrowPoints(2).X = TextRect.Left
                    SortArrowPoints(2).Y = SortArrowPoints(0).Y - SortArrowMetrics.CalcSize.CY
                End If
        End Select
        If SortArrowVSpace > 0 Then
            SortArrowPoints(0).Y = SortArrowPoints(0).Y + SortArrowVSpace
            SortArrowPoints(1).Y = SortArrowPoints(1).Y + SortArrowVSpace
            SortArrowPoints(2).Y = SortArrowPoints(2).Y + SortArrowVSpace
        End If
        Dim SortArrowColor As Long
        If Not (ItemState And ODS_SELECTED) = ODS_SELECTED Or (ItemState And ODS_FOCUS) = ODS_FOCUS Then
            If VBFlexGridColsInfo(iCol).SortArrowColor = -1 Then
                SortArrowColor = WinColor(PropSortArrowColor)
            Else
                SortArrowColor = WinColor(VBFlexGridColsInfo(iCol).SortArrowColor)
            End If
        Else
            SortArrowColor = WinColor(PropForeColorSel)
        End If
        Call DrawSortArrow(hDC, SortArrowColor, SortArrowPoints(), TextRect)
    End If
    If VBFlexGridColsInfo(iCol).SortArrowAlignment = FlexLeftRightAlignmentRight Then
        TextRect.Right = TextRect.Right - SortArrowMetrics.ClientSize.CX
    ElseIf VBFlexGridColsInfo(iCol).SortArrowAlignment = FlexLeftRightAlignmentLeft Then
        TextRect.Left = TextRect.Left + SortArrowMetrics.ClientSize.CX
    End If
End If
If Not Text = vbNullString And TextRect.Right >= TextRect.Left And TextRect.Bottom >= TextRect.Top And HiddenText = False Then
    Dim TextStyle As FlexTextStyleConstants, DrawFlags As Long
    If .TextStyle = -1 Then
        TextStyle = PropTextStyleFixed
    Else
        TextStyle = .TextStyle
    End If
    DrawFlags = DT_NOPREFIX
    If VBFlexGridRTLReading = True Then DrawFlags = DrawFlags Or DT_RTLREADING
    Select Case Alignment
        Case FlexAlignmentLeftTop, FlexAlignmentLeftCenter, FlexAlignmentLeftBottom
            DrawFlags = DrawFlags Or DT_LEFT
        Case FlexAlignmentCenterTop, FlexAlignmentCenterCenter, FlexAlignmentCenterBottom
            DrawFlags = DrawFlags Or DT_CENTER
        Case FlexAlignmentRightTop, FlexAlignmentRightCenter, FlexAlignmentRightBottom
            DrawFlags = DrawFlags Or DT_RIGHT
        Case FlexAlignmentGeneral, FlexAlignmentGeneralTop, FlexAlignmentGeneralCenter, FlexAlignmentGeneralBottom
            If PropMirrorAlignGeneral = False Then
                If Not IsNumeric(Text) And Not IsDate(Text) Then
                    DrawFlags = DrawFlags Or DT_LEFT
                Else
                    DrawFlags = DrawFlags Or DT_RIGHT
                End If
            Else
                If Not IsNumeric(Text) And Not IsDate(Text) Then
                    DrawFlags = DrawFlags Or DT_RIGHT
                Else
                    DrawFlags = DrawFlags Or DT_LEFT
                End If
            End If
    End Select
    If VBFlexGridColsInfo(iCol).WordWrapOptionFixed = -1 Then
        If PropWordWrap = True Then
            DrawFlags = DrawFlags Or DT_WORDBREAK
        ElseIf PropSingleLine = True Then
            DrawFlags = DrawFlags Or DT_SINGLELINE
        End If
        Select Case PropEllipsisFormatFixed
            Case FlexEllipsisFormatEnd
                DrawFlags = DrawFlags Or DT_END_ELLIPSIS
            Case FlexEllipsisFormatPath
                DrawFlags = DrawFlags Or DT_PATH_ELLIPSIS
            Case FlexEllipsisFormatWord
                DrawFlags = DrawFlags Or DT_WORD_ELLIPSIS
        End Select
    Else
        Select Case VBFlexGridColsInfo(iCol).WordWrapOptionFixed
            Case FlexWordWrapNone
                ' Void
            Case FlexWordBreak
                DrawFlags = DrawFlags Or DT_WORDBREAK
            Case FlexSingleLine
                DrawFlags = DrawFlags Or DT_SINGLELINE
            Case FlexEndEllipsis
                DrawFlags = DrawFlags Or DT_END_ELLIPSIS
            Case FlexPathEllipsis
                DrawFlags = DrawFlags Or DT_PATH_ELLIPSIS
            Case FlexWordEllipsis
                DrawFlags = DrawFlags Or DT_WORD_ELLIPSIS
            Case FlexWordBreakEndEllipsis
                DrawFlags = DrawFlags Or DT_WORDBREAK Or DT_END_ELLIPSIS
            Case FlexWordBreakPathEllipsis
                DrawFlags = DrawFlags Or DT_WORDBREAK Or DT_PATH_ELLIPSIS
            Case FlexWordBreakWordEllipsis
                DrawFlags = DrawFlags Or DT_WORDBREAK Or DT_WORD_ELLIPSIS
            Case FlexSingleLineEndEllipsis
                DrawFlags = DrawFlags Or DT_SINGLELINE Or DT_END_ELLIPSIS
            Case FlexSingleLinePathEllipsis
                DrawFlags = DrawFlags Or DT_SINGLELINE Or DT_PATH_ELLIPSIS
            Case FlexSingleLineWordEllipsis
                DrawFlags = DrawFlags Or DT_SINGLELINE Or DT_WORD_ELLIPSIS
        End Select
    End If
    If VBFlexGridColsInfo(iCol).MimicTextBoxFixed = -1 Then
        If PropMimicTextBox = True Then DrawFlags = DrawFlags Or DT_EDITCONTROL
    Else
        If VBFlexGridColsInfo(iCol).MimicTextBoxFixed = FlexMimicTextBoxOn Then DrawFlags = DrawFlags Or DT_EDITCONTROL
    End If
    If Not (DrawFlags And DT_SINGLELINE) = DT_SINGLELINE Then
        Dim CalcRect As RECT, Height As Long, Result As Long
        Select Case Alignment
            Case FlexAlignmentLeftCenter, FlexAlignmentCenterCenter, FlexAlignmentRightCenter, FlexAlignmentGeneral, FlexAlignmentGeneralCenter
                LSet CalcRect = TextRect
                Height = DrawText(hDC, StrPtr(Text), -1, CalcRect, DrawFlags Or DT_CALCRECT)
                Result = (((TextRect.Bottom - TextRect.Top) - Height) \ 2)
            Case FlexAlignmentLeftBottom, FlexAlignmentCenterBottom, FlexAlignmentRightBottom, FlexAlignmentGeneralBottom
                LSet CalcRect = TextRect
                Height = DrawText(hDC, StrPtr(Text), -1, CalcRect, DrawFlags Or DT_CALCRECT)
                Result = ((TextRect.Bottom - TextRect.Top) - Height)
        End Select
        If Result > 0 Then TextRect.Top = TextRect.Top + Result
    Else
        Select Case Alignment
            Case FlexAlignmentLeftCenter, FlexAlignmentCenterCenter, FlexAlignmentRightCenter, FlexAlignmentGeneral, FlexAlignmentGeneralCenter
                DrawFlags = DrawFlags Or DT_VCENTER
            Case FlexAlignmentLeftBottom, FlexAlignmentCenterBottom, FlexAlignmentRightBottom, FlexAlignmentGeneralBottom
                DrawFlags = DrawFlags Or DT_BOTTOM
        End Select
    End If
    Dim TempTextColor As Long
    Select Case TextStyle
        Case FlexTextStyleRaised
            TempTextColor = SetTextColor(hDC, &H808080)
            SetRect TextRect, TextRect.Left + 1, TextRect.Top + 1, TextRect.Right + 1, TextRect.Bottom + 1
            DrawText hDC, StrPtr(Text), -1, TextRect, DrawFlags
            SetTextColor hDC, vbWhite
            SetRect TextRect, TextRect.Left - 2, TextRect.Top - 2, TextRect.Right - 2, TextRect.Bottom - 2
            DrawText hDC, StrPtr(Text), -1, TextRect, DrawFlags
            SetTextColor hDC, TempTextColor
            SetRect TextRect, TextRect.Left + 1, TextRect.Top + 1, TextRect.Right + 1, TextRect.Bottom + 1
        Case FlexTextStyleInset
            TempTextColor = SetTextColor(hDC, vbWhite)
            SetRect TextRect, TextRect.Left + 1, TextRect.Top + 1, TextRect.Right + 1, TextRect.Bottom + 1
            DrawText hDC, StrPtr(Text), -1, TextRect, DrawFlags
            SetTextColor hDC, &H808080
            SetRect TextRect, TextRect.Left - 2, TextRect.Top - 2, TextRect.Right - 2, TextRect.Bottom - 2
            DrawText hDC, StrPtr(Text), -1, TextRect, DrawFlags
            SetTextColor hDC, TempTextColor
            SetRect TextRect, TextRect.Left + 1, TextRect.Top + 1, TextRect.Right + 1, TextRect.Bottom + 1
        Case FlexTextStyleRaisedLight
            TempTextColor = SetTextColor(hDC, vbWhite)
            SetRect TextRect, TextRect.Left - 1, TextRect.Top - 1, TextRect.Right - 1, TextRect.Bottom - 1
            DrawText hDC, StrPtr(Text), -1, TextRect, DrawFlags
            SetTextColor hDC, TempTextColor
            SetRect TextRect, TextRect.Left + 1, TextRect.Top + 1, TextRect.Right + 1, TextRect.Bottom + 1
        Case FlexTextStyleInsetLight
            TempTextColor = SetTextColor(hDC, vbWhite)
            SetRect TextRect, TextRect.Left + 1, TextRect.Top + 1, TextRect.Right + 1, TextRect.Bottom + 1
            DrawText hDC, StrPtr(Text), -1, TextRect, DrawFlags
            SetTextColor hDC, TempTextColor
            SetRect TextRect, TextRect.Left - 1, TextRect.Top - 1, TextRect.Right - 1, TextRect.Bottom - 1
    End Select
    DrawText hDC, StrPtr(Text), -1, TextRect, DrawFlags
    If (iRow = VBFlexGridIncrementalSearch.Row And iCol = VBFlexGridIncrementalSearch.Col) Then Call DrawIncrementalSearch(hDC, Text, TextRect, DrawFlags)
End If
SetTextColor hDC, OldTextColor
If hFontOld <> NULL_PTR Then SelectObject hDC, hFontOld
If hFontTemp <> NULL_PTR Then DeleteObject hFontTemp
End With
If ComboCueWidth > 0 Then
    Dim DIS As DRAWITEMSTRUCT, P As POINTAPI
    DIS.CtlType = ComboCueCtlType
    DIS.CtlID = ID_COMBOBUTTONCHILD
    DIS.ItemID = 0
    DIS.ItemAction = ODA_DRAWENTIRE
    DIS.ItemState = ComboCueItemState
    DIS.hWndItem = VBFlexGridHandle
    DIS.hDC = hDC
    DIS.RCItem.Left = 0
    DIS.RCItem.Top = 0
    DIS.RCItem.Right = ComboCueWidth
    DIS.RCItem.Bottom = (CellRect.Bottom - CellRect.Top) - (VBFlexGridDrawInfo.GridLineOffsets.LeftTop.CY + VBFlexGridDrawInfo.GridLineOffsets.RightBottom.CY)
    DIS.ItemData = 0
    If ComboCueAlignment = FlexLeftRightAlignmentRight Then
        SetViewportOrgEx DIS.hDC, CellRect.Right - ComboCueWidth - VBFlexGridDrawInfo.GridLineOffsets.RightBottom.CX, CellRect.Top + VBFlexGridDrawInfo.GridLineOffsets.LeftTop.CY, P
    ElseIf ComboCueAlignment = FlexLeftRightAlignmentLeft Then
        SetViewportOrgEx DIS.hDC, CellRect.Left + VBFlexGridDrawInfo.GridLineOffsets.LeftTop.CX, CellRect.Top + VBFlexGridDrawInfo.GridLineOffsets.LeftTop.CY, P
    End If
    Call ComboButtonDraw(iRow, iCol, DIS)
    SetViewportOrgEx DIS.hDC, P.X, P.Y, P
End If
If VBFlexGridDoDragRowCol = True Then
    If VBFlexGridDoDragRow > -1 Then
        If iRow = VBFlexGridDoDragRow Then
            If iCol < PropFixedCols Then InvertRect hDC, CellRect: Exit Sub
        End If
    ElseIf VBFlexGridDoDragCol > -1 Then
        If iCol = VBFlexGridDoDragCol Then
            If iRow < PropFixedRows Then InvertRect hDC, CellRect: Exit Sub
        End If
    End If
End If
If VBFlexGridDropHighlight > -1 Then
    If VBFlexGridDropHighlightMode = FlexDropTargetModeByRow Then
        If iRow = VBFlexGridDropHighlight Then
            If iCol < PropFixedCols Then InvertRect hDC, CellRect
        End If
    ElseIf VBFlexGridDropHighlightMode = FlexDropTargetModeByColumn Then
        If iCol = VBFlexGridDropHighlight Then
            If iRow < PropFixedRows Then InvertRect hDC, CellRect
        End If
    End If
End If
End Sub

Private Sub DrawCell(ByRef hDC As LongPtr, ByRef CellRect As RECT, ByVal iRow As Long, ByVal iCol As Long)
Dim ItemState As Long
If PropMergeCells <> FlexMergeCellsNever Then
    If (VBFlexGridRow >= (iRow - VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset) And VBFlexGridRow <= iRow) And (VBFlexGridCol >= (iCol - VBFlexGridMergeDrawInfo.Row.ColOffset) And VBFlexGridCol <= iCol) Then
        iRow = VBFlexGridRow
        iCol = VBFlexGridCol
    Else
        iRow = iRow - VBFlexGridMergeDrawInfo.Row.Cols(iCol).RowOffset
        iCol = iCol - VBFlexGridMergeDrawInfo.Row.ColOffset
    End If
End If
With VBFlexGridDrawInfo.SelRange
If PropAllowMultiSelection = False Then
    Select Case PropSelectionMode
        Case FlexSelectionModeFree, FlexSelectionModeByRow, FlexSelectionModeByColumn
            Select Case PropHighLight
                Case FlexHighLightAlways, FlexHighLightAlwaysFocusRect
                    If (iCol >= .LeftCol And iCol <= .RightCol) And (iRow >= .TopRow And iRow <= .BottomRow) Then ItemState = ItemState Or ODS_SELECTED
                Case FlexHighLightWithFocus
                    If VBFlexGridFocused = True Then
                        If (iCol >= .LeftCol And iCol <= .RightCol) And (iRow >= .TopRow And iRow <= .BottomRow) Then ItemState = ItemState Or ODS_SELECTED
                    End If
            End Select
        Case FlexSelectionModeFreeByRow
            Select Case PropHighLight
                Case FlexHighLightAlways, FlexHighLightAlwaysFocusRect
                    If (iRow >= .TopRow And iRow <= .BottomRow) Then ItemState = ItemState Or ODS_SELECTED
                Case FlexHighLightWithFocus
                    If VBFlexGridFocused = True Then
                        If (iRow >= .TopRow And iRow <= .BottomRow) Then ItemState = ItemState Or ODS_SELECTED
                    End If
            End Select
        Case FlexSelectionModeFreeByColumn
            Select Case PropHighLight
                Case FlexHighLightAlways, FlexHighLightAlwaysFocusRect
                    If (iCol >= .LeftCol And iCol <= .RightCol) Then ItemState = ItemState Or ODS_SELECTED
                Case FlexHighLightWithFocus
                    If VBFlexGridFocused = True Then
                        If (iCol >= .LeftCol And iCol <= .RightCol) Then ItemState = ItemState Or ODS_SELECTED
                    End If
            End Select
    End Select
    Select Case PropHighLight
        Case FlexHighLightAlways, FlexHighLightAlwaysFocusRect
            If (VBFlexGridCells.Rows(iRow).RowInfo.State And RWIS_SELECTED) = RWIS_SELECTED Then
                If Not (ItemState And ODS_SELECTED) = ODS_SELECTED Then ItemState = ItemState Or ODS_SELECTED
            End If
        Case FlexHighLightWithFocus
            If VBFlexGridFocused = True Then
                If (VBFlexGridCells.Rows(iRow).RowInfo.State And RWIS_SELECTED) = RWIS_SELECTED Then
                    If Not (ItemState And ODS_SELECTED) = ODS_SELECTED Then ItemState = ItemState Or ODS_SELECTED
                End If
            End If
    End Select
Else
    Select Case PropHighLight
        Case FlexHighLightAlways, FlexHighLightAlwaysFocusRect
            If (VBFlexGridCells.Rows(iRow).RowInfo.State And RWIS_SELECTED) = RWIS_SELECTED Then ItemState = ItemState Or ODS_SELECTED
        Case FlexHighLightWithFocus
            If VBFlexGridFocused = True Then
                If (VBFlexGridCells.Rows(iRow).RowInfo.State And RWIS_SELECTED) = RWIS_SELECTED Then ItemState = ItemState Or ODS_SELECTED
            End If
    End Select
    If VBFlexGridCaptureRow > -1 And VBFlexGridCaptureCol > -1 Then
        Select Case PropSelectionMode
            Case FlexSelectionModeFree, FlexSelectionModeByRow, FlexSelectionModeByColumn
                Select Case PropHighLight
                    Case FlexHighLightAlways, FlexHighLightAlwaysFocusRect
                        If (iCol >= .LeftCol And iCol <= .RightCol) And (iRow >= .TopRow And iRow <= .BottomRow) Then
                            If VBFlexGridInvertSelection = False Then
                                If Not (ItemState And ODS_SELECTED) = ODS_SELECTED Then ItemState = ItemState Or ODS_SELECTED
                            Else
                                If (ItemState And ODS_SELECTED) = ODS_SELECTED Then ItemState = ItemState And Not ODS_SELECTED
                            End If
                        End If
                    Case FlexHighLightWithFocus
                        If VBFlexGridFocused = True Then
                            If (iCol >= .LeftCol And iCol <= .RightCol) And (iRow >= .TopRow And iRow <= .BottomRow) Then
                                If VBFlexGridInvertSelection = False Then
                                    If Not (ItemState And ODS_SELECTED) = ODS_SELECTED Then ItemState = ItemState Or ODS_SELECTED
                                Else
                                    If (ItemState And ODS_SELECTED) = ODS_SELECTED Then ItemState = ItemState And Not ODS_SELECTED
                                End If
                            End If
                        End If
                End Select
            Case FlexSelectionModeFreeByRow
                Select Case PropHighLight
                    Case FlexHighLightAlways, FlexHighLightAlwaysFocusRect
                        If (iRow >= .TopRow And iRow <= .BottomRow) Then
                            If VBFlexGridInvertSelection = False Then
                                If Not (ItemState And ODS_SELECTED) = ODS_SELECTED Then ItemState = ItemState Or ODS_SELECTED
                            Else
                                If (ItemState And ODS_SELECTED) = ODS_SELECTED Then ItemState = ItemState And Not ODS_SELECTED
                            End If
                        End If
                    Case FlexHighLightWithFocus
                        If VBFlexGridFocused = True Then
                            If (iRow >= .TopRow And iRow <= .BottomRow) Then
                                If VBFlexGridInvertSelection = False Then
                                    If Not (ItemState And ODS_SELECTED) = ODS_SELECTED Then ItemState = ItemState Or ODS_SELECTED
                                Else
                                    If (ItemState And ODS_SELECTED) = ODS_SELECTED Then ItemState = ItemState And Not ODS_SELECTED
                                End If
                            End If
                        End If
                End Select
            Case FlexSelectionModeFreeByColumn
                Select Case PropHighLight
                    Case FlexHighLightAlways, FlexHighLightAlwaysFocusRect
                        If (iCol >= .LeftCol And iCol <= .RightCol) Then
                            If VBFlexGridInvertSelection = False Then
                                If Not (ItemState And ODS_SELECTED) = ODS_SELECTED Then ItemState = ItemState Or ODS_SELECTED
                            Else
                                If (ItemState And ODS_SELECTED) = ODS_SELECTED Then ItemState = ItemState And Not ODS_SELECTED
                            End If
                        End If
                    Case FlexHighLightWithFocus
                        If VBFlexGridFocused = True Then
                            If (iCol >= .LeftCol And iCol <= .RightCol) Then
                                If VBFlexGridInvertSelection = False Then
                                    If Not (ItemState And ODS_SELECTED) = ODS_SELECTED Then ItemState = ItemState Or ODS_SELECTED
                                Else
                                    If (ItemState And ODS_SELECTED) = ODS_SELECTED Then ItemState = ItemState And Not ODS_SELECTED
                                End If
                            End If
                        End If
                End Select
        End Select
    End If
End If
End With
If PropFocusRect <> FlexFocusRectNone Then
    If (iRow = VBFlexGridRow And iCol = VBFlexGridCol) Then
        If PropHighLight <> FlexHighLightAlwaysFocusRect Or VBFlexGridFocused = True Then ItemState = ItemState Or ODS_FOCUS
    End If
End If
If VBFlexGridFocused = False Then ItemState = ItemState Or ODS_NOFOCUSRECT
If VBFlexGridDropHighlight > -1 Then
    If VBFlexGridDropHighlightMode = FlexDropTargetModeByRow Then
        If iRow = VBFlexGridDropHighlight Then
            If Not (ItemState And ODS_SELECTED) = ODS_SELECTED Then ItemState = ItemState Or ODS_SELECTED
            If (ItemState And ODS_FOCUS) = ODS_FOCUS Then ItemState = ItemState And Not ODS_FOCUS
        End If
    ElseIf VBFlexGridDropHighlightMode = FlexDropTargetModeByColumn Then
        If iCol = VBFlexGridDropHighlight Then
            If Not (ItemState And ODS_SELECTED) = ODS_SELECTED Then ItemState = ItemState Or ODS_SELECTED
            If (ItemState And ODS_FOCUS) = ODS_FOCUS Then ItemState = ItemState And Not ODS_FOCUS
        End If
    End If
End If
Call GetGridLineOffsetsStruct(iRow, iCol, VBFlexGridDrawInfo.GridLineOffsets)
Dim CellFmtg As TCELLFMTG
Call GetCellFmtg(iRow, iCol, CFM_TEXTSTYLE Or CFM_ALIGNMENT Or CFM_PICTURE Or CFM_PICTURERENDERFLAG Or CFM_PICTUREALIGNMENT Or CFM_BACKCOLOR Or CFM_FORECOLOR Or CFM_FLOODPERCENT Or CFM_FLOODCOLOR Or CFM_FONT, CellFmtg)
With CellFmtg
Dim ComboCue As FlexComboCueConstants, ComboCueWidth As Long, ComboCueAlignment As FlexLeftRightAlignmentConstants, ComboCueCtlType As Long, ComboCueItemState As Long
If PropAllowUserEditing = True Or PropAlwaysAllowComboCues = True Then
    ComboCue = GetComboCueActive(iRow, iCol)
    If ComboCue > FlexComboCueNone Then
        ComboCueWidth = GetComboButtonWidth(iRow, iCol, ComboCue)
        If (((CellRect.Right - CellRect.Left) - (VBFlexGridDrawInfo.GridLineOffsets.LeftTop.CX + VBFlexGridDrawInfo.GridLineOffsets.RightBottom.CX)) - ComboCueWidth) < 0 Then ComboCueWidth = ((CellRect.Right - CellRect.Left) - (VBFlexGridDrawInfo.GridLineOffsets.LeftTop.CX + VBFlexGridDrawInfo.GridLineOffsets.RightBottom.CX))
        If VBFlexGridColsInfo(iCol).ComboButtonAlignment = -1 Then
            ComboCueAlignment = VBFlexGridComboButtonAlignment
        Else
            ComboCueAlignment = VBFlexGridColsInfo(iCol).ComboButtonAlignment
        End If
        Select Case ComboCue
            Case FlexComboCueDropDown, FlexComboCueDisabledDropDown
                ComboCueCtlType = ODT_COMBOBOX
            Case FlexComboCueButton, FlexComboCueDisabledButton
                ComboCueCtlType = ODT_BUTTON
        End Select
        Select Case ComboCue
            Case FlexComboCueDropDown, FlexComboCueButton
                If VBFlexGridHotRow = iRow And VBFlexGridHotCol = iCol And VBFlexGridHotHitResult = FlexHitResultComboCue Then ComboCueItemState = ODS_HOTLIGHT
            Case FlexComboCueDisabledDropDown, FlexComboCueDisabledButton
                ComboCueItemState = ODS_DISABLED
        End Select
        If PropAlwaysAllowComboCues = True Then
            If VBFlexGridComboCueClickRow = iRow And VBFlexGridComboCueClickCol = iCol Then ComboCueItemState = ComboCueItemState Or ODS_SELECTED
        End If
    End If
End If
Dim TextIndent As TTEXTINDENT
If (VBFlexGridColsInfo(iCol).State And CLIS_TEXTINDENT) = CLIS_TEXTINDENT Then
    With TextIndent
    RaiseEvent CellTextIndent(iRow, iCol, .Left, .Right)
    If .Left > 0 Then .Left = UserControl.ScaleX(.Left, vbTwips, vbPixels) Else .Left = 0
    If .Right > 0 Then .Right = UserControl.ScaleX(.Right, vbTwips, vbPixels) Else .Right = 0
    End With
End If
Dim Text As String, TextRect As RECT, HiddenText As Boolean
Call GetCellText(iRow, iCol, Text)
Call GetTextDisplay(iRow, iCol, Text)
With TextRect
.Left = CellRect.Left + VBFlexGridPixelMetrics.TextPadding.CX + TextIndent.Left
.Top = CellRect.Top + VBFlexGridPixelMetrics.TextPadding.CY
.Right = CellRect.Right - VBFlexGridPixelMetrics.TextPadding.CX - TextIndent.Right
If ComboCueWidth > 0 Then
    If ComboCueAlignment = FlexLeftRightAlignmentRight Then
        .Right = .Right - ComboCueWidth
    ElseIf ComboCueAlignment = FlexLeftRightAlignmentLeft Then
        .Left = .Left + ComboCueWidth
    End If
End If
.Bottom = CellRect.Bottom - VBFlexGridPixelMetrics.TextPadding.CY
End With
Dim hFontTemp As LongPtr, hFontOld As LongPtr
If Not .FontName = vbNullString Then
    Dim TempFont As StdFont
    Set TempFont = New StdFont
    TempFont.Name = .FontName
    TempFont.Size = .FontSize
    TempFont.Bold = CBool((.FontStyle And FS_BOLD) = FS_BOLD)
    TempFont.Italic = CBool((.FontStyle And FS_ITALIC) = FS_ITALIC)
    TempFont.Strikethrough = CBool((.FontStyle And FS_STRIKEOUT) = FS_STRIKEOUT)
    TempFont.Underline = CBool((.FontStyle And FS_UNDERLINE) = FS_UNDERLINE)
    TempFont.Charset = .FontCharset
    hFontTemp = CreateGDIFontFromOLEFont(TempFont, PropFontQuality)
    hFontOld = SelectObject(hDC, hFontTemp)
    Set TempFont = Nothing
End If
Dim Brush As LongPtr, Color As Long
If Not (ItemState And ODS_SELECTED) = ODS_SELECTED Or (ItemState And ODS_FOCUS) = ODS_FOCUS Then
    If .BackColor = -1 Then
        If PropBackColor = PropBackColorAlt Then
            If (VBFlexGridDrawInfo.Flags And DRAWINFO_FLAG_WALLPAPER) = 0 Then PatBlt hDC, CellRect.Left, CellRect.Top, CellRect.Right - CellRect.Left, CellRect.Bottom - CellRect.Top, vbPatCopy
        Else
            If (iRow - PropFixedRows) Mod 2 = 0 Then
                If (VBFlexGridDrawInfo.Flags And DRAWINFO_FLAG_WALLPAPER) = 0 Then PatBlt hDC, CellRect.Left, CellRect.Top, CellRect.Right - CellRect.Left, CellRect.Bottom - CellRect.Top, vbPatCopy
            Else
                Brush = SelectObject(hDC, VBFlexGridBackColorAltBrush)
                PatBlt hDC, CellRect.Left, CellRect.Top, CellRect.Right - CellRect.Left, CellRect.Bottom - CellRect.Top, vbPatCopy
                SelectObject hDC, Brush
            End If
        End If
    Else
        Color = SetBkColor(hDC, WinColor(.BackColor))
        ExtTextOut hDC, 0, 0, ETO_OPAQUE, CellRect, NULL_PTR, 0, NULL_PTR
        SetBkColor hDC, Color
    End If
Else
    Brush = SelectObject(hDC, VBFlexGridBackColorSelBrush)
    PatBlt hDC, CellRect.Left, CellRect.Top, CellRect.Right - CellRect.Left, CellRect.Bottom - CellRect.Top, vbPatCopy
    SelectObject hDC, Brush
End If
If .FloodPercent <> 0 Then
    If .FloodColor = -1 Then Color = WinColor(PropFloodColor) Else Color = WinColor(.FloodColor)
    Call DrawCellFlooding(hDC, CellRect, .FloodPercent, Color)
End If
Dim hRgnOld As LongPtr
If Not .Picture Is Nothing Then
    If .Picture.Handle <> NULL_PTR Then
        Dim PictureRect As RECT, PictureWidth As Long, PictureHeight As Long
        Dim PictureLeft As Long, PictureTop As Long, PictureOffsetX As Long, PictureOffsetY As Long
        LSet PictureRect = CellRect
        If ComboCueWidth > 0 Then
            If ComboCueAlignment = FlexLeftRightAlignmentRight Then
                PictureRect.Right = PictureRect.Right - ComboCueWidth
            ElseIf ComboCueAlignment = FlexLeftRightAlignmentLeft Then
                PictureRect.Left = PictureRect.Left + ComboCueWidth
            End If
        End If
        If .PictureAlignment <> FlexPictureAlignmentStretch Then
            PictureWidth = CHimetricToPixel_X(.Picture.Width)
            PictureHeight = CHimetricToPixel_Y(.Picture.Height)
        Else
            PictureWidth = (PictureRect.Right - PictureRect.Left)
            PictureHeight = (PictureRect.Bottom - PictureRect.Top)
        End If
        PictureLeft = PictureRect.Left
        PictureTop = PictureRect.Top
        Select Case .PictureAlignment
            Case FlexPictureAlignmentLeftCenter, FlexPictureAlignmentLeftCenterNoOverlap
                PictureOffsetY = (((PictureRect.Bottom - PictureRect.Top) - PictureHeight) \ 2)
            Case FlexPictureAlignmentLeftBottom, FlexPictureAlignmentLeftBottomNoOverlap
                PictureOffsetY = ((PictureRect.Bottom - PictureRect.Top) - PictureHeight)
            Case FlexPictureAlignmentCenterTop
                PictureOffsetX = (((PictureRect.Right - PictureRect.Left) - PictureWidth) \ 2)
            Case FlexPictureAlignmentCenterCenter
                PictureOffsetX = (((PictureRect.Right - PictureRect.Left) - PictureWidth) \ 2)
                PictureOffsetY = (((PictureRect.Bottom - PictureRect.Top) - PictureHeight) \ 2)
            Case FlexPictureAlignmentCenterBottom
                PictureOffsetX = (((PictureRect.Right - PictureRect.Left) - PictureWidth) \ 2)
                PictureOffsetY = ((PictureRect.Bottom - PictureRect.Top) - PictureHeight)
            Case FlexPictureAlignmentRightTop, FlexPictureAlignmentRightTopNoOverlap
                PictureOffsetX = ((PictureRect.Right - PictureRect.Left) - PictureWidth)
            Case FlexPictureAlignmentRightCenter, FlexPictureAlignmentRightCenterNoOverlap
                PictureOffsetX = ((PictureRect.Right - PictureRect.Left) - PictureWidth)
                PictureOffsetY = (((PictureRect.Bottom - PictureRect.Top) - PictureHeight) \ 2)
            Case FlexPictureAlignmentRightBottom, FlexPictureAlignmentRightBottomNoOverlap
                PictureOffsetX = ((PictureRect.Right - PictureRect.Left) - PictureWidth)
                PictureOffsetY = ((PictureRect.Bottom - PictureRect.Top) - PictureHeight)
        End Select
        If PictureOffsetX > 0 Then PictureLeft = PictureLeft + PictureOffsetX
        If PictureOffsetY > 0 Then PictureTop = PictureTop + PictureOffsetY
        hRgnOld = CreateRectRgn(0, 0, 0, 0)
        If hRgnOld <> NULL_PTR Then
            If GetClipRgn(hDC, hRgnOld) = 0 Then
                DeleteObject hRgnOld
                hRgnOld = NULL_PTR
            End If
        End If
        IntersectClipRect hDC, PictureRect.Left, PictureRect.Top, PictureRect.Right, PictureRect.Bottom
        If .PictureAlignment <> FlexPictureAlignmentTile Then
            If .PictureRenderFlag = 0 Then
                Call RenderPicture(.Picture, hDC, PictureLeft, PictureTop, PictureWidth, PictureHeight, .PictureRenderFlag)
                Call SetCellFmtg(iRow, iCol, CFM_PICTURERENDERFLAG, CellFmtg)
            Else
                Call RenderPicture(.Picture, hDC, PictureLeft, PictureTop, PictureWidth, PictureHeight, .PictureRenderFlag)
            End If
        Else
            Do
                Do
                    If .PictureRenderFlag = 0 Then
                        Call RenderPicture(.Picture, hDC, PictureLeft, PictureTop, PictureWidth, PictureHeight, .PictureRenderFlag)
                        Call SetCellFmtg(iRow, iCol, CFM_PICTURERENDERFLAG, CellFmtg)
                    Else
                        Call RenderPicture(.Picture, hDC, PictureLeft, PictureTop, PictureWidth, PictureHeight, .PictureRenderFlag)
                    End If
                    PictureTop = PictureTop + PictureHeight
                Loop While PictureTop < PictureRect.Bottom
                PictureLeft = PictureLeft + PictureWidth
                PictureTop = PictureRect.Top
            Loop While PictureLeft < PictureRect.Right
        End If
        If hRgnOld <> NULL_PTR Then
            ExtSelectClipRgn hDC, hRgnOld, RGN_COPY
            DeleteObject hRgnOld
            hRgnOld = NULL_PTR
        Else
            ExtSelectClipRgn hDC, NULL_PTR, RGN_COPY
        End If
        Select Case .PictureAlignment
            Case FlexPictureAlignmentLeftTopNoOverlap, FlexPictureAlignmentLeftCenterNoOverlap, FlexPictureAlignmentLeftBottomNoOverlap
                TextRect.Left = TextRect.Left + PictureWidth
            Case FlexPictureAlignmentRightTopNoOverlap, FlexPictureAlignmentRightCenterNoOverlap, FlexPictureAlignmentRightBottomNoOverlap
                TextRect.Right = TextRect.Right - PictureWidth
        End Select
    End If
End If
If VBFlexGridColsInfo(iCol).ImageList.Handle <> NULL_PTR Then
    Dim ImageIndex As Long
    ImageIndex = GetImageIndex(iRow, iCol, Text)
    If ImageIndex > 0 Then
        Dim ImageRect As RECT, ImageAlignment As FlexAlignmentConstants, ImageWidth As Long, ImageHeight As Long
        Dim ImageLeft As Long, ImageTop As Long, ImageOffsetX As Long, ImageOffsetY As Long
        LSet ImageRect = CellRect
        If ComboCueWidth > 0 Then
            If ComboCueAlignment = FlexLeftRightAlignmentRight Then
                ImageRect.Right = ImageRect.Right - ComboCueWidth
            ElseIf ComboCueAlignment = FlexLeftRightAlignmentLeft Then
                ImageRect.Left = ImageRect.Left + ComboCueWidth
            End If
        End If
        If .Alignment = -1 Then
            ImageAlignment = VBFlexGridColsInfo(iCol).Alignment
        Else
            ImageAlignment = .Alignment
        End If
        ImageWidth = VBFlexGridColsInfo(iCol).ImageList.Size.CX
        ImageHeight = VBFlexGridColsInfo(iCol).ImageList.Size.CY
        ImageLeft = ImageRect.Left
        ImageTop = ImageRect.Top
        Select Case ImageAlignment
            Case FlexAlignmentLeftCenter
                ImageOffsetY = (((ImageRect.Bottom - ImageRect.Top) - ImageHeight) \ 2)
            Case FlexAlignmentLeftBottom
                ImageOffsetY = ((ImageRect.Bottom - ImageRect.Top) - ImageHeight)
            Case FlexAlignmentCenterTop, FlexAlignmentGeneralTop
                ImageOffsetX = (((ImageRect.Right - ImageRect.Left) - ImageWidth) \ 2)
            Case FlexAlignmentCenterCenter, FlexAlignmentGeneral, FlexAlignmentGeneralCenter
                ImageOffsetX = (((ImageRect.Right - ImageRect.Left) - ImageWidth) \ 2)
                ImageOffsetY = (((ImageRect.Bottom - ImageRect.Top) - ImageHeight) \ 2)
            Case FlexAlignmentCenterBottom, FlexAlignmentGeneralBottom
                ImageOffsetX = (((ImageRect.Right - ImageRect.Left) - ImageWidth) \ 2)
                ImageOffsetY = ((ImageRect.Bottom - ImageRect.Top) - ImageHeight)
            Case FlexAlignmentRightTop
                ImageOffsetX = ((ImageRect.Right - ImageRect.Left) - ImageWidth)
            Case FlexAlignmentRightCenter
                ImageOffsetX = ((ImageRect.Right - ImageRect.Left) - ImageWidth)
                ImageOffsetY = (((ImageRect.Bottom - ImageRect.Top) - ImageHeight) \ 2)
            Case FlexAlignmentRightBottom
                ImageOffsetX = ((ImageRect.Right - ImageRect.Left) - ImageWidth)
                ImageOffsetY = ((ImageRect.Bottom - ImageRect.Top) - ImageHeight)
        End Select
        If ImageOffsetX > 0 Then ImageLeft = ImageLeft + ImageOffsetX
        If ImageOffsetY > 0 Then ImageTop = ImageTop + ImageOffsetY
        hRgnOld = CreateRectRgn(0, 0, 0, 0)
        If hRgnOld <> NULL_PTR Then
            If GetClipRgn(hDC, hRgnOld) = 0 Then
                DeleteObject hRgnOld
                hRgnOld = NULL_PTR
            End If
        End If
        IntersectClipRect hDC, ImageRect.Left, ImageRect.Top, ImageRect.Right, ImageRect.Bottom
        ImageList_Draw VBFlexGridColsInfo(iCol).ImageList.Handle, ImageIndex - 1, hDC, ImageLeft, ImageTop, ILD_TRANSPARENT
        If hRgnOld <> NULL_PTR Then
            ExtSelectClipRgn hDC, hRgnOld, RGN_COPY
            DeleteObject hRgnOld
            hRgnOld = NULL_PTR
        Else
            ExtSelectClipRgn hDC, NULL_PTR, RGN_COPY
        End If
        HiddenText = True
    End If
End If
Dim Checked As Integer
Checked = GetCellChecked(iRow, iCol)
If Checked > -1 Then
    Dim CheckBoxRect As RECT, CheckBoxAlignment As FlexCheckBoxAlignmentConstants, CheckBoxOffsetX As Long, CheckBoxOffsetY As Long
    LSet CheckBoxRect = TextRect
    If VBFlexGridColsInfo(iCol).CheckBoxAlignment = FlexCheckBoxAlignmentUsePictureAlignment Then
        Select Case .PictureAlignment
            Case FlexPictureAlignmentLeftTop, FlexPictureAlignmentLeftCenter, FlexPictureAlignmentLeftBottom, FlexPictureAlignmentLeftTopNoOverlap, FlexPictureAlignmentLeftCenterNoOverlap, FlexPictureAlignmentLeftBottomNoOverlap
                CheckBoxAlignment = FlexCheckBoxAlignmentLeftCenter
            Case FlexPictureAlignmentCenterTop, FlexPictureAlignmentCenterCenter, FlexPictureAlignmentCenterBottom, FlexPictureAlignmentStretch, FlexPictureAlignmentTile
                CheckBoxAlignment = FlexCheckBoxAlignmentCenterCenter
            Case FlexPictureAlignmentRightTop, FlexPictureAlignmentRightCenter, FlexPictureAlignmentRightBottom, FlexPictureAlignmentRightTopNoOverlap, FlexPictureAlignmentRightCenterNoOverlap, FlexPictureAlignmentRightBottomNoOverlap
                CheckBoxAlignment = FlexCheckBoxAlignmentRightCenter
        End Select
    Else
        CheckBoxAlignment = VBFlexGridColsInfo(iCol).CheckBoxAlignment
    End If
    Select Case CheckBoxAlignment
        Case FlexCheckBoxAlignmentLeftCenter
            CheckBoxOffsetY = (((CheckBoxRect.Bottom - CheckBoxRect.Top) - VBFlexGridPixelMetrics.CheckBoxSize) \ 2)
        Case FlexCheckBoxAlignmentLeftBottom
            CheckBoxOffsetY = ((CheckBoxRect.Bottom - CheckBoxRect.Top) - VBFlexGridPixelMetrics.CheckBoxSize)
        Case FlexCheckBoxAlignmentCenterTop
            CheckBoxOffsetX = (((CheckBoxRect.Right - CheckBoxRect.Left) - VBFlexGridPixelMetrics.CheckBoxSize) \ 2)
        Case FlexCheckBoxAlignmentCenterCenter
            CheckBoxOffsetX = (((CheckBoxRect.Right - CheckBoxRect.Left) - VBFlexGridPixelMetrics.CheckBoxSize) \ 2)
            CheckBoxOffsetY = (((CheckBoxRect.Bottom - CheckBoxRect.Top) - VBFlexGridPixelMetrics.CheckBoxSize) \ 2)
        Case FlexCheckBoxAlignmentCenterBottom
            CheckBoxOffsetX = (((CheckBoxRect.Right - CheckBoxRect.Left) - VBFlexGridPixelMetrics.CheckBoxSize) \ 2)
            CheckBoxOffsetY = ((CheckBoxRect.Bottom - CheckBoxRect.Top) - VBFlexGridPixelMetrics.CheckBoxSize)
        Case FlexCheckBoxAlignmentRightTop
            CheckBoxOffsetX = ((CheckBoxRect.Right - CheckBoxRect.Left) - VBFlexGridPixelMetrics.CheckBoxSize)
        Case FlexCheckBoxAlignmentRightCenter
            CheckBoxOffsetX = ((CheckBoxRect.Right - CheckBoxRect.Left) - VBFlexGridPixelMetrics.CheckBoxSize)
            CheckBoxOffsetY = (((CheckBoxRect.Bottom - CheckBoxRect.Top) - VBFlexGridPixelMetrics.CheckBoxSize) \ 2)
        Case FlexCheckBoxAlignmentRightBottom
            CheckBoxOffsetX = ((CheckBoxRect.Right - CheckBoxRect.Left) - VBFlexGridPixelMetrics.CheckBoxSize)
            CheckBoxOffsetY = ((CheckBoxRect.Bottom - CheckBoxRect.Top) - VBFlexGridPixelMetrics.CheckBoxSize)
    End Select
    If CheckBoxOffsetX > 0 Then CheckBoxRect.Left = CheckBoxRect.Left + CheckBoxOffsetX
    If CheckBoxOffsetY > 0 Then CheckBoxRect.Top = CheckBoxRect.Top + CheckBoxOffsetY
    CheckBoxRect.Right = CheckBoxRect.Left + VBFlexGridPixelMetrics.CheckBoxSize
    CheckBoxRect.Bottom = CheckBoxRect.Top + VBFlexGridPixelMetrics.CheckBoxSize
    Call DrawCellCheckBox(hDC, CheckBoxRect, CellRect, Text, iRow, iCol, Checked)
    Select Case CheckBoxAlignment
        Case FlexCheckBoxAlignmentLeftTop, FlexCheckBoxAlignmentLeftCenter, FlexCheckBoxAlignmentLeftBottom
            TextRect.Left = TextRect.Left + VBFlexGridPixelMetrics.CheckBoxSize + VBFlexGridPixelMetrics.TextPadding.CX
        Case FlexCheckBoxAlignmentRightTop, FlexCheckBoxAlignmentRightCenter, FlexCheckBoxAlignmentRightBottom
            TextRect.Right = TextRect.Right - VBFlexGridPixelMetrics.CheckBoxSize - VBFlexGridPixelMetrics.TextPadding.CX
    End Select
    Select Case Checked
        Case FlexTextAsCheckBox, FlexDisabledTextAsCheckBox
            HiddenText = True
    End Select
End If
Dim OldTextColor As Long
If Not (ItemState And ODS_SELECTED) = ODS_SELECTED Or (ItemState And ODS_FOCUS) = ODS_FOCUS Then
    If Not Text = vbNullString Then
        If .ForeColor = -1 Then
            OldTextColor = SetTextColor(hDC, WinColor(PropForeColor))
        Else
            OldTextColor = SetTextColor(hDC, WinColor(.ForeColor))
        End If
    Else
        OldTextColor = SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT))
    End If
Else
    OldTextColor = SetTextColor(hDC, WinColor(PropForeColorSel))
End If
Dim hPenOld As LongPtr
Select Case PropGridLines
    Case FlexGridLineFlat, FlexGridLineDashes, FlexGridLineDots
        hPenOld = SelectObject(hDC, VBFlexGridGridLinePen)
        Polyline hDC, VBFlexGridDrawInfo.GridLinePoints(0), 3
    Case FlexGridLineInset, FlexGridLineRaised
        If PropGridLines = FlexGridLineInset Then
            hPenOld = SelectObject(hDC, VBFlexGridGridLineBlackPen)
        ElseIf PropGridLines = FlexGridLineRaised Then
            hPenOld = SelectObject(hDC, VBFlexGridGridLineWhitePen)
        End If
        Polyline hDC, VBFlexGridDrawInfo.GridLinePoints(0), 3
        If PropGridLines = FlexGridLineInset Then
            SelectObject hDC, VBFlexGridGridLineWhitePen
        ElseIf PropGridLines = FlexGridLineRaised Then
            SelectObject hDC, VBFlexGridGridLineBlackPen
        End If
        Polyline hDC, VBFlexGridDrawInfo.GridLinePoints(3), 3
    Case FlexGridLineFlatHorz, FlexGridLineDashesHorz, FlexGridLineDotsHorz
        hPenOld = SelectObject(hDC, VBFlexGridGridLinePen)
        VBFlexGridDrawInfo.GridLinePoints(1).X = VBFlexGridDrawInfo.GridLinePoints(1).X + 1
        Polyline hDC, VBFlexGridDrawInfo.GridLinePoints(0), 2
        VBFlexGridDrawInfo.GridLinePoints(1).X = VBFlexGridDrawInfo.GridLinePoints(1).X - 1
    Case FlexGridLineInsetHorz, FlexGridLineRaisedHorz
        If PropGridLines = FlexGridLineInsetHorz Then
            hPenOld = SelectObject(hDC, VBFlexGridGridLineBlackPen)
        ElseIf PropGridLines = FlexGridLineRaisedHorz Then
            hPenOld = SelectObject(hDC, VBFlexGridGridLineWhitePen)
        End If
        VBFlexGridDrawInfo.GridLinePoints(1).X = VBFlexGridDrawInfo.GridLinePoints(1).X + 1
        Polyline hDC, VBFlexGridDrawInfo.GridLinePoints(0), 2
        VBFlexGridDrawInfo.GridLinePoints(1).X = VBFlexGridDrawInfo.GridLinePoints(1).X - 1
        If PropGridLines = FlexGridLineInsetHorz Then
            SelectObject hDC, VBFlexGridGridLineWhitePen
        ElseIf PropGridLines = FlexGridLineRaisedHorz Then
            SelectObject hDC, VBFlexGridGridLineBlackPen
        End If
        VBFlexGridDrawInfo.GridLinePoints(3).X = VBFlexGridDrawInfo.GridLinePoints(3).X + 1
        VBFlexGridDrawInfo.GridLinePoints(4).X = VBFlexGridDrawInfo.GridLinePoints(4).X - 1
        Polyline hDC, VBFlexGridDrawInfo.GridLinePoints(3), 2
        VBFlexGridDrawInfo.GridLinePoints(3).X = VBFlexGridDrawInfo.GridLinePoints(3).X - 1
        VBFlexGridDrawInfo.GridLinePoints(4).X = VBFlexGridDrawInfo.GridLinePoints(4).X + 1
    Case FlexGridLineFlatVert, FlexGridLineDashesVert, FlexGridLineDotsVert
        hPenOld = SelectObject(hDC, VBFlexGridGridLinePen)
        Polyline hDC, VBFlexGridDrawInfo.GridLinePoints(1), 2
    Case FlexGridLineInsetVert, FlexGridLineRaisedVert
        If PropGridLines = FlexGridLineInsetVert Then
            hPenOld = SelectObject(hDC, VBFlexGridGridLineBlackPen)
        ElseIf PropGridLines = FlexGridLineRaisedVert Then
            hPenOld = SelectObject(hDC, VBFlexGridGridLineWhitePen)
        End If
        Polyline hDC, VBFlexGridDrawInfo.GridLinePoints(1), 2
        If PropGridLines = FlexGridLineInsetVert Then
            SelectObject hDC, VBFlexGridGridLineWhitePen
        ElseIf PropGridLines = FlexGridLineRaisedVert Then
            SelectObject hDC, VBFlexGridGridLineBlackPen
        End If
        Polyline hDC, VBFlexGridDrawInfo.GridLinePoints(4), 2
End Select
If hPenOld <> NULL_PTR Then
    SelectObject hDC, hPenOld
    hPenOld = NULL_PTR
End If
If (ItemState And ODS_FOCUS) = ODS_FOCUS And Not (ItemState And ODS_NOFOCUSRECT) = ODS_NOFOCUSRECT Then
    Dim FocusRect As RECT
    With FocusRect
    .Left = CellRect.Left + VBFlexGridDrawInfo.GridLineOffsets.LeftTop.CX
    .Top = CellRect.Top + VBFlexGridDrawInfo.GridLineOffsets.LeftTop.CY
    .Right = CellRect.Right - VBFlexGridDrawInfo.GridLineOffsets.RightBottom.CX
    .Bottom = CellRect.Bottom - VBFlexGridDrawInfo.GridLineOffsets.RightBottom.CY
    Select Case PropFocusRect
        Case FlexFocusRectLight, FlexFocusRectHeavy
            If (.Right - VBFlexGridFocusBorder.CX) <= .Left Then .Right = CellRect.Right + 1
            If (.Bottom - VBFlexGridFocusBorder.CY) <= .Top Then .Bottom = CellRect.Bottom + 1
            If ComboCueWidth > 0 Then
                If ComboCueAlignment = FlexLeftRightAlignmentRight Then
                    .Right = .Right - ComboCueWidth
                ElseIf ComboCueAlignment = FlexLeftRightAlignmentLeft Then
                    .Left = .Left + ComboCueWidth
                End If
            End If
            DrawFocusRect hDC, FocusRect
            If PropFocusRect = FlexFocusRectHeavy Then
                If (.Right - VBFlexGridFocusBorder.CX) > (.Left + VBFlexGridFocusBorder.CX) And (.Bottom - VBFlexGridFocusBorder.CY) > (.Top + VBFlexGridFocusBorder.CY) Then
                    .Left = .Left + VBFlexGridFocusBorder.CX
                    .Right = .Right - VBFlexGridFocusBorder.CX
                    .Top = .Top + VBFlexGridFocusBorder.CY
                    .Bottom = .Bottom - VBFlexGridFocusBorder.CY
                    DrawFocusRect hDC, FocusRect
                End If
            End If
        Case FlexFocusRectFlat
            If (.Right - GetFocusRectWidth()) <= .Left Then .Right = CellRect.Right + 1
            If (.Bottom - GetFocusRectWidth()) <= .Top Then .Bottom = CellRect.Bottom + 1
            If ComboCueWidth > 0 Then
                If ComboCueAlignment = FlexLeftRightAlignmentRight Then
                    .Right = .Right - ComboCueWidth
                ElseIf ComboCueAlignment = FlexLeftRightAlignmentLeft Then
                    .Left = .Left + ComboCueWidth
                End If
            End If
            hPenOld = SelectObject(hDC, VBFlexGridFocusRectPen)
            Brush = SelectObject(hDC, GetStockObject(NULL_BRUSH))
            Rectangle hDC, .Left, .Top, .Right, .Bottom
            SelectObject hDC, Brush
            If hPenOld <> NULL_PTR Then
                SelectObject hDC, hPenOld
                hPenOld = NULL_PTR
            End If
    End Select
    End With
End If
If Not Text = vbNullString And TextRect.Right >= TextRect.Left And TextRect.Bottom >= TextRect.Top And HiddenText = False Then
    Dim TextStyle As FlexTextStyleConstants, Alignment As FlexAlignmentConstants, DrawFlags As Long
    If .TextStyle = -1 Then
        TextStyle = PropTextStyle
    Else
        TextStyle = .TextStyle
    End If
    If .Alignment = -1 Then
        Alignment = VBFlexGridColsInfo(iCol).Alignment
    Else
        Alignment = .Alignment
    End If
    DrawFlags = DT_NOPREFIX
    If VBFlexGridRTLReading = True Then DrawFlags = DrawFlags Or DT_RTLREADING
    Select Case Alignment
        Case FlexAlignmentLeftTop, FlexAlignmentLeftCenter, FlexAlignmentLeftBottom
            DrawFlags = DrawFlags Or DT_LEFT
        Case FlexAlignmentCenterTop, FlexAlignmentCenterCenter, FlexAlignmentCenterBottom
            DrawFlags = DrawFlags Or DT_CENTER
        Case FlexAlignmentRightTop, FlexAlignmentRightCenter, FlexAlignmentRightBottom
            DrawFlags = DrawFlags Or DT_RIGHT
        Case FlexAlignmentGeneral, FlexAlignmentGeneralTop, FlexAlignmentGeneralCenter, FlexAlignmentGeneralBottom
            If PropMirrorAlignGeneral = False Then
                If Not IsNumeric(Text) And Not IsDate(Text) Then
                    DrawFlags = DrawFlags Or DT_LEFT
                Else
                    DrawFlags = DrawFlags Or DT_RIGHT
                End If
            Else
                If Not IsNumeric(Text) And Not IsDate(Text) Then
                    DrawFlags = DrawFlags Or DT_RIGHT
                Else
                    DrawFlags = DrawFlags Or DT_LEFT
                End If
            End If
    End Select
    If VBFlexGridColsInfo(iCol).WordWrapOption = -1 Then
        If PropWordWrap = True Then
            DrawFlags = DrawFlags Or DT_WORDBREAK
        ElseIf PropSingleLine = True Then
            DrawFlags = DrawFlags Or DT_SINGLELINE
        End If
        Select Case PropEllipsisFormat
            Case FlexEllipsisFormatEnd
                DrawFlags = DrawFlags Or DT_END_ELLIPSIS
            Case FlexEllipsisFormatPath
                DrawFlags = DrawFlags Or DT_PATH_ELLIPSIS
            Case FlexEllipsisFormatWord
                DrawFlags = DrawFlags Or DT_WORD_ELLIPSIS
        End Select
    Else
        Select Case VBFlexGridColsInfo(iCol).WordWrapOption
            Case FlexWordWrapNone
                ' Void
            Case FlexWordBreak
                DrawFlags = DrawFlags Or DT_WORDBREAK
            Case FlexSingleLine
                DrawFlags = DrawFlags Or DT_SINGLELINE
            Case FlexEndEllipsis
                DrawFlags = DrawFlags Or DT_END_ELLIPSIS
            Case FlexPathEllipsis
                DrawFlags = DrawFlags Or DT_PATH_ELLIPSIS
            Case FlexWordEllipsis
                DrawFlags = DrawFlags Or DT_WORD_ELLIPSIS
            Case FlexWordBreakEndEllipsis
                DrawFlags = DrawFlags Or DT_WORDBREAK Or DT_END_ELLIPSIS
            Case FlexWordBreakPathEllipsis
                DrawFlags = DrawFlags Or DT_WORDBREAK Or DT_PATH_ELLIPSIS
            Case FlexWordBreakWordEllipsis
                DrawFlags = DrawFlags Or DT_WORDBREAK Or DT_WORD_ELLIPSIS
            Case FlexSingleLineEndEllipsis
                DrawFlags = DrawFlags Or DT_SINGLELINE Or DT_END_ELLIPSIS
            Case FlexSingleLinePathEllipsis
                DrawFlags = DrawFlags Or DT_SINGLELINE Or DT_PATH_ELLIPSIS
            Case FlexSingleLineWordEllipsis
                DrawFlags = DrawFlags Or DT_SINGLELINE Or DT_WORD_ELLIPSIS
        End Select
    End If
    If VBFlexGridColsInfo(iCol).MimicTextBox = -1 Then
        If PropMimicTextBox = True Then DrawFlags = DrawFlags Or DT_EDITCONTROL
    Else
        If VBFlexGridColsInfo(iCol).MimicTextBox = FlexMimicTextBoxOn Then DrawFlags = DrawFlags Or DT_EDITCONTROL
    End If
    If Not (DrawFlags And DT_SINGLELINE) = DT_SINGLELINE Then
        Dim CalcRect As RECT, Height As Long, Result As Long
        Select Case Alignment
            Case FlexAlignmentLeftCenter, FlexAlignmentCenterCenter, FlexAlignmentRightCenter, FlexAlignmentGeneral, FlexAlignmentGeneralCenter
                LSet CalcRect = TextRect
                Height = DrawText(hDC, StrPtr(Text), -1, CalcRect, DrawFlags Or DT_CALCRECT)
                Result = (((TextRect.Bottom - TextRect.Top) - Height) \ 2)
            Case FlexAlignmentLeftBottom, FlexAlignmentCenterBottom, FlexAlignmentRightBottom, FlexAlignmentGeneralBottom
                LSet CalcRect = TextRect
                Height = DrawText(hDC, StrPtr(Text), -1, CalcRect, DrawFlags Or DT_CALCRECT)
                Result = ((TextRect.Bottom - TextRect.Top) - Height)
        End Select
        If Result > 0 Then TextRect.Top = TextRect.Top + Result
    Else
        Select Case Alignment
            Case FlexAlignmentLeftCenter, FlexAlignmentCenterCenter, FlexAlignmentRightCenter, FlexAlignmentGeneral, FlexAlignmentGeneralCenter
                DrawFlags = DrawFlags Or DT_VCENTER
            Case FlexAlignmentLeftBottom, FlexAlignmentCenterBottom, FlexAlignmentRightBottom, FlexAlignmentGeneralBottom
                DrawFlags = DrawFlags Or DT_BOTTOM
        End Select
    End If
    Dim TempTextColor As Long
    Select Case TextStyle
        Case FlexTextStyleRaised
            TempTextColor = SetTextColor(hDC, &H808080)
            SetRect TextRect, TextRect.Left + 1, TextRect.Top + 1, TextRect.Right + 1, TextRect.Bottom + 1
            DrawText hDC, StrPtr(Text), -1, TextRect, DrawFlags
            SetTextColor hDC, vbWhite
            SetRect TextRect, TextRect.Left - 2, TextRect.Top - 2, TextRect.Right - 2, TextRect.Bottom - 2
            DrawText hDC, StrPtr(Text), -1, TextRect, DrawFlags
            SetTextColor hDC, TempTextColor
            SetRect TextRect, TextRect.Left + 1, TextRect.Top + 1, TextRect.Right + 1, TextRect.Bottom + 1
        Case FlexTextStyleInset
            TempTextColor = SetTextColor(hDC, vbWhite)
            SetRect TextRect, TextRect.Left + 1, TextRect.Top + 1, TextRect.Right + 1, TextRect.Bottom + 1
            DrawText hDC, StrPtr(Text), -1, TextRect, DrawFlags
            SetTextColor hDC, &H808080
            SetRect TextRect, TextRect.Left - 2, TextRect.Top - 2, TextRect.Right - 2, TextRect.Bottom - 2
            DrawText hDC, StrPtr(Text), -1, TextRect, DrawFlags
            SetTextColor hDC, TempTextColor
            SetRect TextRect, TextRect.Left + 1, TextRect.Top + 1, TextRect.Right + 1, TextRect.Bottom + 1
        Case FlexTextStyleRaisedLight
            TempTextColor = SetTextColor(hDC, vbWhite)
            SetRect TextRect, TextRect.Left - 1, TextRect.Top - 1, TextRect.Right - 1, TextRect.Bottom - 1
            DrawText hDC, StrPtr(Text), -1, TextRect, DrawFlags
            SetTextColor hDC, TempTextColor
            SetRect TextRect, TextRect.Left + 1, TextRect.Top + 1, TextRect.Right + 1, TextRect.Bottom + 1
        Case FlexTextStyleInsetLight
            TempTextColor = SetTextColor(hDC, vbWhite)
            SetRect TextRect, TextRect.Left + 1, TextRect.Top + 1, TextRect.Right + 1, TextRect.Bottom + 1
            DrawText hDC, StrPtr(Text), -1, TextRect, DrawFlags
            SetTextColor hDC, TempTextColor
            SetRect TextRect, TextRect.Left - 1, TextRect.Top - 1, TextRect.Right - 1, TextRect.Bottom - 1
    End Select
    DrawText hDC, StrPtr(Text), -1, TextRect, DrawFlags
    If (iRow = VBFlexGridIncrementalSearch.Row And iCol = VBFlexGridIncrementalSearch.Col) Then Call DrawIncrementalSearch(hDC, Text, TextRect, DrawFlags)
End If
SetTextColor hDC, OldTextColor
If hFontOld <> NULL_PTR Then SelectObject hDC, hFontOld
If hFontTemp <> NULL_PTR Then DeleteObject hFontTemp
End With
If ComboCueWidth > 0 Then
    Dim DIS As DRAWITEMSTRUCT, P As POINTAPI
    DIS.CtlType = ComboCueCtlType
    DIS.CtlID = ID_COMBOBUTTONCHILD
    DIS.ItemID = 0
    DIS.ItemAction = ODA_DRAWENTIRE
    DIS.ItemState = ComboCueItemState
    DIS.hWndItem = VBFlexGridHandle
    DIS.hDC = hDC
    DIS.RCItem.Left = 0
    DIS.RCItem.Top = 0
    DIS.RCItem.Right = ComboCueWidth
    DIS.RCItem.Bottom = (CellRect.Bottom - CellRect.Top) - (VBFlexGridDrawInfo.GridLineOffsets.LeftTop.CY + VBFlexGridDrawInfo.GridLineOffsets.RightBottom.CY)
    DIS.ItemData = 0
    If ComboCueAlignment = FlexLeftRightAlignmentRight Then
        SetViewportOrgEx DIS.hDC, CellRect.Right - ComboCueWidth - VBFlexGridDrawInfo.GridLineOffsets.RightBottom.CX, CellRect.Top + VBFlexGridDrawInfo.GridLineOffsets.LeftTop.CY, P
    ElseIf ComboCueAlignment = FlexLeftRightAlignmentLeft Then
        SetViewportOrgEx DIS.hDC, CellRect.Left + VBFlexGridDrawInfo.GridLineOffsets.LeftTop.CX, CellRect.Top + VBFlexGridDrawInfo.GridLineOffsets.LeftTop.CY, P
    End If
    Call ComboButtonDraw(iRow, iCol, DIS)
    SetViewportOrgEx DIS.hDC, P.X, P.Y, P
End If
End Sub

Private Sub GetSelRangeStruct(ByRef SelRange As TCELLRANGE)
With SelRange
If VBFlexGridRow > VBFlexGridRowSel Then .TopRow = VBFlexGridRowSel Else .TopRow = VBFlexGridRow
If VBFlexGridRowSel > VBFlexGridRow Then .BottomRow = VBFlexGridRowSel Else .BottomRow = VBFlexGridRow
If VBFlexGridCol > VBFlexGridColSel Then .LeftCol = VBFlexGridColSel Else .LeftCol = VBFlexGridCol
If VBFlexGridColSel > VBFlexGridCol Then .RightCol = VBFlexGridColSel Else .RightCol = VBFlexGridCol
End With
End Sub

Private Sub GetMergedRangeStruct(ByVal iRow As Long, ByVal iCol As Long, ByRef MergedRange As TCELLRANGE)
With MergedRange
.TopRow = iRow
.BottomRow = iRow
.LeftCol = iCol
.RightCol = iCol
If PropMergeCells <> FlexMergeCellsNever And PropRows > 0 And PropCols > 0 Then
    If iRow > (PropFixedRows - 1) And iCol > (PropFixedCols - 1) Then
        If (VBFlexGridCells.Rows(iRow).RowInfo.State And RWIS_MERGE) = RWIS_MERGE Then
            Select Case PropMergeCells
                Case FlexMergeCellsFree, FlexMergeCellsRestrictRows
                    If iCol > PropFixedCols Then
                        Do
                            If MergeCompareFunction(iRow, iCol, iRow, .LeftCol - 1) = True Then .LeftCol = .LeftCol - 1 Else Exit Do
                        Loop While .LeftCol > PropFixedCols
                    End If
                    If iCol < (PropCols - 1) Then
                        Do
                            If MergeCompareFunction(iRow, iCol, iRow, .RightCol + 1) = True Then .RightCol = .RightCol + 1 Else Exit Do
                        Loop While .RightCol < (PropCols - 1)
                    End If
                Case FlexMergeCellsRestrictColumns, FlexMergeCellsRestrictAll
                    If iCol > PropFixedCols Then
                        Do
                            If MergeCompareFunction(iRow, iCol, iRow, .LeftCol - 1) = True Then
                                If iRow > PropFixedRows Then
                                    If MergeCompareFunction(iRow - 1, iCol, iRow - 1, .LeftCol - 1) = True Then .LeftCol = .LeftCol - 1 Else Exit Do
                                Else
                                    .LeftCol = .LeftCol - 1
                                End If
                            Else
                                Exit Do
                            End If
                        Loop While .LeftCol > PropFixedCols
                    End If
                    If iCol < (PropCols - 1) Then
                        Do
                            If MergeCompareFunction(iRow, iCol, iRow, .RightCol + 1) = True Then
                                If iRow > PropFixedRows Then
                                    If MergeCompareFunction(iRow - 1, iCol, iRow - 1, .RightCol + 1) = True Then .RightCol = .RightCol + 1 Else Exit Do
                                Else
                                    .RightCol = .RightCol + 1
                                End If
                            Else
                                Exit Do
                            End If
                        Loop While .RightCol < (PropCols - 1)
                    End If
            End Select
        End If
        If (VBFlexGridColsInfo(iCol).State And CLIS_MERGE) = CLIS_MERGE Then
            Select Case PropMergeCells
                Case FlexMergeCellsFree, FlexMergeCellsRestrictColumns
                    If iRow > PropFixedRows Then
                        Do
                            If MergeCompareFunction(iRow, iCol, .TopRow - 1, iCol) = True Then .TopRow = .TopRow - 1 Else Exit Do
                        Loop While .TopRow > PropFixedRows
                    End If
                    If iRow < (PropRows - 1) Then
                        Do
                            If MergeCompareFunction(iRow, iCol, .BottomRow + 1, iCol) = True Then .BottomRow = .BottomRow + 1 Else Exit Do
                        Loop While .BottomRow < (PropRows - 1)
                    End If
                Case FlexMergeCellsRestrictRows, FlexMergeCellsRestrictAll
                    If iRow > PropFixedRows Then
                        Do
                            If MergeCompareFunction(iRow, iCol, .TopRow - 1, iCol) = True Then
                                If iCol > PropFixedCols Then
                                    If MergeCompareFunction(iRow, iCol - 1, .TopRow - 1, iCol - 1) = True Then .TopRow = .TopRow - 1 Else Exit Do
                                Else
                                    .TopRow = .TopRow - 1
                                End If
                            Else
                                Exit Do
                            End If
                        Loop While .TopRow > PropFixedRows
                    End If
                    If iRow < (PropRows - 1) Then
                        Do
                            If MergeCompareFunction(iRow, iCol, .BottomRow + 1, iCol) = True Then
                                If iCol > PropFixedCols Then
                                    If MergeCompareFunction(iRow, iCol - 1, .BottomRow + 1, iCol - 1) = True Then .BottomRow = .BottomRow + 1 Else Exit Do
                                Else
                                    .BottomRow = .BottomRow + 1
                                End If
                            Else
                                Exit Do
                            End If
                        Loop While .BottomRow < (PropRows - 1)
                    End If
            End Select
        End If
    Else
        If (VBFlexGridCells.Rows(iRow).RowInfo.State And RWIS_MERGE) = RWIS_MERGE Then
            Select Case PropMergeCells
                Case FlexMergeCellsFree, FlexMergeCellsRestrictRows, FlexMergeCellsFixedOnly
                    If iCol > 0 Then
                        Do
                            If MergeCompareFunction(iRow, iCol, iRow, .LeftCol - 1) = True Then .LeftCol = .LeftCol - 1 Else Exit Do
                        Loop While .LeftCol > 0
                    End If
                    If iCol < (PropCols - 1) Then
                        Do
                            If MergeCompareFunction(iRow, iCol, iRow, .RightCol + 1) = True Then .RightCol = .RightCol + 1 Else Exit Do
                        Loop While .RightCol < (PropCols - 1)
                    End If
                Case FlexMergeCellsRestrictColumns, FlexMergeCellsRestrictAll
                    If iCol > 0 Then
                        Do
                            If MergeCompareFunction(iRow, iCol, iRow, .LeftCol - 1) = True Then
                                If Row > 0 Then
                                    If MergeCompareFunction(iRow - 1, iCol, iRow - 1, .LeftCol - 1) = True Then .LeftCol = .LeftCol - 1 Else Exit Do
                                Else
                                    .LeftCol = .LeftCol - 1
                                End If
                            Else
                                Exit Do
                            End If
                        Loop While .LeftCol > 0
                    End If
                    If iCol < (PropCols - 1) Then
                        Do
                            If MergeCompareFunction(iRow, iCol, iRow, .RightCol + 1) = True Then
                                If Row > 0 Then
                                    If MergeCompareFunction(iRow - 1, iCol, iRow - 1, .RightCol + 1) = True Then .RightCol = .RightCol + 1 Else Exit Do
                                Else
                                    .RightCol = .RightCol + 1
                                End If
                            Else
                                Exit Do
                            End If
                        Loop While .RightCol < (PropCols - 1)
                    End If
            End Select
        End If
        If (VBFlexGridColsInfo(iCol).State And CLIS_MERGE) = CLIS_MERGE Then
            Select Case PropMergeCells
                Case FlexMergeCellsFree, FlexMergeCellsRestrictColumns, FlexMergeCellsFixedOnly
                    If iRow > 0 Then
                        Do
                            If MergeCompareFunction(iRow, iCol, .TopRow - 1, iCol) = True Then .TopRow = .TopRow - 1 Else Exit Do
                        Loop While .TopRow > 0
                    End If
                    If iRow < (PropRows - 1) Then
                        Do
                            If MergeCompareFunction(iRow, iCol, .BottomRow + 1, iCol) = True Then .BottomRow = .BottomRow + 1 Else Exit Do
                        Loop While .BottomRow < (PropRows - 1)
                    End If
                Case FlexMergeCellsRestrictRows, FlexMergeCellsRestrictAll
                    If iRow > 0 Then
                        Do
                            If MergeCompareFunction(iRow, iCol, .TopRow - 1, iCol) = True Then
                                If iCol > 0 Then
                                    If MergeCompareFunction(iRow, iCol - 1, .TopRow - 1, iCol - 1) = True Then .TopRow = .TopRow - 1 Else Exit Do
                                Else
                                    .TopRow = .TopRow - 1
                                End If
                            Else
                                Exit Do
                            End If
                        Loop While .TopRow > 0
                    End If
                    If iRow < (PropRows - 1) Then
                        Do
                            If MergeCompareFunction(iRow, iCol, .BottomRow + 1, iCol) = True Then
                                If iCol > 0 Then
                                    If MergeCompareFunction(iRow, iCol - 1, .BottomRow + 1, iCol - 1) = True Then .BottomRow = .BottomRow + 1 Else Exit Do
                                Else
                                    .BottomRow = .BottomRow + 1
                                End If
                            Else
                                Exit Do
                            End If
                        Loop While .BottomRow < (PropRows - 1)
                    End If
            End Select
        End If
    End If
    ' MergeCol overrules MergeRow.
    For iRow = .TopRow To .BottomRow
        If (VBFlexGridCells.Rows(iRow).RowInfo.State And RWIS_MERGE) = 0 Then
            .RightCol = .LeftCol
            Exit For
        End If
    Next iRow
End If
End With
End Sub

Private Sub GetCellRect(ByVal iRow As Long, ByVal iCol As Long, ByRef CellRect As RECT)
If PropRows < 1 Or PropCols < 1 Then Exit Sub
Dim i As Long
With CellRect
.Left = 0
.Top = 0
.Right = 0
.Bottom = 0
For i = 0 To iRow
    If i >= VBFlexGridTopRow Or i < (PropFixedRows + PropFrozenRows) Then
        .Top = .Bottom
        .Bottom = .Bottom + GetRowHeight(i)
    End If
Next i
For i = 0 To iCol
    If i >= VBFlexGridLeftCol Or i < (PropFixedCols + PropFrozenCols) Then
        .Left = .Right
        .Right = .Right + GetColWidth(i)
    End If
Next i
End With
End Sub

Private Sub GetCellRangeRect(ByRef CellRange As TCELLRANGE, ByRef CellRangeRect As RECT)
If PropRows < 1 Or PropCols < 1 Then Exit Sub
Dim i As Long
With CellRangeRect
.Left = 0
.Top = 0
.Right = 0
.Bottom = 0
For i = 0 To CellRange.TopRow
    If i >= VBFlexGridTopRow Or i < (PropFixedRows + PropFrozenRows) Then
        .Top = .Bottom
        .Bottom = .Bottom + GetRowHeight(i)
    End If
Next i
For i = CellRange.TopRow + 1 To CellRange.BottomRow
    If i >= VBFlexGridTopRow Or i < (PropFixedRows + PropFrozenRows) Then .Bottom = .Bottom + GetRowHeight(i)
Next i
For i = 0 To CellRange.LeftCol
    If i >= VBFlexGridLeftCol Or i < (PropFixedCols + PropFrozenCols) Then
        .Left = .Right
        .Right = .Right + GetColWidth(i)
    End If
Next i
For i = CellRange.LeftCol + 1 To CellRange.RightCol
    If i >= VBFlexGridLeftCol Or i < (PropFixedCols + PropFrozenCols) Then .Right = .Right + GetColWidth(i)
Next i
End With
End Sub

Private Function GetFocusRectWidth() As Integer
If PropFocusRectWidth = -1 Then GetFocusRectWidth = VBFlexGridFocusBorder.CX Else GetFocusRectWidth = PropFocusRectWidth
End Function

Private Function GetComboButtonWidth(ByVal iRow As Long, ByVal iCol As Long, ByVal ComboCue As FlexComboCueConstants) As Long
Dim CtlType As Long
Select Case ComboCue
    Case FlexComboCueHidden
        Exit Function
    Case FlexComboCueNone
        Select Case VBFlexGridComboModeActive
            Case FlexComboModeDropDown, FlexComboModeEditable, FlexComboModeCalendar
                CtlType = ODT_COMBOBOX
            Case FlexComboModeButton
                CtlType = ODT_BUTTON
        End Select
    Case FlexComboCueDropDown, FlexComboCueDisabledDropDown
        CtlType = ODT_COMBOBOX
    Case FlexComboCueButton, FlexComboCueDisabledButton
        CtlType = ODT_BUTTON
End Select
If CtlType = ODT_COMBOBOX Then
    GetComboButtonWidth = VBFlexGridPixelMetrics.ScrollBarSize
ElseIf CtlType = ODT_BUTTON Then
    Dim Width As Long
    If VBFlexGridColsInfo(iCol).ComboButtonWidth = -1 Then
        If VBFlexGridComboButtonWidth = -1 Then
            Width = VBFlexGridPixelMetrics.ScrollBarSize
        Else
            Width = VBFlexGridComboButtonWidth
        End If
    Else
        Width = VBFlexGridColsInfo(iCol).ComboButtonWidth
    End If
    RaiseEvent ComboButtonMeasure(iRow, iCol, Width)
    If Width > 0 Then GetComboButtonWidth = Width
End If
End Function

Private Sub GetCellText(ByVal iRow As Long, ByVal iCol As Long, ByRef TextOut As String)

' ByRef parameter is faster than returning the string as the function return value.

#If ImplementFlexDataSource = True Then

If VBFlexGridFlexDataSource Is Nothing Then
    TextOut = VBFlexGridCells.Rows(iRow).Cols(iCol).Text
ElseIf (VBFlexGridFlexDataSourceFlags And FlexDataSourceNoData) = 0 Then
    If iRow >= PropFixedRows Then
        If (VBFlexGridFlexDataSourceFlags And FlexDataSourceUnboundFixedColumns) = 0 Then
            TextOut = VBFlexGridFlexDataSource.GetData(iCol, iRow - PropFixedRows)
        Else
            If iCol >= PropFixedCols Then
                TextOut = VBFlexGridFlexDataSource.GetData(iCol - PropFixedCols, iRow - PropFixedRows)
            Else
                TextOut = VBFlexGridCells.Rows(iRow).Cols(iCol).Text
            End If
        End If
    Else
        TextOut = VBFlexGridCells.Rows(iRow).Cols(iCol).Text
    End If
Else
    TextOut = VBFlexGridCells.Rows(iRow).Cols(iCol).Text
End If

#Else

TextOut = VBFlexGridCells.Rows(iRow).Cols(iCol).Text

#End If

End Sub

Private Sub SetCellText(ByVal iRow As Long, ByVal iCol As Long, ByRef TextIn As String)

#If ImplementFlexDataSource = True Then

If VBFlexGridFlexDataSource Is Nothing Then
    VBFlexGridCells.Rows(iRow).Cols(iCol).Text = TextIn
ElseIf (VBFlexGridFlexDataSourceFlags And FlexDataSourceNoData) = 0 Then
    If iRow >= PropFixedRows Then
        If (VBFlexGridFlexDataSourceFlags And FlexDataSourceUnboundFixedColumns) = 0 Then
            VBFlexGridFlexDataSource.SetData iCol, iRow - PropFixedRows, TextIn
        Else
            If iCol >= PropFixedCols Then
                VBFlexGridFlexDataSource.SetData iCol - PropFixedCols, iRow - PropFixedRows, TextIn
            Else
                VBFlexGridCells.Rows(iRow).Cols(iCol).Text = TextIn
            End If
        End If
    Else
        VBFlexGridCells.Rows(iRow).Cols(iCol).Text = TextIn
    End If
Else
    VBFlexGridCells.Rows(iRow).Cols(iCol).Text = TextIn
End If

#Else

VBFlexGridCells.Rows(iRow).Cols(iCol).Text = TextIn

#End If

End Sub

Private Sub GetCellToolTipText(ByVal iRow As Long, ByVal iCol As Long, ByRef TextOut As String)

' ByRef parameter is faster than returning the string as the function return value.

#If ImplementFlexDataSource = True Then

If VBFlexGridFlexDataSource2 Is Nothing Then
    Call GetCellFmtgToolTipText(iRow, iCol, TextOut)
ElseIf (VBFlexGridFlexDataSourceFlags And FlexDataSourceToolTipText) <> 0 Then
    If iRow >= PropFixedRows Then
        If (VBFlexGridFlexDataSourceFlags And FlexDataSourceUnboundFixedColumns) = 0 Then
            TextOut = VBFlexGridFlexDataSource2.GetToolTipText(iCol, iRow - PropFixedRows)
        Else
            If iCol >= PropFixedCols Then
                TextOut = VBFlexGridFlexDataSource2.GetToolTipText(iCol - PropFixedCols, iRow - PropFixedRows)
            Else
                Call GetCellFmtgToolTipText(iRow, iCol, TextOut)
            End If
        End If
    Else
        Call GetCellFmtgToolTipText(iRow, iCol, TextOut)
    End If
Else
    Call GetCellFmtgToolTipText(iRow, iCol, TextOut)
End If

#Else

Call GetCellFmtgToolTipText(iRow, iCol, TextOut)

#End If

End Sub

Private Sub SetCellToolTipText(ByVal iRow As Long, ByVal iCol As Long, ByRef TextIn As String)

#If ImplementFlexDataSource = True Then

If VBFlexGridFlexDataSource2 Is Nothing Then
    Call SetCellFmtgToolTipText(iRow, iCol, TextIn)
ElseIf (VBFlexGridFlexDataSourceFlags And FlexDataSourceToolTipText) <> 0 Then
    If iRow >= PropFixedRows Then
        If (VBFlexGridFlexDataSourceFlags And FlexDataSourceUnboundFixedColumns) = 0 Then
            VBFlexGridFlexDataSource2.SetToolTipText iCol, iRow - PropFixedRows, TextIn
        Else
            If iCol >= PropFixedCols Then
                VBFlexGridFlexDataSource2.SetToolTipText iCol - PropFixedCols, iRow - PropFixedRows, TextIn
            Else
                Call SetCellFmtgToolTipText(iRow, iCol, TextIn)
            End If
        End If
    Else
        Call SetCellFmtgToolTipText(iRow, iCol, TextIn)
    End If
Else
    Call SetCellFmtgToolTipText(iRow, iCol, TextIn)
End If

#Else

Call SetCellFmtgToolTipText(iRow, iCol, TextIn)

#End If

End Sub

Private Function GetCellChecked(ByVal iRow As Long, ByVal iCol As Long) As Integer
If (VBFlexGridColsInfo(iCol).State And CLIS_CHECKBOXES) = 0 Then
    GetCellChecked = GetCellFmtgChecked(iRow, iCol)
Else
    If iRow >= PropFixedRows Then
        Dim Checked As Integer
        
        #If ImplementFlexDataSource = True Then
        
        If VBFlexGridFlexDataSource2 Is Nothing Then
            Checked = GetCellFmtgChecked(iRow, iCol)
            If Checked <> -1 Then GetCellChecked = Checked
        ElseIf (VBFlexGridFlexDataSourceFlags And FlexDataSourceChecked) <> 0 Then
            If (VBFlexGridFlexDataSourceFlags And FlexDataSourceUnboundFixedColumns) = 0 Then
                Checked = VBFlexGridFlexDataSource2.GetChecked(iCol, iRow - PropFixedRows)
                If Checked >= -2 And Checked <= 7 Then GetCellChecked = Checked
            Else
                If iCol >= PropFixedCols Then
                    Checked = VBFlexGridFlexDataSource2.GetChecked(iCol - PropFixedCols, iRow - PropFixedRows)
                    If Checked >= -2 And Checked <= 7 Then GetCellChecked = Checked
                Else
                    Checked = GetCellFmtgChecked(iRow, iCol)
                    If Checked <> -1 Then GetCellChecked = Checked
                End If
            End If
        Else
            Checked = GetCellFmtgChecked(iRow, iCol)
            If Checked <> -1 Then GetCellChecked = Checked
        End If
        
        #Else
        
        Checked = GetCellFmtgChecked(iRow, iCol)
        If Checked <> -1 Then GetCellChecked = Checked
        
        #End If
        
    Else
        GetCellChecked = GetCellFmtgChecked(iRow, iCol)
    End If
End If
End Function

Private Function GetCellChecked_HitTest(ByVal iRow As Long, ByVal iCol As Long) As Integer
If iRow >= PropFixedRows And iCol >= PropFixedCols Then
    If (VBFlexGridColsInfo(iCol).State And CLIS_CHECKBOXESHITTESTINVISIBLE) = 0 Then
        If (VBFlexGridColsInfo(iCol).State And CLIS_CHECKBOXESHITTESTINVISIBLEDISABLEDONLY) = 0 Then
            GetCellChecked_HitTest = GetCellChecked(iRow, iCol)
        Else
            GetCellChecked_HitTest = GetCellChecked(iRow, iCol)
            If GetCellChecked_HitTest >= 0 And GetCellChecked_HitTest <= 3 Then GetCellChecked_HitTest = -1
        End If
    Else
        If (VBFlexGridColsInfo(iCol).State And CLIS_CHECKBOXESHITTESTINVISIBLEDISABLEDONLY) = 0 Then
            GetCellChecked_HitTest = -1
        Else
            GetCellChecked_HitTest = GetCellChecked(iRow, iCol)
            If GetCellChecked_HitTest >= 4 And GetCellChecked_HitTest <= 7 Then GetCellChecked_HitTest = -1
        End If
    End If
Else
    If (VBFlexGridColsInfo(iCol).State And CLIS_CHECKBOXESHITTESTINVISIBLEFIXED) = 0 Then
        If (VBFlexGridColsInfo(iCol).State And CLIS_CHECKBOXESHITTESTINVISIBLEFIXEDDISABLEDONLY) = 0 Then
            GetCellChecked_HitTest = GetCellChecked(iRow, iCol)
        Else
            GetCellChecked_HitTest = GetCellChecked(iRow, iCol)
            If GetCellChecked_HitTest >= 0 And GetCellChecked_HitTest <= 3 Then GetCellChecked_HitTest = -1
        End If
    Else
        If (VBFlexGridColsInfo(iCol).State And CLIS_CHECKBOXESHITTESTINVISIBLEFIXEDDISABLEDONLY) = 0 Then
            GetCellChecked_HitTest = -1
        Else
            GetCellChecked_HitTest = GetCellChecked(iRow, iCol)
            If GetCellChecked_HitTest >= 4 And GetCellChecked_HitTest <= 7 Then GetCellChecked_HitTest = -1
        End If
    End If
End If
End Function

Private Sub SetCellChecked(ByVal iRow As Long, ByVal iCol As Long, ByVal NewValue As Integer)
If (VBFlexGridColsInfo(iCol).State And CLIS_CHECKBOXES) = 0 Then
    Call SetCellFmtgChecked(iRow, iCol, NewValue)
Else
    If iRow >= PropFixedRows Then
        
        #If ImplementFlexDataSource = True Then
        
        If VBFlexGridFlexDataSource2 Is Nothing Then
            Call SetCellFmtgChecked(iRow, iCol, NewValue)
        ElseIf (VBFlexGridFlexDataSourceFlags And FlexDataSourceChecked) <> 0 Then
            If (VBFlexGridFlexDataSourceFlags And FlexDataSourceUnboundFixedColumns) = 0 Then
                VBFlexGridFlexDataSource2.SetChecked iCol, iRow - PropFixedRows, NewValue
            Else
                If iCol >= PropFixedCols Then
                    VBFlexGridFlexDataSource2.SetChecked iCol - PropFixedCols, iRow - PropFixedRows, NewValue
                Else
                    Call SetCellFmtgChecked(iRow, iCol, NewValue)
                End If
            End If
        Else
            Call SetCellFmtgChecked(iRow, iCol, NewValue)
        End If
        
        #Else
        
        Call SetCellFmtgChecked(iRow, iCol, NewValue)
        
        #End If
        
    Else
        Call SetCellFmtgChecked(iRow, iCol, NewValue)
    End If
End If
End Sub

Private Sub FreeCellFmtg(ByRef lpFmtg As LongPtr)
If lpFmtg <> NULL_PTR Then
    Dim lpCellFmtg As TLPCELLFMTG
    CopyMemory ByVal VarPtr(lpCellFmtg), ByVal lpFmtg, LenB(lpCellFmtg)
    If lpCellFmtg.lpPicture <> NULL_PTR Then FlexObjSet Nothing, lpCellFmtg.lpPicture
    If lpCellFmtg.lpToolTipText <> NULL_PTR Then SysFreeString lpCellFmtg.lpToolTipText
    If lpCellFmtg.lpFontName <> NULL_PTR Then SysFreeString lpCellFmtg.lpFontName
    HeapFree GetProcessHeap(), 0, lpFmtg
    lpFmtg = NULL_PTR
End If
End Sub

Private Sub AllocCellFmtg(ByRef lpFmtg As LongPtr)
If lpFmtg = NULL_PTR Then
    lpFmtg = HeapAlloc(GetProcessHeap(), 0, LenB(VBFlexGridDefaultLpCellFmtg))
    If lpFmtg <> NULL_PTR Then CopyMemory ByVal lpFmtg, ByVal VarPtr(VBFlexGridDefaultLpCellFmtg), LenB(VBFlexGridDefaultLpCellFmtg)
End If
End Sub

Private Sub GetCellFmtg(ByVal iRow As Long, ByVal iCol As Long, ByVal Mask As Long, ByRef CellFmtg As TCELLFMTG)
With VBFlexGridCells.Rows(iRow).Cols(iCol)
If .lpFmtg = NULL_PTR Then
    If (Mask And CFM_TEXTSTYLE) = CFM_TEXTSTYLE Then CellFmtg.TextStyle = VBFlexGridDefaultCellFmtg.TextStyle
    If (Mask And CFM_ALIGNMENT) = CFM_ALIGNMENT Then CellFmtg.Alignment = VBFlexGridDefaultCellFmtg.Alignment
    If (Mask And CFM_PICTURE) = CFM_PICTURE Then Set CellFmtg.Picture = VBFlexGridDefaultCellFmtg.Picture
    If (Mask And CFM_PICTURERENDERFLAG) = CFM_PICTURERENDERFLAG Then CellFmtg.PictureRenderFlag = VBFlexGridDefaultCellFmtg.PictureRenderFlag
    If (Mask And CFM_PICTUREALIGNMENT) = CFM_PICTUREALIGNMENT Then CellFmtg.PictureAlignment = VBFlexGridDefaultCellFmtg.PictureAlignment
    If (Mask And CFM_BACKCOLOR) = CFM_BACKCOLOR Then CellFmtg.BackColor = VBFlexGridDefaultCellFmtg.BackColor
    If (Mask And CFM_FORECOLOR) = CFM_FORECOLOR Then CellFmtg.ForeColor = VBFlexGridDefaultCellFmtg.ForeColor
    If (Mask And CFM_TOOLTIPTEXT) = CFM_TOOLTIPTEXT Then CellFmtg.ToolTipText = VBFlexGridDefaultCellFmtg.ToolTipText
    If (Mask And CFM_COMBOCUE) = CFM_COMBOCUE Then CellFmtg.ComboCue = VBFlexGridDefaultCellFmtg.ComboCue
    If (Mask And CFM_CHECKED) = CFM_CHECKED Then CellFmtg.Checked = VBFlexGridDefaultCellFmtg.Checked
    If (Mask And CFM_FLOODPERCENT) = CFM_FLOODPERCENT Then CellFmtg.FloodPercent = VBFlexGridDefaultCellFmtg.FloodPercent
    If (Mask And CFM_FLOODCOLOR) = CFM_FLOODCOLOR Then CellFmtg.FloodColor = VBFlexGridDefaultCellFmtg.FloodColor
    If (Mask And CFM_FONT) = CFM_FONT Then
        CellFmtg.FontName = VBFlexGridDefaultCellFmtg.FontName
        CellFmtg.FontSize = VBFlexGridDefaultCellFmtg.FontSize
        CellFmtg.FontStyle = VBFlexGridDefaultCellFmtg.FontStyle
        CellFmtg.FontCharset = VBFlexGridDefaultCellFmtg.FontCharset
    End If
Else
    Dim lpCellFmtg As TLPCELLFMTG
    CopyMemory ByVal VarPtr(lpCellFmtg), ByVal .lpFmtg, LenB(lpCellFmtg)
    With lpCellFmtg
    If (Mask And CFM_TEXTSTYLE) = CFM_TEXTSTYLE Then CellFmtg.TextStyle = .TextStyle
    If (Mask And CFM_ALIGNMENT) = CFM_ALIGNMENT Then CellFmtg.Alignment = .Alignment
    If (Mask And CFM_PICTURE) = CFM_PICTURE Then
        If .lpPicture <> NULL_PTR Then
            FlexObjSetAddRef CellFmtg.Picture, .lpPicture
        Else
            Set CellFmtg.Picture = Nothing
        End If
    End If
    If (Mask And CFM_PICTURERENDERFLAG) = CFM_PICTURERENDERFLAG Then CellFmtg.PictureRenderFlag = .PictureRenderFlag
    If (Mask And CFM_PICTUREALIGNMENT) = CFM_PICTUREALIGNMENT Then CellFmtg.PictureAlignment = .PictureAlignment
    If (Mask And CFM_BACKCOLOR) = CFM_BACKCOLOR Then CellFmtg.BackColor = .BackColor
    If (Mask And CFM_FORECOLOR) = CFM_FORECOLOR Then CellFmtg.ForeColor = .ForeColor
    If (Mask And CFM_TOOLTIPTEXT) = CFM_TOOLTIPTEXT Then
        If lpCellFmtg.lpToolTipText <> NULL_PTR Then
            SysReAllocString VarPtr(CellFmtg.ToolTipText), lpCellFmtg.lpToolTipText
        Else
            CellFmtg.ToolTipText = vbNullString
        End If
    End If
    If (Mask And CFM_COMBOCUE) = CFM_COMBOCUE Then CellFmtg.ComboCue = .ComboCue
    If (Mask And CFM_CHECKED) = CFM_CHECKED Then CellFmtg.Checked = .Checked
    If (Mask And CFM_FLOODPERCENT) = CFM_FLOODPERCENT Then CellFmtg.FloodPercent = .FloodPercent
    If (Mask And CFM_FLOODCOLOR) = CFM_FLOODCOLOR Then CellFmtg.FloodColor = .FloodColor
    If (Mask And CFM_FONT) = CFM_FONT Then
        If lpCellFmtg.lpFontName <> NULL_PTR Then
            SysReAllocString VarPtr(CellFmtg.FontName), lpCellFmtg.lpFontName
        Else
            CellFmtg.FontName = vbNullString
        End If
        CellFmtg.FontSize = .FontSize
        CellFmtg.FontStyle = .FontStyle
        CellFmtg.FontCharset = .FontCharset
    End If
    End With
End If
End With
End Sub

Private Sub SetCellFmtg(ByVal iRow As Long, ByVal iCol As Long, ByVal Mask As Long, ByRef CellFmtg As TCELLFMTG)
Dim lpCellFmtg As TLPCELLFMTG
With VBFlexGridCells.Rows(iRow).Cols(iCol)
If .lpFmtg = NULL_PTR Then Call AllocCellFmtg(.lpFmtg)
If .lpFmtg <> NULL_PTR Then
    CopyMemory ByVal VarPtr(lpCellFmtg), ByVal .lpFmtg, LenB(lpCellFmtg)
    With lpCellFmtg
    If (Mask And CFM_TEXTSTYLE) = CFM_TEXTSTYLE Then .TextStyle = CellFmtg.TextStyle
    If (Mask And CFM_ALIGNMENT) = CFM_ALIGNMENT Then .Alignment = CellFmtg.Alignment
    If (Mask And CFM_PICTURE) = CFM_PICTURE Then
        If lpCellFmtg.lpPicture <> NULL_PTR Then
            FlexObjSet Nothing, lpCellFmtg.lpPicture
            lpCellFmtg.lpPicture = NULL_PTR
        End If
        lpCellFmtg.lpPicture = ObjPtr(CellFmtg.Picture)
        If lpCellFmtg.lpPicture <> NULL_PTR Then FlexObjAddRef lpCellFmtg.lpPicture
    End If
    If (Mask And CFM_PICTURERENDERFLAG) = CFM_PICTURERENDERFLAG Then .PictureRenderFlag = CellFmtg.PictureRenderFlag
    If (Mask And CFM_PICTUREALIGNMENT) = CFM_PICTUREALIGNMENT Then .PictureAlignment = CellFmtg.PictureAlignment
    If (Mask And CFM_BACKCOLOR) = CFM_BACKCOLOR Then .BackColor = CellFmtg.BackColor
    If (Mask And CFM_FORECOLOR) = CFM_FORECOLOR Then .ForeColor = CellFmtg.ForeColor
    If (Mask And CFM_TOOLTIPTEXT) = CFM_TOOLTIPTEXT Then
        If lpCellFmtg.lpToolTipText <> NULL_PTR Then
            SysFreeString lpCellFmtg.lpToolTipText
            lpCellFmtg.lpToolTipText = NULL_PTR
        End If
        lpCellFmtg.lpToolTipText = SysAllocString(StrPtr(CellFmtg.ToolTipText))
    End If
    If (Mask And CFM_COMBOCUE) = CFM_COMBOCUE Then .ComboCue = CellFmtg.ComboCue
    If (Mask And CFM_CHECKED) = CFM_CHECKED Then .Checked = CellFmtg.Checked
    If (Mask And CFM_FLOODPERCENT) = CFM_FLOODPERCENT Then .FloodPercent = CellFmtg.FloodPercent
    If (Mask And CFM_FLOODCOLOR) = CFM_FLOODCOLOR Then .FloodColor = CellFmtg.FloodColor
    If (Mask And CFM_FONT) = CFM_FONT Then
        If lpCellFmtg.lpFontName <> NULL_PTR Then
            SysFreeString lpCellFmtg.lpFontName
            lpCellFmtg.lpFontName = NULL_PTR
        End If
        lpCellFmtg.lpFontName = SysAllocString(StrPtr(CellFmtg.FontName))
        .FontSize = CellFmtg.FontSize
        .FontStyle = CellFmtg.FontStyle
        .FontCharset = CellFmtg.FontCharset
    End If
    End With
    CopyMemory ByVal .lpFmtg, ByVal VarPtr(lpCellFmtg), LenB(lpCellFmtg)
End If
End With
End Sub

Private Sub GetCellFmtgToolTipText(ByVal iRow As Long, ByVal iCol As Long, ByRef TextOut As String)
Dim lpCellFmtg As TLPCELLFMTG
With VBFlexGridCells.Rows(iRow).Cols(iCol)
If .lpFmtg = NULL_PTR Then
    TextOut = VBFlexGridDefaultCellFmtg.ToolTipText
Else
    CopyMemory ByVal VarPtr(lpCellFmtg), ByVal .lpFmtg, LenB(lpCellFmtg)
    If lpCellFmtg.lpToolTipText <> NULL_PTR Then
        SysReAllocString VarPtr(TextOut), lpCellFmtg.lpToolTipText
    Else
        TextOut = vbNullString
    End If
End If
End With
End Sub

Private Sub SetCellFmtgToolTipText(ByVal iRow As Long, ByVal iCol As Long, ByRef TextIn As String)
Dim lpCellFmtg As TLPCELLFMTG
With VBFlexGridCells.Rows(iRow).Cols(iCol)
If .lpFmtg = NULL_PTR Then Call AllocCellFmtg(.lpFmtg)
If .lpFmtg <> NULL_PTR Then
    CopyMemory ByVal VarPtr(lpCellFmtg), ByVal .lpFmtg, LenB(lpCellFmtg)
    If lpCellFmtg.lpToolTipText <> NULL_PTR Then
        SysFreeString lpCellFmtg.lpToolTipText
        lpCellFmtg.lpToolTipText = NULL_PTR
    End If
    lpCellFmtg.lpToolTipText = SysAllocString(StrPtr(TextIn))
    CopyMemory ByVal .lpFmtg, ByVal VarPtr(lpCellFmtg), LenB(lpCellFmtg)
End If
End With
End Sub

Private Function GetCellFmtgChecked(ByVal iRow As Long, ByVal iCol As Long) As Integer
Dim lpCellFmtg As TLPCELLFMTG
With VBFlexGridCells.Rows(iRow).Cols(iCol)
If .lpFmtg = NULL_PTR Then
    GetCellFmtgChecked = VBFlexGridDefaultCellFmtg.Checked
Else
    CopyMemory ByVal VarPtr(lpCellFmtg), ByVal .lpFmtg, LenB(lpCellFmtg)
    GetCellFmtgChecked = lpCellFmtg.Checked
End If
End With
End Function

Private Sub SetCellFmtgChecked(ByVal iRow As Long, ByVal iCol As Long, ByVal NewValue As Integer)
Dim lpCellFmtg As TLPCELLFMTG
With VBFlexGridCells.Rows(iRow).Cols(iCol)
If .lpFmtg = NULL_PTR Then Call AllocCellFmtg(.lpFmtg)
If .lpFmtg <> NULL_PTR Then
    CopyMemory ByVal VarPtr(lpCellFmtg), ByVal .lpFmtg, LenB(lpCellFmtg)
    lpCellFmtg.Checked = NewValue
    CopyMemory ByVal .lpFmtg, ByVal VarPtr(lpCellFmtg), LenB(lpCellFmtg)
End If
End With
End Sub

Private Sub FreeCellTag(ByRef lpTag As LongPtr)
If lpTag <> NULL_PTR Then
    VariantClear ByVal lpTag
    HeapFree GetProcessHeap(), 0, lpTag
    lpTag = NULL_PTR
End If
End Sub

Private Sub AllocCellTag(ByRef lpTag As LongPtr)
If lpTag = NULL_PTR Then
    #If Win64 Then
    Const VARIANT_CB As Long = 24
    #Else
    Const VARIANT_CB As Long = 16
    #End If
    lpTag = HeapAlloc(GetProcessHeap(), 0, VARIANT_CB)
    If lpTag <> NULL_PTR Then VariantInit ByVal lpTag
End If
End Sub

Private Sub GetCellTag(ByVal iRow As Long, ByVal iCol As Long, ByRef TagOut As Variant)
With VBFlexGridCells.Rows(iRow).Cols(iCol)
If .lpTag = NULL_PTR Then
    TagOut = Empty
Else
    VariantCopy TagOut, ByVal .lpTag
End If
End With
End Sub

Private Sub SetCellTag(ByVal iRow As Long, ByVal iCol As Long, ByRef TagIn As Variant)
With VBFlexGridCells.Rows(iRow).Cols(iCol)
If .lpTag = NULL_PTR Then Call AllocCellTag(.lpTag)
If .lpTag <> NULL_PTR Then VariantCopy ByVal .lpTag, TagIn
End With
End Sub

Private Sub GetTextDisplay(ByVal iRow As Long, ByVal iCol As Long, ByRef Text As String)
If VBFlexGridColsInfo(iCol).Lookup.Count > 0 Then
    Dim Hash As Long, i As Long
    Hash = CalcHash(Text)
    For i = 0 To (VBFlexGridColsInfo(iCol).Lookup.Count - 1)
        If VBFlexGridColsInfo(iCol).Lookup.Items(i).Hash = Hash Then
            If StrComp(VBFlexGridColsInfo(iCol).Lookup.Items(i).Key, Text, vbTextCompare) = 0 Then
                Text = VBFlexGridColsInfo(iCol).Lookup.Items(i).Value
                Exit For
            End If
        End If
    Next i
End If
If iRow >= PropFixedRows And iCol >= PropFixedCols Then
    If Not VBFlexGridColsInfo(iCol).Format = vbNullString Then Text = Format$(Text, VBFlexGridColsInfo(iCol).Format, vbUseSystemDayOfWeek, vbUseSystem)
Else
    If StrPtr(VBFlexGridColsInfo(iCol).FixedFormat) = NULL_PTR Then
        If Not VBFlexGridColsInfo(iCol).Format = vbNullString Then Text = Format$(Text, VBFlexGridColsInfo(iCol).Format, vbUseSystemDayOfWeek, vbUseSystem)
    Else
        If Not VBFlexGridColsInfo(iCol).FixedFormat = vbNullString Then Text = Format$(Text, VBFlexGridColsInfo(iCol).FixedFormat, vbUseSystemDayOfWeek, vbUseSystem)
    End If
End If
End Sub

Private Function CellTextDisplay() As String
If VBFlexGridRow > -1 And VBFlexGridCol > -1 Then
    Call GetCellText(VBFlexGridRow, VBFlexGridCol, CellTextDisplay)
    Call GetTextDisplay(VBFlexGridRow, VBFlexGridCol, CellTextDisplay)
End If
End Function

Private Function CalcHash(ByRef Key As String, Optional ByVal CaseSensitive As Boolean) As Long
If Key = vbNullString Then Exit Function
Dim Length As Long, Buffer() As Integer, i As Long
Length = Len(Key)
ReDim Buffer(0 To (Length - 1)) As Integer
If CaseSensitive = False Then
    Const LCMAP_LOWERCASE As Long = &H100
    LCMapString GetUserDefaultLCID(), LCMAP_LOWERCASE, StrPtr(Key), Length, VarPtr(Buffer(0)), Length
Else
    CopyMemory ByVal VarPtr(Buffer(0)), ByVal StrPtr(Key), LenB(Key)
End If
For i = 0 To (Length - 1)
    CalcHash = (CalcHash * 37& + Buffer(i) And &HFFFF&)
Next i
Const HASH_SIZE As Long = 2999
CalcHash = (CalcHash And &H7FFFFFFF) Mod HASH_SIZE
End Function

Private Function CellTextHidden() As Boolean
If VBFlexGridRow > -1 And VBFlexGridCol > -1 Then
    Dim Text As String
    Call GetCellText(VBFlexGridRow, VBFlexGridCol, Text)
    Call GetTextDisplay(VBFlexGridRow, VBFlexGridCol, Text)
    If VBFlexGridColsInfo(VBFlexGridCol).ImageList.Handle <> NULL_PTR Then
        If GetImageIndex(VBFlexGridRow, VBFlexGridCol, Text) > 0 Then
            CellTextHidden = True
            Exit Function
        End If
    End If
    Dim Checked As Integer
    Checked = GetCellChecked(VBFlexGridRow, VBFlexGridCol)
    If Checked > -1 Then
        Select Case Checked
            Case FlexTextAsCheckBox, FlexDisabledTextAsCheckBox
                CellTextHidden = True
                Exit Function
        End Select
    End If
End If
End Function

Private Function GetRowHeight(ByVal iRow As Long) As Long
If PropRows < 1 Or PropCols < 1 Then Exit Function
If (VBFlexGridCells.Rows(iRow).RowInfo.State And RWIS_HIDDEN) = 0 Then
    If VBFlexGridCells.Rows(iRow).RowInfo.Height = -1 Then
        If VBFlexGridUniformRowHeight = -1 Then
            If (iRow > (PropFixedRows - 1) And PropFixedCols = 0) Or VBFlexGridDefaultFixedRowHeight = -1 Then
                GetRowHeight = VBFlexGridDefaultRowHeight
            ElseIf iRow > (PropFixedRows - 1) Then
                If VBFlexGridDefaultRowHeight > VBFlexGridDefaultFixedRowHeight Then
                    GetRowHeight = VBFlexGridDefaultRowHeight
                Else
                    GetRowHeight = VBFlexGridDefaultFixedRowHeight
                End If
            Else
                GetRowHeight = VBFlexGridDefaultFixedRowHeight
            End If
        Else
            GetRowHeight = VBFlexGridUniformRowHeight
        End If
    Else
        GetRowHeight = VBFlexGridCells.Rows(iRow).RowInfo.Height
    End If
    If GetRowHeight > 0 Then
        If PropRowHeightMin > 0 Then If GetRowHeight < PropRowHeightMin Then GetRowHeight = PropRowHeightMin
        If PropRowHeightMax > 0 Then If GetRowHeight > PropRowHeightMax Then GetRowHeight = PropRowHeightMax
    End If
End If
End Function

Private Function GetColWidth(ByVal iCol As Long) As Long
If PropRows < 1 Or PropCols < 1 Then Exit Function
If iCol <> VBFlexGridExtendLastCol Then
    If (VBFlexGridColsInfo(iCol).State And CLIS_HIDDEN) = 0 Then
        If VBFlexGridColsInfo(iCol).Width = -1 Then
            If iCol > (PropFixedCols - 1) Or VBFlexGridDefaultFixedColWidth = -1 Then
                GetColWidth = VBFlexGridDefaultColWidth
            Else
                GetColWidth = VBFlexGridDefaultFixedColWidth
            End If
        Else
            GetColWidth = VBFlexGridColsInfo(iCol).Width
        End If
        If GetColWidth > 0 Then
            If PropColWidthMin > 0 Then If GetColWidth < PropColWidthMin Then GetColWidth = PropColWidthMin
            If PropColWidthMax > 0 Then If GetColWidth > PropColWidthMax Then GetColWidth = PropColWidthMax
        End If
    End If
Else
    GetColWidth = GetColWidth_NoExtendLastCol(iCol)
    Dim i As Long, CX As Long
    For i = 0 To ((PropFixedCols + PropFrozenCols) - 1)
        If i < iCol Then CX = CX + GetColWidth_NoExtendLastCol(i)
    Next i
    For i = iCol To VBFlexGridLeftCol Step -1
        CX = CX + GetColWidth_NoExtendLastCol(i)
        If CX > VBFlexGridClientRect.Right Then Exit For
    Next i
    If (VBFlexGridClientRect.Right - CX) > 0 Then GetColWidth = GetColWidth + (VBFlexGridClientRect.Right - CX)
End If
End Function

Private Function GetColWidth_NoExtendLastCol(ByVal iCol As Long) As Long
If PropRows < 1 Or PropCols < 1 Then Exit Function
If (VBFlexGridColsInfo(iCol).State And CLIS_HIDDEN) = 0 Then
    If VBFlexGridColsInfo(iCol).Width = -1 Then
        If iCol > (PropFixedCols - 1) Or VBFlexGridDefaultFixedColWidth = -1 Then
            GetColWidth_NoExtendLastCol = VBFlexGridDefaultColWidth
        Else
            GetColWidth_NoExtendLastCol = VBFlexGridDefaultFixedColWidth
        End If
    Else
        GetColWidth_NoExtendLastCol = VBFlexGridColsInfo(iCol).Width
    End If
    If GetColWidth_NoExtendLastCol > 0 Then
        If PropColWidthMin > 0 Then If GetColWidth_NoExtendLastCol < PropColWidthMin Then GetColWidth_NoExtendLastCol = PropColWidthMin
        If PropColWidthMax > 0 Then If GetColWidth_NoExtendLastCol > PropColWidthMax Then GetColWidth_NoExtendLastCol = PropColWidthMax
    End If
End If
End Function

Private Function GetTextSize(ByVal iRow As Long, ByVal iCol As Long, ByVal Text As String, Optional ByVal hDC As LongPtr) As SIZEAPI
If VBFlexGridHandle = NULL_PTR Or (PropRows < 1 Or PropCols < 1) Then Exit Function
Dim hDCTemp As LongPtr
If hDC = NULL_PTR Then
    hDCTemp = GetDC(VBFlexGridHandle)
    hDC = hDCTemp
End If
If hDC <> NULL_PTR Then
    Dim CellFmtg As TCELLFMTG
    Call GetCellFmtg(iRow, iCol, CFM_FONT, CellFmtg)
    With CellFmtg
    Dim hFontTemp As LongPtr, hFontOld As LongPtr
    If .FontName = vbNullString Then
        If iRow > (PropFixedRows - 1) And iCol > (PropFixedCols - 1) Then
            hFontOld = SelectObject(hDC, VBFlexGridFontHandle)
        Else
            If VBFlexGridFontFixedHandle = NULL_PTR Then
                hFontOld = SelectObject(hDC, VBFlexGridFontHandle)
            Else
                hFontOld = SelectObject(hDC, VBFlexGridFontFixedHandle)
            End If
        End If
    Else
        Dim TempFont As StdFont
        Set TempFont = New StdFont
        TempFont.Name = .FontName
        TempFont.Size = .FontSize
        TempFont.Bold = CBool((.FontStyle And FS_BOLD) = FS_BOLD)
        TempFont.Italic = CBool((.FontStyle And FS_ITALIC) = FS_ITALIC)
        TempFont.Strikethrough = CBool((.FontStyle And FS_STRIKEOUT) = FS_STRIKEOUT)
        TempFont.Underline = CBool((.FontStyle And FS_UNDERLINE) = FS_UNDERLINE)
        TempFont.Charset = .FontCharset
        hFontTemp = CreateGDIFontFromOLEFont(TempFont, PropFontQuality)
        hFontOld = SelectObject(hDC, hFontTemp)
        Set TempFont = Nothing
    End If
    End With
    If Not Text = vbNullString Then
        If PropSingleLine = False Then
            If InStr(Text, vbCrLf) Then Text = Replace$(Text, vbCrLf, vbCr)
            If InStr(Text, vbLf) Then Text = Replace$(Text, vbLf, vbCr)
        Else
            If InStr(Text, vbCr) Then Text = Replace$(Text, vbCr, vbNullString)
            If InStr(Text, vbLf) Then Text = Replace$(Text, vbLf, vbNullString)
        End If
        Dim Pos1 As Long, Pos2 As Long, Temp As String, Size As SIZEAPI
        Do
            Pos1 = InStr(Pos1 + 1, Text, vbCr)
            If Pos1 > 0 Then
                Temp = Mid$(Text, Pos2 + 1, Pos1 - Pos2 - 1)
            Else
                Temp = Mid$(Text, Pos2 + 1)
            End If
            GetTextExtentPoint32 hDC, ByVal StrPtr(Temp), Len(Temp), Size
            With GetTextSize
            .CY = .CY + Size.CY
            If Size.CX > .CX Then .CX = Size.CX
            End With
            Pos2 = Pos1
        Loop Until Pos1 = 0
    Else
        Dim TM As TEXTMETRIC
        If GetTextMetrics(hDC, TM) <> 0 Then GetTextSize.CY = TM.TMHeight
    End If
    If hFontOld <> NULL_PTR Then SelectObject hDC, hFontOld
    If hFontTemp <> NULL_PTR Then DeleteObject hFontTemp
    If hDCTemp <> NULL_PTR Then ReleaseDC VBFlexGridHandle, hDCTemp
End If
End Function

Private Function GetBestHeight(ByVal iRow As Long, ByVal iCol As Long, ByRef Text As String, Optional ByVal hDC As LongPtr) As Long
If VBFlexGridHandle = NULL_PTR Or (PropRows < 1 Or PropCols < 1) Then Exit Function
Dim hDCTemp As LongPtr
If hDC = NULL_PTR Then
    hDCTemp = GetDC(VBFlexGridHandle)
    hDC = hDCTemp
End If
If hDC <> NULL_PTR Then
    Dim CellFmtg As TCELLFMTG
    Call GetCellFmtg(iRow, iCol, CFM_PICTURE Or CFM_PICTUREALIGNMENT Or CFM_FONT, CellFmtg)
    With CellFmtg
    Dim hFontTemp As LongPtr, hFontOld As LongPtr
    If .FontName = vbNullString Then
        If iRow > (PropFixedRows - 1) And iCol > (PropFixedCols - 1) Then
            hFontOld = SelectObject(hDC, VBFlexGridFontHandle)
        Else
            If VBFlexGridFontFixedHandle = NULL_PTR Then
                hFontOld = SelectObject(hDC, VBFlexGridFontHandle)
            Else
                hFontOld = SelectObject(hDC, VBFlexGridFontFixedHandle)
            End If
        End If
    Else
        Dim TempFont As StdFont
        Set TempFont = New StdFont
        TempFont.Name = .FontName
        TempFont.Size = .FontSize
        TempFont.Bold = CBool((.FontStyle And FS_BOLD) = FS_BOLD)
        TempFont.Italic = CBool((.FontStyle And FS_ITALIC) = FS_ITALIC)
        TempFont.Strikethrough = CBool((.FontStyle And FS_STRIKEOUT) = FS_STRIKEOUT)
        TempFont.Underline = CBool((.FontStyle And FS_UNDERLINE) = FS_UNDERLINE)
        TempFont.Charset = .FontCharset
        hFontTemp = CreateGDIFontFromOLEFont(TempFont, PropFontQuality)
        hFontOld = SelectObject(hDC, hFontTemp)
        Set TempFont = Nothing
    End If
    Dim HiddenText As Boolean, Checked As Integer
    If VBFlexGridColsInfo(iCol).ImageList.Handle <> NULL_PTR Then
        If GetImageIndex(iRow, iCol, Text) > 0 Then HiddenText = True
    End If
    Checked = GetCellChecked(iRow, iCol)
    If Checked > -1 Then
        Select Case Checked
            Case FlexTextAsCheckBox, FlexDisabledTextAsCheckBox
                HiddenText = True
        End Select
    End If
    Dim CY As Long
    If Not Text = vbNullString And HiddenText = False Then
        Dim CellRect As RECT
        With CellRect
        .Left = 0
        .Top = 0
        .Right = GetColWidth(iCol)
        .Bottom = GetRowHeight(iRow)
        End With
        Dim GridLineOffsets As TGRIDLINEOFFSETS, ComboCue As FlexComboCueConstants, ComboCueWidth As Long, ComboCueAlignment As FlexLeftRightAlignmentConstants
        If PropAllowUserEditing = True Or PropAlwaysAllowComboCues = True Then
            ComboCue = GetComboCueActive(iRow, iCol)
            If ComboCue > FlexComboCueNone Then
                Call GetGridLineOffsetsStruct(iRow, iCol, GridLineOffsets)
                ComboCueWidth = GetComboButtonWidth(iRow, iCol, ComboCue)
                If (((CellRect.Right - CellRect.Left) - (GridLineOffsets.LeftTop.CX + GridLineOffsets.RightBottom.CX)) - ComboCueWidth) < 0 Then ComboCueWidth = ((CellRect.Right - CellRect.Left) - (GridLineOffsets.LeftTop.CX + GridLineOffsets.RightBottom.CX))
                If VBFlexGridColsInfo(iCol).ComboButtonAlignment = -1 Then
                    ComboCueAlignment = VBFlexGridComboButtonAlignment
                Else
                    ComboCueAlignment = VBFlexGridColsInfo(iCol).ComboButtonAlignment
                End If
            End If
        End If
        Dim TextIndent As TTEXTINDENT
        If (VBFlexGridColsInfo(iCol).State And CLIS_TEXTINDENT) = CLIS_TEXTINDENT Then
            With TextIndent
            RaiseEvent CellTextIndent(iRow, iCol, .Left, .Right)
            If .Left > 0 Then .Left = UserControl.ScaleX(.Left, vbTwips, vbPixels) Else .Left = 0
            If .Right > 0 Then .Right = UserControl.ScaleX(.Right, vbTwips, vbPixels) Else .Right = 0
            End With
        End If
        Dim TextRect As RECT, DrawFlags As Long
        With TextRect
        .Left = CellRect.Left + VBFlexGridPixelMetrics.TextPadding.CX + TextIndent.Left
        .Top = CellRect.Top + VBFlexGridPixelMetrics.TextPadding.CY
        .Right = CellRect.Right - VBFlexGridPixelMetrics.TextPadding.CX - TextIndent.Right
        If ComboCueWidth > 0 Then
            If ComboCueAlignment = FlexLeftRightAlignmentRight Then
                .Right = .Right - ComboCueWidth
            ElseIf ComboCueAlignment = FlexLeftRightAlignmentLeft Then
                .Left = .Left + ComboCueWidth
            End If
        End If
        .Bottom = CellRect.Bottom - VBFlexGridPixelMetrics.TextPadding.CY
        End With
        DrawFlags = DT_NOPREFIX
        If VBFlexGridRTLReading = True Then DrawFlags = DrawFlags Or DT_RTLREADING
        ' Alignment format will be ignored.
        If Not .Picture Is Nothing Then
            If .Picture.Handle <> NULL_PTR Then
                Select Case .PictureAlignment
                    Case FlexPictureAlignmentLeftTopNoOverlap, FlexPictureAlignmentLeftCenterNoOverlap, FlexPictureAlignmentLeftBottomNoOverlap
                        TextRect.Left = TextRect.Left + CHimetricToPixel_X(.Picture.Width)
                    Case FlexPictureAlignmentRightTopNoOverlap, FlexPictureAlignmentRightCenterNoOverlap, FlexPictureAlignmentRightBottomNoOverlap
                        TextRect.Right = TextRect.Right - CHimetricToPixel_X(.Picture.Width)
                End Select
            End If
        End If
        If Checked > -1 Then
            Dim CheckBoxAlignment As FlexCheckBoxAlignmentConstants
            If iRow < PropFixedRows Or iCol < PropFixedCols Then
                If VBFlexGridColsInfo(iCol).FixedCheckBoxAlignment = -1 Then
                    CheckBoxAlignment = VBFlexGridColsInfo(iCol).CheckBoxAlignment
                Else
                    CheckBoxAlignment = VBFlexGridColsInfo(iCol).FixedCheckBoxAlignment
                End If
            Else
                CheckBoxAlignment = VBFlexGridColsInfo(iCol).CheckBoxAlignment
            End If
            If CheckBoxAlignment = FlexCheckBoxAlignmentUsePictureAlignment Then
                Select Case .PictureAlignment
                    Case FlexPictureAlignmentLeftTop, FlexPictureAlignmentLeftCenter, FlexPictureAlignmentLeftBottom, FlexPictureAlignmentLeftTopNoOverlap, FlexPictureAlignmentLeftCenterNoOverlap, FlexPictureAlignmentLeftBottomNoOverlap
                        CheckBoxAlignment = FlexCheckBoxAlignmentLeftCenter
                    Case FlexPictureAlignmentCenterTop, FlexPictureAlignmentCenterCenter, FlexPictureAlignmentCenterBottom, FlexPictureAlignmentStretch, FlexPictureAlignmentTile
                        CheckBoxAlignment = FlexCheckBoxAlignmentCenterCenter
                    Case FlexPictureAlignmentRightTop, FlexPictureAlignmentRightCenter, FlexPictureAlignmentRightBottom, FlexPictureAlignmentRightTopNoOverlap, FlexPictureAlignmentRightCenterNoOverlap, FlexPictureAlignmentRightBottomNoOverlap
                        CheckBoxAlignment = FlexCheckBoxAlignmentRightCenter
                End Select
            End If
            Select Case CheckBoxAlignment
                Case FlexCheckBoxAlignmentLeftTop, FlexCheckBoxAlignmentLeftCenter, FlexCheckBoxAlignmentLeftBottom
                    TextRect.Left = TextRect.Left + VBFlexGridPixelMetrics.CheckBoxSize + VBFlexGridPixelMetrics.TextPadding.CX
                Case FlexCheckBoxAlignmentRightTop, FlexCheckBoxAlignmentRightCenter, FlexCheckBoxAlignmentRightBottom
                    TextRect.Right = TextRect.Right - VBFlexGridPixelMetrics.CheckBoxSize - VBFlexGridPixelMetrics.TextPadding.CX
            End Select
        End If
        If iRow > (PropFixedRows - 1) And iCol > (PropFixedCols - 1) Then
            If VBFlexGridColsInfo(iCol).WordWrapOption = -1 Then
                If PropWordWrap = True Then
                    DrawFlags = DrawFlags Or DT_WORDBREAK
                ElseIf PropSingleLine = True Then
                    DrawFlags = DrawFlags Or DT_SINGLELINE
                End If
            Else
                Select Case VBFlexGridColsInfo(iCol).WordWrapOption
                    Case FlexWordWrapNone, FlexEndEllipsis, FlexPathEllipsis, FlexWordEllipsis
                        ' Void
                    Case FlexWordBreak, FlexWordBreakEndEllipsis, FlexWordBreakPathEllipsis, FlexWordBreakWordEllipsis
                        DrawFlags = DrawFlags Or DT_WORDBREAK
                    Case FlexSingleLine, FlexSingleLineEndEllipsis, FlexSingleLinePathEllipsis, FlexSingleLineWordEllipsis
                        DrawFlags = DrawFlags Or DT_SINGLELINE
                End Select
            End If
        Else
            If VBFlexGridColsInfo(iCol).WordWrapOptionFixed = -1 Then
                If PropWordWrap = True Then
                    DrawFlags = DrawFlags Or DT_WORDBREAK
                ElseIf PropSingleLine = True Then
                    DrawFlags = DrawFlags Or DT_SINGLELINE
                End If
            Else
                Select Case VBFlexGridColsInfo(iCol).WordWrapOptionFixed
                    Case FlexWordWrapNone, FlexEndEllipsis, FlexPathEllipsis, FlexWordEllipsis
                        ' Void
                    Case FlexWordBreak, FlexWordBreakEndEllipsis, FlexWordBreakPathEllipsis, FlexWordBreakWordEllipsis
                        DrawFlags = DrawFlags Or DT_WORDBREAK
                    Case FlexSingleLine, FlexSingleLineEndEllipsis, FlexSingleLinePathEllipsis, FlexSingleLineWordEllipsis
                        DrawFlags = DrawFlags Or DT_SINGLELINE
                End Select
            End If
        End If
        ' Ellipsis format will be ignored.
        If iRow > (PropFixedRows - 1) And iCol > (PropFixedCols - 1) Then
            If VBFlexGridColsInfo(iCol).MimicTextBox = -1 Then
                If PropMimicTextBox = True Then DrawFlags = DrawFlags Or DT_EDITCONTROL
            Else
                If VBFlexGridColsInfo(iCol).MimicTextBox = FlexMimicTextBoxOn Then DrawFlags = DrawFlags Or DT_EDITCONTROL
            End If
        Else
            If VBFlexGridColsInfo(iCol).MimicTextBoxFixed = -1 Then
                If PropMimicTextBox = True Then DrawFlags = DrawFlags Or DT_EDITCONTROL
            Else
                If VBFlexGridColsInfo(iCol).MimicTextBoxFixed = FlexMimicTextBoxOn Then DrawFlags = DrawFlags Or DT_EDITCONTROL
            End If
        End If
        If VBFlexGridColsInfo(iCol).SortArrow <> FlexSortArrowNone And iRow = PropRowSortArrows And iRow < PropFixedRows Then
            Dim SortArrowMetrics As TSORTARROWMETRICS
            Call GetSortArrowMetrics(hDC, SortArrowMetrics)
            If VBFlexGridColsInfo(iCol).SortArrowAlignment = FlexLeftRightAlignmentRight Then
                TextRect.Right = TextRect.Right - SortArrowMetrics.ClientSize.CX
            ElseIf VBFlexGridColsInfo(iCol).SortArrowAlignment = FlexLeftRightAlignmentLeft Then
                TextRect.Left = TextRect.Left + SortArrowMetrics.ClientSize.CX
            End If
        End If
        CY = DrawText(hDC, StrPtr(Text), -1, TextRect, DrawFlags Or DT_CALCRECT)
    Else
        Dim TM As TEXTMETRIC
        If GetTextMetrics(hDC, TM) <> 0 Then CY = TM.TMHeight
    End If
    If PropBestFitMode <> FlexBestFitModeTextOnly Then
        ' The height of the sort arrow client size equals to TM.TMHeight.
        ' No other content currently adjusts the text rect at the height.
    End If
    GetBestHeight = CY
    If hFontOld <> NULL_PTR Then SelectObject hDC, hFontOld
    If hFontTemp <> NULL_PTR Then DeleteObject hFontTemp
    If hDCTemp <> NULL_PTR Then ReleaseDC VBFlexGridHandle, hDCTemp
    End With
End If
End Function

Private Function GetBestWidth(ByVal iRow As Long, ByVal iCol As Long, ByRef Text As String, Optional ByVal hDC As LongPtr) As Long
If VBFlexGridHandle = NULL_PTR Or (PropRows < 1 Or PropCols < 1) Then Exit Function
Dim hDCTemp As LongPtr
If hDC = NULL_PTR Then
    hDCTemp = GetDC(VBFlexGridHandle)
    hDC = hDCTemp
End If
If hDC <> NULL_PTR Then
    Dim CellFmtg As TCELLFMTG
    Call GetCellFmtg(iRow, iCol, CFM_PICTURE Or CFM_PICTUREALIGNMENT Or CFM_FONT, CellFmtg)
    With CellFmtg
    Dim hFontTemp As LongPtr, hFontOld As LongPtr
    If .FontName = vbNullString Then
        If iRow > (PropFixedRows - 1) And iCol > (PropFixedCols - 1) Then
            hFontOld = SelectObject(hDC, VBFlexGridFontHandle)
        Else
            If VBFlexGridFontFixedHandle = NULL_PTR Then
                hFontOld = SelectObject(hDC, VBFlexGridFontHandle)
            Else
                hFontOld = SelectObject(hDC, VBFlexGridFontFixedHandle)
            End If
        End If
    Else
        Dim TempFont As StdFont
        Set TempFont = New StdFont
        TempFont.Name = .FontName
        TempFont.Size = .FontSize
        TempFont.Bold = CBool((.FontStyle And FS_BOLD) = FS_BOLD)
        TempFont.Italic = CBool((.FontStyle And FS_ITALIC) = FS_ITALIC)
        TempFont.Strikethrough = CBool((.FontStyle And FS_STRIKEOUT) = FS_STRIKEOUT)
        TempFont.Underline = CBool((.FontStyle And FS_UNDERLINE) = FS_UNDERLINE)
        TempFont.Charset = .FontCharset
        hFontTemp = CreateGDIFontFromOLEFont(TempFont, PropFontQuality)
        hFontOld = SelectObject(hDC, hFontTemp)
        Set TempFont = Nothing
    End If
    Dim HiddenText As Boolean, Checked As Integer
    If VBFlexGridColsInfo(iCol).ImageList.Handle <> NULL_PTR Then
        If GetImageIndex(iRow, iCol, Text) > 0 Then HiddenText = True
    End If
    Checked = GetCellChecked(iRow, iCol)
    If Checked > -1 Then
        Select Case Checked
            Case FlexTextAsCheckBox, FlexDisabledTextAsCheckBox
                HiddenText = True
        End Select
    End If
    Dim CX As Long
    If HiddenText = False Then CX = GetTextSize(iRow, iCol, Text, hDC).CX
    If (VBFlexGridColsInfo(iCol).State And CLIS_TEXTINDENT) = CLIS_TEXTINDENT Then
        Dim TextIndent As TTEXTINDENT
        With TextIndent
        RaiseEvent CellTextIndent(iRow, iCol, .Left, .Right)
        If .Left > 0 Then .Left = UserControl.ScaleX(.Left, vbTwips, vbPixels) Else .Left = 0
        If .Right > 0 Then .Right = UserControl.ScaleX(.Right, vbTwips, vbPixels) Else .Right = 0
        CX = CX + .Left + .Right
        End With
    End If
    If PropBestFitMode <> FlexBestFitModeTextOnly Then
        Select Case PropBestFitMode
            Case FlexBestFitModeFull, FlexBestFitModeOtherText
                Dim ComboCue As FlexComboCueConstants, ComboCueWidth As Long
                If PropAllowUserEditing = True Or PropAlwaysAllowComboCues = True Then
                    ComboCue = GetComboCueActive(iRow, iCol)
                    If ComboCue > FlexComboCueNone Then ComboCueWidth = GetComboButtonWidth(iRow, iCol, ComboCue)
                End If
                If ComboCueWidth > 0 Then CX = CX + ComboCueWidth
                If Not .Picture Is Nothing Then
                    If .Picture.Handle <> NULL_PTR Then
                        Select Case .PictureAlignment
                            Case FlexPictureAlignmentLeftTopNoOverlap, FlexPictureAlignmentLeftCenterNoOverlap, FlexPictureAlignmentLeftBottomNoOverlap, FlexPictureAlignmentRightTopNoOverlap, FlexPictureAlignmentRightCenterNoOverlap, FlexPictureAlignmentRightBottomNoOverlap
                                CX = CX + CHimetricToPixel_X(.Picture.Width)
                        End Select
                    End If
                End If
                If Checked > -1 Then
                    Dim CheckBoxAlignment As FlexCheckBoxAlignmentConstants
                    If iRow < PropFixedRows Or iCol < PropFixedCols Then
                        If VBFlexGridColsInfo(iCol).FixedCheckBoxAlignment = -1 Then
                            CheckBoxAlignment = VBFlexGridColsInfo(iCol).CheckBoxAlignment
                        Else
                            CheckBoxAlignment = VBFlexGridColsInfo(iCol).FixedCheckBoxAlignment
                        End If
                    Else
                        CheckBoxAlignment = VBFlexGridColsInfo(iCol).CheckBoxAlignment
                    End If
                    If CheckBoxAlignment = FlexCheckBoxAlignmentUsePictureAlignment Then
                        Select Case .PictureAlignment
                            Case FlexPictureAlignmentLeftTop, FlexPictureAlignmentLeftCenter, FlexPictureAlignmentLeftBottom, FlexPictureAlignmentLeftTopNoOverlap, FlexPictureAlignmentLeftCenterNoOverlap, FlexPictureAlignmentLeftBottomNoOverlap
                                CheckBoxAlignment = FlexCheckBoxAlignmentLeftCenter
                            Case FlexPictureAlignmentCenterTop, FlexPictureAlignmentCenterCenter, FlexPictureAlignmentCenterBottom, FlexPictureAlignmentStretch, FlexPictureAlignmentTile
                                CheckBoxAlignment = FlexCheckBoxAlignmentCenterCenter
                            Case FlexPictureAlignmentRightTop, FlexPictureAlignmentRightCenter, FlexPictureAlignmentRightBottom, FlexPictureAlignmentRightTopNoOverlap, FlexPictureAlignmentRightCenterNoOverlap, FlexPictureAlignmentRightBottomNoOverlap
                                CheckBoxAlignment = FlexCheckBoxAlignmentRightCenter
                        End Select
                    End If
                    Select Case CheckBoxAlignment
                        Case FlexCheckBoxAlignmentLeftTop, FlexCheckBoxAlignmentLeftCenter, FlexCheckBoxAlignmentLeftBottom, FlexCheckBoxAlignmentRightTop, FlexCheckBoxAlignmentRightCenter, FlexCheckBoxAlignmentRightBottom
                            CX = CX + VBFlexGridPixelMetrics.CheckBoxSize + VBFlexGridPixelMetrics.TextPadding.CX
                    End Select
                End If
        End Select
        Select Case PropBestFitMode
            Case FlexBestFitModeFull, FlexBestFitModeSortArrowText
                If VBFlexGridColsInfo(iCol).SortArrow <> FlexSortArrowNone And iRow = PropRowSortArrows And iRow < PropFixedRows Then
                    Dim SortArrowMetrics As TSORTARROWMETRICS
                    Call GetSortArrowMetrics(hDC, SortArrowMetrics)
                    CX = CX + SortArrowMetrics.ClientSize.CX
                End If
        End Select
    End If
    GetBestWidth = CX
    If hFontOld <> NULL_PTR Then SelectObject hDC, hFontOld
    If hFontTemp <> NULL_PTR Then DeleteObject hFontTemp
    If hDCTemp <> NULL_PTR Then ReleaseDC VBFlexGridHandle, hDCTemp
    End With
End If
End Function

Private Sub GetGridLineOffsetsStruct(ByVal iRow As Long, ByVal iCol As Long, ByRef GridLineOffsets As TGRIDLINEOFFSETS)
' The grid line offsets in the MS flex grid control are hard-coded for all scenarios as per below values.
With GridLineOffsets
.LeftTop.CX = 0
.LeftTop.CY = 0
.RightBottom.CX = 1
.RightBottom.CY = 1
If PropFixGridLineOffsets = True Then
    Select Case IIf(CBool(iRow >= PropFixedRows And iCol >= PropFixedCols), PropGridLines, PropGridLinesFixed)
        Case FlexGridLineNone
            .LeftTop.CX = 0
            .LeftTop.CY = 0
            .RightBottom.CX = 0
            .RightBottom.CY = 0
        Case FlexGridLineFlat, FlexGridLineDashes, FlexGridLineDots
            .LeftTop.CX = 0
            .LeftTop.CY = 0
            .RightBottom.CX = 1
            .RightBottom.CY = 1
        Case FlexGridLineInset
            .LeftTop.CX = 0
            .LeftTop.CY = 0
            .RightBottom.CX = 1
            .RightBottom.CY = 1
        Case FlexGridLineRaised
            .LeftTop.CX = 1
            .LeftTop.CY = 1
            .RightBottom.CX = 0
            .RightBottom.CY = 0
        Case FlexGridLineFlatHorz, FlexGridLineDashesHorz, FlexGridLineDotsHorz
            .LeftTop.CX = 0
            .LeftTop.CY = 0
            .RightBottom.CX = 0
            .RightBottom.CY = 1
        Case FlexGridLineInsetHorz
            .LeftTop.CX = 0
            .LeftTop.CY = 0
            .RightBottom.CX = 0
            .RightBottom.CY = 1
        Case FlexGridLineRaisedHorz
            .LeftTop.CX = 0
            .LeftTop.CY = 1
            .RightBottom.CX = 0
            .RightBottom.CY = 0
        Case FlexGridLineFlatVert, FlexGridLineDashesVert, FlexGridLineDotsVert
            .LeftTop.CX = 0
            .LeftTop.CY = 0
            .RightBottom.CX = 1
            .RightBottom.CY = 0
        Case FlexGridLineInsetVert
            .LeftTop.CX = 0
            .LeftTop.CY = 0
            .RightBottom.CX = 1
            .RightBottom.CY = 0
        Case FlexGridLineRaisedVert
            .LeftTop.CX = 1
            .LeftTop.CY = 0
            .RightBottom.CX = 0
            .RightBottom.CY = 0
    End Select
    If PropSheetBorder = True Or PropFrozenRows > 0 Or PropFrozenCols > 0 Then
        Dim MergedRange As TCELLRANGE
        Call GetMergedRangeStruct(iRow, iCol, MergedRange)
        If PropSheetBorder = True Then
            Select Case GetSheetBorderRow()
                Case MergedRange.TopRow To MergedRange.BottomRow
                    If .RightBottom.CY < 1 Then .RightBottom.CY = 1
            End Select
            Select Case GetSheetBorderCol()
                Case MergedRange.LeftCol To MergedRange.RightCol
                    If .RightBottom.CX < 1 Then .RightBottom.CX = 1
            End Select
        End If
        If PropFrozenRows > 0 Then
            Select Case GetFrozenRow(False)
                Case MergedRange.TopRow To MergedRange.BottomRow
                    Select Case PropGridLinesFrozen
                        Case FlexGridLineNone
                            ' Void
                        Case FlexGridLineFlat, FlexGridLineDashes, FlexGridLineDots
                            If .RightBottom.CY < 1 Then .RightBottom.CY = 1
                        Case FlexGridLineInset
                            If .RightBottom.CY < 1 Then .RightBottom.CY = 1
                        Case FlexGridLineRaised
                            ' Void
                        Case FlexGridLineFlatHorz, FlexGridLineDashesHorz, FlexGridLineDotsHorz
                            If .RightBottom.CY < 1 Then .RightBottom.CY = 1
                        Case FlexGridLineInsetHorz
                            If .RightBottom.CY < 1 Then .RightBottom.CY = 1
                        Case FlexGridLineRaisedHorz
                            ' Void
                        Case FlexGridLineFlatVert, FlexGridLineDashesVert, FlexGridLineDotsVert
                            ' Void
                        Case FlexGridLineInsetVert
                            ' Void
                        Case FlexGridLineRaisedVert
                            ' Void
                    End Select
            End Select
            Select Case GetFrozenRow(True)
                Case MergedRange.TopRow To MergedRange.BottomRow
                    Select Case PropGridLinesFrozen
                        Case FlexGridLineNone
                            ' Void
                        Case FlexGridLineFlat, FlexGridLineDashes, FlexGridLineDots
                            ' Void
                        Case FlexGridLineInset
                            ' Void
                        Case FlexGridLineRaised
                            If .LeftTop.CY < 1 Then .LeftTop.CY = 1
                        Case FlexGridLineFlatHorz, FlexGridLineDashesHorz, FlexGridLineDotsHorz
                            ' Void
                        Case FlexGridLineInsetHorz
                            ' Void
                        Case FlexGridLineRaisedHorz
                            If .LeftTop.CY < 1 Then .LeftTop.CY = 1
                        Case FlexGridLineFlatVert, FlexGridLineDashesVert, FlexGridLineDotsVert
                            ' Void
                        Case FlexGridLineInsetVert
                            ' Void
                        Case FlexGridLineRaisedVert
                            ' Void
                    End Select
            End Select
        End If
        If PropFrozenCols > 0 Then
            Select Case GetFrozenCol(False)
                Case MergedRange.LeftCol To MergedRange.RightCol
                    Select Case PropGridLinesFrozen
                        Case FlexGridLineNone
                            ' Void
                        Case FlexGridLineFlat, FlexGridLineDashes, FlexGridLineDots
                            If .RightBottom.CX < 1 Then .RightBottom.CX = 1
                        Case FlexGridLineInset
                            If .RightBottom.CX < 1 Then .RightBottom.CX = 1
                        Case FlexGridLineRaised
                            ' Void
                        Case FlexGridLineFlatHorz, FlexGridLineDashesHorz, FlexGridLineDotsHorz
                            ' Void
                        Case FlexGridLineInsetHorz
                            ' Void
                        Case FlexGridLineRaisedHorz
                            ' Void
                        Case FlexGridLineFlatVert, FlexGridLineDashesVert, FlexGridLineDotsVert
                            If .RightBottom.CX < 1 Then .RightBottom.CX = 1
                        Case FlexGridLineInsetVert
                            If .RightBottom.CX < 1 Then .RightBottom.CX = 1
                        Case FlexGridLineRaisedVert
                            ' Void
                    End Select
            End Select
            Select Case GetFrozenCol(True)
                Case MergedRange.LeftCol To MergedRange.RightCol
                    Select Case PropGridLinesFrozen
                        Case FlexGridLineNone
                            ' Void
                        Case FlexGridLineFlat, FlexGridLineDashes, FlexGridLineDots
                            ' Void
                        Case FlexGridLineInset
                            ' Void
                        Case FlexGridLineRaised
                            If .LeftTop.CX < 1 Then .LeftTop.CX = 1
                        Case FlexGridLineFlatHorz, FlexGridLineDashesHorz, FlexGridLineDotsHorz
                            ' Void
                        Case FlexGridLineInsetHorz
                            ' Void
                        Case FlexGridLineRaisedHorz
                            ' Void
                        Case FlexGridLineFlatVert, FlexGridLineDashesVert, FlexGridLineDotsVert
                            ' Void
                        Case FlexGridLineInsetVert
                            ' Void
                        Case FlexGridLineRaisedVert
                            If .LeftTop.CX < 1 Then .LeftTop.CX = 1
                    End Select
            End Select
        End If
    End If
End If
End With
End Sub

Private Sub GetHitTestInfo(ByRef HTI As THITTESTINFO)
HTI.HitRow = -1
HTI.HitCol = -1
HTI.HitRowDivider = -1
HTI.HitColDivider = -1
HTI.HitResult = FlexHitResultNoWhere
HTI.MouseRow = 0
HTI.MouseCol = 0
If VBFlexGridHandle = NULL_PTR Or (PropRows < 1 Or PropCols < 1) Or (HTI.PT.X < 0 And HTI.PT.Y < 0) Then Exit Sub
Dim iRow As Long, iCol As Long, iRowHit As Long, iColHit As Long, iRowDivider As Long, iColDivider As Long
Dim CellRect As RECT, TempRect As RECT
iRowHit = -1
iColHit = -1
iRowDivider = -1
iColDivider = -1
With CellRect
If HTI.PT.Y >= 0 Then
    For iRow = 0 To ((PropFixedRows + PropFrozenRows) - 1)
        .Top = .Bottom
        .Bottom = .Top + GetRowHeight(iRow)
        If HTI.PT.Y >= .Top Then
            HTI.MouseRow = iRow
            If HTI.PT.Y < .Bottom Then
                iRowHit = iRow
                Exit For
            End If
        End If
    Next iRow
    If iRowHit = -1 Then
        For iRow = VBFlexGridTopRow To (PropRows - 1)
            .Top = .Bottom
            .Bottom = .Top + GetRowHeight(iRow)
            If HTI.PT.Y >= .Top Then
                HTI.MouseRow = iRow
                If HTI.PT.Y < .Bottom Then
                    iRowHit = iRow
                    Exit For
                End If
            End If
        Next iRow
    End If
End If
If HTI.PT.X >= 0 Then
    For iCol = 0 To ((PropFixedCols + PropFrozenCols) - 1)
        .Left = .Right
        .Right = .Left + GetColWidth(iCol)
        If HTI.PT.X >= .Left Then
            HTI.MouseCol = iCol
            If HTI.PT.X < .Right Then
                iColHit = iCol
                Exit For
            End If
        End If
    Next iCol
    If iColHit = -1 Then
        For iCol = VBFlexGridLeftCol To (PropCols - 1)
            .Left = .Right
            .Right = .Left + GetColWidth(iCol)
            If HTI.PT.X >= .Left Then
                HTI.MouseCol = iCol
                If HTI.PT.X < .Right Then
                    iColHit = iCol
                    Exit For
                End If
            End If
        Next iCol
    End If
End If
If iRowHit > -1 And iColHit > -1 Then
    Dim GridLineOffsets As TGRIDLINEOFFSETS, ComboCue As FlexComboCueConstants, ComboCueWidth As Long, ComboCueAlignment As FlexLeftRightAlignmentConstants
    If PropAllowUserEditing = True Or PropAlwaysAllowComboCues = True Then
        ComboCue = GetComboCueActive(iRowHit, iColHit)
        If ComboCue > FlexComboCueNone Then
            Call GetGridLineOffsetsStruct(iRowHit, iColHit, GridLineOffsets)
            ComboCueWidth = GetComboButtonWidth(iRowHit, iColHit, ComboCue)
            If (((.Right - .Left) - (GridLineOffsets.LeftTop.CX + GridLineOffsets.RightBottom.CX)) - ComboCueWidth) < 0 Then ComboCueWidth = ((.Right - .Left) - (GridLineOffsets.LeftTop.CX + GridLineOffsets.RightBottom.CX))
            If VBFlexGridColsInfo(iColHit).ComboButtonAlignment = -1 Then
                ComboCueAlignment = VBFlexGridComboButtonAlignment
            Else
                ComboCueAlignment = VBFlexGridColsInfo(iCol).ComboButtonAlignment
            End If
            If ComboCueAlignment = FlexLeftRightAlignmentRight Then
                SetRect TempRect, .Right - ComboCueWidth - GridLineOffsets.RightBottom.CX, .Top + GridLineOffsets.LeftTop.CY, .Right - GridLineOffsets.RightBottom.CX, .Bottom - GridLineOffsets.RightBottom.CY
            ElseIf ComboCueAlignment = FlexLeftRightAlignmentLeft Then
                SetRect TempRect, .Left + GridLineOffsets.LeftTop.CX, .Top + GridLineOffsets.LeftTop.CY, .Left + ComboCueWidth + GridLineOffsets.LeftTop.CX, .Bottom - GridLineOffsets.RightBottom.CY
            End If
            If PtInRect(TempRect, HTI.PT.X, HTI.PT.Y) <> 0 Then
                Select Case ComboCue
                    Case FlexComboCueDropDown, FlexComboCueButton
                        HTI.HitResult = FlexHitResultComboCue
                    Case FlexComboCueDisabledDropDown, FlexComboCueDisabledButton
                        HTI.HitResult = FlexHitResultComboCueDisabled
                End Select
                HTI.HitRow = iRowHit
                HTI.HitCol = iColHit
                Exit Sub
            End If
        End If
    End If
    Dim Checked As Integer
    Checked = GetCellChecked_HitTest(iRowHit, iColHit)
    If Checked > -1 Then
        Dim CheckBoxRect As RECT, CheckBoxAlignment As FlexCheckBoxAlignmentConstants, CheckBoxOffsetX As Long, CheckBoxOffsetY As Long
        With CheckBoxRect
        .Left = CellRect.Left + VBFlexGridPixelMetrics.TextPadding.CX
        .Top = CellRect.Top + VBFlexGridPixelMetrics.TextPadding.CY
        .Right = CellRect.Right - VBFlexGridPixelMetrics.TextPadding.CX
        If ComboCueWidth > 0 Then
            If ComboCueAlignment = FlexLeftRightAlignmentRight Then
                .Right = .Right - ComboCueWidth
            ElseIf ComboCueAlignment = FlexLeftRightAlignmentLeft Then
                .Left = .Left + ComboCueWidth
            End If
        End If
        .Bottom = CellRect.Bottom - VBFlexGridPixelMetrics.TextPadding.CY
        End With
        Dim CellFmtg As TCELLFMTG
        Call GetCellFmtg(iRowHit, iColHit, CFM_PICTURE Or CFM_PICTUREALIGNMENT, CellFmtg)
        With CellFmtg
        If iRowHit < PropFixedRows Or iColHit < PropFixedCols Then
            If VBFlexGridColsInfo(iColHit).FixedCheckBoxAlignment = -1 Then
                CheckBoxAlignment = VBFlexGridColsInfo(iColHit).CheckBoxAlignment
            Else
                CheckBoxAlignment = VBFlexGridColsInfo(iColHit).FixedCheckBoxAlignment
            End If
        Else
            CheckBoxAlignment = VBFlexGridColsInfo(iColHit).CheckBoxAlignment
        End If
        If CheckBoxAlignment = FlexCheckBoxAlignmentUsePictureAlignment Then
            Select Case .PictureAlignment
                Case FlexPictureAlignmentLeftTop, FlexPictureAlignmentLeftCenter, FlexPictureAlignmentLeftBottom, FlexPictureAlignmentLeftTopNoOverlap, FlexPictureAlignmentLeftCenterNoOverlap, FlexPictureAlignmentLeftBottomNoOverlap
                    CheckBoxAlignment = FlexCheckBoxAlignmentLeftCenter
                Case FlexPictureAlignmentCenterTop, FlexPictureAlignmentCenterCenter, FlexPictureAlignmentCenterBottom, FlexPictureAlignmentStretch, FlexPictureAlignmentTile
                    CheckBoxAlignment = FlexCheckBoxAlignmentCenterCenter
                Case FlexPictureAlignmentRightTop, FlexPictureAlignmentRightCenter, FlexPictureAlignmentRightBottom, FlexPictureAlignmentRightTopNoOverlap, FlexPictureAlignmentRightCenterNoOverlap, FlexPictureAlignmentRightBottomNoOverlap
                    CheckBoxAlignment = FlexCheckBoxAlignmentRightCenter
            End Select
        End If
        If Not .Picture Is Nothing Then
            If .Picture.Handle <> NULL_PTR Then
                Select Case .PictureAlignment
                    Case FlexPictureAlignmentLeftTopNoOverlap, FlexPictureAlignmentLeftCenterNoOverlap, FlexPictureAlignmentLeftBottomNoOverlap
                        CheckBoxRect.Left = CheckBoxRect.Left + CHimetricToPixel_X(.Picture.Width)
                    Case FlexPictureAlignmentRightTopNoOverlap, FlexPictureAlignmentRightCenterNoOverlap, FlexPictureAlignmentRightBottomNoOverlap
                        CheckBoxRect.Right = CheckBoxRect.Right - CHimetricToPixel_X(.Picture.Width)
                End Select
            End If
        End If
        Select Case CheckBoxAlignment
            Case FlexCheckBoxAlignmentLeftCenter
                CheckBoxOffsetY = (((CheckBoxRect.Bottom - CheckBoxRect.Top) - VBFlexGridPixelMetrics.CheckBoxSize) \ 2)
            Case FlexCheckBoxAlignmentLeftBottom
                CheckBoxOffsetY = ((CheckBoxRect.Bottom - CheckBoxRect.Top) - VBFlexGridPixelMetrics.CheckBoxSize)
            Case FlexCheckBoxAlignmentCenterTop
                CheckBoxOffsetX = (((CheckBoxRect.Right - CheckBoxRect.Left) - VBFlexGridPixelMetrics.CheckBoxSize) \ 2)
            Case FlexCheckBoxAlignmentCenterCenter
                CheckBoxOffsetX = (((CheckBoxRect.Right - CheckBoxRect.Left) - VBFlexGridPixelMetrics.CheckBoxSize) \ 2)
                CheckBoxOffsetY = (((CheckBoxRect.Bottom - CheckBoxRect.Top) - VBFlexGridPixelMetrics.CheckBoxSize) \ 2)
            Case FlexCheckBoxAlignmentCenterBottom
                CheckBoxOffsetX = (((CheckBoxRect.Right - CheckBoxRect.Left) - VBFlexGridPixelMetrics.CheckBoxSize) \ 2)
                CheckBoxOffsetY = ((CheckBoxRect.Bottom - CheckBoxRect.Top) - VBFlexGridPixelMetrics.CheckBoxSize)
            Case FlexCheckBoxAlignmentRightTop
                CheckBoxOffsetX = ((CheckBoxRect.Right - CheckBoxRect.Left) - VBFlexGridPixelMetrics.CheckBoxSize)
            Case FlexCheckBoxAlignmentRightCenter
                CheckBoxOffsetX = ((CheckBoxRect.Right - CheckBoxRect.Left) - VBFlexGridPixelMetrics.CheckBoxSize)
                CheckBoxOffsetY = (((CheckBoxRect.Bottom - CheckBoxRect.Top) - VBFlexGridPixelMetrics.CheckBoxSize) \ 2)
            Case FlexCheckBoxAlignmentRightBottom
                CheckBoxOffsetX = ((CheckBoxRect.Right - CheckBoxRect.Left) - VBFlexGridPixelMetrics.CheckBoxSize)
                CheckBoxOffsetY = ((CheckBoxRect.Bottom - CheckBoxRect.Top) - VBFlexGridPixelMetrics.CheckBoxSize)
        End Select
        If CheckBoxOffsetX > 0 Then CheckBoxRect.Left = CheckBoxRect.Left + CheckBoxOffsetX
        If CheckBoxOffsetY > 0 Then CheckBoxRect.Top = CheckBoxRect.Top + CheckBoxOffsetY
        CheckBoxRect.Right = CheckBoxRect.Left + VBFlexGridPixelMetrics.CheckBoxSize
        CheckBoxRect.Bottom = CheckBoxRect.Top + VBFlexGridPixelMetrics.CheckBoxSize
        End With
        If PtInRect(CheckBoxRect, HTI.PT.X, HTI.PT.Y) <> 0 Then
            Select Case Checked
                Case FlexUnchecked, FlexChecked, FlexGrayed, FlexTextAsCheckBox
                    HTI.HitResult = FlexHitResultCheckBox
                Case FlexDisabledUnchecked, FlexDisabledChecked, FlexDisabledGrayed, FlexDisabledTextAsCheckBox
                    HTI.HitResult = FlexHitResultCheckBoxDisabled
            End Select
            HTI.HitRow = iRowHit
            HTI.HitCol = iColHit
            Exit Sub
        End If
    End If
    If iRowHit >= VBFlexGridTopRow Then
        If iColHit >= VBFlexGridLeftCol Then
            HTI.HitResult = FlexHitResultCell
        ElseIf iColHit < PropFixedCols Then
            If PropAllowUserResizing = FlexAllowUserResizingRows Or PropAllowUserResizing = FlexAllowUserResizingBoth Then
                SetRect TempRect, .Left, .Top, .Right, .Bottom
                Call AdjustRectRowDividerSpacing(TempRect, iRowHit)
                If PtInRect(TempRect, HTI.PT.X, HTI.PT.Y) <> 0 Then
                    HTI.HitResult = FlexHitResultCell
                Else
                    TempRect.Bottom = .Bottom
                    If PtInRect(TempRect, HTI.PT.X, HTI.PT.Y) = 0 Then
                        iRowDivider = GetRowDividerTop(iRowHit)
                        HTI.HitResult = FlexHitResultDividerRowTop
                        If iRowDivider = -1 Then
                            HTI.HitResult = FlexHitResultCell
                        Else
                            If (VBFlexGridCells.Rows(iRowDivider).RowInfo.State And RWIS_NOSIZING) = RWIS_NOSIZING Then
                                iRowDivider = -1
                                HTI.HitResult = FlexHitResultCell
                            End If
                        End If
                    Else
                        If (VBFlexGridCells.Rows(iRowHit).RowInfo.State And RWIS_NOSIZING) = 0 Then
                            iRowDivider = iRowHit
                            HTI.HitResult = FlexHitResultDividerRowBottom
                        Else
                            iRowDivider = -1
                            HTI.HitResult = FlexHitResultCell
                        End If
                    End If
                End If
            Else
                HTI.HitResult = FlexHitResultCell
            End If
        ElseIf iColHit < (PropFixedCols + PropFrozenCols) Then
            HTI.HitResult = FlexHitResultCell
        End If
    ElseIf iRowHit < PropFixedRows Then
        If PropAllowUserResizing <> FlexAllowUserResizingNone Then
            SetRect TempRect, .Left, .Top, .Right, .Bottom
            Call AdjustRectColDividerSpacing(TempRect, iColHit)
            If PtInRect(TempRect, HTI.PT.X, HTI.PT.Y) <> 0 Then
                If iColHit < PropFixedCols Then
                    If PropAllowUserResizing <> FlexAllowUserResizingColumns Then
                        SetRect TempRect, .Left, .Top, .Right, .Bottom
                        Call AdjustRectRowDividerSpacing(TempRect, iRowHit)
                        If PtInRect(TempRect, HTI.PT.X, HTI.PT.Y) <> 0 Then
                            HTI.HitResult = FlexHitResultCell
                        Else
                            TempRect.Bottom = .Bottom
                            If PtInRect(TempRect, HTI.PT.X, HTI.PT.Y) = 0 Then
                                iRowDivider = GetRowDividerTop(iRowHit)
                                HTI.HitResult = FlexHitResultDividerRowTop
                                If iRowDivider = -1 Then
                                    HTI.HitResult = FlexHitResultCell
                                Else
                                    If (VBFlexGridCells.Rows(iRowDivider).RowInfo.State And RWIS_NOSIZING) = RWIS_NOSIZING Then
                                        iRowDivider = -1
                                        HTI.HitResult = FlexHitResultCell
                                    End If
                                End If
                            Else
                                If (VBFlexGridCells.Rows(iRowHit).RowInfo.State And RWIS_NOSIZING) = 0 Then
                                    iRowDivider = iRowHit
                                    HTI.HitResult = FlexHitResultDividerRowBottom
                                Else
                                    iRowDivider = -1
                                    HTI.HitResult = FlexHitResultCell
                                End If
                            End If
                        End If
                    Else
                        HTI.HitResult = FlexHitResultCell
                    End If
                Else
                    HTI.HitResult = FlexHitResultCell
                End If
            ElseIf PropAllowUserResizing <> FlexAllowUserResizingRows Then
                TempRect.Right = .Right
                If PtInRect(TempRect, HTI.PT.X, HTI.PT.Y) = 0 Then
                    iColDivider = GetColDividerLeft(iColHit)
                    HTI.HitResult = FlexHitResultDividerColumnLeft
                    If iColDivider = -1 Then
                        HTI.HitResult = FlexHitResultCell
                    Else
                        If (VBFlexGridColsInfo(iColDivider).State And CLIS_NOSIZING) = CLIS_NOSIZING Then
                            iColDivider = -1
                            HTI.HitResult = FlexHitResultCell
                        End If
                    End If
                Else
                    If iColHit <> VBFlexGridExtendLastCol Then
                        If (VBFlexGridColsInfo(iColHit).State And CLIS_NOSIZING) = 0 Then
                            iColDivider = iColHit
                            HTI.HitResult = FlexHitResultDividerColumnRight
                        Else
                            iColDivider = -1
                            HTI.HitResult = FlexHitResultCell
                        End If
                    Else
                        ' Avoid divider column right hit test info for the extended last column only.
                        iColDivider = -1
                        HTI.HitResult = FlexHitResultCell
                    End If
                End If
            Else
                HTI.HitResult = FlexHitResultCell
            End If
        Else
            HTI.HitResult = FlexHitResultCell
        End If
    ElseIf iRowHit < (PropFixedRows + PropFrozenRows) Then
        If iColHit >= VBFlexGridLeftCol Then
            HTI.HitResult = FlexHitResultCell
        ElseIf iColHit < PropFixedCols Then
            If PropAllowUserResizing = FlexAllowUserResizingRows Or PropAllowUserResizing = FlexAllowUserResizingBoth Then
                SetRect TempRect, .Left, .Top, .Right, .Bottom
                Call AdjustRectRowDividerSpacing(TempRect, iRowHit)
                If PtInRect(TempRect, HTI.PT.X, HTI.PT.Y) <> 0 Then
                    HTI.HitResult = FlexHitResultCell
                Else
                    TempRect.Bottom = .Bottom
                    If PtInRect(TempRect, HTI.PT.X, HTI.PT.Y) = 0 Then
                        iRowDivider = GetRowDividerTop(iRowHit)
                        HTI.HitResult = FlexHitResultDividerRowTop
                        If iRowDivider = -1 Then
                            HTI.HitResult = FlexHitResultCell
                        Else
                            If (VBFlexGridCells.Rows(iRowDivider).RowInfo.State And RWIS_NOSIZING) = RWIS_NOSIZING Then
                                iRowDivider = -1
                                HTI.HitResult = FlexHitResultCell
                            End If
                        End If
                    Else
                        If (VBFlexGridCells.Rows(iRowHit).RowInfo.State And RWIS_NOSIZING) = 0 Then
                            iRowDivider = iRowHit
                            HTI.HitResult = FlexHitResultDividerRowBottom
                        Else
                            iRowDivider = -1
                            HTI.HitResult = FlexHitResultCell
                        End If
                    End If
                End If
            Else
                HTI.HitResult = FlexHitResultCell
            End If
        ElseIf iColHit < (PropFixedCols + PropFrozenCols) Then
            HTI.HitResult = FlexHitResultCell
        End If
    End If
    If HTI.HitResult = FlexHitResultCell And PropAllowUserFreezing <> FlexAllowUserFreezingNone Then
        Dim iRowFrozen As Long, iRowFrozenAdjacent As Long, iColFrozen As Long, iColFrozenAdjacent As Long
        iRowFrozen = GetFrozenRow(False)
        If iRowFrozen < PropFixedRows Then
            ' Avoid divider row bottom hit test info.
            iRowFrozen = -1
        End If
        iRowFrozenAdjacent = GetFrozenRow(True)
        iColFrozen = GetFrozenCol(False)
        If iColFrozen < PropFixedCols Then
            ' Avoid divider column right hit test info.
            iColFrozen = -1
        End If
        iColFrozenAdjacent = GetFrozenCol(True)
        If (iRowHit = iRowFrozen Or iRowHit = iRowFrozenAdjacent) And iColHit >= PropFixedCols Then
            If (iColHit = iColFrozen Or iColHit = iColFrozenAdjacent) And iRowHit >= PropFixedRows Then
                If PropAllowUserFreezing = FlexAllowUserFreezingColumns Or PropAllowUserFreezing = FlexAllowUserFreezingBoth Then
                    If iColHit = iColFrozenAdjacent Then
                        SetRect TempRect, .Left, .Top, .Right, .Bottom
                        Call AdjustRectColDividerFrozenSpacing(TempRect, iColHit, True)
                        If PtInRect(TempRect, HTI.PT.X, HTI.PT.Y) = 0 Then
                            iColDivider = GetColDividerFrozenLeft(iColHit)
                            HTI.HitResult = FlexHitResultDividerFrozenColumnLeft
                            If iColDivider = -1 Then
                                If iColFrozen = -1 Then iColDivider = 0 Else HTI.HitResult = FlexHitResultCell
                            End If
                        End If
                    Else
                        SetRect TempRect, .Left, .Top, .Right, .Bottom
                        Call AdjustRectColDividerFrozenSpacing(TempRect, iColHit, False)
                        If PtInRect(TempRect, HTI.PT.X, HTI.PT.Y) = 0 Then
                            iColDivider = iColHit
                            HTI.HitResult = FlexHitResultDividerFrozenColumnRight
                        End If
                    End If
                End If
                If HTI.HitResult = FlexHitResultCell Then
                    If PropAllowUserFreezing = FlexAllowUserFreezingRows Or PropAllowUserFreezing = FlexAllowUserFreezingBoth Then
                        If iRowHit = iRowFrozenAdjacent Then
                            SetRect TempRect, .Left, .Top, .Right, .Bottom
                            Call AdjustRectRowDividerFrozenSpacing(TempRect, iRowHit, True)
                            If PtInRect(TempRect, HTI.PT.X, HTI.PT.Y) = 0 Then
                                iRowDivider = GetRowDividerFrozenTop(iRowHit)
                                HTI.HitResult = FlexHitResultDividerFrozenRowTop
                                If iRowDivider = -1 Then
                                    If iRowFrozen = -1 Then iRowDivider = 0 Else HTI.HitResult = FlexHitResultCell
                                End If
                            End If
                        Else
                            SetRect TempRect, .Left, .Top, .Right, .Bottom
                            Call AdjustRectRowDividerFrozenSpacing(TempRect, iRowHit, False)
                            If PtInRect(TempRect, HTI.PT.X, HTI.PT.Y) = 0 Then
                                iRowDivider = iRowHit
                                HTI.HitResult = FlexHitResultDividerFrozenRowBottom
                            End If
                        End If
                    End If
                End If
            Else
                If PropAllowUserFreezing = FlexAllowUserFreezingRows Or PropAllowUserFreezing = FlexAllowUserFreezingBoth Then
                    If iRowHit = iRowFrozenAdjacent Then
                        SetRect TempRect, .Left, .Top, .Right, .Bottom
                        Call AdjustRectRowDividerFrozenSpacing(TempRect, iRowHit, True)
                        If PtInRect(TempRect, HTI.PT.X, HTI.PT.Y) = 0 Then
                            iRowDivider = GetRowDividerFrozenTop(iRowHit)
                            HTI.HitResult = FlexHitResultDividerFrozenRowTop
                            If iRowDivider = -1 Then
                                If iRowFrozen = -1 Then iRowDivider = 0 Else HTI.HitResult = FlexHitResultCell
                            End If
                        End If
                    Else
                        SetRect TempRect, .Left, .Top, .Right, .Bottom
                        Call AdjustRectRowDividerFrozenSpacing(TempRect, iRowHit, False)
                        If PtInRect(TempRect, HTI.PT.X, HTI.PT.Y) = 0 Then
                            iRowDivider = iRowHit
                            HTI.HitResult = FlexHitResultDividerFrozenRowBottom
                        End If
                    End If
                End If
            End If
        ElseIf (iColHit = iColFrozen Or iColHit = iColFrozenAdjacent) And iRowHit >= PropFixedRows Then
            If PropAllowUserFreezing = FlexAllowUserFreezingColumns Or PropAllowUserFreezing = FlexAllowUserFreezingBoth Then
                If iColHit = iColFrozenAdjacent Then
                    SetRect TempRect, .Left, .Top, .Right, .Bottom
                    Call AdjustRectColDividerFrozenSpacing(TempRect, iColHit, True)
                    If PtInRect(TempRect, HTI.PT.X, HTI.PT.Y) = 0 Then
                        iColDivider = GetColDividerFrozenLeft(iColHit)
                        HTI.HitResult = FlexHitResultDividerFrozenColumnLeft
                        If iColDivider = -1 Then
                            If iColFrozen = -1 Then iColDivider = 0 Else HTI.HitResult = FlexHitResultCell
                        End If
                    End If
                Else
                    SetRect TempRect, .Left, .Top, .Right, .Bottom
                    Call AdjustRectColDividerFrozenSpacing(TempRect, iColHit, False)
                    If PtInRect(TempRect, HTI.PT.X, HTI.PT.Y) = 0 Then
                        iColDivider = iColHit
                        HTI.HitResult = FlexHitResultDividerFrozenColumnRight
                    End If
                End If
            End If
        End If
    End If
Else
    If PropAllowUserResizing <> FlexAllowUserResizingNone Then
        If iColHit > -1 And PropAllowUserResizing <> FlexAllowUserResizingColumns Then
            If iRowHit = -1 And iColHit < PropFixedCols Then
                If HTI.PT.Y < (.Bottom + VBFlexGridPixelMetrics.DividerSpacing.CY) Then
                    iRowDivider = (PropRows - 1)
                    If iRowDivider > -1 Then
                        Do While (VBFlexGridCells.Rows(iRowDivider).RowInfo.State And RWIS_HIDDEN) = RWIS_HIDDEN
                            iRowDivider = iRowDivider - 1
                            If iRowDivider = -1 Then Exit Do
                        Loop
                    End If
                    HTI.HitResult = FlexHitResultDividerRowBottom
                    If iRowDivider = -1 Then
                        HTI.HitResult = FlexHitResultNoWhere
                    Else
                        If (VBFlexGridCells.Rows(iRowDivider).RowInfo.State And RWIS_NOSIZING) = RWIS_NOSIZING Then
                            iRowDivider = -1
                            HTI.HitResult = FlexHitResultNoWhere
                        End If
                    End If
                End If
            End If
        ElseIf iRowHit > -1 And PropAllowUserResizing <> FlexAllowUserResizingRows Then
            If iColHit = -1 And iRowHit < PropFixedRows Then
                If HTI.PT.X < (.Right + VBFlexGridPixelMetrics.DividerSpacing.CX) Then
                    iColDivider = (PropCols - 1)
                    If iColDivider > -1 Then
                        Do While (VBFlexGridColsInfo(iColDivider).State And CLIS_HIDDEN) = CLIS_HIDDEN
                            iColDivider = iColDivider - 1
                            If iColDivider = -1 Then Exit Do
                        Loop
                    End If
                    HTI.HitResult = FlexHitResultDividerColumnRight
                    If iColDivider = -1 Then
                        HTI.HitResult = FlexHitResultNoWhere
                    Else
                        If (VBFlexGridColsInfo(iColDivider).State And CLIS_NOSIZING) = CLIS_NOSIZING Then
                            iColDivider = -1
                            HTI.HitResult = FlexHitResultNoWhere
                        End If
                    End If
                End If
            End If
        End If
    End If
    iRowHit = -1
    iColHit = -1
End If
End With
If HTI.HitResult <> FlexHitResultNoWhere Then
    HTI.HitRow = iRowHit
    HTI.HitCol = iColHit
    Select Case HTI.HitResult
        Case FlexHitResultDividerRowTop, FlexHitResultDividerRowBottom, FlexHitResultDividerColumnLeft, FlexHitResultDividerColumnRight, FlexHitResultDividerFrozenRowTop, FlexHitResultDividerFrozenRowBottom, FlexHitResultDividerFrozenColumnLeft, FlexHitResultDividerFrozenColumnRight
            HTI.HitRowDivider = iRowDivider
            HTI.HitColDivider = iColDivider
    End Select
End If
End Sub

Private Sub AdjustRectColDividerSpacing(ByRef RC As RECT, ByVal iCol As Long)
Dim Spacing As Long
Spacing = VBFlexGridPixelMetrics.DividerSpacing.CX
If iCol > 0 Then
    Dim iColLeft As Long
    iColLeft = GetColDividerLeft(iCol)
    If (RC.Right - RC.Left) >= (Spacing * 2) Then
        If (VBFlexGridColsInfo(iColLeft).State And CLIS_NOSIZING) = 0 Then RC.Left = RC.Left + Spacing
        If (VBFlexGridColsInfo(iCol).State And CLIS_NOSIZING) = 0 Then RC.Right = RC.Right - Spacing
    Else
        ' Rectangle is not wide enough to include the spacing.
        If (VBFlexGridColsInfo(iColLeft).State And CLIS_NOSIZING) = 0 And (VBFlexGridColsInfo(iCol).State And CLIS_NOSIZING) = 0 Then
            RC.Left = RC.Left + ((RC.Right - RC.Left) \ 2)
            RC.Right = RC.Left ' Remainder
        Else
            If (VBFlexGridColsInfo(iColLeft).State And CLIS_NOSIZING) = 0 Then RC.Left = RC.Left + ((RC.Right - RC.Left) \ 2)
            If (VBFlexGridColsInfo(iCol).State And CLIS_NOSIZING) = 0 Then RC.Right = RC.Right - ((RC.Right - RC.Left) \ 2)
        End If
    End If
ElseIf iCol > -1 Then
    ' First column need divider spacing to the right only.
    If (VBFlexGridColsInfo(iCol).State And CLIS_NOSIZING) = 0 Then
        RC.Right = RC.Right - Spacing
        If RC.Right < RC.Left Then RC.Right = RC.Left
    End If
End If
End Sub

Private Sub AdjustRectRowDividerSpacing(ByRef RC As RECT, ByVal iRow As Long)
Dim Spacing As Long
Spacing = VBFlexGridPixelMetrics.DividerSpacing.CY
If iRow > 0 Then
    Dim iRowTop As Long
    iRowTop = GetRowDividerTop(iRow)
    If (RC.Bottom - RC.Top) >= (Spacing * 2) Then
        If (VBFlexGridCells.Rows(iRowTop).RowInfo.State And RWIS_NOSIZING) = 0 Then RC.Top = RC.Top + Spacing
        If (VBFlexGridCells.Rows(iRow).RowInfo.State And RWIS_NOSIZING) = 0 Then RC.Bottom = RC.Bottom - Spacing
    Else
        ' Rectangle is not wide enough to include the spacing.
        If (VBFlexGridCells.Rows(iRowTop).RowInfo.State And RWIS_NOSIZING) = 0 And (VBFlexGridCells.Rows(iRow).RowInfo.State And RWIS_NOSIZING) = 0 Then
            RC.Top = RC.Top + ((RC.Bottom - RC.Top) \ 2)
            RC.Bottom = RC.Top ' Remainder
        Else
            If (VBFlexGridCells.Rows(iRowTop).RowInfo.State And RWIS_NOSIZING) = 0 Then RC.Top = RC.Top + ((RC.Bottom - RC.Top) \ 2)
            If (VBFlexGridCells.Rows(iRow).RowInfo.State And RWIS_NOSIZING) = 0 Then RC.Bottom = RC.Bottom - ((RC.Bottom - RC.Top) \ 2)
        End If
    End If
ElseIf iRow > -1 Then
    ' First row need divider spacing to the bottom only.
    If (VBFlexGridCells.Rows(iRow).RowInfo.State And RWIS_NOSIZING) = 0 Then
        RC.Bottom = RC.Bottom - Spacing
        If RC.Bottom < RC.Top Then RC.Bottom = RC.Top
    End If
End If
End Sub

Private Sub AdjustRectColDividerFrozenSpacing(ByRef RC As RECT, ByVal iCol As Long, ByVal Adjacent As Boolean)
Dim Spacing As Long
Spacing = VBFlexGridPixelMetrics.DividerSpacing.CX
If iCol > -1 Then
    If Adjacent = False Then
        RC.Right = RC.Right - Spacing
        If RC.Right < RC.Left Then RC.Right = RC.Left
    Else
        RC.Left = RC.Left + Spacing
        If RC.Left > RC.Right Then RC.Left = RC.Right
    End If
End If
End Sub

Private Sub AdjustRectRowDividerFrozenSpacing(ByRef RC As RECT, ByVal iRow As Long, ByVal Adjacent As Boolean)
Dim Spacing As Long
Spacing = VBFlexGridPixelMetrics.DividerSpacing.CY
If iRow > -1 Then
    If Adjacent = False Then
        RC.Bottom = RC.Bottom - Spacing
        If RC.Bottom < RC.Top Then RC.Bottom = RC.Top
    Else
        RC.Top = RC.Top + Spacing
        If RC.Top > RC.Bottom Then RC.Top = RC.Bottom
    End If
End If
End Sub

Private Sub GetLabelInfo(ByVal iRow As Long, ByVal iCol As Long, ByRef LBLI As TLABELINFO, Optional ByVal hDC As LongPtr)
LBLI.Flags = 0
If VBFlexGridHandle = NULL_PTR Or (PropRows < 1 Or PropCols < 1) Then Exit Sub
Dim CellRect As RECT
Call GetCellRect(iRow, iCol, CellRect)
If (CellRect.Bottom - CellRect.Top) <= 0 Or (CellRect.Right - CellRect.Left) <= 0 Then Exit Sub
Dim hDCTemp As LongPtr
If hDC = NULL_PTR Then
    hDCTemp = GetDC(VBFlexGridHandle)
    hDC = hDCTemp
End If
If hDC <> NULL_PTR Then
    Dim GridLineOffsets As TGRIDLINEOFFSETS, ComboCue As FlexComboCueConstants, ComboCueWidth As Long, ComboCueAlignment As FlexLeftRightAlignmentConstants
    If PropAllowUserEditing = True Or PropAlwaysAllowComboCues = True Then
        ComboCue = GetComboCueActive(iRow, iCol)
        If ComboCue > FlexComboCueNone Then
            Call GetGridLineOffsetsStruct(iRow, iCol, GridLineOffsets)
            ComboCueWidth = GetComboButtonWidth(iRow, iCol, ComboCue)
            If (((CellRect.Right - CellRect.Left) - (GridLineOffsets.LeftTop.CX + GridLineOffsets.RightBottom.CX)) - ComboCueWidth) < 0 Then ComboCueWidth = ((CellRect.Right - CellRect.Left) - (GridLineOffsets.LeftTop.CX + GridLineOffsets.RightBottom.CX))
            If VBFlexGridColsInfo(iCol).ComboButtonAlignment = -1 Then
                ComboCueAlignment = VBFlexGridComboButtonAlignment
            Else
                ComboCueAlignment = VBFlexGridColsInfo(iCol).ComboButtonAlignment
            End If
        End If
    End If
    Dim TextIndent As TTEXTINDENT
    If (VBFlexGridColsInfo(iCol).State And CLIS_TEXTINDENT) = CLIS_TEXTINDENT Then
        With TextIndent
        RaiseEvent CellTextIndent(iRow, iCol, .Left, .Right)
        If .Left > 0 Then .Left = UserControl.ScaleX(.Left, vbTwips, vbPixels) Else .Left = 0
        If .Right > 0 Then .Right = UserControl.ScaleX(.Right, vbTwips, vbPixels) Else .Right = 0
        End With
    End If
    Dim Text As String, TextRect As RECT, HiddenText As Boolean
    Call GetCellText(iRow, iCol, Text)
    Call GetTextDisplay(iRow, iCol, Text)
    If StrPtr(Text) = NULL_PTR Then Text = ""
    With TextRect
    .Left = CellRect.Left + VBFlexGridPixelMetrics.TextPadding.CX + TextIndent.Left
    .Top = CellRect.Top + VBFlexGridPixelMetrics.TextPadding.CY
    .Right = CellRect.Right - VBFlexGridPixelMetrics.TextPadding.CX - TextIndent.Right
    If ComboCueWidth > 0 Then
        If ComboCueAlignment = FlexLeftRightAlignmentRight Then
            .Right = .Right - ComboCueWidth
        ElseIf ComboCueAlignment = FlexLeftRightAlignmentLeft Then
            .Left = .Left + ComboCueWidth
        End If
    End If
    .Bottom = CellRect.Bottom - VBFlexGridPixelMetrics.TextPadding.CY
    End With
    Dim CellFmtg As TCELLFMTG
    Call GetCellFmtg(iRow, iCol, CFM_ALIGNMENT Or CFM_PICTURE Or CFM_PICTUREALIGNMENT Or CFM_FONT, CellFmtg)
    With CellFmtg
    Dim hFontTemp As LongPtr, hFontOld As LongPtr
    If .FontName = vbNullString Then
        If iRow > (PropFixedRows - 1) And iCol > (PropFixedCols - 1) Then
            hFontOld = SelectObject(hDC, VBFlexGridFontHandle)
        Else
            If VBFlexGridFontFixedHandle = NULL_PTR Then
                hFontOld = SelectObject(hDC, VBFlexGridFontHandle)
            Else
                hFontOld = SelectObject(hDC, VBFlexGridFontFixedHandle)
            End If
        End If
    Else
        Dim TempFont As StdFont
        Set TempFont = New StdFont
        TempFont.Name = .FontName
        TempFont.Size = .FontSize
        TempFont.Bold = CBool((.FontStyle And FS_BOLD) = FS_BOLD)
        TempFont.Italic = CBool((.FontStyle And FS_ITALIC) = FS_ITALIC)
        TempFont.Strikethrough = CBool((.FontStyle And FS_STRIKEOUT) = FS_STRIKEOUT)
        TempFont.Underline = CBool((.FontStyle And FS_UNDERLINE) = FS_UNDERLINE)
        TempFont.Charset = .FontCharset
        hFontTemp = CreateGDIFontFromOLEFont(TempFont, PropFontQuality)
        hFontOld = SelectObject(hDC, hFontTemp)
        Set TempFont = Nothing
    End If
    Dim Alignment As FlexAlignmentConstants, DrawFlags As Long
    If .Alignment = -1 Then
        If iRow > (PropFixedRows - 1) And iCol > (PropFixedCols - 1) Then
            Alignment = VBFlexGridColsInfo(iCol).Alignment
        Else
            If VBFlexGridColsInfo(iCol).FixedAlignment = -1 Then
                Alignment = VBFlexGridColsInfo(iCol).Alignment
            Else
                Alignment = VBFlexGridColsInfo(iCol).FixedAlignment
            End If
        End If
    Else
        Alignment = .Alignment
    End If
    If Not .Picture Is Nothing Then
        If .Picture.Handle <> NULL_PTR Then
            Select Case .PictureAlignment
                Case FlexPictureAlignmentLeftTopNoOverlap, FlexPictureAlignmentLeftCenterNoOverlap, FlexPictureAlignmentLeftBottomNoOverlap
                    TextRect.Left = TextRect.Left + CHimetricToPixel_X(.Picture.Width)
                Case FlexPictureAlignmentRightTopNoOverlap, FlexPictureAlignmentRightCenterNoOverlap, FlexPictureAlignmentRightBottomNoOverlap
                    TextRect.Right = TextRect.Right - CHimetricToPixel_X(.Picture.Width)
            End Select
        End If
    End If
    If VBFlexGridColsInfo(iCol).ImageList.Handle <> NULL_PTR Then
        If GetImageIndex(iRow, iCol, Text) > 0 Then HiddenText = True
    End If
    Dim Checked As Integer
    Checked = GetCellChecked(iRow, iCol)
    If Checked > -1 Then
        Dim CheckBoxAlignment As FlexCheckBoxAlignmentConstants
        If iRow < PropFixedRows Or iCol < PropFixedCols Then
            If VBFlexGridColsInfo(iCol).FixedCheckBoxAlignment = -1 Then
                CheckBoxAlignment = VBFlexGridColsInfo(iCol).CheckBoxAlignment
            Else
                CheckBoxAlignment = VBFlexGridColsInfo(iCol).FixedCheckBoxAlignment
            End If
        Else
            CheckBoxAlignment = VBFlexGridColsInfo(iCol).CheckBoxAlignment
        End If
        If CheckBoxAlignment = FlexCheckBoxAlignmentUsePictureAlignment Then
            Select Case .PictureAlignment
                Case FlexPictureAlignmentLeftTop, FlexPictureAlignmentLeftCenter, FlexPictureAlignmentLeftBottom, FlexPictureAlignmentLeftTopNoOverlap, FlexPictureAlignmentLeftCenterNoOverlap, FlexPictureAlignmentLeftBottomNoOverlap
                    CheckBoxAlignment = FlexCheckBoxAlignmentLeftCenter
                Case FlexPictureAlignmentCenterTop, FlexPictureAlignmentCenterCenter, FlexPictureAlignmentCenterBottom, FlexPictureAlignmentStretch, FlexPictureAlignmentTile
                    CheckBoxAlignment = FlexCheckBoxAlignmentCenterCenter
                Case FlexPictureAlignmentRightTop, FlexPictureAlignmentRightCenter, FlexPictureAlignmentRightBottom, FlexPictureAlignmentRightTopNoOverlap, FlexPictureAlignmentRightCenterNoOverlap, FlexPictureAlignmentRightBottomNoOverlap
                    CheckBoxAlignment = FlexCheckBoxAlignmentRightCenter
            End Select
        End If
        Select Case CheckBoxAlignment
            Case FlexCheckBoxAlignmentLeftTop, FlexCheckBoxAlignmentLeftCenter, FlexCheckBoxAlignmentLeftBottom
                TextRect.Left = TextRect.Left + VBFlexGridPixelMetrics.CheckBoxSize + VBFlexGridPixelMetrics.TextPadding.CX
            Case FlexCheckBoxAlignmentRightTop, FlexCheckBoxAlignmentRightCenter, FlexCheckBoxAlignmentRightBottom
                TextRect.Right = TextRect.Right - VBFlexGridPixelMetrics.CheckBoxSize - VBFlexGridPixelMetrics.TextPadding.CX
        End Select
        Select Case Checked
            Case FlexTextAsCheckBox, FlexDisabledTextAsCheckBox
                HiddenText = True
        End Select
    End If
    End With
    DrawFlags = DT_NOPREFIX
    If VBFlexGridRTLReading = True Then DrawFlags = DrawFlags Or DT_RTLREADING
    Select Case Alignment
        Case FlexAlignmentLeftTop, FlexAlignmentLeftCenter, FlexAlignmentLeftBottom
            DrawFlags = DrawFlags Or DT_LEFT
        Case FlexAlignmentCenterTop, FlexAlignmentCenterCenter, FlexAlignmentCenterBottom
            DrawFlags = DrawFlags Or DT_CENTER
        Case FlexAlignmentRightTop, FlexAlignmentRightCenter, FlexAlignmentRightBottom
            DrawFlags = DrawFlags Or DT_RIGHT
        Case FlexAlignmentGeneral, FlexAlignmentGeneralTop, FlexAlignmentGeneralCenter, FlexAlignmentGeneralBottom
            If PropMirrorAlignGeneral = False Then
                If Not IsNumeric(Text) And Not IsDate(Text) Then
                    DrawFlags = DrawFlags Or DT_LEFT
                Else
                    DrawFlags = DrawFlags Or DT_RIGHT
                End If
            Else
                If Not IsNumeric(Text) And Not IsDate(Text) Then
                    DrawFlags = DrawFlags Or DT_RIGHT
                Else
                    DrawFlags = DrawFlags Or DT_LEFT
                End If
            End If
    End Select
    If iRow > (PropFixedRows - 1) And iCol > (PropFixedCols - 1) Then
        If VBFlexGridColsInfo(iCol).WordWrapOption = -1 Then
            If PropWordWrap = True Then
                DrawFlags = DrawFlags Or DT_WORDBREAK
            ElseIf PropSingleLine = True Then
                DrawFlags = DrawFlags Or DT_SINGLELINE
            End If
        Else
            Select Case VBFlexGridColsInfo(iCol).WordWrapOption
                Case FlexWordWrapNone, FlexEndEllipsis, FlexPathEllipsis, FlexWordEllipsis
                    ' Void
                Case FlexWordBreak, FlexWordBreakEndEllipsis, FlexWordBreakPathEllipsis, FlexWordBreakWordEllipsis
                    DrawFlags = DrawFlags Or DT_WORDBREAK
                Case FlexSingleLine, FlexSingleLineEndEllipsis, FlexSingleLinePathEllipsis, FlexSingleLineWordEllipsis
                    DrawFlags = DrawFlags Or DT_SINGLELINE
            End Select
        End If
    Else
        If VBFlexGridColsInfo(iCol).WordWrapOptionFixed = -1 Then
            If PropWordWrap = True Then
                DrawFlags = DrawFlags Or DT_WORDBREAK
            ElseIf PropSingleLine = True Then
                DrawFlags = DrawFlags Or DT_SINGLELINE
            End If
        Else
            Select Case VBFlexGridColsInfo(iCol).WordWrapOptionFixed
                Case FlexWordWrapNone, FlexEndEllipsis, FlexPathEllipsis, FlexWordEllipsis
                    ' Void
                Case FlexWordBreak, FlexWordBreakEndEllipsis, FlexWordBreakPathEllipsis, FlexWordBreakWordEllipsis
                    DrawFlags = DrawFlags Or DT_WORDBREAK
                Case FlexSingleLine, FlexSingleLineEndEllipsis, FlexSingleLinePathEllipsis, FlexSingleLineWordEllipsis
                    DrawFlags = DrawFlags Or DT_SINGLELINE
            End Select
        End If
    End If
    ' Ellipsis format will be ignored.
    If iRow > (PropFixedRows - 1) And iCol > (PropFixedCols - 1) Then
        If VBFlexGridColsInfo(iCol).MimicTextBox = -1 Then
            If PropMimicTextBox = True Then DrawFlags = DrawFlags Or DT_EDITCONTROL
        Else
            If VBFlexGridColsInfo(iCol).MimicTextBox = FlexMimicTextBoxOn Then DrawFlags = DrawFlags Or DT_EDITCONTROL
        End If
    Else
        If VBFlexGridColsInfo(iCol).MimicTextBoxFixed = -1 Then
            If PropMimicTextBox = True Then DrawFlags = DrawFlags Or DT_EDITCONTROL
        Else
            If VBFlexGridColsInfo(iCol).MimicTextBoxFixed = FlexMimicTextBoxOn Then DrawFlags = DrawFlags Or DT_EDITCONTROL
        End If
    End If
    If VBFlexGridColsInfo(iCol).SortArrow <> FlexSortArrowNone And iRow = PropRowSortArrows And iRow < PropFixedRows Then
        Dim SortArrowMetrics As TSORTARROWMETRICS
        Call GetSortArrowMetrics(hDC, SortArrowMetrics)
        If VBFlexGridColsInfo(iCol).SortArrowAlignment = FlexLeftRightAlignmentRight Then
            TextRect.Right = TextRect.Right - SortArrowMetrics.ClientSize.CX
        ElseIf VBFlexGridColsInfo(iCol).SortArrowAlignment = FlexLeftRightAlignmentLeft Then
            TextRect.Left = TextRect.Left + SortArrowMetrics.ClientSize.CX
        End If
    End If
    Dim CalcRect As RECT, Height As Long, Result As Long
    LSet CalcRect = TextRect
    Select Case Alignment
        Case FlexAlignmentLeftCenter, FlexAlignmentCenterCenter, FlexAlignmentRightCenter, FlexAlignmentGeneral, FlexAlignmentGeneralCenter
            Height = DrawText(hDC, StrPtr(Text), -1, CalcRect, DrawFlags Or DT_CALCRECT)
            Result = (((TextRect.Bottom - TextRect.Top) - Height) \ 2)
            ' DT_VCENTER not applicable to apply here in case of DT_SINGLELINE.
        Case FlexAlignmentLeftBottom, FlexAlignmentCenterBottom, FlexAlignmentRightBottom, FlexAlignmentGeneralBottom
            Height = DrawText(hDC, StrPtr(Text), -1, CalcRect, DrawFlags Or DT_CALCRECT)
            Result = ((TextRect.Bottom - TextRect.Top) - Height)
            ' DT_BOTTOM not applicable to apply here in case of DT_SINGLELINE.
    End Select
    If Result > 0 Or (DrawFlags And DT_SINGLELINE) = DT_SINGLELINE Then
        CalcRect.Top = CalcRect.Top + Result
        CalcRect.Bottom = CalcRect.Bottom + Result
    End If
    With LBLI
    .Flags = LBLI_VALID
    If CalcRect.Right <= VBFlexGridClientRect.Right And CalcRect.Bottom <= VBFlexGridClientRect.Bottom Then
        If CalcRect.Right <= TextRect.Right And CalcRect.Bottom <= TextRect.Bottom Then .Flags = .Flags Or LBLI_UNFOLDED
    End If
    If HiddenText = True Then .Flags = .Flags Or LBLI_HIDDEN
    If (DrawFlags And DT_CENTER) = DT_CENTER Then
        Result = (((TextRect.Right - TextRect.Left) - (CalcRect.Right - CalcRect.Left)) \ 2)
        CalcRect.Left = CalcRect.Left + Result
        CalcRect.Right = CalcRect.Right + Result
    ElseIf (DrawFlags And DT_RIGHT) = DT_RIGHT Then
        Result = ((TextRect.Right - TextRect.Left) - (CalcRect.Right - CalcRect.Left))
        CalcRect.Left = CalcRect.Left + Result
        CalcRect.Right = CalcRect.Right + Result
    End If
    LSet .RC = CalcRect
    .DrawFlags = DrawFlags
    End With
    If hFontOld <> NULL_PTR Then SelectObject hDC, hFontOld
    If hFontTemp <> NULL_PTR Then DeleteObject hFontTemp
    If hDCTemp <> NULL_PTR Then ReleaseDC VBFlexGridHandle, hDCTemp
End If
End Sub

Private Sub SetScrollBars()
Static InProc As Boolean
If VBFlexGridHandle = NULL_PTR Or InProc = True Or VBFlexGridNoRedraw = True Then Exit Sub
InProc = True
Dim dwStyleOld As Long, dwStyleNew As Long, dwStyleTemp As Long
dwStyleOld = GetWindowLong(VBFlexGridHandle, GWL_STYLE)
dwStyleNew = dwStyleOld
dwStyleTemp = dwStyleOld
If (dwStyleNew And WS_HSCROLL) = WS_HSCROLL Then dwStyleNew = dwStyleNew And Not WS_HSCROLL
If (dwStyleNew And WS_VSCROLL) = WS_VSCROLL Then dwStyleNew = dwStyleNew And Not WS_VSCROLL
If (PropRows > 0 And PropCols > 0) And PropScrollBars <> vbSBNone Then
    Select Case PropScrollBars
        Case vbHorizontal
            dwStyleNew = dwStyleNew Or WS_HSCROLL
        Case vbVertical
            dwStyleNew = dwStyleNew Or WS_VSCROLL
        Case vbBoth
            dwStyleNew = dwStyleNew Or WS_HSCROLL Or WS_VSCROLL
    End Select
Else
    If dwStyleNew <> dwStyleOld Then
        SetWindowLong VBFlexGridHandle, GWL_STYLE, dwStyleNew
        SetWindowPos VBFlexGridHandle, NULL_PTR, 0, 0, 0, 0, SWP_NOMOVE Or SWP_NOSIZE Or SWP_NOOWNERZORDER Or SWP_NOZORDER Or SWP_FRAMECHANGED
    End If
    InProc = False
    Exit Sub
End If
Dim SCI(0 To 1) As SCROLLINFO, iRow As Long, iCol As Long, LastMovableRow As Long, LastMovableCol As Long
Dim ClientRect As RECT, GridRect As RECT, Changed As Boolean
SCI(0).cbSize = LenB(SCI(0))
SCI(0).fMask = SIF_RANGE Or SIF_PAGE
If PropDisableNoScroll = True Then SCI(0).fMask = SCI(0).fMask Or SIF_DISABLENOSCROLL
LSet SCI(1) = SCI(0)
LSet ClientRect = VBFlexGridClientRect
With GridRect
Do
    If PropScrollBars = vbHorizontal Or PropScrollBars = vbBoth Then
        SCI(0).nMin = 0
        SCI(0).nMax = 0
        SCI(0).nPage = 0
        .Right = 0
        For iCol = 0 To ((PropFixedCols + PropFrozenCols) - 1)
            .Right = .Right + GetColWidth(iCol)
        Next iCol
        LastMovableCol = GetLastMovableCol()
        For iCol = LastMovableCol To (PropFixedCols + PropFrozenCols) Step -1
            .Right = .Right + GetColWidth(iCol)
            If .Right > ClientRect.Right And iCol < LastMovableCol Then
                SCI(0).nMax = iCol - ((PropFixedCols + PropFrozenCols) - 1)
                Exit For
            End If
        Next iCol
        If SCI(0).nMax > 0 Then
            SCI(0).nPage = 1
        ElseIf PropDisableNoScroll = False Then
            If (dwStyleNew And WS_HSCROLL) = WS_HSCROLL Then dwStyleNew = dwStyleNew And Not WS_HSCROLL
        End If
    End If
    If PropScrollBars = vbVertical Or PropScrollBars = vbBoth Then
        SCI(1).nMin = 0
        SCI(1).nMax = 0
        SCI(1).nPage = 0
        .Bottom = 0
        For iRow = 0 To ((PropFixedRows + PropFrozenRows) - 1)
            .Bottom = .Bottom + GetRowHeight(iRow)
        Next iRow
        LastMovableRow = GetLastMovableRow()
        For iRow = LastMovableRow To (PropFixedRows + PropFrozenRows) Step -1
            .Bottom = .Bottom + GetRowHeight(iRow)
            If .Bottom > ClientRect.Bottom And iRow < LastMovableRow Then
                SCI(1).nMax = iRow - ((PropFixedRows + PropFrozenRows) - 1)
                Exit For
            End If
        Next iRow
        If SCI(1).nMax > 0 Then
            SCI(1).nPage = 1
        ElseIf PropDisableNoScroll = False Then
            If (dwStyleNew And WS_VSCROLL) = WS_VSCROLL Then dwStyleNew = dwStyleNew And Not WS_VSCROLL
        End If
    End If
    Changed = CBool(dwStyleNew <> dwStyleTemp)
    If (dwStyleNew And WS_VSCROLL) = WS_VSCROLL And (dwStyleTemp And WS_VSCROLL) = 0 Then
        ClientRect.Right = ClientRect.Right - GetSystemMetrics(SM_CXVSCROLL)
    ElseIf (dwStyleNew And WS_VSCROLL) = 0 And (dwStyleTemp And WS_VSCROLL) = WS_VSCROLL Then
        ClientRect.Right = ClientRect.Right + GetSystemMetrics(SM_CXVSCROLL)
    End If
    If (dwStyleNew And WS_HSCROLL) = WS_HSCROLL And (dwStyleTemp And WS_HSCROLL) = 0 Then
        ClientRect.Bottom = ClientRect.Bottom - GetSystemMetrics(SM_CYHSCROLL)
    ElseIf (dwStyleNew And WS_HSCROLL) = 0 And (dwStyleTemp And WS_HSCROLL) = WS_HSCROLL Then
        ClientRect.Bottom = ClientRect.Bottom + GetSystemMetrics(SM_CYHSCROLL)
    End If
    dwStyleTemp = dwStyleNew
Loop Until Changed = False
End With
If dwStyleNew <> dwStyleOld Then
    SetWindowLong VBFlexGridHandle, GWL_STYLE, dwStyleNew
    SetWindowPos VBFlexGridHandle, NULL_PTR, 0, 0, 0, 0, SWP_NOMOVE Or SWP_NOSIZE Or SWP_NOOWNERZORDER Or SWP_NOZORDER Or SWP_FRAMECHANGED
End If
SetScrollInfo VBFlexGridHandle, SB_HORZ, SCI(0), 0
SetScrollInfo VBFlexGridHandle, SB_VERT, SCI(1), 0
SetWindowPos VBFlexGridHandle, NULL_PTR, 0, 0, 0, 0, SWP_NOMOVE Or SWP_NOSIZE Or SWP_NOOWNERZORDER Or SWP_NOZORDER Or SWP_DRAWFRAME
InProc = False
End Sub

Private Function GetRowsPerPage(ByVal TopRow As Long) As Long
If VBFlexGridHandle = NULL_PTR Or (PropRows < 1 Or PropCols < 1) Then Exit Function
Dim GridRect As RECT, iRow As Long, Count As Long
With GridRect
For iRow = 0 To ((PropFixedRows + PropFrozenRows) - 1)
    .Bottom = .Bottom + GetRowHeight(iRow)
Next iRow
For iRow = TopRow To (PropRows - 1)
    .Bottom = .Bottom + GetRowHeight(iRow)
    If iRow > TopRow And .Bottom > VBFlexGridClientRect.Bottom Then Exit For
    Count = Count + 1
Next iRow
GetRowsPerPage = Count
End With
End Function

Private Function GetRowsPerPageRev(ByVal BottomRow As Long) As Long
If VBFlexGridHandle = NULL_PTR Or (PropRows < 1 Or PropCols < 1) Then Exit Function
Dim GridRect As RECT, iRow As Long, Count As Long
With GridRect
For iRow = 0 To ((PropFixedRows + PropFrozenRows) - 1)
    .Bottom = .Bottom + GetRowHeight(iRow)
Next iRow
For iRow = BottomRow To (PropFixedRows + PropFrozenRows) Step -1
    .Bottom = .Bottom + GetRowHeight(iRow)
    If iRow < BottomRow And .Bottom > VBFlexGridClientRect.Bottom Then Exit For
    Count = Count + 1
Next iRow
GetRowsPerPageRev = Count
End With
End Function

Private Function GetColsPerPage(ByVal LeftCol As Long) As Long
If VBFlexGridHandle = NULL_PTR Or (PropRows < 1 Or PropCols < 1) Then Exit Function
Dim GridRect As RECT, iCol As Long, Count As Long
With GridRect
For iCol = 0 To ((PropFixedCols + PropFrozenCols) - 1)
    .Right = .Right + GetColWidth(iCol)
Next iCol
For iCol = LeftCol To (PropCols - 1)
    .Right = .Right + GetColWidth(iCol)
    If iCol > LeftCol And .Right > VBFlexGridClientRect.Right Then Exit For
    Count = Count + 1
Next iCol
GetColsPerPage = Count
End With
End Function

Private Function GetColsPerPageRev(ByVal RightCol As Long) As Long
If VBFlexGridHandle = NULL_PTR Or (PropRows < 1 Or PropCols < 1) Then Exit Function
Dim GridRect As RECT, iCol As Long, Count As Long
With GridRect
For iCol = 0 To ((PropFixedCols + PropFrozenCols) - 1)
    .Right = .Right + GetColWidth(iCol)
Next iCol
For iCol = RightCol To (PropFixedCols + PropFrozenCols) Step -1
    .Right = .Right + GetColWidth(iCol)
    If iCol < RightCol And .Right > VBFlexGridClientRect.Right Then Exit For
    Count = Count + 1
Next iCol
GetColsPerPageRev = Count
End With
End Function

Private Function DoScroll(ByVal wBar As Long, ByVal TopRowOrLeftCol As Long) As Boolean
If VBFlexGridHandle = NULL_PTR Or (PropRows < 1 Or PropCols < 1) Then Exit Function
Dim dwStyle As Long
dwStyle = GetWindowLong(VBFlexGridHandle, GWL_STYLE)
If wBar = SB_HORZ Then
    DoScroll = CBool(VBFlexGridLeftCol <> TopRowOrLeftCol)
ElseIf wBar = SB_VERT Then
    DoScroll = CBool(VBFlexGridTopRow <> TopRowOrLeftCol)
End If
If (wBar = SB_HORZ And (dwStyle And WS_HSCROLL) = WS_HSCROLL) Or (wBar = SB_VERT And (dwStyle And WS_VSCROLL) = WS_VSCROLL) Then
    Dim SCI As SCROLLINFO, PrevPos As Long
    SCI.cbSize = LenB(SCI)
    SCI.fMask = SIF_POS
    GetScrollInfo VBFlexGridHandle, wBar, SCI
    PrevPos = SCI.nPos
    If wBar = SB_HORZ Then
        SCI.nPos = TopRowOrLeftCol - (PropFixedCols + PropFrozenCols)
    ElseIf wBar = SB_VERT Then
        SCI.nPos = TopRowOrLeftCol - (PropFixedRows + PropFrozenRows)
    End If
    If PrevPos <> SCI.nPos Then SetScrollInfo VBFlexGridHandle, wBar, SCI, 1
End If
If DoScroll = True Then
    If wBar = SB_HORZ Then
        VBFlexGridLeftCol = TopRowOrLeftCol
    ElseIf wBar = SB_VERT Then
        VBFlexGridTopRow = TopRowOrLeftCol
    End If
    Call RedrawGrid
    If PropShowInfoTips = True Or PropShowLabelTips = True Then
        Dim Pos As Long
        Pos = GetMessagePos()
        Call CheckToolTipRowCol(Get_X_lParam(Pos), Get_Y_lParam(Pos))
    End If
    If VBFlexGridEditRow > -1 And VBFlexGridEditCol > -1 Then Call UpdateEditRect
    RaiseEvent Scroll
End If
End Function

Private Sub CheckTopRow(ByRef TopRow As Long)
If VBFlexGridHandle = NULL_PTR Or (PropRows < 1 Or PropCols < 1) Then Exit Sub
Dim GridRect As RECT, iRow As Long
With GridRect
For iRow = 0 To ((PropFixedRows + PropFrozenRows) - 1)
    .Bottom = .Bottom + GetRowHeight(iRow)
Next iRow
For iRow = TopRow To (PropRows - 1)
    .Bottom = .Bottom + GetRowHeight(iRow)
    If .Bottom > VBFlexGridClientRect.Bottom Then Exit For
Next iRow
If .Bottom <= VBFlexGridClientRect.Bottom Then
    Do While TopRow > (((PropFixedRows + PropFrozenRows) - 1) + 1)
        .Bottom = .Bottom + GetRowHeight(TopRow - 1)
        If .Bottom > VBFlexGridClientRect.Bottom Then
            Exit Do
        Else
            TopRow = TopRow - 1
        End If
    Loop
End If
End With
End Sub

Private Sub CheckLeftCol(ByRef LeftCol As Long)
If VBFlexGridHandle = NULL_PTR Or (PropRows < 1 Or PropCols < 1) Then Exit Sub
Dim GridRect As RECT, iCol As Long
With GridRect
For iCol = 0 To ((PropFixedCols + PropFrozenCols) - 1)
    .Right = .Right + GetColWidth(iCol)
Next iCol
For iCol = LeftCol To (PropCols - 1)
    .Right = .Right + GetColWidth(iCol)
    If .Right > VBFlexGridClientRect.Right Then Exit For
Next iCol
If .Right <= VBFlexGridClientRect.Right Then
    Do While LeftCol > (((PropFixedCols + PropFrozenCols) - 1) + 1)
        .Right = .Right + GetColWidth(LeftCol - 1)
        If .Right > VBFlexGridClientRect.Right Then
            Exit Do
        Else
            LeftCol = LeftCol - 1
        End If
    Loop
End If
End With
End Sub

Private Sub SetRowColParams(ByRef RCP As TROWCOLPARAMS)
Dim RowColChanged As Boolean, SelChanged As Boolean, MultiSelChanged As Boolean, ScrollChanged As Boolean
Dim NoRedraw As Boolean, Cancel As Boolean
With RCP
Select Case PropScrollBars
    Case vbSBNone
        If Not (.Flags And RCPF_FORCETOPROWMASK) = RCPF_FORCETOPROWMASK Then
            If (.Mask And RCPM_TOPROW) = RCPM_TOPROW Then .Mask = .Mask And Not RCPM_TOPROW
        End If
        If Not (.Flags And RCPF_FORCELEFTCOLMASK) = RCPF_FORCELEFTCOLMASK Then
            If (.Mask And RCPM_LEFTCOL) = RCPM_LEFTCOL Then .Mask = .Mask And Not RCPM_LEFTCOL
        End If
    Case vbHorizontal
        If Not (.Flags And RCPF_FORCETOPROWMASK) = RCPF_FORCETOPROWMASK Then
            If (.Mask And RCPM_TOPROW) = RCPM_TOPROW Then .Mask = .Mask And Not RCPM_TOPROW
        End If
    Case vbVertical
        If Not (.Flags And RCPF_FORCELEFTCOLMASK) = RCPF_FORCELEFTCOLMASK Then
            If (.Mask And RCPM_LEFTCOL) = RCPM_LEFTCOL Then .Mask = .Mask And Not RCPM_LEFTCOL
        End If
End Select
If (.Mask And RCPM_ROW) = RCPM_ROW Then
    If .Row > (PropRows - 1) Then .Row = (PropRows - 1)
    If VBFlexGridRow <> .Row Then RowColChanged = True
End If
If (.Mask And RCPM_COL) = RCPM_COL Then
    If .Col > (PropCols - 1) Then .Col = (PropCols - 1)
    If VBFlexGridCol <> .Col Then RowColChanged = True
End If
If (.Mask And RCPM_ROWSEL) = RCPM_ROWSEL Then
    If .RowSel > (PropRows - 1) Then .RowSel = (PropRows - 1)
End If
If (.Mask And RCPM_COLSEL) = RCPM_COLSEL Then
    If .ColSel > (PropCols - 1) Then .ColSel = (PropCols - 1)
End If
If RowColChanged = True Then
    Dim NewRow As Long, NewCol As Long
    NewRow = IIf((.Mask And RCPM_ROW) = RCPM_ROW, .Row, VBFlexGridRow)
    NewCol = IIf((.Mask And RCPM_COL) = RCPM_COL, .Col, VBFlexGridCol)
    RaiseEvent BeforeRowColChange(NewRow, NewCol, Cancel)
    If Cancel = True Then RowColChanged = False
    Cancel = False
End If
If RowColChanged = False Then
    If (.Mask And RCPM_ROWSEL) = RCPM_ROWSEL Then
        If PropAllowSelection = True Then
            If VBFlexGridRowSel <> .RowSel Then SelChanged = True
        Else
            If PropSelectionMode <> FlexSelectionModeByColumn Then
                If (.Mask And RCPM_ROW) = RCPM_ROW Then
                    If VBFlexGridRowSel <> .Row Then SelChanged = True
                Else
                    If VBFlexGridRowSel <> VBFlexGridRow Then SelChanged = True
                End If
            Else
                If VBFlexGridRowSel <> .RowSel Then SelChanged = True
            End If
        End If
    End If
    If (.Mask And RCPM_COLSEL) = RCPM_COLSEL Then
        If PropAllowSelection = True Then
            If VBFlexGridColSel <> .ColSel Then SelChanged = True
        Else
            If PropSelectionMode <> FlexSelectionModeByRow Then
                If (.Mask And RCPM_COL) = RCPM_COL Then
                    If VBFlexGridColSel <> .Col Then SelChanged = True
                Else
                    If VBFlexGridColSel <> VBFlexGridCol Then SelChanged = True
                End If
            Else
                If VBFlexGridColSel <> .ColSel Then SelChanged = True
            End If
        End If
    End If
Else
    SelChanged = True
End If
If SelChanged = True Then
    Dim NewRowSel As Long, NewColSel As Long
    If PropAllowSelection = True Then
        NewRowSel = IIf((.Mask And RCPM_ROWSEL) = RCPM_ROWSEL, .RowSel, VBFlexGridRowSel)
        NewColSel = IIf((.Mask And RCPM_COLSEL) = RCPM_COLSEL, .ColSel, VBFlexGridColSel)
    Else
        Select Case PropSelectionMode
            Case FlexSelectionModeFree, FlexSelectionModeFreeByRow, FlexSelectionModeFreeByColumn
                NewRowSel = IIf((.Mask And RCPM_ROW) = RCPM_ROW, .Row, VBFlexGridRow)
                NewColSel = IIf((.Mask And RCPM_COL) = RCPM_COL, .Col, VBFlexGridCol)
            Case FlexSelectionModeByRow
                NewRowSel = IIf((.Mask And RCPM_ROW) = RCPM_ROW, .Row, VBFlexGridRow)
                NewColSel = IIf((.Mask And RCPM_COLSEL) = RCPM_COLSEL, .ColSel, VBFlexGridColSel)
            Case FlexSelectionModeByColumn
                NewRowSel = IIf((.Mask And RCPM_ROWSEL) = RCPM_ROWSEL, .RowSel, VBFlexGridRowSel)
                NewColSel = IIf((.Mask And RCPM_COL) = RCPM_COL, .Col, VBFlexGridCol)
        End Select
    End If
    RaiseEvent BeforeSelChange(NewRowSel, NewColSel, Cancel)
    If Cancel = True Then SelChanged = False
    Cancel = False
End If
If (.Mask And RCPM_TOPROW) = RCPM_TOPROW Then
    If .TopRow < (PropFixedRows + PropFrozenRows) Then .TopRow = PropFixedRows + PropFrozenRows
    If (.Flags And RCPF_CHECKTOPROW) = RCPF_CHECKTOPROW Then Call CheckTopRow(.TopRow)
    If VBFlexGridTopRow <> .TopRow Then ScrollChanged = True
End If
If (.Mask And RCPM_LEFTCOL) = RCPM_LEFTCOL Then
    If .LeftCol < (PropFixedCols + PropFrozenCols) Then .LeftCol = PropFixedCols + PropFrozenCols
    If (.Flags And RCPF_CHECKLEFTCOL) = RCPF_CHECKLEFTCOL Then Call CheckLeftCol(.LeftCol)
    If VBFlexGridLeftCol <> .LeftCol Then ScrollChanged = True
End If
If RowColChanged = True Then
    RaiseEvent LeaveCell
    If (.Mask And RCPM_ROW) = RCPM_ROW Then VBFlexGridRow = .Row
    If (.Mask And RCPM_COL) = RCPM_COL Then VBFlexGridCol = .Col
End If
If SelChanged = True Then
    If PropAllowSelection = True Then
        If (.Mask And RCPM_ROWSEL) = RCPM_ROWSEL Then VBFlexGridRowSel = .RowSel
        If (.Mask And RCPM_COLSEL) = RCPM_COLSEL Then VBFlexGridColSel = .ColSel
    Else
        Select Case PropSelectionMode
            Case FlexSelectionModeFree, FlexSelectionModeFreeByRow, FlexSelectionModeFreeByColumn
                If (.Mask And RCPM_ROWSEL) = RCPM_ROWSEL Then VBFlexGridRowSel = IIf((.Mask And RCPM_ROW) = RCPM_ROW, .Row, VBFlexGridRow)
                If (.Mask And RCPM_COLSEL) = RCPM_COLSEL Then VBFlexGridColSel = IIf((.Mask And RCPM_COL) = RCPM_COL, .Col, VBFlexGridCol)
            Case FlexSelectionModeByRow
                If (.Mask And RCPM_ROWSEL) = RCPM_ROWSEL Then VBFlexGridRowSel = IIf((.Mask And RCPM_ROW) = RCPM_ROW, .Row, VBFlexGridRow)
                If (.Mask And RCPM_COLSEL) = RCPM_COLSEL Then VBFlexGridColSel = .ColSel
            Case FlexSelectionModeByColumn
                If (.Mask And RCPM_ROWSEL) = RCPM_ROWSEL Then VBFlexGridRowSel = .RowSel
                If (.Mask And RCPM_COLSEL) = RCPM_COLSEL Then VBFlexGridColSel = IIf((.Mask And RCPM_COL) = RCPM_COL, .Col, VBFlexGridCol)
        End Select
    End If
End If
If PropAllowMultiSelection = True Then
    Select Case PropSelectionMode
        Case FlexSelectionModeFree
            ' Not supported.
        Case FlexSelectionModeByRow, FlexSelectionModeFreeByRow
            Select Case .Message
                Case WM_MOUSEMOVE
                    If VBFlexGridExpandSelectedRows = True Then MultiSelChanged = ExpandSelectedRows()
                Case WM_LBUTTONUP, WM_CAPTURECHANGED
                    If VBFlexGridExpandSelectedRows = True Then
                        VBFlexGridExpandSelectedRows = False
                        If PropAllowSelection = True Then
                            If VBFlexGridInvertSelection = False Then
                                MultiSelChanged = AddSelectedRows()
                            Else
                                MultiSelChanged = RemoveSelectedRows()
                            End If
                        Else
                            If VBFlexGridInvertSelection = False Then
                                MultiSelChanged = AddSelectedRow()
                            Else
                                MultiSelChanged = RemoveSelectedRow()
                            End If
                        End If
                    End If
                Case Else
                    If (.Mask And RCPM_ROW) = RCPM_ROW Or (.Mask And RCPM_ROWSEL) = RCPM_ROWSEL Then
                        VBFlexGridInvertSelection = False
                        If PropAllowSelection = True Then
                            If (.Flags And RCPF_SHIFT) = RCPF_SHIFT And (.Flags And RCPF_CTRL) = RCPF_CTRL Then
                                MultiSelChanged = AddSelectedRows()
                            ElseIf (.Flags And RCPF_CTRL) = RCPF_CTRL Then
                                VBFlexGridInvertSelection = Not ToggleSelectedRow()
                                MultiSelChanged = True
                            Else
                                If .Message <> WM_LBUTTONDOWN Then
                                    MultiSelChanged = InitSelectedRows()
                                Else
                                    MultiSelChanged = InitSelectedRow()
                                End If
                            End If
                        Else
                            If PropAllowBigSelection = True Then
                                If (.Flags And RCPF_SHIFT) = RCPF_SHIFT And (.Flags And RCPF_CTRL) = RCPF_CTRL Then
                                    MultiSelChanged = Not GetSelectedRow()
                                ElseIf (.Flags And RCPF_CTRL) = RCPF_CTRL Then
                                    VBFlexGridInvertSelection = GetSelectedRow()
                                    MultiSelChanged = True
                                Else
                                    If .Message <> WM_LBUTTONDOWN Then
                                        MultiSelChanged = InitSelectedRow()
                                    Else
                                        MultiSelChanged = ClearSelectedRows() Or (Not GetSelectedRow())
                                    End If
                                End If
                            Else
                                If (.Flags And RCPF_SHIFT) = 0 And (.Flags And RCPF_CTRL) = RCPF_CTRL Then
                                    VBFlexGridInvertSelection = GetSelectedRow()
                                    Call ClearSelectedRows
                                    If VBFlexGridInvertSelection = True Then Call InitSelectedRow
                                    MultiSelChanged = True
                                Else
                                    If .Message <> WM_LBUTTONDOWN Then
                                        MultiSelChanged = InitSelectedRow()
                                    Else
                                        MultiSelChanged = ClearSelectedRows() Or (Not GetSelectedRow())
                                    End If
                                End If
                            End If
                        End If
                        If .Message = WM_LBUTTONDOWN Then
                            Call ExpandSelectedRows(True)
                        ElseIf .Message = 0 And VBFlexGridMultiSelChangeTimer = True Then
                            If VBFlexGridHandle <> NULL_PTR Then KillTimer VBFlexGridHandle, IDT_MULTISELCHANGE
                            VBFlexGridMultiSelChangeTimer = False
                            MultiSelChanged = True
                        End If
                    End If
            End Select
        Case FlexSelectionModeByColumn, FlexSelectionModeFreeByColumn
            ' Not supported.
    End Select
End If
If ScrollChanged = True Then
    If (.Mask And RCPM_TOPROW) = RCPM_TOPROW And (.Mask And RCPM_LEFTCOL) = RCPM_LEFTCOL Then
        NoRedraw = (DoScroll(SB_VERT, .TopRow) Or DoScroll(SB_HORZ, .LeftCol))
    ElseIf (.Mask And RCPM_TOPROW) = RCPM_TOPROW Then
        NoRedraw = DoScroll(SB_VERT, .TopRow)
    ElseIf (.Mask And RCPM_LEFTCOL) = RCPM_LEFTCOL Then
        NoRedraw = DoScroll(SB_HORZ, .LeftCol)
    End If
End If
If NoRedraw = False Then
    If RowColChanged = True Or SelChanged = True Or MultiSelChanged = True Or ScrollChanged = True Or (.Flags And RCPF_FORCEREDRAW) = RCPF_FORCEREDRAW Then
        Call RedrawGrid
    ElseIf .Message = WM_SIZE Then
        If VBFlexGridExtendLastCol > -1 Then
            Dim iCol As Long, CX As Long
            For iCol = 0 To ((PropFixedCols + PropFrozenCols) - 1)
                CX = CX + GetColWidth(iCol)
            Next iCol
            For iCol = VBFlexGridLeftCol To (VBFlexGridExtendLastCol - 1)
                CX = CX + GetColWidth(iCol)
            Next iCol
            If CX < VBFlexGridClientRect.Right Then Call RedrawGrid
        End If
    End If
End If
If (.Flags And RCPF_SETSCROLLBARS) = RCPF_SETSCROLLBARS Then Call SetScrollBars
If SelChanged = True Then RaiseEvent SelChange
If MultiSelChanged = True Then
    If VBFlexGridDesignMode = False Then
        If .Message = 0 Or PropMultiSelChangeTime = 0 Then
            RaiseEvent MultiSelChange
        ElseIf VBFlexGridHandle <> NULL_PTR Then
            SetTimer VBFlexGridHandle, IDT_MULTISELCHANGE, PropMultiSelChangeTime, NULL_PTR
            VBFlexGridMultiSelChangeTimer = True
        End If
    Else
        RaiseEvent MultiSelChange
    End If
End If
If RowColChanged = True Then
    RaiseEvent EnterCell
    RaiseEvent RowColChange
End If
End With
End Sub

Private Sub MovePreviousRow(ByRef iRow As Long)
Dim i As Long, Cancel As Boolean
i = iRow
Do
    If i > PropFixedRows Then i = i - 1 Else Cancel = True
Loop Until GetRowHeight(i) > 0 Or Cancel = True
If Cancel = False Then iRow = i
End Sub

Private Sub MoveNextRow(ByRef iRow As Long)
Dim i As Long, Cancel As Boolean
i = iRow
Do
    If i < (PropRows - 1) Then i = i + 1 Else Cancel = True
Loop Until GetRowHeight(i) > 0 Or Cancel = True
If Cancel = False Then iRow = i
End Sub

Private Sub MoveFirstRow(ByRef iRow As Long)
Dim i As Long, Cancel As Boolean
i = PropFixedRows
Do Until GetRowHeight(i) > 0 Or Cancel = True
    If i < iRow Then i = i + 1 Else Cancel = True
Loop
If Cancel = False Then iRow = i
End Sub

Private Sub MoveLastRow(ByRef iRow As Long)
Dim i As Long, Cancel As Boolean
i = PropRows - 1
Do Until GetRowHeight(i) > 0 Or Cancel = True
    If i > iRow Then i = i - 1 Else Cancel = True
Loop
If Cancel = False Then iRow = i
End Sub

Private Sub MovePreviousCol(ByRef iCol As Long)
Dim i As Long, Cancel As Boolean
i = iCol
Do
    If i > PropFixedCols Then i = i - 1 Else Cancel = True
Loop Until GetColWidth(i) > 0 Or Cancel = True
If Cancel = False Then iCol = i
End Sub

Private Sub MoveNextCol(ByRef iCol As Long)
Dim i As Long, Cancel As Boolean
i = iCol
Do
    If i < (PropCols - 1) Then i = i + 1 Else Cancel = True
Loop Until GetColWidth(i) > 0 Or Cancel = True
If Cancel = False Then iCol = i
End Sub

Private Sub MoveFirstCol(ByRef iCol As Long)
Dim i As Long, Cancel As Boolean
i = PropFixedCols
Do Until GetColWidth(i) > 0 Or Cancel = True
    If i < iCol Then i = i + 1 Else Cancel = True
Loop
If Cancel = False Then iCol = i
End Sub

Private Sub MoveLastCol(ByRef iCol As Long)
Dim i As Long, Cancel As Boolean
i = PropCols - 1
Do Until GetColWidth(i) > 0 Or Cancel = True
    If i > iCol Then i = i - 1 Else Cancel = True
Loop
If Cancel = False Then iCol = i
End Sub

Private Function GetFirstMovableRow() As Long
Dim i As Long, Cancel As Boolean
i = PropFixedRows
Do Until GetRowHeight(i) > 0 Or Cancel = True
    If i < (PropRows - 1) Then i = i + 1 Else Cancel = True
Loop
If Cancel = False Then GetFirstMovableRow = i Else GetFirstMovableRow = -1
End Function

Private Function GetLastMovableRow() As Long
Dim i As Long, Cancel As Boolean
i = PropRows - 1
Do Until GetRowHeight(i) > 0 Or Cancel = True
    If i > PropFixedRows Then i = i - 1 Else Cancel = True
Loop
If Cancel = False Then GetLastMovableRow = i Else GetLastMovableRow = -1
End Function

Private Function GetFirstMovableCol() As Long
Dim i As Long, Cancel As Boolean
i = PropFixedCols
Do Until GetColWidth(i) > 0 Or Cancel = True
    If i < (PropCols - 1) Then i = i + 1 Else Cancel = True
Loop
If Cancel = False Then GetFirstMovableCol = i Else GetFirstMovableCol = -1
End Function

Private Function GetLastMovableCol() As Long
Dim i As Long, Cancel As Boolean
i = PropCols - 1
Do Until GetColWidth(i) > 0 Or Cancel = True
    If i > PropFixedCols Then i = i - 1 Else Cancel = True
Loop
If Cancel = False Then GetLastMovableCol = i Else GetLastMovableCol = -1
End Function

Private Function GetSheetBorderRow() As Long
Dim i As Long, Cancel As Boolean
i = PropRows - 1
Do Until GetRowHeight(i) > 0 Or Cancel = True
    If i > PropFixedRows Then i = i - 1 Else Cancel = True
Loop
If Cancel = False Then GetSheetBorderRow = i Else GetSheetBorderRow = PropFixedRows - 1
End Function

Private Function GetSheetBorderCol() As Long
Dim i As Long, Cancel As Boolean
i = PropCols - 1
Do Until GetColWidth(i) > 0 Or Cancel = True
    If i > PropFixedCols Then i = i - 1 Else Cancel = True
Loop
If Cancel = False Then GetSheetBorderCol = i Else GetSheetBorderCol = PropFixedCols - 1
End Function

Private Function GetFrozenRow(ByVal Adjacent As Boolean) As Long
If Adjacent = False Then
    If PropFrozenRows > 0 Then
        Dim i As Long, Cancel As Boolean
        i = (PropFixedRows + PropFrozenRows) - 1
        Do Until GetRowHeight(i) > 0 Or Cancel = True
            If i > PropFixedRows Then i = i - 1 Else Cancel = True
        Loop
        If Cancel = False Then GetFrozenRow = i Else GetFrozenRow = PropFixedRows - 1
    Else
        GetFrozenRow = -1
    End If
Else
    Dim iRow As Long
    iRow = VBFlexGridTopRow
    If iRow < (PropRows - 1) Then
        If GetRowHeight(iRow) = 0 Then Call MoveNextRow(iRow)
    End If
    GetFrozenRow = iRow
End If
End Function

Private Function GetFrozenCol(ByVal Adjacent As Boolean) As Long
If Adjacent = False Then
    If PropFrozenCols > 0 Then
        Dim i As Long, Cancel As Boolean
        i = (PropFixedCols + PropFrozenCols) - 1
        Do Until GetColWidth(i) > 0 Or Cancel = True
            If i > PropFixedCols Then i = i - 1 Else Cancel = True
        Loop
        If Cancel = False Then GetFrozenCol = i Else GetFrozenCol = PropFixedCols - 1
    Else
        GetFrozenCol = -1
    End If
Else
    Dim iCol As Long
    iCol = VBFlexGridLeftCol
    If iCol < (PropCols - 1) Then
        If GetColWidth(iCol) = 0 Then Call MoveNextCol(iCol)
    End If
    GetFrozenCol = iCol
End If
End Function

Private Function GetExtendLastCol() As Long
If PropExtendLastCol = False Then
    GetExtendLastCol = -1
Else
    Dim i As Long
    i = PropCols - 1
    If i > -1 Then
        Do Until (VBFlexGridColsInfo(i).State And CLIS_HIDDEN) = 0 And VBFlexGridColsInfo(i).Width <> 0
            i = i - 1
            If i < 0 Then Exit Do
        Loop
    End If
    GetExtendLastCol = i
End If
End Function

Private Function GetRowDividerTop(ByVal iRow As Long) As Long
Dim iRowDivider As Long
iRowDivider = iRow - 1
If iRow >= (PropFixedRows + PropFrozenRows) Then
    Dim iRowTop As Long
    iRowTop = VBFlexGridTopRow
    Do While iRowTop < (PropRows - 1)
        If (VBFlexGridCells.Rows(iRowTop).RowInfo.State And RWIS_HIDDEN) = 0 Then Exit Do
        iRowTop = iRowTop + 1
    Loop
    If iRow = iRowTop Then
        ' Gap adjustment between the topmost row and the non-scrollable rows for divider row top only.
        iRowDivider = iRowDivider - (iRowTop - (PropFixedRows + PropFrozenRows))
    End If
End If
If iRowDivider > -1 Then
    Do While (VBFlexGridCells.Rows(iRowDivider).RowInfo.State And RWIS_HIDDEN) = RWIS_HIDDEN
        iRowDivider = iRowDivider - 1
        If iRowDivider = -1 Then Exit Do
    Loop
End If
GetRowDividerTop = iRowDivider
End Function

Private Function GetColDividerLeft(ByVal iCol As Long) As Long
Dim iColDivider As Long
iColDivider = iCol - 1
If iCol >= (PropFixedCols + PropFrozenCols) Then
    Dim iColLeft As Long
    iColLeft = VBFlexGridLeftCol
    Do While iColLeft < (PropCols - 1)
        If (VBFlexGridColsInfo(iColLeft).State And CLIS_HIDDEN) = 0 Then Exit Do
        iColLeft = iColLeft + 1
    Loop
    If iCol = iColLeft Then
        ' Gap adjustment between the leftmost column and the non-scrollable columns for divider column left only.
        iColDivider = iColDivider - (iColLeft - (PropFixedCols + PropFrozenCols))
    End If
End If
If iColDivider > -1 Then
    Do While (VBFlexGridColsInfo(iColDivider).State And CLIS_HIDDEN) = CLIS_HIDDEN
        iColDivider = iColDivider - 1
        If iColDivider = -1 Then Exit Do
    Loop
End If
GetColDividerLeft = iColDivider
End Function

Private Function GetRowDividerFrozenTop(ByVal iRow As Long) As Long
Dim iRowDivider As Long
iRowDivider = iRow - 1
If iRow >= (PropFixedRows + PropFrozenRows) Then
    Dim iRowTop As Long
    iRowTop = VBFlexGridTopRow
    Do While iRowTop < (PropRows - 1)
        If GetRowHeight(iRowTop) > 0 Then Exit Do
        iRowTop = iRowTop + 1
    Loop
    If iRow = iRowTop Then
        ' Gap adjustment between the topmost row and the non-scrollable rows for divider row top only.
        iRowDivider = iRowDivider - (iRowTop - (PropFixedRows + PropFrozenRows))
    End If
End If
If iRowDivider > -1 Then
    Do While GetRowHeight(iRowDivider) = 0
        iRowDivider = iRowDivider - 1
        If iRowDivider = -1 Then Exit Do
    Loop
End If
GetRowDividerFrozenTop = iRowDivider
End Function

Private Function GetColDividerFrozenLeft(ByVal iCol As Long) As Long
Dim iColDivider As Long
iColDivider = iCol - 1
If iCol >= (PropFixedCols + PropFrozenCols) Then
    Dim iColLeft As Long
    iColLeft = VBFlexGridLeftCol
    Do While iColLeft < (PropCols - 1)
        If GetColWidth(iColLeft) > 0 Then Exit Do
        iColLeft = iColLeft + 1
    Loop
    If iCol = iColLeft Then
        ' Gap adjustment between the leftmost column and the non-scrollable columns for divider column left only.
        iColDivider = iColDivider - (iColLeft - (PropFixedCols + PropFrozenCols))
    End If
End If
If iColDivider > -1 Then
    Do While GetColWidth(iColDivider) = 0
        iColDivider = iColDivider - 1
        If iColDivider = -1 Then Exit Do
    Loop
End If
GetColDividerFrozenLeft = iColDivider
End Function

Private Function ClearSelectedRows() As Boolean
If PropRows < 1 Or PropCols < 1 Then Exit Function
Dim i As Long, Count As Long
For i = 0 To (PropRows - 1)
    With VBFlexGridCells.Rows(i).RowInfo
    If (.State And RWIS_SELECTED) = RWIS_SELECTED Then .State = .State And Not RWIS_SELECTED: Count = Count + 1
    End With
Next i
If Count > 0 Then ClearSelectedRows = True
If VBFlexGridSelectedRows > 0 Then
    Erase VBFlexGridSelectedRowIndices()
    VBFlexGridSelectedRows = 0
End If
End Function

Private Function ExpandSelectedRows(Optional ByVal Initialize As Boolean) As Boolean
Static LastRow As Long, LastRowSel As Long
If Initialize = True Then
    VBFlexGridExpandSelectedRows = True
ElseIf VBFlexGridRow <> LastRow Or VBFlexGridRowSel <> LastRowSel Then
    ExpandSelectedRows = True
    If VBFlexGridSelectedRows > 0 Then
        Erase VBFlexGridSelectedRowIndices()
        VBFlexGridSelectedRows = 0
    End If
End If
LastRow = VBFlexGridRow
LastRowSel = VBFlexGridRowSel
End Function

Private Function InitSelectedRows() As Boolean
If PropRows < 1 Or PropCols < 1 Then Exit Function
Dim SelRange As TCELLRANGE
Call GetSelRangeStruct(SelRange)
Dim i As Long, Count As Long
For i = 0 To (PropRows - 1)
    With VBFlexGridCells.Rows(i).RowInfo
    If i < SelRange.TopRow Or i > SelRange.BottomRow Then
        If (.State And RWIS_SELECTED) = RWIS_SELECTED Then .State = .State And Not RWIS_SELECTED: Count = Count + 1
    Else
        If Not (.State And RWIS_SELECTED) = RWIS_SELECTED Then .State = .State Or RWIS_SELECTED: Count = Count + 1
    End If
    End With
Next i
If Count > 0 Then InitSelectedRows = True
If VBFlexGridSelectedRows > 0 Then
    Erase VBFlexGridSelectedRowIndices()
    VBFlexGridSelectedRows = 0
End If
End Function

Private Function InitSelectedRow() As Boolean
If PropRows < 1 Or PropCols < 1 Then Exit Function
Dim i As Long, Count As Long
For i = 0 To (PropRows - 1)
    With VBFlexGridCells.Rows(i).RowInfo
    If i <> VBFlexGridRow Then
        If (.State And RWIS_SELECTED) = RWIS_SELECTED Then .State = .State And Not RWIS_SELECTED: Count = Count + 1
    Else
        If Not (.State And RWIS_SELECTED) = RWIS_SELECTED Then .State = .State Or RWIS_SELECTED: Count = Count + 1
    End If
    End With
Next i
If Count > 0 Or VBFlexGridRow <> VBFlexGridRowSel Then InitSelectedRow = True
If VBFlexGridSelectedRows > 0 Then
    Erase VBFlexGridSelectedRowIndices()
    VBFlexGridSelectedRows = 0
End If
End Function

Private Function AddSelectedRows() As Boolean
If PropRows < 1 Or PropCols < 1 Then Exit Function
Dim SelRange As TCELLRANGE
Call GetSelRangeStruct(SelRange)
If SelRange.TopRow > -1 And SelRange.BottomRow > -1 Then
    Dim i As Long, Count As Long
    For i = SelRange.TopRow To SelRange.BottomRow
        With VBFlexGridCells.Rows(i).RowInfo
        If Not (.State And RWIS_SELECTED) = RWIS_SELECTED Then .State = .State Or RWIS_SELECTED: Count = Count + 1
        End With
    Next i
    If Count > 0 Then AddSelectedRows = True
End If
If VBFlexGridSelectedRows > 0 Then
    Erase VBFlexGridSelectedRowIndices()
    VBFlexGridSelectedRows = 0
End If
End Function

Private Function RemoveSelectedRows() As Boolean
If PropRows < 1 Or PropCols < 1 Then Exit Function
Dim SelRange As TCELLRANGE
Call GetSelRangeStruct(SelRange)
If SelRange.TopRow > -1 And SelRange.BottomRow > -1 Then
    Dim i As Long, Count As Long
    For i = SelRange.TopRow To SelRange.BottomRow
        With VBFlexGridCells.Rows(i).RowInfo
        If (.State And RWIS_SELECTED) = RWIS_SELECTED Then .State = .State And Not RWIS_SELECTED: Count = Count + 1
        End With
    Next i
    If Count > 0 Then RemoveSelectedRows = True
End If
If VBFlexGridSelectedRows > 0 Then
    Erase VBFlexGridSelectedRowIndices()
    VBFlexGridSelectedRows = 0
End If
End Function

Private Function AddSelectedRow() As Boolean
If PropRows < 1 Or PropCols < 1 Then Exit Function
If VBFlexGridRow > -1 Then
    With VBFlexGridCells.Rows(VBFlexGridRow).RowInfo
    If Not (.State And RWIS_SELECTED) = RWIS_SELECTED Then .State = .State Or RWIS_SELECTED: AddSelectedRow = True
    End With
End If
If VBFlexGridSelectedRows > 0 Then
    Erase VBFlexGridSelectedRowIndices()
    VBFlexGridSelectedRows = 0
End If
End Function

Private Function RemoveSelectedRow() As Boolean
If PropRows < 1 Or PropCols < 1 Then Exit Function
If VBFlexGridRow > -1 Then
    With VBFlexGridCells.Rows(VBFlexGridRow).RowInfo
    If (.State And RWIS_SELECTED) = RWIS_SELECTED Then .State = .State And Not RWIS_SELECTED: RemoveSelectedRow = True
    End With
End If
If VBFlexGridSelectedRows > 0 Then
    Erase VBFlexGridSelectedRowIndices()
    VBFlexGridSelectedRows = 0
End If
End Function

Private Function ToggleSelectedRow() As Boolean
If PropRows < 1 Or PropCols < 1 Then Exit Function
If VBFlexGridRow > -1 Then
    With VBFlexGridCells.Rows(VBFlexGridRow).RowInfo
    If Not (.State And RWIS_SELECTED) = RWIS_SELECTED Then
        .State = .State Or RWIS_SELECTED
        ToggleSelectedRow = True
    Else
        .State = .State And Not RWIS_SELECTED
        ToggleSelectedRow = False
    End If
    End With
End If
If VBFlexGridSelectedRows > 0 Then
    Erase VBFlexGridSelectedRowIndices()
    VBFlexGridSelectedRows = 0
End If
End Function

Private Function GetSelectedRow() As Boolean
If PropRows < 1 Or PropCols < 1 Then Exit Function
If VBFlexGridRow > -1 Then
    With VBFlexGridCells.Rows(VBFlexGridRow).RowInfo
    GetSelectedRow = CBool((.State And RWIS_SELECTED) = RWIS_SELECTED)
    End With
End If
End Function

Private Function GetComboCueActive(ByVal iRow As Long, ByVal iCol As Long) As FlexComboCueConstants
If PropRows < 1 Or PropCols < 1 Then Exit Function
Dim CellFmtg As TCELLFMTG
Call GetCellFmtg(iRow, iCol, CFM_COMBOCUE, CellFmtg)
GetComboCueActive = CellFmtg.ComboCue
If GetComboCueActive = FlexComboCueNone Then
    If iRow >= PropFixedRows And VBFlexGridColsInfo(iCol).ComboCue <> FlexComboModeNone Then
        GetComboCueActive = VBFlexGridColsInfo(iCol).ComboCue
    ElseIf VBFlexGridComboCue <> FlexComboCueNone Then
        If (iRow = GetComboCueRow() And iCol = GetComboCueCol()) Then GetComboCueActive = VBFlexGridComboCue
    End If
End If
End Function

Private Function GetComboCueRow() As Long
If VBFlexGridComboCueRow = -1 Then GetComboCueRow = VBFlexGridRow Else GetComboCueRow = VBFlexGridComboCueRow
End Function

Private Function GetComboCueCol() As Long
If VBFlexGridComboCueCol = -1 Then GetComboCueCol = VBFlexGridCol Else GetComboCueCol = VBFlexGridComboCueCol
End Function

Private Function GetImageIndex(ByVal iRow As Long, ByVal iCol As Long, ByRef Text As String) As Long
If PropRows < 1 Or PropCols < 1 Then Exit Function
If VBFlexGridColsInfo(iCol).ImageList.Handle = NULL_PTR Then Exit Function
Dim Image As Variant, Handled As Boolean, ImageIndex As Long
RaiseEvent CellImageCallback(iRow, iCol, Image, Handled)
If Handled = True Then
    Select Case VarType(Image)
        Case vbLong, vbInteger, vbByte
            ImageIndex = Image
        Case vbString
            If Not Image = vbNullString And VBFlexGridColsInfo(iCol).ImageList.ObjectPointer <> NULL_PTR Then
                On Error Resume Next
                ImageIndex = PtrToObj(VBFlexGridColsInfo(iCol).ImageList.ObjectPointer).ListImages(Image).Index
                On Error GoTo 0
            End If
        Case vbDouble, vbSingle
            On Error Resume Next
            ImageIndex = CLng(Image)
            On Error GoTo 0
    End Select
ElseIf Not Text = vbNullString Then
    If IsNumeric(Text) Then
        On Error Resume Next
        ImageIndex = CLng(Text)
        On Error GoTo 0
    ElseIf VBFlexGridColsInfo(iCol).ImageList.ObjectPointer <> NULL_PTR Then
        On Error Resume Next
        ImageIndex = PtrToObj(VBFlexGridColsInfo(iCol).ImageList.ObjectPointer).ListImages(Text).Index
        On Error GoTo 0
    End If
End If
If ImageIndex > 0 Then
    If ImageIndex <= ImageList_GetImageCount(VBFlexGridColsInfo(iCol).ImageList.Handle) Then GetImageIndex = ImageIndex
End If
End Function

Private Function GetIncrementalSearchTime() As Long
If VBFlexGridIncrementalSearch.Time = -1 Then GetIncrementalSearchTime = GetDoubleClickTime() * 2 Else GetIncrementalSearchTime = VBFlexGridIncrementalSearch.Time
End Function

Private Sub AddUndo(ByRef UndoRedoEntry As TUNDOREDOENTRY)
If PropUndoLimit > 0 Then
    If (VBFlexGridUndoQueueIndex + 1) <= (PropUndoLimit - 1) Then
        VBFlexGridUndoQueueIndex = VBFlexGridUndoQueueIndex + 1
    Else
        Dim i As Long
        For i = 0 To (VBFlexGridUndoQueueIndex - 1)
            LSet VBFlexGridUndoQueue(i) = VBFlexGridUndoQueue(i + 1)
        Next i
    End If
    LSet VBFlexGridUndoQueue(VBFlexGridUndoQueueIndex) = UndoRedoEntry
End If
End Sub

Private Sub ResetUndo()
If PropUndoLimit > 0 Then
    ReDim VBFlexGridUndoQueue(0 To (PropUndoLimit - 1)) As TUNDOREDOENTRY
Else
    Erase VBFlexGridUndoQueue()
End If
VBFlexGridUndoQueueIndex = -1
End Sub

Private Sub AddRedo(ByRef UndoRedoEntry As TUNDOREDOENTRY)
If PropUndoLimit > 0 Then
    If (VBFlexGridRedoQueueIndex + 1) <= (PropUndoLimit - 1) Then
        VBFlexGridRedoQueueIndex = VBFlexGridRedoQueueIndex + 1
    Else
        Dim i As Long
        For i = 0 To (VBFlexGridRedoQueueIndex - 1)
            LSet VBFlexGridRedoQueue(i) = VBFlexGridRedoQueue(i + 1)
        Next i
    End If
    LSet VBFlexGridRedoQueue(VBFlexGridRedoQueueIndex) = UndoRedoEntry
End If
End Sub

Private Sub ResetRedo()
If PropUndoLimit > 0 Then
    ReDim VBFlexGridRedoQueue(0 To (PropUndoLimit - 1)) As TUNDOREDOENTRY
Else
    Erase VBFlexGridRedoQueue()
End If
VBFlexGridRedoQueueIndex = -1
End Sub

Private Sub ProcessKeyDown(ByVal KeyCode As Integer, ByVal Shift As Integer)
If PropRows < 1 Or PropCols < 1 Then Exit Sub
If VBFlexGridEditHandle <> NULL_PTR Then Exit Sub
Dim ScrollLock As Boolean
Select Case KeyCode
    Case vbKeyUp, vbKeyDown, vbKeyLeft, vbKeyRight
        If PropAllowScrollLock = True Then ScrollLock = KeyToggled(vbKeyScrollLock)
    Case vbKeyPageUp, vbKeyPageDown, vbKeyHome, vbKeyEnd
    Case vbKeyTab
        If PropTabBehavior = FlexTabControls Then Exit Sub
    Case vbKeyReturn
        Select Case PropDirectionAfterReturn
            Case FlexDirectionAfterReturnNone, FlexDirectionAfterReturnEdit
                Exit Sub
        End Select
    Case Else
        Exit Sub
End Select
If PropAllowSelection = False Then
    If (Shift And vbShiftMask) = vbShiftMask And KeyCode <> vbKeyTab And KeyCode <> vbKeyReturn Then Exit Sub
End If
Dim RCP As TROWCOLPARAMS, RowsPerPage As Long, ColsPerPage As Long
With RCP
.Mask = RCPM_ROW Or RCPM_COL Or RCPM_ROWSEL Or RCPM_COLSEL Or RCPM_TOPROW Or RCPM_LEFTCOL
If (Shift And vbShiftMask) <> 0 Then
    .Flags = .Flags Or RCPF_SHIFT
    If (Shift And vbCtrlMask) <> 0 Then .Flags = .Flags Or RCPF_CTRL
End If
If PropAllowIncrementalSearch = True Then
    If Not VBFlexGridIncrementalSearch.SearchString = vbNullString Then
        Call CancelIncrementalSearch(True)
        .Flags = .Flags Or RCPF_FORCEREDRAW
    End If
End If
.Message = WM_KEYDOWN
.Row = VBFlexGridRow
.Col = VBFlexGridCol
Select Case KeyCode
    Case vbKeyUp, vbKeyPageUp
        If .Row < PropFixedRows Then .Row = PropFixedRows
    Case vbKeyDown, vbKeyPageDown
        If .Row > (PropRows - 1) Then .Row = (PropRows - 1)
    Case vbKeyLeft, vbKeyHome
        If .Col < PropFixedCols Then .Col = PropFixedCols
    Case vbKeyRight, vbKeyEnd
        If .Col > (PropCols - 1) Then .Col = (PropCols - 1)
End Select
.RowSel = VBFlexGridRowSel
.ColSel = VBFlexGridColSel
.TopRow = VBFlexGridTopRow
.LeftCol = VBFlexGridLeftCol
Select Case PropSelectionMode
    Case FlexSelectionModeFree, FlexSelectionModeFreeByRow, FlexSelectionModeFreeByColumn
        Select Case KeyCode
            Case vbKeyUp
                If (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) = 0 Then
                    If ScrollLock = False Then
                        Call MovePreviousRow(.Row)
                        .RowSel = .Row
                        .ColSel = .Col
                        If .TopRow > .Row Then
                            If .Row >= (PropFixedRows + PropFrozenRows) Then .TopRow = .Row
                        ElseIf .Row > (.TopRow + GetRowsPerPage(.TopRow) - 1) Then
                            .TopRow = .Row - GetRowsPerPageRev(.Row) + 1
                        End If
                        If .LeftCol > .Col Then
                            If .Col >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .Col
                        ElseIf .Col > (.LeftCol + GetColsPerPage(.LeftCol) - 1) Then
                            .LeftCol = .Col - GetColsPerPageRev(.Col) + 1
                        End If
                    Else
                        Call MovePreviousRow(.TopRow)
                        If .TopRow < (PropFixedRows + PropFrozenRows) Then .TopRow = (PropFixedRows + PropFrozenRows)
                    End If
                ElseIf (Shift And vbShiftMask) <> 0 And (Shift And vbCtrlMask) = 0 Then
                    If ScrollLock = False Then
                        Call MovePreviousRow(.RowSel)
                        If .TopRow > .RowSel Then
                            If .RowSel >= (PropFixedRows + PropFrozenRows) Then .TopRow = .RowSel
                        End If
                    Else
                        ' Void
                    End If
                ElseIf (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) <> 0 Then
                    If ScrollLock = False Then
                        Call MoveFirstRow(.Row)
                        .RowSel = .Row
                        .ColSel = .Col
                        If .Row >= (PropFixedRows + PropFrozenRows) Then .TopRow = .Row
                        If .LeftCol > .Col Then
                            If .Col >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .Col
                        ElseIf .Col > (.LeftCol + GetColsPerPage(.LeftCol) - 1) Then
                            .LeftCol = .Col - GetColsPerPageRev(.Col) + 1
                        End If
                    Else
                        .TopRow = .TopRow - GetRowsPerPageRev(.TopRow)
                        If .TopRow < (PropFixedRows + PropFrozenRows) Then .TopRow = (PropFixedRows + PropFrozenRows)
                    End If
                Else
                    Call MoveFirstRow(.RowSel)
                    If .RowSel >= (PropFixedRows + PropFrozenRows) Then .TopRow = .RowSel
                End If
            Case vbKeyDown
                If (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) = 0 Then
                    If ScrollLock = False Then
                        Call MoveNextRow(.Row)
                        .RowSel = .Row
                        .ColSel = .Col
                        If .TopRow > .Row Then
                            If .Row >= (PropFixedRows + PropFrozenRows) Then .TopRow = .Row
                        ElseIf .Row > (.TopRow + GetRowsPerPage(.TopRow) - 1) Then
                            .TopRow = .Row - GetRowsPerPageRev(.Row) + 1
                        End If
                        If .LeftCol > .Col Then
                            If .Col >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .Col
                        ElseIf .Col > (.LeftCol + GetColsPerPage(.LeftCol) - 1) Then
                            .LeftCol = .Col - GetColsPerPageRev(.Col) + 1
                        End If
                    Else
                        If .TopRow < (PropRows - 1) - GetRowsPerPageRev(PropRows - 1) + 1 Then Call MoveNextRow(.TopRow)
                    End If
                ElseIf (Shift And vbShiftMask) <> 0 And (Shift And vbCtrlMask) = 0 Then
                    If ScrollLock = False Then
                        Call MoveNextRow(.RowSel)
                        If .TopRow > .RowSel Then
                            If .RowSel >= (PropFixedRows + PropFrozenRows) Then .TopRow = .RowSel
                        ElseIf .RowSel > (.TopRow + GetRowsPerPage(.TopRow) - 1) Then
                            .TopRow = .RowSel - GetRowsPerPageRev(.RowSel) + 1
                        End If
                    Else
                        ' Void
                    End If
                ElseIf (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) <> 0 Then
                    If ScrollLock = False Then
                        Call MoveLastRow(.Row)
                        .RowSel = .Row
                        .ColSel = .Col
                        .TopRow = (PropRows - 1) - GetRowsPerPageRev(PropRows - 1) + 1
                        If .LeftCol > .Col Then
                            If .Col >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .Col
                        ElseIf .Col > (.LeftCol + GetColsPerPage(.LeftCol) - 1) Then
                            .LeftCol = .Col - GetColsPerPageRev(.Col) + 1
                        End If
                    Else
                        .TopRow = .TopRow + GetRowsPerPage(.TopRow)
                        RowsPerPage = GetRowsPerPageRev(PropRows - 1)
                        If .TopRow > (PropRows - 1) - RowsPerPage + 1 Then .TopRow = (PropRows - 1) - RowsPerPage + 1
                    End If
                Else
                    Call MoveLastRow(.RowSel)
                    .TopRow = (PropRows - 1) - GetRowsPerPageRev(PropRows - 1) + 1
                End If
            Case vbKeyLeft
                If (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) = 0 Then
                    If ScrollLock = False Then
                        If PropWrapCellBehavior <> FlexWrapNone Then
                            If .Col > GetFirstMovableCol() Then
                                Call MovePreviousCol(.Col)
                            Else
                                If .Row > GetFirstMovableRow() Then
                                    Call MoveLastCol(.Col)
                                    Call MovePreviousRow(.Row)
                                Else
                                    If PropWrapCellBehavior = FlexWrapGrid Then
                                        Call MoveLastCol(.Col)
                                        Call MoveLastRow(.Row)
                                    End If
                                End If
                            End If
                        Else
                            Call MovePreviousCol(.Col)
                        End If
                        .RowSel = .Row
                        .ColSel = .Col
                        If .TopRow > .Row Then
                            If .Row >= (PropFixedRows + PropFrozenRows) Then .TopRow = .Row
                        ElseIf .Row > (.TopRow + GetRowsPerPage(.TopRow) - 1) Then
                            .TopRow = .Row - GetRowsPerPageRev(.Row) + 1
                        End If
                        If .LeftCol > .Col Then
                            If .Col >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .Col
                        ElseIf .Col > (.LeftCol + GetColsPerPage(.LeftCol) - 1) Then
                            .LeftCol = .Col - GetColsPerPageRev(.Col) + 1
                        End If
                    Else
                        Call MovePreviousCol(.LeftCol)
                        If .LeftCol < (PropFixedCols + PropFrozenCols) Then .LeftCol = (PropFixedCols + PropFrozenCols)
                    End If
                ElseIf (Shift And vbShiftMask) <> 0 And (Shift And vbCtrlMask) = 0 Then
                    If ScrollLock = False Then
                        Call MovePreviousCol(.ColSel)
                        If .LeftCol > .ColSel Then
                            If .ColSel >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .ColSel
                        End If
                    Else
                        ' Void
                    End If
                ElseIf (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) <> 0 Then
                    If ScrollLock = False Then
                        Call MoveFirstCol(.Col)
                        .RowSel = .Row
                        .ColSel = .Col
                        If .TopRow > .Row Then
                            If .Row >= (PropFixedRows + PropFrozenRows) Then .TopRow = .Row
                        ElseIf .Row > (.TopRow + GetRowsPerPage(.TopRow) - 1) Then
                            .TopRow = .Row - GetRowsPerPageRev(.Row) + 1
                        End If
                        If .Col >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .Col
                    Else
                        .LeftCol = .LeftCol - GetColsPerPageRev(.LeftCol)
                        If .LeftCol < (PropFixedCols + PropFrozenCols) Then .LeftCol = (PropFixedCols + PropFrozenCols)
                    End If
                Else
                    Call MoveFirstCol(.ColSel)
                    If .ColSel >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .ColSel
                End If
            Case vbKeyRight
                If (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) = 0 Then
                    If ScrollLock = False Then
                        If PropWrapCellBehavior <> FlexWrapNone Then
                            If .Col < GetLastMovableCol() Then
                                Call MoveNextCol(.Col)
                            Else
                                If .Row < GetLastMovableRow() Then
                                    Call MoveFirstCol(.Col)
                                    Call MoveNextRow(.Row)
                                Else
                                    If PropWrapCellBehavior = FlexWrapGrid Then
                                        Call MoveFirstCol(.Col)
                                        Call MoveFirstRow(.Row)
                                    End If
                                End If
                            End If
                        Else
                            Call MoveNextCol(.Col)
                        End If
                        .RowSel = .Row
                        .ColSel = .Col
                        If .TopRow > .Row Then
                            If .Row >= (PropFixedRows + PropFrozenRows) Then .TopRow = .Row
                        ElseIf .Row > (.TopRow + GetRowsPerPage(.TopRow) - 1) Then
                            .TopRow = .Row - GetRowsPerPageRev(.Row) + 1
                        End If
                        If .LeftCol > .Col Then
                            If .Col >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .Col
                        ElseIf .Col > (.LeftCol + GetColsPerPage(.LeftCol) - 1) Then
                            .LeftCol = .Col - GetColsPerPageRev(.Col) + 1
                        End If
                    Else
                        If .LeftCol < (PropCols - 1) - GetColsPerPageRev(PropCols - 1) + 1 Then Call MoveNextCol(.LeftCol)
                    End If
                ElseIf (Shift And vbShiftMask) <> 0 And (Shift And vbCtrlMask) = 0 Then
                    If ScrollLock = False Then
                        Call MoveNextCol(.ColSel)
                        If .LeftCol > .ColSel Then
                            If .ColSel >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .ColSel
                        ElseIf .ColSel > (.LeftCol + GetColsPerPage(.LeftCol) - 1) Then
                            .LeftCol = .ColSel - GetColsPerPageRev(.ColSel) + 1
                        End If
                    Else
                        ' Void
                    End If
                ElseIf (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) <> 0 Then
                    If ScrollLock = False Then
                        Call MoveLastCol(.Col)
                        .RowSel = .Row
                        .ColSel = .Col
                        If .TopRow > .Row Then
                            If .Row >= (PropFixedRows + PropFrozenRows) Then .TopRow = .Row
                        ElseIf .Row > (.TopRow + GetRowsPerPage(.TopRow) - 1) Then
                            .TopRow = .Row - GetRowsPerPageRev(.Row) + 1
                        End If
                        .LeftCol = (PropCols - 1) - GetColsPerPageRev(PropCols - 1) + 1
                    Else
                        .LeftCol = .LeftCol + GetColsPerPage(.LeftCol)
                        ColsPerPage = GetColsPerPageRev(PropCols - 1)
                        If .LeftCol > (PropCols - 1) - ColsPerPage + 1 Then .LeftCol = (PropCols - 1) - ColsPerPage + 1
                    End If
                Else
                    Call MoveLastCol(.ColSel)
                    .LeftCol = (PropCols - 1) - GetColsPerPageRev(PropCols - 1) + 1
                End If
            Case vbKeyPageUp
                If (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) = 0 Then
                    If .Row >= PropFixedRows And .Row < (PropFixedRows + PropFrozenRows) Then
                        RowsPerPage = PropFrozenRows - .Row + 1
                        If (.Row + RowsPerPage) < (PropRows - 1) Then
                            .Row = .Row + RowsPerPage
                        Else
                            .Row = (PropRows - 1)
                        End If
                        If GetRowHeight(.Row) = 0 Then Call MovePreviousRow(.Row)
                    ElseIf .Row > PropFixedRows Then
                        RowsPerPage = GetRowsPerPageRev(.Row)
                        If (.Row - RowsPerPage) > (PropFixedRows + PropFrozenRows) Then
                            .Row = .Row - RowsPerPage
                        Else
                            .Row = PropFixedRows + PropFrozenRows
                        End If
                        If GetRowHeight(.Row) = 0 Then Call MoveNextRow(.Row)
                    End If
                    .RowSel = .Row
                    .ColSel = .Col
                    If .TopRow > .Row Then
                        If .Row >= (PropFixedRows + PropFrozenRows) Then .TopRow = .Row
                    Else
                        .TopRow = .Row - GetRowsPerPageRev(.Row) + 1
                    End If
                    If .LeftCol > .Col Then
                        If .Col >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .Col
                    ElseIf .ColSel > (.LeftCol + GetColsPerPage(.LeftCol) - 1) Then
                        .LeftCol = .ColSel - GetColsPerPageRev(.ColSel) + 1
                    End If
                ElseIf (Shift And vbShiftMask) <> 0 And (Shift And vbCtrlMask) = 0 Then
                    If .RowSel >= PropFixedRows And .RowSel < (PropFixedRows + PropFrozenRows) Then
                        RowsPerPage = PropFrozenRows - .RowSel + 1
                        If (.RowSel + RowsPerPage) < (PropRows - 1) Then
                            .RowSel = .RowSel + RowsPerPage
                        Else
                            .RowSel = (PropRows - 1)
                        End If
                        If GetRowHeight(.Row) = 0 Then Call MovePreviousRow(.Row)
                    ElseIf .RowSel > PropFixedRows Then
                        RowsPerPage = GetRowsPerPageRev(.RowSel)
                        If (.RowSel - RowsPerPage) > (PropFixedRows + PropFrozenRows) Then
                            .RowSel = .RowSel - RowsPerPage
                        Else
                            .RowSel = PropFixedRows + PropFrozenRows
                        End If
                        If GetRowHeight(.RowSel) = 0 Then Call MoveNextRow(.RowSel)
                    End If
                    If .TopRow > .RowSel Then
                        If .RowSel >= (PropFixedRows + PropFrozenRows) Then .TopRow = .RowSel
                    Else
                        .TopRow = .RowSel - GetRowsPerPageRev(.RowSel) + 1
                    End If
                ElseIf (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) <> 0 Then
                    Call MoveFirstRow(.Row)
                    .RowSel = .Row
                    .ColSel = .Col
                    If .Row >= (PropFixedRows + PropFrozenRows) Then .TopRow = .Row
                    If .LeftCol > .Col Then
                        If .Col >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .Col
                    ElseIf .Col > (.LeftCol + GetColsPerPage(.LeftCol) - 1) Then
                        .LeftCol = .Col - GetColsPerPageRev(.Col) + 1
                    End If
                Else
                    Call MoveFirstRow(.RowSel)
                    If .RowSel >= (PropFixedRows + PropFrozenRows) Then .TopRow = .RowSel
                End If
            Case vbKeyPageDown
                If (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) = 0 Then
                    If .Row < (PropRows - 1) Then
                        If .Row >= PropFixedRows And .Row < (PropFixedRows + PropFrozenRows) Then
                            RowsPerPage = PropFrozenRows - .Row + 1
                        Else
                            RowsPerPage = GetRowsPerPage(.Row)
                        End If
                        If (.Row + RowsPerPage) < (PropRows - 1) Then
                            .Row = .Row + RowsPerPage
                        Else
                            .Row = (PropRows - 1)
                        End If
                        If GetRowHeight(.Row) = 0 Then Call MovePreviousRow(.Row)
                    End If
                    .RowSel = .Row
                    .ColSel = .Col
                    If .TopRow > .Row Then
                        If .Row >= (PropFixedRows + PropFrozenRows) Then .TopRow = .Row
                    Else
                        .TopRow = .Row - GetRowsPerPageRev(.Row) + 1
                    End If
                    If .LeftCol > .Col Then
                        If .Col >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .Col
                    ElseIf .ColSel > (.LeftCol + GetColsPerPage(.LeftCol) - 1) Then
                        .LeftCol = .ColSel - GetColsPerPageRev(.ColSel) + 1
                    End If
                ElseIf (Shift And vbShiftMask) <> 0 And (Shift And vbCtrlMask) = 0 Then
                    If .RowSel < (PropRows - 1) Then
                        If .RowSel >= PropFixedRows And .RowSel < (PropFixedRows + PropFrozenRows) Then
                            RowsPerPage = PropFrozenRows - .RowSel + 1
                        Else
                            RowsPerPage = GetRowsPerPage(.RowSel)
                        End If
                        If (.RowSel + RowsPerPage) < (PropRows - 1) Then
                            .RowSel = .RowSel + RowsPerPage
                        Else
                            .RowSel = (PropRows - 1)
                        End If
                        If GetRowHeight(.RowSel) = 0 Then Call MovePreviousRow(.RowSel)
                    End If
                    If .TopRow > .RowSel Then
                        If .RowSel >= (PropFixedRows + PropFrozenRows) Then .TopRow = .RowSel
                    Else
                        .TopRow = .RowSel - GetRowsPerPageRev(.RowSel) + 1
                    End If
                ElseIf (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) <> 0 Then
                    Call MoveLastRow(.Row)
                    .RowSel = .Row
                    .ColSel = .Col
                    .TopRow = (PropRows - 1) - GetRowsPerPageRev(PropRows - 1) + 1
                    If .LeftCol > .Col Then
                        If .Col >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .Col
                    ElseIf .Col > (.LeftCol + GetColsPerPage(.LeftCol) - 1) Then
                        .LeftCol = .Col - GetColsPerPageRev(.Col) + 1
                    End If
                Else
                    Call MoveLastRow(.RowSel)
                    .TopRow = (PropRows - 1) - GetRowsPerPageRev(PropRows - 1) + 1
                End If
            Case vbKeyHome
                If (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) = 0 Then
                    Call MoveFirstCol(.Col)
                    .RowSel = .Row
                    .ColSel = .Col
                    If .TopRow > .Row Then
                        If .Row >= (PropFixedRows + PropFrozenRows) Then .TopRow = .Row
                    ElseIf .Row > (.TopRow + GetRowsPerPage(.TopRow) - 1) Then
                        .TopRow = .Row - GetRowsPerPageRev(.Row) + 1
                    End If
                    If .Col >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .Col
                ElseIf (Shift And vbShiftMask) <> 0 And (Shift And vbCtrlMask) = 0 Then
                    Call MoveFirstCol(.ColSel)
                    If .ColSel >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .ColSel
                ElseIf (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) <> 0 Then
                    Call MoveFirstRow(.Row)
                    Call MoveFirstCol(.Col)
                    .RowSel = .Row
                    .ColSel = .Col
                    If .Row >= (PropFixedRows + PropFrozenRows) Then .TopRow = .Row
                    If .Col >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .Col
                Else
                    Call MoveFirstRow(.RowSel)
                    Call MoveFirstCol(.ColSel)
                    If .RowSel >= (PropFixedRows + PropFrozenRows) Then .TopRow = .RowSel
                    If .ColSel >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .ColSel
                End If
            Case vbKeyEnd
                If (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) = 0 Then
                    Call MoveLastCol(.Col)
                    .RowSel = .Row
                    .ColSel = .Col
                    If .TopRow > .Row Then
                        If .Row >= (PropFixedRows + PropFrozenRows) Then .TopRow = .Row
                    ElseIf .Row > (.TopRow + GetRowsPerPage(.TopRow) - 1) Then
                        .TopRow = .Row - GetRowsPerPageRev(.Row) + 1
                    End If
                    .LeftCol = (PropCols - 1) - GetColsPerPageRev(PropCols - 1) + 1
                ElseIf (Shift And vbShiftMask) <> 0 And (Shift And vbCtrlMask) = 0 Then
                    Call MoveLastCol(.ColSel)
                    .LeftCol = (PropCols - 1) - GetColsPerPageRev(PropCols - 1) + 1
                ElseIf (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) <> 0 Then
                    Call MoveLastRow(.Row)
                    Call MoveLastCol(.Col)
                    .RowSel = .Row
                    .ColSel = .Col
                    .TopRow = (PropRows - 1) - GetRowsPerPageRev(PropRows - 1) + 1
                    .LeftCol = (PropCols - 1) - GetColsPerPageRev(PropCols - 1) + 1
                Else
                    Call MoveLastRow(.RowSel)
                    Call MoveLastCol(.ColSel)
                    .TopRow = (PropRows - 1) - GetRowsPerPageRev(PropRows - 1) + 1
                    .LeftCol = (PropCols - 1) - GetColsPerPageRev(PropCols - 1) + 1
                End If
            Case vbKeyTab
                If (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) = 0 Then
                    If PropWrapCellBehavior <> FlexWrapNone Then
                        If .Col < GetLastMovableCol() Then
                            Call MoveNextCol(.Col)
                        Else
                            If .Row < GetLastMovableRow() Then
                                Call MoveFirstCol(.Col)
                                Call MoveNextRow(.Row)
                            Else
                                If PropWrapCellBehavior = FlexWrapGrid Then
                                    Call MoveFirstCol(.Col)
                                    Call MoveFirstRow(.Row)
                                End If
                            End If
                        End If
                    Else
                        Call MoveNextCol(.Col)
                    End If
                    .RowSel = .Row
                    .ColSel = .Col
                    If .TopRow > .Row Then
                        If .Row >= (PropFixedRows + PropFrozenRows) Then .TopRow = .Row
                    ElseIf .Row > (.TopRow + GetRowsPerPage(.TopRow) - 1) Then
                        .TopRow = .Row - GetRowsPerPageRev(.Row) + 1
                    End If
                    If .LeftCol > .Col Then
                        If .Col >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .Col
                    ElseIf .Col > (.LeftCol + GetColsPerPage(.LeftCol) - 1) Then
                        .LeftCol = .Col - GetColsPerPageRev(.Col) + 1
                    End If
                ElseIf (Shift And vbShiftMask) <> 0 And (Shift And vbCtrlMask) = 0 Then
                    If PropWrapCellBehavior <> FlexWrapNone Then
                        If .Col > GetFirstMovableCol() Then
                            Call MovePreviousCol(.Col)
                        Else
                            If .Row > GetFirstMovableRow() Then
                                Call MoveLastCol(.Col)
                                Call MovePreviousRow(.Row)
                            Else
                                If PropWrapCellBehavior = FlexWrapGrid Then
                                    Call MoveLastCol(.Col)
                                    Call MoveLastRow(.Row)
                                End If
                            End If
                        End If
                    Else
                        Call MovePreviousCol(.Col)
                    End If
                    .RowSel = .Row
                    .ColSel = .Col
                    If .TopRow > .Row Then
                        If .Row >= (PropFixedRows + PropFrozenRows) Then .TopRow = .Row
                    ElseIf .Row > (.TopRow + GetRowsPerPage(.TopRow) - 1) Then
                        .TopRow = .Row - GetRowsPerPageRev(.Row) + 1
                    End If
                    If .LeftCol > .Col Then
                        If .Col >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .Col
                    ElseIf .Col > (.LeftCol + GetColsPerPage(.LeftCol) - 1) Then
                        .LeftCol = .Col - GetColsPerPageRev(.Col) + 1
                    End If
                ElseIf (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) <> 0 Then
                    ' Void
                Else
                    ' Void
                End If
            Case vbKeyReturn
                If (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) = 0 Then
                    Select Case PropDirectionAfterReturn
                        Case FlexDirectionAfterReturnUp
                            If .Row > GetFirstMovableRow() Then
                                Call MovePreviousRow(.Row)
                            Else
                                If PropWrapCellBehavior = FlexWrapGrid Then Call MoveLastRow(.Row)
                            End If
                        Case FlexDirectionAfterReturnDown
                            If .Row < GetLastMovableRow() Then
                                Call MoveNextRow(.Row)
                            Else
                                If PropWrapCellBehavior = FlexWrapGrid Then Call MoveFirstRow(.Row)
                            End If
                        Case FlexDirectionAfterReturnLeft
                            If PropWrapCellBehavior <> FlexWrapNone Then
                                If .Col > GetFirstMovableCol() Then
                                    Call MovePreviousCol(.Col)
                                Else
                                    If .Row > GetFirstMovableRow() Then
                                        Call MoveLastCol(.Col)
                                        Call MovePreviousRow(.Row)
                                    Else
                                        If PropWrapCellBehavior = FlexWrapGrid Then
                                            Call MoveLastCol(.Col)
                                            Call MoveLastRow(.Row)
                                        End If
                                    End If
                                End If
                            Else
                                Call MovePreviousCol(.Col)
                            End If
                        Case FlexDirectionAfterReturnRight
                            If PropWrapCellBehavior <> FlexWrapNone Then
                                If .Col < GetLastMovableCol() Then
                                    Call MoveNextCol(.Col)
                                Else
                                    If .Row < GetLastMovableRow() Then
                                        Call MoveFirstCol(.Col)
                                        Call MoveNextRow(.Row)
                                    Else
                                        If PropWrapCellBehavior = FlexWrapGrid Then
                                            Call MoveFirstCol(.Col)
                                            Call MoveFirstRow(.Row)
                                        End If
                                    End If
                                End If
                            Else
                                Call MoveNextCol(.Col)
                            End If
                    End Select
                    .RowSel = .Row
                    .ColSel = .Col
                    If .TopRow > .Row Then
                        If .Row >= (PropFixedRows + PropFrozenRows) Then .TopRow = .Row
                    ElseIf .Row > (.TopRow + GetRowsPerPage(.TopRow) - 1) Then
                        .TopRow = .Row - GetRowsPerPageRev(.Row) + 1
                    End If
                    If .LeftCol > .Col Then
                        If .Col >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .Col
                    ElseIf .Col > (.LeftCol + GetColsPerPage(.LeftCol) - 1) Then
                        .LeftCol = .Col - GetColsPerPageRev(.Col) + 1
                    End If
                ElseIf (Shift And vbShiftMask) <> 0 And (Shift And vbCtrlMask) = 0 Then
                    Select Case PropDirectionAfterReturn
                        Case FlexDirectionAfterReturnUp
                            If .Row < GetLastMovableRow() Then
                                Call MoveNextRow(.Row)
                            Else
                                If PropWrapCellBehavior = FlexWrapGrid Then Call MoveFirstRow(.Row)
                            End If
                        Case FlexDirectionAfterReturnDown
                            If .Row > GetFirstMovableRow() Then
                                Call MovePreviousRow(.Row)
                            Else
                                If PropWrapCellBehavior = FlexWrapGrid Then Call MoveLastRow(.Row)
                            End If
                        Case FlexDirectionAfterReturnLeft
                            If PropWrapCellBehavior <> FlexWrapNone Then
                                If .Col < GetLastMovableCol() Then
                                    Call MoveNextCol(.Col)
                                Else
                                    If .Row < GetLastMovableRow() Then
                                        Call MoveFirstCol(.Col)
                                        Call MoveNextRow(.Row)
                                    Else
                                        If PropWrapCellBehavior = FlexWrapGrid Then
                                            Call MoveFirstCol(.Col)
                                            Call MoveFirstRow(.Row)
                                        End If
                                    End If
                                End If
                            Else
                                Call MoveNextCol(.Col)
                            End If
                        Case FlexDirectionAfterReturnRight
                            If PropWrapCellBehavior <> FlexWrapNone Then
                                If .Col > GetFirstMovableCol() Then
                                    Call MovePreviousCol(.Col)
                                Else
                                    If .Row > GetFirstMovableRow() Then
                                        Call MoveLastCol(.Col)
                                        Call MovePreviousRow(.Row)
                                    Else
                                        If PropWrapCellBehavior = FlexWrapGrid Then
                                            Call MoveLastCol(.Col)
                                            Call MoveLastRow(.Row)
                                        End If
                                    End If
                                End If
                            Else
                                Call MovePreviousCol(.Col)
                            End If
                    End Select
                    .RowSel = .Row
                    .ColSel = .Col
                    If .TopRow > .Row Then
                        If .Row >= (PropFixedRows + PropFrozenRows) Then .TopRow = .Row
                    ElseIf .Row > (.TopRow + GetRowsPerPage(.TopRow) - 1) Then
                        .TopRow = .Row - GetRowsPerPageRev(.Row) + 1
                    End If
                    If .LeftCol > .Col Then
                        If .Col >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .Col
                    ElseIf .Col > (.LeftCol + GetColsPerPage(.LeftCol) - 1) Then
                        .LeftCol = .Col - GetColsPerPageRev(.Col) + 1
                    End If
                ElseIf (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) <> 0 Then
                    ' Void
                Else
                    ' Void
                End If
        End Select
    Case FlexSelectionModeByRow
        Select Case KeyCode
            Case vbKeyUp
                If (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) = 0 Then
                    If ScrollLock = False Then
                        If PropWrapCellBehavior = FlexWrapGrid Then
                            If .Row > GetFirstMovableRow() Then
                                Call MovePreviousRow(.Row)
                            Else
                                Call MoveLastRow(.Row)
                            End If
                        Else
                            Call MovePreviousRow(.Row)
                        End If
                        .RowSel = .Row
                        .ColSel = (PropCols - 1)
                        If .TopRow > .Row Then
                            If .Row >= (PropFixedRows + PropFrozenRows) Then .TopRow = .Row
                        ElseIf .Row > (.TopRow + GetRowsPerPage(.TopRow) - 1) Then
                            .TopRow = .Row - GetRowsPerPageRev(.Row) + 1
                        End If
                    Else
                        Call MovePreviousRow(.TopRow)
                        If .TopRow < (PropFixedRows + PropFrozenRows) Then .TopRow = (PropFixedRows + PropFrozenRows)
                    End If
                ElseIf (Shift And vbShiftMask) <> 0 And (Shift And vbCtrlMask) = 0 Then
                    If ScrollLock = False Then
                        Call MovePreviousRow(.RowSel)
                        If .TopRow > .RowSel Then
                            If .RowSel >= (PropFixedRows + PropFrozenRows) Then .TopRow = .RowSel
                        End If
                    Else
                        ' Void
                    End If
                ElseIf (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) <> 0 Then
                    If ScrollLock = False Then
                        Call MoveFirstRow(.Row)
                        .RowSel = .Row
                        .ColSel = (PropCols - 1)
                        If .Row >= (PropFixedRows + PropFrozenRows) Then .TopRow = .Row
                    Else
                        .TopRow = .TopRow - GetRowsPerPageRev(.TopRow)
                        If .TopRow < (PropFixedRows + PropFrozenRows) Then .TopRow = (PropFixedRows + PropFrozenRows)
                    End If
                Else
                    Call MoveFirstRow(.RowSel)
                    If .RowSel >= (PropFixedRows + PropFrozenRows) Then .TopRow = .RowSel
                End If
            Case vbKeyDown
                If (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) = 0 Then
                    If ScrollLock = False Then
                        If PropWrapCellBehavior = FlexWrapGrid Then
                            If .Row < GetLastMovableRow() Then
                                Call MoveNextRow(.Row)
                            Else
                                Call MoveFirstRow(.Row)
                            End If
                        Else
                            Call MoveNextRow(.Row)
                        End If
                        .RowSel = .Row
                        .ColSel = (PropCols - 1)
                        If .TopRow > .Row Then
                            If .Row >= (PropFixedRows + PropFrozenRows) Then .TopRow = .Row
                        ElseIf .Row > (.TopRow + GetRowsPerPage(.TopRow) - 1) Then
                            .TopRow = .Row - GetRowsPerPageRev(.Row) + 1
                        End If
                    Else
                        If .TopRow < (PropRows - 1) - GetRowsPerPageRev(PropRows - 1) + 1 Then Call MoveNextRow(.TopRow)
                    End If
                ElseIf (Shift And vbShiftMask) <> 0 And (Shift And vbCtrlMask) = 0 Then
                    If ScrollLock = False Then
                        Call MoveNextRow(.RowSel)
                        If .TopRow > .RowSel Then
                            If .RowSel >= (PropFixedRows + PropFrozenRows) Then .TopRow = .RowSel
                        ElseIf .RowSel > (.TopRow + GetRowsPerPage(.TopRow) - 1) Then
                            .TopRow = .RowSel - GetRowsPerPageRev(.RowSel) + 1
                        End If
                    Else
                        ' Void
                    End If
                ElseIf (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) <> 0 Then
                    If ScrollLock = False Then
                        Call MoveLastRow(.Row)
                        .RowSel = .Row
                        .ColSel = (PropCols - 1)
                        .TopRow = (PropRows - 1) - GetRowsPerPageRev(PropRows - 1) + 1
                    Else
                        .TopRow = .TopRow + GetRowsPerPage(.TopRow)
                        RowsPerPage = GetRowsPerPageRev(PropRows - 1)
                        If .TopRow > (PropRows - 1) - RowsPerPage + 1 Then .TopRow = (PropRows - 1) - RowsPerPage + 1
                    End If
                Else
                    Call MoveLastRow(.RowSel)
                    .TopRow = (PropRows - 1) - GetRowsPerPageRev(PropRows - 1) + 1
                End If
            Case vbKeyLeft
                If (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) = 0 Then
                    If ScrollLock = False Then
                        .RowSel = .Row
                        .ColSel = (PropCols - 1)
                        If .TopRow > .Row Then
                            If .Row >= (PropFixedRows + PropFrozenRows) Then .TopRow = .Row
                        ElseIf .Row > (.TopRow + GetRowsPerPage(.TopRow) - 1) Then
                            .TopRow = .Row - GetRowsPerPageRev(.Row) + 1
                        End If
                        Call MovePreviousCol(.LeftCol)
                        If .LeftCol < (PropFixedCols + PropFrozenCols) Then .LeftCol = (PropFixedCols + PropFrozenCols)
                    Else
                        Call MovePreviousCol(.LeftCol)
                        If .LeftCol < (PropFixedCols + PropFrozenCols) Then .LeftCol = (PropFixedCols + PropFrozenCols)
                    End If
                ElseIf (Shift And vbShiftMask) <> 0 And (Shift And vbCtrlMask) = 0 Then
                    If ScrollLock = False Then
                        Call MovePreviousCol(.LeftCol)
                        If .LeftCol < (PropFixedCols + PropFrozenCols) Then .LeftCol = (PropFixedCols + PropFrozenCols)
                    Else
                        ' Void
                    End If
                ElseIf (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) <> 0 Then
                    If ScrollLock = False Then
                        .RowSel = .Row
                        .ColSel = (PropCols - 1)
                        If .TopRow > .Row Then
                            If .Row >= (PropFixedRows + PropFrozenRows) Then .TopRow = .Row
                        ElseIf .Row > (.TopRow + GetRowsPerPage(.TopRow) - 1) Then
                            .TopRow = .Row - GetRowsPerPageRev(.Row) + 1
                        End If
                        Call MoveFirstCol(.LeftCol)
                        If .LeftCol < (PropFixedCols + PropFrozenCols) Then .LeftCol = (PropFixedCols + PropFrozenCols)
                    Else
                        .LeftCol = .LeftCol - GetColsPerPageRev(.LeftCol)
                        If .LeftCol < (PropFixedCols + PropFrozenCols) Then .LeftCol = (PropFixedCols + PropFrozenCols)
                    End If
                Else
                    Call MoveFirstCol(.LeftCol)
                    If .LeftCol < (PropFixedCols + PropFrozenCols) Then .LeftCol = (PropFixedCols + PropFrozenCols)
                End If
            Case vbKeyRight
                If (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) = 0 Then
                    If ScrollLock = False Then
                        .RowSel = .Row
                        .ColSel = (PropCols - 1)
                        If .TopRow > .Row Then
                            If .Row >= (PropFixedRows + PropFrozenRows) Then .TopRow = .Row
                        ElseIf .Row > (.TopRow + GetRowsPerPage(.TopRow) - 1) Then
                            .TopRow = .Row - GetRowsPerPageRev(.Row) + 1
                        End If
                        If .LeftCol < (PropCols - 1) - GetColsPerPageRev(PropCols - 1) + 1 Then Call MoveNextCol(.LeftCol)
                    Else
                        If .LeftCol < (PropCols - 1) - GetColsPerPageRev(PropCols - 1) + 1 Then Call MoveNextCol(.LeftCol)
                    End If
                ElseIf (Shift And vbShiftMask) <> 0 And (Shift And vbCtrlMask) = 0 Then
                    If ScrollLock = False Then
                        If .LeftCol < (PropCols - 1) - GetColsPerPageRev(PropCols - 1) + 1 Then Call MoveNextCol(.LeftCol)
                    Else
                        ' Void
                    End If
                ElseIf (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) <> 0 Then
                    If ScrollLock = False Then
                        .RowSel = .Row
                        .ColSel = (PropCols - 1)
                        If .TopRow > .Row Then
                            If .Row >= (PropFixedRows + PropFrozenRows) Then .TopRow = .Row
                        ElseIf .Row > (.TopRow + GetRowsPerPage(.TopRow) - 1) Then
                            .TopRow = .Row - GetRowsPerPageRev(.Row) + 1
                        End If
                        .LeftCol = (PropCols - 1) - GetColsPerPageRev(PropCols - 1) + 1
                    Else
                        .LeftCol = .LeftCol + GetColsPerPage(.LeftCol)
                        ColsPerPage = GetColsPerPageRev(PropCols - 1)
                        If .LeftCol > (PropCols - 1) - ColsPerPage + 1 Then .LeftCol = (PropCols - 1) - ColsPerPage + 1
                    End If
                Else
                    .LeftCol = (PropCols - 1) - GetColsPerPageRev(PropCols - 1) + 1
                End If
            Case vbKeyPageUp
                If (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) = 0 Then
                    If .Row >= PropFixedRows And .Row < (PropFixedRows + PropFrozenRows) Then
                        RowsPerPage = PropFrozenRows - .Row + 1
                        If (.Row + RowsPerPage) < (PropRows - 1) Then
                            .Row = .Row + RowsPerPage
                        Else
                            .Row = (PropRows - 1)
                        End If
                        If GetRowHeight(.Row) = 0 Then Call MovePreviousRow(.Row)
                    ElseIf .Row > PropFixedRows Then
                        RowsPerPage = GetRowsPerPageRev(.Row)
                        If (.Row - RowsPerPage) > (PropFixedRows + PropFrozenRows) Then
                            .Row = .Row - RowsPerPage
                        Else
                            .Row = PropFixedRows + PropFrozenRows
                        End If
                        If GetRowHeight(.Row) = 0 Then Call MoveNextRow(.Row)
                    End If
                    .RowSel = .Row
                    .ColSel = (PropCols - 1)
                    If .TopRow > .Row Then
                        If .Row >= (PropFixedRows + PropFrozenRows) Then .TopRow = .Row
                    Else
                        .TopRow = .Row - GetRowsPerPageRev(.Row) + 1
                    End If
                ElseIf (Shift And vbShiftMask) <> 0 And (Shift And vbCtrlMask) = 0 Then
                    If .RowSel >= PropFixedRows And .RowSel < (PropFixedRows + PropFrozenRows) Then
                        RowsPerPage = PropFrozenRows - .RowSel + 1
                        If (.RowSel + RowsPerPage) < (PropRows - 1) Then
                            .RowSel = .RowSel + RowsPerPage
                        Else
                            .RowSel = (PropRows - 1)
                        End If
                        If GetRowHeight(.Row) = 0 Then Call MovePreviousRow(.Row)
                    ElseIf .RowSel > PropFixedRows Then
                        RowsPerPage = GetRowsPerPageRev(.RowSel)
                        If (.RowSel - RowsPerPage) > (PropFixedRows + PropFrozenRows) Then
                            .RowSel = .RowSel - RowsPerPage
                        Else
                            .RowSel = PropFixedRows + PropFrozenRows
                        End If
                        If GetRowHeight(.RowSel) = 0 Then Call MoveNextRow(.RowSel)
                    End If
                    If .TopRow > .RowSel Then
                        If .RowSel >= (PropFixedRows + PropFrozenRows) Then .TopRow = .RowSel
                    Else
                        .TopRow = .RowSel - GetRowsPerPageRev(.RowSel) + 1
                    End If
                ElseIf (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) <> 0 Then
                    Call MoveFirstRow(.Row)
                    .RowSel = .Row
                    .ColSel = (PropCols - 1)
                    If .Row >= (PropFixedRows + PropFrozenRows) Then .TopRow = .Row
                Else
                    Call MoveFirstRow(.RowSel)
                    If .RowSel >= (PropFixedRows + PropFrozenRows) Then .TopRow = .RowSel
                End If
            Case vbKeyPageDown
                If (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) = 0 Then
                    If .Row < (PropRows - 1) Then
                        If .Row >= PropFixedRows And .Row < (PropFixedRows + PropFrozenRows) Then
                            RowsPerPage = PropFrozenRows - .Row + 1
                        Else
                            RowsPerPage = GetRowsPerPage(.Row)
                        End If
                        If (.Row + RowsPerPage) < (PropRows - 1) Then
                            .Row = .Row + RowsPerPage
                        Else
                            .Row = (PropRows - 1)
                        End If
                        If GetRowHeight(.Row) = 0 Then Call MovePreviousRow(.Row)
                    End If
                    .RowSel = .Row
                    .ColSel = (PropCols - 1)
                    If .TopRow > .Row Then
                        If .Row >= (PropFixedRows + PropFrozenRows) Then .TopRow = .Row
                    Else
                        .TopRow = .Row - GetRowsPerPageRev(.Row) + 1
                    End If
                ElseIf (Shift And vbShiftMask) <> 0 And (Shift And vbCtrlMask) = 0 Then
                    If .RowSel < (PropRows - 1) Then
                        If .RowSel >= PropFixedRows And .RowSel < (PropFixedRows + PropFrozenRows) Then
                            RowsPerPage = PropFrozenRows - .RowSel + 1
                        Else
                            RowsPerPage = GetRowsPerPage(.RowSel)
                        End If
                        If (.RowSel + RowsPerPage) < (PropRows - 1) Then
                            .RowSel = .RowSel + RowsPerPage
                        Else
                            .RowSel = (PropRows - 1)
                        End If
                        If GetRowHeight(.RowSel) = 0 Then Call MovePreviousRow(.RowSel)
                    End If
                    If .TopRow > .RowSel Then
                        If .RowSel >= (PropFixedRows + PropFrozenRows) Then .TopRow = .RowSel
                    Else
                        .TopRow = .RowSel - GetRowsPerPageRev(.RowSel) + 1
                    End If
                ElseIf (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) <> 0 Then
                    Call MoveLastRow(.Row)
                    .RowSel = .Row
                    .ColSel = (PropCols - 1)
                    .TopRow = (PropRows - 1) - GetRowsPerPageRev(PropRows - 1) + 1
                Else
                    Call MoveLastRow(.RowSel)
                    .TopRow = (PropRows - 1) - GetRowsPerPageRev(PropRows - 1) + 1
                End If
            Case vbKeyHome
                If (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) = 0 Then
                    .RowSel = .Row
                    .ColSel = (PropCols - 1)
                    If .TopRow > .Row Then
                        If .Row >= (PropFixedRows + PropFrozenRows) Then .TopRow = .Row
                    ElseIf .Row > (.TopRow + GetRowsPerPage(.TopRow) - 1) Then
                        .TopRow = .Row - GetRowsPerPageRev(.Row) + 1
                    End If
                ElseIf (Shift And vbShiftMask) <> 0 And (Shift And vbCtrlMask) = 0 Then
                    ' Void
                ElseIf (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) <> 0 Then
                    Call MoveFirstRow(.Row)
                    .Col = PropFixedCols
                    .RowSel = .Row
                    .ColSel = (PropCols - 1)
                    .TopRow = .Row
                Else
                    Call MoveFirstRow(.RowSel)
                    .ColSel = (PropCols - 1)
                    .TopRow = .RowSel
                End If
            Case vbKeyEnd
                If (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) = 0 Then
                    .RowSel = .Row
                    .ColSel = (PropCols - 1)
                    If .TopRow > .Row Then
                        If .Row >= (PropFixedRows + PropFrozenRows) Then .TopRow = .Row
                    ElseIf .Row > (.TopRow + GetRowsPerPage(.TopRow) - 1) Then
                        .TopRow = .Row - GetRowsPerPageRev(.Row) + 1
                    End If
                ElseIf (Shift And vbShiftMask) <> 0 And (Shift And vbCtrlMask) = 0 Then
                    ' Void
                ElseIf (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) <> 0 Then
                    Call MoveLastRow(.Row)
                    .Col = PropFixedCols
                    .RowSel = .Row
                    .ColSel = (PropCols - 1)
                    .TopRow = (PropRows - 1) - GetRowsPerPageRev(PropRows - 1) + 1
                Else
                    Call MoveLastRow(.RowSel)
                    .ColSel = (PropCols - 1)
                    .TopRow = (PropRows - 1) - GetRowsPerPageRev(PropRows - 1) + 1
                End If
            Case vbKeyTab
                If (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) = 0 Then
                    If PropWrapCellBehavior <> FlexWrapNone Then
                        If .Row < GetLastMovableRow() Then
                            Call MoveNextRow(.Row)
                        Else
                            If PropWrapCellBehavior = FlexWrapGrid Then Call MoveFirstRow(.Row)
                        End If
                    End If
                    .RowSel = .Row
                    .ColSel = (PropCols - 1)
                    If .TopRow > .Row Then
                        If .Row >= (PropFixedRows + PropFrozenRows) Then .TopRow = .Row
                    ElseIf .Row > (.TopRow + GetRowsPerPage(.TopRow) - 1) Then
                        .TopRow = .Row - GetRowsPerPageRev(.Row) + 1
                    End If
                ElseIf (Shift And vbShiftMask) <> 0 And (Shift And vbCtrlMask) = 0 Then
                    If PropWrapCellBehavior <> FlexWrapNone Then
                        If .Row > GetFirstMovableRow() Then
                            Call MovePreviousRow(.Row)
                        Else
                            If PropWrapCellBehavior = FlexWrapGrid Then Call MoveLastRow(.Row)
                        End If
                    End If
                    .RowSel = .Row
                    .ColSel = (PropCols - 1)
                    If .TopRow > .Row Then
                        If .Row >= (PropFixedRows + PropFrozenRows) Then .TopRow = .Row
                    ElseIf .Row > (.TopRow + GetRowsPerPage(.TopRow) - 1) Then
                        .TopRow = .Row - GetRowsPerPageRev(.Row) + 1
                    End If
                ElseIf (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) <> 0 Then
                    ' Void
                Else
                    ' Void
                End If
            Case vbKeyReturn
                If (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) = 0 Then
                    Select Case PropDirectionAfterReturn
                        Case FlexDirectionAfterReturnUp
                            If .Row > GetFirstMovableRow() Then
                                Call MovePreviousRow(.Row)
                            Else
                                If PropWrapCellBehavior = FlexWrapGrid Then Call MoveLastRow(.Row)
                            End If
                        Case FlexDirectionAfterReturnDown
                            If .Row < GetLastMovableRow() Then
                                Call MoveNextRow(.Row)
                            Else
                                If PropWrapCellBehavior = FlexWrapGrid Then Call MoveFirstRow(.Row)
                            End If
                        Case FlexDirectionAfterReturnLeft
                            If PropWrapCellBehavior <> FlexWrapNone Then
                                If .Row > GetFirstMovableRow() Then
                                    Call MovePreviousRow(.Row)
                                Else
                                    If PropWrapCellBehavior = FlexWrapGrid Then Call MoveLastRow(.Row)
                                End If
                            End If
                        Case FlexDirectionAfterReturnRight
                            If PropWrapCellBehavior <> FlexWrapNone Then
                                If .Row < GetLastMovableRow() Then
                                    Call MoveNextRow(.Row)
                                Else
                                    If PropWrapCellBehavior = FlexWrapGrid Then Call MoveFirstRow(.Row)
                                End If
                            End If
                    End Select
                    .RowSel = .Row
                    .ColSel = (PropCols - 1)
                    If .TopRow > .Row Then
                        If .Row >= (PropFixedRows + PropFrozenRows) Then .TopRow = .Row
                    ElseIf .Row > (.TopRow + GetRowsPerPage(.TopRow) - 1) Then
                        .TopRow = .Row - GetRowsPerPageRev(.Row) + 1
                    End If
                ElseIf (Shift And vbShiftMask) <> 0 And (Shift And vbCtrlMask) = 0 Then
                    Select Case PropDirectionAfterReturn
                        Case FlexDirectionAfterReturnUp
                            If .Row < GetLastMovableRow() Then
                                Call MoveNextRow(.Row)
                            Else
                                If PropWrapCellBehavior = FlexWrapGrid Then Call MoveFirstRow(.Row)
                            End If
                        Case FlexDirectionAfterReturnDown
                            If .Row > GetFirstMovableRow() Then
                                Call MovePreviousRow(.Row)
                            Else
                                If PropWrapCellBehavior = FlexWrapGrid Then Call MoveLastRow(.Row)
                            End If
                        Case FlexDirectionAfterReturnLeft
                            If PropWrapCellBehavior <> FlexWrapNone Then
                                If .Row < GetLastMovableRow() Then
                                    Call MoveNextRow(.Row)
                                Else
                                    If PropWrapCellBehavior = FlexWrapGrid Then Call MoveFirstRow(.Row)
                                End If
                            End If
                        Case FlexDirectionAfterReturnRight
                            If PropWrapCellBehavior <> FlexWrapNone Then
                                If .Row > GetFirstMovableRow() Then
                                    Call MovePreviousRow(.Row)
                                Else
                                    If PropWrapCellBehavior = FlexWrapGrid Then Call MoveLastRow(.Row)
                                End If
                            End If
                    End Select
                    .RowSel = .Row
                    .ColSel = (PropCols - 1)
                    If .TopRow > .Row Then
                        If .Row >= (PropFixedRows + PropFrozenRows) Then .TopRow = .Row
                    ElseIf .Row > (.TopRow + GetRowsPerPage(.TopRow) - 1) Then
                        .TopRow = .Row - GetRowsPerPageRev(.Row) + 1
                    End If
                ElseIf (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) <> 0 Then
                    ' Void
                Else
                    ' Void
                End If
        End Select
    Case FlexSelectionModeByColumn
        Select Case KeyCode
            Case vbKeyUp
                If (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) = 0 Then
                    If ScrollLock = False Then
                        .RowSel = (PropRows - 1)
                        .ColSel = .Col
                        Call MovePreviousRow(.TopRow)
                        If .TopRow < (PropFixedRows + PropFrozenRows) Then .TopRow = (PropFixedRows + PropFrozenRows)
                        If .LeftCol > .Col Then
                            If .Col >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .Col
                        ElseIf .Col > (.LeftCol + GetColsPerPage(.LeftCol) - 1) Then
                            .LeftCol = .Col - GetColsPerPageRev(.Col) + 1
                        End If
                    Else
                        Call MovePreviousRow(.TopRow)
                        If .TopRow < (PropFixedRows + PropFrozenRows) Then .TopRow = (PropFixedRows + PropFrozenRows)
                    End If
                ElseIf (Shift And vbShiftMask) <> 0 And (Shift And vbCtrlMask) = 0 Then
                    If ScrollLock = False Then
                        Call MovePreviousRow(.TopRow)
                        If .TopRow < (PropFixedRows + PropFrozenRows) Then .TopRow = (PropFixedRows + PropFrozenRows)
                    Else
                        ' Void
                    End If
                ElseIf (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) <> 0 Then
                    If ScrollLock = False Then
                        .RowSel = (PropRows - 1)
                        .ColSel = .Col
                        Call MoveFirstRow(.TopRow)
                        If .TopRow < (PropFixedRows + PropFrozenRows) Then .TopRow = (PropFixedRows + PropFrozenRows)
                        If .LeftCol > .Col Then
                            If .Col >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .Col
                        ElseIf .Col > (.LeftCol + GetColsPerPage(.LeftCol) - 1) Then
                            .LeftCol = .Col - GetColsPerPageRev(.Col) + 1
                        End If
                    Else
                        .TopRow = .TopRow - GetRowsPerPageRev(.TopRow)
                        If .TopRow < (PropFixedRows + PropFrozenRows) Then .TopRow = (PropFixedRows + PropFrozenRows)
                    End If
                Else
                    Call MoveFirstRow(.TopRow)
                    If .TopRow < (PropFixedRows + PropFrozenRows) Then .TopRow = (PropFixedRows + PropFrozenRows)
                End If
            Case vbKeyDown
                If (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) = 0 Then
                    If ScrollLock = False Then
                        .RowSel = (PropRows - 1)
                        .ColSel = .Col
                        If .TopRow < (PropRows - 1) - GetRowsPerPageRev(PropRows - 1) + 1 Then Call MoveNextRow(.TopRow)
                        If .LeftCol > .Col Then
                            If .Col >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .Col
                        ElseIf .Col > (.LeftCol + GetColsPerPage(.LeftCol) - 1) Then
                            .LeftCol = .Col - GetColsPerPageRev(.Col) + 1
                        End If
                    Else
                        If .TopRow < (PropRows - 1) - GetRowsPerPageRev(PropRows - 1) + 1 Then Call MoveNextRow(.TopRow)
                    End If
                ElseIf (Shift And vbShiftMask) <> 0 And (Shift And vbCtrlMask) = 0 Then
                    If ScrollLock = False Then
                        If .TopRow < (PropRows - 1) - GetRowsPerPageRev(PropRows - 1) + 1 Then Call MoveNextRow(.TopRow)
                    Else
                        ' Void
                    End If
                ElseIf (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) <> 0 Then
                    If ScrollLock = False Then
                        .RowSel = (PropRows - 1)
                        .ColSel = .Col
                        .TopRow = (PropRows - 1) - GetRowsPerPageRev(PropRows - 1) + 1
                        If .LeftCol > .Col Then
                            If .Col >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .Col
                        ElseIf .Col > (.LeftCol + GetColsPerPage(.LeftCol) - 1) Then
                            .LeftCol = .Col - GetColsPerPageRev(.Col) + 1
                        End If
                    Else
                        .TopRow = .TopRow + GetRowsPerPage(.TopRow)
                        RowsPerPage = GetRowsPerPageRev(PropRows - 1)
                        If .TopRow > (PropRows - 1) - RowsPerPage + 1 Then .TopRow = (PropRows - 1) - RowsPerPage + 1
                    End If
                Else
                    .TopRow = (PropRows - 1) - GetRowsPerPageRev(PropRows - 1) + 1
                End If
            Case vbKeyLeft
                If (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) = 0 Then
                    If ScrollLock = False Then
                        If PropWrapCellBehavior = FlexWrapGrid Then
                            If .Col > GetFirstMovableCol() Then
                                Call MovePreviousCol(.Col)
                            Else
                                Call MoveLastCol(.Col)
                            End If
                        Else
                            Call MovePreviousCol(.Col)
                        End If
                        .RowSel = (PropRows - 1)
                        .ColSel = .Col
                        If .LeftCol > .Col Then
                            If .Col >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .Col
                        ElseIf .Col > (.LeftCol + GetColsPerPage(.LeftCol) - 1) Then
                            .LeftCol = .Col - GetColsPerPageRev(.Col) + 1
                        End If
                    Else
                        Call MovePreviousCol(.LeftCol)
                        If .LeftCol < (PropFixedCols + PropFrozenCols) Then .LeftCol = (PropFixedCols + PropFrozenCols)
                    End If
                ElseIf (Shift And vbShiftMask) <> 0 And (Shift And vbCtrlMask) = 0 Then
                    If ScrollLock = False Then
                        Call MovePreviousCol(.ColSel)
                        If .LeftCol > .ColSel Then
                            If .ColSel >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .ColSel
                        End If
                    Else
                        ' Void
                    End If
                ElseIf (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) <> 0 Then
                    If ScrollLock = False Then
                        Call MoveFirstCol(.Col)
                        .RowSel = (PropRows - 1)
                        .ColSel = .Col
                        If .Col >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .Col
                    Else
                        .LeftCol = .LeftCol - GetColsPerPageRev(.LeftCol)
                        If .LeftCol < (PropFixedCols + PropFrozenCols) Then .LeftCol = (PropFixedCols + PropFrozenCols)
                    End If
                Else
                    Call MoveFirstCol(.ColSel)
                    If .ColSel >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .ColSel
                End If
            Case vbKeyRight
                If (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) = 0 Then
                    If ScrollLock = False Then
                        If PropWrapCellBehavior = FlexWrapGrid Then
                            If .Col < GetLastMovableCol() Then
                                Call MoveNextCol(.Col)
                            Else
                                Call MoveFirstCol(.Col)
                            End If
                        Else
                            Call MoveNextCol(.Col)
                        End If
                        .RowSel = (PropRows - 1)
                        .ColSel = .Col
                        If .LeftCol > .Col Then
                            If .Col >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .Col
                        ElseIf .Col > (.LeftCol + GetColsPerPage(.LeftCol) - 1) Then
                            .LeftCol = .Col - GetColsPerPageRev(.Col) + 1
                        End If
                    Else
                        If .LeftCol < (PropCols - 1) - GetColsPerPageRev(PropCols - 1) + 1 Then Call MoveNextCol(.LeftCol)
                    End If
                ElseIf (Shift And vbShiftMask) <> 0 And (Shift And vbCtrlMask) = 0 Then
                    If ScrollLock = False Then
                        Call MoveNextCol(.ColSel)
                        If .LeftCol > .ColSel Then
                            If .ColSel >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .ColSel
                        ElseIf .ColSel > (.LeftCol + GetColsPerPage(.LeftCol) - 1) Then
                            .LeftCol = .ColSel - GetColsPerPageRev(.ColSel) + 1
                        End If
                    Else
                        ' Void
                    End If
                ElseIf (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) <> 0 Then
                    If ScrollLock = False Then
                        Call MoveLastCol(.Col)
                        .RowSel = (PropRows - 1)
                        .ColSel = .Col
                        .LeftCol = (PropCols - 1) - GetColsPerPageRev(PropCols - 1) + 1
                    Else
                        .LeftCol = .LeftCol + GetColsPerPage(.LeftCol)
                        ColsPerPage = GetColsPerPageRev(PropCols - 1)
                        If .LeftCol > (PropCols - 1) - ColsPerPage + 1 Then .LeftCol = (PropCols - 1) - ColsPerPage + 1
                    End If
                Else
                    Call MoveLastCol(.ColSel)
                    .LeftCol = (PropCols - 1) - GetColsPerPageRev(PropCols - 1) + 1
                End If
            Case vbKeyPageUp
                If (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) = 0 Then
                    .RowSel = (PropRows - 1)
                    .ColSel = .Col
                    If .LeftCol > .Col Then
                        If .Col >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .Col
                    ElseIf .ColSel > (.LeftCol + GetColsPerPage(.LeftCol) - 1) Then
                        .LeftCol = .ColSel - GetColsPerPageRev(.ColSel) + 1
                    End If
                ElseIf (Shift And vbShiftMask) <> 0 And (Shift And vbCtrlMask) = 0 Then
                    ' Void
                ElseIf (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) <> 0 Then
                    .RowSel = (PropRows - 1)
                    .ColSel = .Col
                    If .LeftCol > .Col Then
                        If .Col >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .Col
                    ElseIf .Col > (.LeftCol + GetColsPerPage(.LeftCol) - 1) Then
                        .LeftCol = .Col - GetColsPerPageRev(.Col) + 1
                    End If
                Else
                    ' Void
                End If
            Case vbKeyPageDown
                If (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) = 0 Then
                    .RowSel = (PropRows - 1)
                    .ColSel = .Col
                    If .LeftCol > .Col Then
                        If .Col >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .Col
                    ElseIf .ColSel > (.LeftCol + GetColsPerPage(.LeftCol) - 1) Then
                        .LeftCol = .ColSel - GetColsPerPageRev(.ColSel) + 1
                    End If
                ElseIf (Shift And vbShiftMask) <> 0 And (Shift And vbCtrlMask) = 0 Then
                    ' Void
                ElseIf (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) <> 0 Then
                    .RowSel = (PropRows - 1)
                    .ColSel = .Col
                    If .LeftCol > .Col Then
                        If .Col >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .Col
                    ElseIf .Col > (.LeftCol + GetColsPerPage(.LeftCol) - 1) Then
                        .LeftCol = .Col - GetColsPerPageRev(.Col) + 1
                    End If
                Else
                    ' Void
                End If
            Case vbKeyHome
                If (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) = 0 Then
                    Call MoveFirstCol(.Col)
                    .RowSel = (PropRows - 1)
                    .ColSel = .Col
                    If .Col >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .Col
                ElseIf (Shift And vbShiftMask) <> 0 And (Shift And vbCtrlMask) = 0 Then
                    Call MoveFirstCol(.ColSel)
                    If .ColSel >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .ColSel
                ElseIf (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) <> 0 Then
                    .Row = PropFixedRows
                    Call MoveFirstCol(.Col)
                    .RowSel = (PropRows - 1)
                    .ColSel = .Col
                    If .Col >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .Col
                Else
                    .RowSel = (PropRows - 1)
                    Call MoveFirstCol(.ColSel)
                    If .ColSel >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .ColSel
                End If
            Case vbKeyEnd
                If (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) = 0 Then
                    Call MoveLastCol(.Col)
                    .RowSel = (PropRows - 1)
                    .ColSel = .Col
                    .LeftCol = (PropCols - 1) - GetColsPerPageRev(PropCols - 1) + 1
                ElseIf (Shift And vbShiftMask) <> 0 And (Shift And vbCtrlMask) = 0 Then
                    Call MoveLastCol(.ColSel)
                    .LeftCol = (PropCols - 1) - GetColsPerPageRev(PropCols - 1) + 1
                ElseIf (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) <> 0 Then
                    .Row = PropFixedRows
                    Call MoveLastCol(.Col)
                    .RowSel = (PropRows - 1)
                    .ColSel = .Col
                    .LeftCol = (PropCols - 1) - GetColsPerPageRev(PropCols - 1) + 1
                Else
                    .RowSel = (PropRows - 1)
                    Call MoveLastCol(.ColSel)
                    .LeftCol = (PropCols - 1) - GetColsPerPageRev(PropCols - 1) + 1
                End If
            Case vbKeyTab
                If (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) = 0 Then
                    If PropWrapCellBehavior <> FlexWrapNone Then
                        If .Col < GetLastMovableCol() Then
                            Call MoveNextCol(.Col)
                        Else
                            If PropWrapCellBehavior = FlexWrapGrid Then Call MoveFirstCol(.Col)
                        End If
                    End If
                    .RowSel = (PropRows - 1)
                    .ColSel = .Col
                    If .LeftCol > .Col Then
                        If .Col >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .Col
                    ElseIf .Col > (.LeftCol + GetColsPerPage(.LeftCol) - 1) Then
                        .LeftCol = .Col - GetColsPerPageRev(.Col) + 1
                    End If
                ElseIf (Shift And vbShiftMask) <> 0 And (Shift And vbCtrlMask) = 0 Then
                    If PropWrapCellBehavior <> FlexWrapNone Then
                        If .Col > GetFirstMovableCol() Then
                            Call MovePreviousCol(.Col)
                        Else
                            If PropWrapCellBehavior = FlexWrapGrid Then Call MoveLastCol(.Col)
                        End If
                    End If
                    .RowSel = (PropRows - 1)
                    .ColSel = .Col
                    If .LeftCol > .Col Then
                        If .Col >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .Col
                    ElseIf .Col > (.LeftCol + GetColsPerPage(.LeftCol) - 1) Then
                        .LeftCol = .Col - GetColsPerPageRev(.Col) + 1
                    End If
                ElseIf (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) <> 0 Then
                    ' Void
                Else
                    ' Void
                End If
            Case vbKeyReturn
                If (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) = 0 Then
                    Select Case PropDirectionAfterReturn
                        Case FlexDirectionAfterReturnUp
                            If PropWrapCellBehavior <> FlexWrapNone Then
                                If .Col > GetFirstMovableCol() Then
                                    Call MovePreviousCol(.Col)
                                Else
                                    If PropWrapCellBehavior = FlexWrapGrid Then Call MoveLastCol(.Col)
                                End If
                            End If
                        Case FlexDirectionAfterReturnDown
                            If PropWrapCellBehavior <> FlexWrapNone Then
                                If .Col < GetLastMovableCol() Then
                                    Call MoveNextCol(.Col)
                                Else
                                    If PropWrapCellBehavior = FlexWrapGrid Then Call MoveFirstCol(.Col)
                                End If
                            End If
                        Case FlexDirectionAfterReturnLeft
                            If .Col > GetFirstMovableCol() Then
                                Call MovePreviousCol(.Col)
                            Else
                                If PropWrapCellBehavior = FlexWrapGrid Then Call MoveLastCol(.Col)
                            End If
                        Case FlexDirectionAfterReturnRight
                            If .Col < GetLastMovableCol() Then
                                Call MoveNextRow(.Col)
                            Else
                                If PropWrapCellBehavior = FlexWrapGrid Then Call MoveFirstRow(.Col)
                            End If
                    End Select
                    .RowSel = (PropRows - 1)
                    .ColSel = .Col
                    If .LeftCol > .Col Then
                        If .Col >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .Col
                    ElseIf .Col > (.LeftCol + GetColsPerPage(.LeftCol) - 1) Then
                        .LeftCol = .Col - GetColsPerPageRev(.Col) + 1
                    End If
                ElseIf (Shift And vbShiftMask) <> 0 And (Shift And vbCtrlMask) = 0 Then
                    Select Case PropDirectionAfterReturn
                        Case FlexDirectionAfterReturnUp
                            If PropWrapCellBehavior <> FlexWrapNone Then
                                If .Col < GetLastMovableCol() Then
                                    Call MoveNextCol(.Col)
                                Else
                                    If PropWrapCellBehavior = FlexWrapGrid Then Call MoveFirstCol(.Col)
                                End If
                            End If
                        Case FlexDirectionAfterReturnDown
                            If PropWrapCellBehavior <> FlexWrapNone Then
                                If .Col > GetFirstMovableCol() Then
                                    Call MovePreviousCol(.Col)
                                Else
                                    If PropWrapCellBehavior = FlexWrapGrid Then Call MoveLastCol(.Col)
                                End If
                            End If
                        Case FlexDirectionAfterReturnLeft
                            If .Col < GetLastMovableCol() Then
                                Call MoveNextRow(.Col)
                            Else
                                If PropWrapCellBehavior = FlexWrapGrid Then Call MoveFirstRow(.Col)
                            End If
                        Case FlexDirectionAfterReturnRight
                            If .Col > GetFirstMovableCol() Then
                                Call MovePreviousCol(.Col)
                            Else
                                If PropWrapCellBehavior = FlexWrapGrid Then Call MoveLastCol(.Col)
                            End If
                    End Select
                    .RowSel = (PropRows - 1)
                    .ColSel = .Col
                    If .LeftCol > .Col Then
                        If .Col >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .Col
                    ElseIf .Col > (.LeftCol + GetColsPerPage(.LeftCol) - 1) Then
                        .LeftCol = .Col - GetColsPerPageRev(.Col) + 1
                    End If
                ElseIf (Shift And vbShiftMask) = 0 And (Shift And vbCtrlMask) <> 0 Then
                    ' Void
                Else
                    ' Void
                End If
        End Select
End Select
Call SetRowColParams(RCP)
If VBFlexGridCaptureDividerDrag = False Then
    If VBFlexGridCaptureRow > (PropFixedRows - 1) Or VBFlexGridCaptureCol > (PropFixedCols - 1) Then
        Dim HTI As THITTESTINFO, Pos As Long
        Pos = GetMessagePos()
        HTI.PT.X = Get_X_lParam(Pos)
        HTI.PT.Y = Get_Y_lParam(Pos)
        ScreenToClient VBFlexGridHandle, HTI.PT
        Call GetHitTestInfo(HTI)
        .Mask = RCPM_ROWSEL Or RCPM_COLSEL
        .Flags = 0
        .Message = WM_MOUSEMOVE
        .RowSel = VBFlexGridRowSel
        .ColSel = VBFlexGridColSel
        Select Case PropSelectionMode
            Case FlexSelectionModeFree, FlexSelectionModeFreeByRow, FlexSelectionModeFreeByColumn
                If VBFlexGridCaptureRow > (PropFixedRows - 1) Or PropAllowBigSelection = False Then
                    If HTI.MouseRow > ((PropFixedRows + PropFrozenRows) - 1) And HTI.PT.Y >= 0 Then
                        .RowSel = HTI.MouseRow
                    Else
                        .RowSel = VBFlexGridTopRow
                    End If
                ElseIf PropSelectionMode <> FlexSelectionModeFreeByRow Then
                    .RowSel = (PropRows - 1)
                End If
                If VBFlexGridCaptureCol > (PropFixedCols - 1) Or PropAllowBigSelection = False Then
                    If HTI.MouseCol > ((PropFixedCols + PropFrozenCols) - 1) And HTI.PT.X >= 0 Then
                        .ColSel = HTI.MouseCol
                    Else
                        .ColSel = VBFlexGridLeftCol
                    End If
                ElseIf PropSelectionMode <> FlexSelectionModeFreeByColumn Then
                    .ColSel = (PropCols - 1)
                End If
            Case FlexSelectionModeByRow
                If VBFlexGridCaptureRow > (PropFixedRows - 1) Or VBFlexGridCaptureCol > (PropFixedCols - 1) Or PropAllowBigSelection = False Then
                    If HTI.MouseRow > ((PropFixedRows + PropFrozenRows) - 1) And HTI.PT.Y >= 0 Then
                        .RowSel = HTI.MouseRow
                    Else
                        .RowSel = VBFlexGridTopRow
                    End If
                End If
            Case FlexSelectionModeByColumn
                If VBFlexGridCaptureRow > (PropFixedRows - 1) Or VBFlexGridCaptureCol > (PropFixedCols - 1) Or PropAllowBigSelection = False Then
                    If HTI.MouseCol > ((PropFixedCols + PropFrozenCols) - 1) And HTI.PT.X >= 0 Then
                        .ColSel = HTI.MouseCol
                    Else
                        .ColSel = VBFlexGridLeftCol
                    End If
                End If
        End Select
        Call SetRowColParams(RCP)
    End If
End If
End With
End Sub

Private Function ProcessLButtonDown(ByVal Shift As Integer, ByRef HTI As THITTESTINFO) As Boolean
VBFlexGridCapturePoint.X = HTI.PT.X
VBFlexGridCapturePoint.Y = HTI.PT.Y
VBFlexGridCaptureRow = HTI.HitRow
VBFlexGridCaptureCol = HTI.HitCol
VBFlexGridCaptureDividerRow = HTI.HitRowDivider
VBFlexGridCaptureDividerCol = HTI.HitColDivider
VBFlexGridCaptureHitResult = HTI.HitResult
VBFlexGridMouseMoveRow = HTI.HitRow
VBFlexGridMouseMoveCol = HTI.HitCol
VBFlexGridMouseMoveChanged = False
Select Case HTI.HitResult
    Case FlexHitResultNoWhere, FlexHitResultComboCue, FlexHitResultComboCueDisabled
        Exit Function
    Case FlexHitResultCheckBox, FlexHitResultCheckBoxDisabled
        If HTI.HitRow <= (PropFixedRows - 1) Or HTI.HitCol <= (PropFixedCols - 1) Then Exit Function
    Case FlexHitResultDividerRowTop, FlexHitResultDividerRowBottom, FlexHitResultDividerColumnLeft, FlexHitResultDividerColumnRight, FlexHitResultDividerFrozenRowTop, FlexHitResultDividerFrozenRowBottom, FlexHitResultDividerFrozenColumnLeft, FlexHitResultDividerFrozenColumnRight
        VBFlexGridCaptureDividerDrag = True
        VBFlexGridCaptureDividerMoved = False
        Dim iRow As Long, iCol As Long, Cancel As Boolean
        iRow = VBFlexGridCaptureDividerRow
        iCol = VBFlexGridCaptureDividerCol
        Select Case VBFlexGridCaptureHitResult
            Case FlexHitResultDividerRowTop, FlexHitResultDividerRowBottom, FlexHitResultDividerColumnLeft, FlexHitResultDividerColumnRight
                RaiseEvent BeforeUserResize(iRow, iCol, Cancel)
        End Select
        If Cancel = False Then
            Dim ClipRect As RECT, i As Long, P As POINTAPI
            LSet ClipRect = VBFlexGridClientRect
            Select Case VBFlexGridCaptureHitResult
                Case FlexHitResultDividerRowTop, FlexHitResultDividerRowBottom, FlexHitResultDividerColumnLeft, FlexHitResultDividerColumnRight
                    With ClipRect
                    If iRow > -1 Then
                        For i = 0 To iRow - 1
                            If i >= VBFlexGridTopRow Or i < (PropFixedRows + PropFrozenRows) Then
                                .Top = .Top + GetRowHeight(i)
                            End If
                        Next i
                        P.Y = .Top + GetRowHeight(iRow)
                        .Top = .Top + (HTI.PT.Y - P.Y) + 1
                        .Bottom = .Bottom + (HTI.PT.Y - P.Y) - 1
                    End If
                    If iCol > -1 Then
                        For i = 0 To iCol - 1
                            If i >= VBFlexGridLeftCol Or i < (PropFixedCols + PropFrozenCols) Then
                                .Left = .Left + GetColWidth(i)
                            End If
                        Next i
                        P.X = .Left + GetColWidth(iCol)
                        .Left = .Left + (HTI.PT.X - P.X) + 1
                        .Right = .Right + (HTI.PT.X - P.X) - 1
                    End If
                    End With
                Case FlexHitResultDividerFrozenRowTop, FlexHitResultDividerFrozenRowBottom, FlexHitResultDividerFrozenColumnLeft, FlexHitResultDividerFrozenColumnRight
                    With ClipRect
                    For i = 0 To PropFixedRows - 1
                        .Top = .Top + GetRowHeight(i)
                    Next i
                    For i = 0 To PropFixedCols - 1
                        .Left = .Left + GetColWidth(i)
                    Next i
                    If iRow > -1 Then
                        P.Y = .Top
                        For i = PropFixedRows To iRow
                            P.Y = P.Y + GetRowHeight(i)
                        Next i
                    End If
                    If iCol > -1 Then
                        P.X = .Left
                        For i = PropFixedCols To iCol
                            P.X = P.X + GetColWidth(i)
                        Next i
                    End If
                    End With
            End Select
            MapWindowPoints VBFlexGridHandle, HWND_DESKTOP, ClipRect, 2
            Select Case VBFlexGridCaptureHitResult
                Case FlexHitResultDividerRowTop, FlexHitResultDividerRowBottom, FlexHitResultDividerColumnLeft, FlexHitResultDividerColumnRight
                    If iRow > -1 Then ClipRect.Bottom = GetSystemMetrics(SM_YVIRTUALSCREEN) + GetSystemMetrics(SM_CYVIRTUALSCREEN)
                    If iCol > -1 Then ClipRect.Right = GetSystemMetrics(SM_XVIRTUALSCREEN) + GetSystemMetrics(SM_CXVIRTUALSCREEN)
                Case FlexHitResultDividerFrozenRowTop, FlexHitResultDividerFrozenRowBottom, FlexHitResultDividerFrozenColumnLeft, FlexHitResultDividerFrozenColumnRight
                    If iRow > -1 Then ClipRect.Top = GetSystemMetrics(SM_YVIRTUALSCREEN)
                    If iCol > -1 Then ClipRect.Left = GetSystemMetrics(SM_XVIRTUALSCREEN)
            End Select
            ClipCursor ClipRect
            VBFlexGridDividerDragOffset.X = HTI.PT.X - P.X
            VBFlexGridDividerDragOffset.Y = HTI.PT.Y - P.Y
            VBFlexGridDividerDragDirty = True
            Call SetDividerDragSplitterRect(P.X, P.Y)
            Call DrawDividerDragSplitter
        Else
            ReleaseCapture
        End If
        ProcessLButtonDown = True
        Exit Function
End Select
Dim RCP As TROWCOLPARAMS
With RCP
.Mask = RCPM_ROW Or RCPM_COL Or RCPM_ROWSEL Or RCPM_COLSEL
If (Shift And vbCtrlMask) <> 0 Then
    .Flags = .Flags Or RCPF_CTRL
    If (Shift And vbShiftMask) <> 0 Then .Flags = .Flags Or RCPF_SHIFT
End If
If PropAllowIncrementalSearch = True Then
    If Not VBFlexGridIncrementalSearch.SearchString = vbNullString Then
        Call CancelIncrementalSearch(True)
        .Flags = .Flags Or RCPF_FORCEREDRAW
    End If
End If
.Message = WM_LBUTTONDOWN
.Row = VBFlexGridRow
.Col = VBFlexGridCol
.RowSel = VBFlexGridRowSel
.ColSel = VBFlexGridColSel
Select Case PropSelectionMode
    Case FlexSelectionModeFree, FlexSelectionModeFreeByRow, FlexSelectionModeFreeByColumn
        If HTI.HitRow > (PropFixedRows - 1) Then
            If (Shift And vbShiftMask) = 0 Then
                .Row = HTI.HitRow
                .RowSel = .Row
            Else
                .RowSel = HTI.HitRow
                If PropAllowSelection = False Then .Row = .RowSel
            End If
        Else
            If PropAllowBigSelection = True Then
                If HTI.HitCol < PropFixedCols Or PropSelectionMode <> FlexSelectionModeFreeByRow Then
                    .Row = PropFixedRows
                    .RowSel = (PropRows - 1)
                End If
            Else
                If (Shift And vbShiftMask) = 0 Then
                    .Row = VBFlexGridTopRow
                    .RowSel = .Row
                Else
                    .RowSel = VBFlexGridTopRow
                End If
            End If
        End If
        If HTI.HitCol > (PropFixedCols - 1) Then
            If (Shift And vbShiftMask) = 0 Then
                .Col = HTI.HitCol
                .ColSel = .Col
            Else
                .ColSel = HTI.HitCol
                If PropAllowSelection = False Then .Col = .ColSel
            End If
        Else
            If PropAllowBigSelection = True Then
                If HTI.HitRow < PropFixedRows Or PropSelectionMode <> FlexSelectionModeFreeByColumn Then
                    .Col = PropFixedCols
                    .ColSel = (PropCols - 1)
                End If
            Else
                If (Shift And vbShiftMask) = 0 Then
                    .Col = VBFlexGridLeftCol
                    .ColSel = .Col
                Else
                    .ColSel = VBFlexGridLeftCol
                End If
            End If
        End If
    Case FlexSelectionModeByRow
        If HTI.HitRow > (PropFixedRows - 1) Then
            If (Shift And vbShiftMask) = 0 Then
                .Row = HTI.HitRow
                .RowSel = .Row
            Else
                .RowSel = HTI.HitRow
                If PropAllowSelection = False Then .Row = .RowSel
            End If
            .Col = PropFixedCols
            .ColSel = (PropCols - 1)
        Else
            If PropAllowBigSelection = True Then
                If HTI.HitCol > (PropFixedCols - 1) Then
                    If (Shift And vbShiftMask) = 0 Then
                        .Row = PropFixedRows
                        .RowSel = .Row
                    Else
                        .RowSel = PropFixedRows
                    End If
                Else
                    .Row = PropFixedRows
                    .RowSel = (PropRows - 1)
                End If
                .Col = PropFixedCols
                .ColSel = (PropCols - 1)
            Else
                If (Shift And vbShiftMask) = 0 Then
                    .Row = VBFlexGridTopRow
                    .RowSel = .Row
                Else
                    .RowSel = VBFlexGridTopRow
                End If
                .Col = PropFixedCols
                .ColSel = (PropCols - 1)
            End If
        End If
    Case FlexSelectionModeByColumn
        If HTI.HitCol > (PropFixedCols - 1) Then
            If (Shift And vbShiftMask) = 0 Then
                .Col = HTI.HitCol
                .ColSel = .Col
            Else
                .ColSel = HTI.HitCol
                If PropAllowSelection = False Then .Col = .ColSel
            End If
            .Row = PropFixedRows
            .RowSel = (PropRows - 1)
        Else
            If PropAllowBigSelection = True Then
                If HTI.HitRow > (PropFixedRows - 1) Then
                    If (Shift And vbShiftMask) = 0 Then
                        .Col = PropFixedCols
                        .ColSel = .Col
                    Else
                        .ColSel = PropFixedCols
                    End If
                Else
                    .Col = PropFixedCols
                    .ColSel = (PropCols - 1)
                End If
                .Row = PropFixedRows
                .RowSel = (PropRows - 1)
            Else
                If (Shift And vbShiftMask) = 0 Then
                    .Col = VBFlexGridLeftCol
                    .ColSel = .Col
                Else
                    .ColSel = VBFlexGridLeftCol
                End If
                .Row = PropFixedRows
                .RowSel = (PropRows - 1)
            End If
        End If
End Select
If HTI.HitRow <= (PropFixedRows - 1) And HTI.HitCol <= (PropFixedCols - 1) Then
    Select Case PropSelectionMode
        Case FlexSelectionModeFree, FlexSelectionModeFreeByRow, FlexSelectionModeFreeByColumn
            If PropAllowBigSelection = True Or (Shift And vbShiftMask) = 0 Then
                .Mask = .Mask Or RCPM_TOPROW Or RCPM_LEFTCOL
                If .Row >= (PropFixedRows + PropFrozenRows) Then
                    .TopRow = .Row
                Else
                    .TopRow = (PropFixedRows + PropFrozenRows)
                End If
                If .Col >= (PropFixedCols + PropFrozenCols) Then
                    .LeftCol = .Col
                Else
                    .LeftCol = (PropFixedCols + PropFrozenCols)
                End If
            End If
        Case FlexSelectionModeByRow, FlexSelectionModeByColumn
            If PropAllowBigSelection = True And (Shift And vbShiftMask) = 0 Then
                .Mask = .Mask Or RCPM_TOPROW Or RCPM_LEFTCOL
                If .Row >= (PropFixedRows + PropFrozenRows) Then
                    .TopRow = .Row
                Else
                    .TopRow = (PropFixedRows + PropFrozenRows)
                End If
                If .Col >= (PropFixedCols + PropFrozenCols) Then
                    .LeftCol = .Col
                Else
                    .LeftCol = (PropFixedCols + PropFrozenCols)
                End If
            End If
    End Select
End If
Call SetRowColParams(RCP)
End With
End Function

Private Sub ProcessLButtonUp(ByVal Shift As Integer, ByVal X As Long, ByVal Y As Long)
Dim RCP As TROWCOLPARAMS
If VBFlexGridCaptureDividerDrag = True Then
    Dim iRow As Long, iCol As Long, i As Long
    iRow = VBFlexGridCaptureDividerRow
    iCol = VBFlexGridCaptureDividerCol
    Select Case VBFlexGridCaptureHitResult
        Case FlexHitResultDividerRowTop, FlexHitResultDividerRowBottom, FlexHitResultDividerColumnLeft, FlexHitResultDividerColumnRight
            If VBFlexGridCaptureDividerMoved = False Then
                ClipCursor ByVal NULL_PTR
                SetRect VBFlexGridDividerDragSplitterRect, 0, 0, 0, 0
                VBFlexGridDividerDragOffset.X = 0
                VBFlexGridDividerDragOffset.Y = 0
                VBFlexGridDividerDragDirty = False
                Call RedrawGrid
            Else
                Dim Size As SIZEAPI, NewSize As Long
                With Size
                If iRow > -1 Then
                    For i = 0 To iRow - 1
                        If i >= VBFlexGridTopRow Then
                            .CY = .CY + GetRowHeight(i)
                        ElseIf i < (PropFixedRows + PropFrozenRows) Then
                            .CY = .CY + GetRowHeight(i)
                        Else
                            i = VBFlexGridTopRow - 1
                        End If
                    Next i
                    If (Y - VBFlexGridDividerDragOffset.Y) < (.CY + 1) Then
                        NewSize = UserControl.ScaleY(1, vbPixels, vbTwips)
                    Else
                        NewSize = UserControl.ScaleY(((Y - VBFlexGridDividerDragOffset.Y) - .CY), vbPixels, vbTwips)
                    End If
                    RaiseEvent AfterUserResize(iRow, iCol, NewSize)
                    If NewSize > 0 Then .CY = UserControl.ScaleY(NewSize, vbTwips, vbPixels) Else .CY = 0
                    Select Case PropRowSizingMode
                        Case FlexRowSizingModeIndividual
                            VBFlexGridCells.Rows(iRow).RowInfo.Height = .CY
                        Case FlexRowSizingModeAll
                            VBFlexGridCells.Rows(iRow).RowInfo.Height = .CY
                            For i = 0 To PropRows - 1
                                VBFlexGridCells.Rows(i).RowInfo.Height = .CY
                            Next i
                        Case FlexRowSizingModeUniform
                            VBFlexGridUniformRowHeight = .CY
                            VBFlexGridCells.Rows(iRow).RowInfo.Height = -1
                    End Select
                ElseIf iCol > -1 Then
                    For i = 0 To iCol - 1
                        If i >= VBFlexGridLeftCol Then
                            .CX = .CX + GetColWidth(i)
                        ElseIf i < (PropFixedCols + PropFrozenCols) Then
                            .CX = .CX + GetColWidth(i)
                        Else
                            i = VBFlexGridLeftCol - 1
                        End If
                    Next i
                    If (X - VBFlexGridDividerDragOffset.X) < (.CX + 1) Then
                        NewSize = UserControl.ScaleX(1, vbPixels, vbTwips)
                    Else
                        NewSize = UserControl.ScaleX(((X - VBFlexGridDividerDragOffset.X) - .CX), vbPixels, vbTwips)
                    End If
                    RaiseEvent AfterUserResize(iRow, iCol, NewSize)
                    If NewSize > 0 Then .CX = UserControl.ScaleX(NewSize, vbTwips, vbPixels) Else .CX = 0
                    VBFlexGridColsInfo(iCol).Width = .CX
                End If
                End With
                ClipCursor ByVal NULL_PTR
                SetRect VBFlexGridDividerDragSplitterRect, 0, 0, 0, 0
                VBFlexGridDividerDragOffset.X = 0
                VBFlexGridDividerDragOffset.Y = 0
                VBFlexGridDividerDragDirty = False
                With RCP
                If iRow > -1 Then
                    .Mask = RCPM_TOPROW
                    .Flags = RCPF_CHECKTOPROW Or RCPF_FORCETOPROWMASK
                    .TopRow = VBFlexGridTopRow
                ElseIf iCol > -1 Then
                    .Mask = RCPM_LEFTCOL
                    .Flags = RCPF_CHECKLEFTCOL Or RCPF_FORCELEFTCOLMASK
                    .LeftCol = VBFlexGridLeftCol
                End If
                .Flags = .Flags Or RCPF_SETSCROLLBARS Or RCPF_FORCEREDRAW
                Call SetRowColParams(RCP)
                End With
                RaiseEvent AfterUserResizeEnd(iRow, iCol)
            End If
        Case FlexHitResultDividerFrozenRowTop, FlexHitResultDividerFrozenRowBottom, FlexHitResultDividerFrozenColumnLeft, FlexHitResultDividerFrozenColumnRight
            Dim HTI As THITTESTINFO, NewCount As Long
            With HTI
            .PT.X = X
            .PT.Y = Y
            Call GetHitTestInfo(HTI)
            If .MouseRow < PropFixedRows Then .MouseRow = PropFixedRows
            If .MouseCol < PropFixedCols Then .MouseCol = PropFixedCols
            .PT.X = 0
            .PT.Y = 0
            If iRow > -1 And .MouseRow < (PropRows - 1) Then
                If .MouseRow >= (PropFixedRows + PropFrozenRows) Then
                    For i = 0 To ((PropFixedRows + PropFrozenRows) - 1)
                        .PT.Y = .PT.Y + GetRowHeight(i)
                    Next i
                    For i = VBFlexGridTopRow To (.MouseRow - 1)
                        .PT.Y = .PT.Y + GetRowHeight(i)
                    Next i
                Else
                    For i = 0 To (PropFixedRows - 1)
                        .PT.Y = .PT.Y + GetRowHeight(i)
                    Next i
                    For i = PropFixedRows To (.MouseRow - 1)
                        .PT.Y = .PT.Y + GetRowHeight(i)
                    Next i
                End If
                If Y > (.PT.Y + (GetRowHeight(.MouseRow) \ 2)) Then
                    iRow = iRow + 1
                    .MouseRow = .MouseRow + 1
                End If
            End If
            If iCol > -1 And .MouseCol < (PropCols - 1) Then
                If .MouseCol >= (PropFixedCols + PropFrozenCols) Then
                    For i = 0 To ((PropFixedCols + PropFrozenCols) - 1)
                        .PT.X = .PT.X + GetColWidth(i)
                    Next i
                    For i = VBFlexGridLeftCol To (.MouseCol - 1)
                        .PT.X = .PT.X + GetColWidth(i)
                    Next i
                Else
                    For i = 0 To (PropFixedCols - 1)
                        .PT.X = .PT.X + GetColWidth(i)
                    Next i
                    For i = PropFixedCols To (.MouseCol - 1)
                        .PT.X = .PT.X + GetColWidth(i)
                    Next i
                End If
                If X > (.PT.X + (GetColWidth(.MouseCol) \ 2)) Then
                    iCol = iCol + 1
                    .MouseCol = .MouseCol + 1
                End If
            End If
            If iRow > -1 Then
                If .MouseRow <= iRow Then
                    ' Decrease of frozen rows.
                    NewCount = .MouseRow - PropFixedRows
                Else
                    ' Relative increase of frozen rows.
                    NewCount = (.MouseRow - PropFixedRows) - (VBFlexGridTopRow - (PropFixedRows + PropFrozenRows))
                End If
            ElseIf iCol > -1 Then
                If .MouseCol <= iCol Then
                    ' Decrease of frozen columns.
                    NewCount = .MouseCol - PropFixedCols
                Else
                    ' Relative increase of frozen columns.
                    NewCount = (.MouseCol - PropFixedCols) - (VBFlexGridLeftCol - (PropFixedCols + PropFrozenCols))
                End If
            End If
            End With
            ClipCursor ByVal NULL_PTR
            SetRect VBFlexGridDividerDragSplitterRect, 0, 0, 0, 0
            VBFlexGridDividerDragOffset.X = 0
            VBFlexGridDividerDragOffset.Y = 0
            VBFlexGridDividerDragDirty = False
            With RCP
            If iRow > -1 And PropFrozenRows <> NewCount Then
                PropFrozenRows = NewCount
                .Mask = RCPM_ROW Or RCPM_TOPROW
                .Flags = RCPF_FORCETOPROWMASK
                .Row = PropFixedRows + PropFrozenRows
                .TopRow = PropFixedRows + PropFrozenRows
                Select Case PropSelectionMode
                    Case FlexSelectionModeFree, FlexSelectionModeFreeByRow, FlexSelectionModeFreeByColumn
                        .Mask = .Mask Or RCPM_ROWSEL
                        .RowSel = .Row
                    Case FlexSelectionModeByRow
                        .Mask = .Mask Or RCPM_ROWSEL Or RCPM_COLSEL
                        .RowSel = .Row
                        .ColSel = (PropCols - 1)
                End Select
            ElseIf iCol > -1 And PropFrozenCols <> NewCount Then
                PropFrozenCols = NewCount
                .Mask = RCPM_COL Or RCPM_LEFTCOL
                .Flags = RCPF_FORCELEFTCOLMASK
                .Col = PropFixedCols + PropFrozenCols
                .LeftCol = PropFixedCols + PropFrozenCols
                Select Case PropSelectionMode
                    Case FlexSelectionModeFree, FlexSelectionModeFreeByRow, FlexSelectionModeFreeByColumn
                        .Mask = .Mask Or RCPM_COLSEL
                        .ColSel = .Col
                    Case FlexSelectionModeByColumn
                        .Mask = .Mask Or RCPM_ROWSEL Or RCPM_COLSEL
                        .RowSel = (PropRows - 1)
                        .ColSel = .Col
                End Select
            End If
            .Flags = .Flags Or RCPF_SETSCROLLBARS Or RCPF_FORCEREDRAW
            Call SetRowColParams(RCP)
            End With
            RaiseEvent AfterUserFreeze
    End Select
    Exit Sub
End If
With RCP
If (Shift And vbCtrlMask) <> 0 Then
    .Flags = .Flags Or RCPF_CTRL
    If (Shift And vbShiftMask) <> 0 Then .Flags = .Flags Or RCPF_SHIFT
End If
.Message = WM_LBUTTONUP
If VBFlexGridMouseMoveChanged = False And VBFlexGridMouseMoveRow > -1 And VBFlexGridMouseMoveCol > -1 Then
    Dim Cancel As Boolean
    Select Case VBFlexGridCaptureHitResult
        Case FlexHitResultNoWhere, FlexHitResultComboCue, FlexHitResultComboCueDisabled
            Cancel = True
        Case FlexHitResultCheckBox, FlexHitResultCheckBoxDisabled
            If VBFlexGridCaptureRow <= (PropFixedRows - 1) Or VBFlexGridCaptureCol <= (PropFixedCols - 1) Then Cancel = True
    End Select
    If Cancel = False Then
        .Mask = .Mask Or RCPM_TOPROW Or RCPM_LEFTCOL
        .TopRow = VBFlexGridTopRow
        .LeftCol = VBFlexGridLeftCol
        If .TopRow <= VBFlexGridRow Then
            If VBFlexGridRow > (.TopRow + GetRowsPerPage(.TopRow) - 1) Then
                .TopRow = VBFlexGridRow - GetRowsPerPageRev(VBFlexGridRow) + 1
            End If
        End If
        If .LeftCol <= VBFlexGridCol Then
            If VBFlexGridCol > (.LeftCol + GetColsPerPage(.LeftCol) - 1) Then
                .LeftCol = VBFlexGridCol - GetColsPerPageRev(VBFlexGridCol) + 1
            End If
        End If
    End If
End If
Call SetRowColParams(RCP)
End With
End Sub

Private Sub ProcessMouseMove(ByVal Button As Integer, ByVal X As Long, ByVal Y As Long)
Dim HTI As THITTESTINFO, i As Long
If PropShowInfoTips = True Or PropShowLabelTips = True Then Call CheckToolTipRowCol(X, Y)
If VBFlexGridCaptureDividerDrag = True Then
    If VBFlexGridCapturePoint.X <> X Or VBFlexGridCapturePoint.Y <> Y Then VBFlexGridCaptureDividerMoved = True
    If VBFlexGridDividerDragDirty = True Then
        Call DrawDividerDragSplitter
        Select Case VBFlexGridCaptureHitResult
            Case FlexHitResultDividerRowTop, FlexHitResultDividerRowBottom, FlexHitResultDividerColumnLeft, FlexHitResultDividerColumnRight
                Call SetDividerDragSplitterRect(X - VBFlexGridDividerDragOffset.X, Y - VBFlexGridDividerDragOffset.Y)
            Case FlexHitResultDividerFrozenRowTop, FlexHitResultDividerFrozenRowBottom, FlexHitResultDividerFrozenColumnLeft, FlexHitResultDividerFrozenColumnRight
                With HTI
                .PT.X = X
                .PT.Y = Y
                Call GetHitTestInfo(HTI)
                .PT.X = 0
                .PT.Y = 0
                If VBFlexGridCaptureDividerRow > -1 Then
                    If .MouseRow >= (PropFixedRows + PropFrozenRows) Then
                        For i = 0 To ((PropFixedRows + PropFrozenRows) - 1)
                            .PT.Y = .PT.Y + GetRowHeight(i)
                        Next i
                        For i = VBFlexGridTopRow To (.MouseRow - 1)
                            .PT.Y = .PT.Y + GetRowHeight(i)
                        Next i
                    Else
                        For i = 0 To (PropFixedRows - 1)
                            .PT.Y = .PT.Y + GetRowHeight(i)
                        Next i
                        For i = PropFixedRows To (.MouseRow - 1)
                            .PT.Y = .PT.Y + GetRowHeight(i)
                        Next i
                    End If
                    If .MouseRow < (PropRows - 1) Then
                        If Y > (.PT.Y + (GetRowHeight(.MouseRow) \ 2)) Then .PT.Y = .PT.Y + GetRowHeight(.MouseRow)
                    End If
                End If
                If VBFlexGridCaptureDividerCol > -1 Then
                    If .MouseCol >= (PropFixedCols + PropFrozenCols) Then
                        For i = 0 To ((PropFixedCols + PropFrozenCols) - 1)
                            .PT.X = .PT.X + GetColWidth(i)
                        Next i
                        For i = VBFlexGridLeftCol To (.MouseCol - 1)
                            .PT.X = .PT.X + GetColWidth(i)
                        Next i
                    Else
                        For i = 0 To (PropFixedCols - 1)
                            .PT.X = .PT.X + GetColWidth(i)
                        Next i
                        For i = PropFixedCols To (.MouseCol - 1)
                            .PT.X = .PT.X + GetColWidth(i)
                        Next i
                    End If
                    If .MouseCol < (PropCols - 1) Then
                        If X > (.PT.X + (GetColWidth(.MouseCol) \ 2)) Then .PT.X = .PT.X + GetColWidth(.MouseCol)
                    End If
                End If
                ' VBFlexGridDividerDragOffset is not applicable as PT has fixed coordinates.
                Call SetDividerDragSplitterRect(.PT.X, .PT.Y)
                End With
        End Select
        Call DrawDividerDragSplitter
    End If
    Exit Sub
End If
Select Case VBFlexGridCaptureHitResult
    Case FlexHitResultNoWhere, FlexHitResultComboCue, FlexHitResultComboCueDisabled
        Exit Sub
    Case FlexHitResultCheckBox, FlexHitResultCheckBoxDisabled
        If VBFlexGridCaptureRow <= (PropFixedRows - 1) Or VBFlexGridCaptureCol <= (PropFixedCols - 1) Then Exit Sub
    Case Else
        If VBFlexGridCaptureRow = -1 Or VBFlexGridCaptureCol = -1 Then Exit Sub
End Select
If (Button And vbLeftButton) = 0 Then Exit Sub
If VBFlexGridCaptureRow <= (PropFixedRows - 1) And VBFlexGridCaptureCol <= (PropFixedCols - 1) Then Exit Sub
HTI.PT.X = X
HTI.PT.Y = Y
Call GetHitTestInfo(HTI)
If HTI.HitRow <> VBFlexGridMouseMoveRow Or HTI.HitCol <> VBFlexGridMouseMoveCol Then
    VBFlexGridMouseMoveRow = HTI.HitRow
    VBFlexGridMouseMoveCol = HTI.HitCol
    VBFlexGridMouseMoveChanged = True
Else
    If VBFlexGridMouseMoveChanged = False Then Exit Sub
End If
Dim RCP As TROWCOLPARAMS, RowsPerPage As Long, ColsPerPage As Long
With RCP
.Mask = RCPM_ROWSEL Or RCPM_COLSEL Or RCPM_TOPROW Or RCPM_LEFTCOL
.Message = WM_MOUSEMOVE
If PropAllowSelection = False Then
    .Mask = .Mask Or RCPM_ROW Or RCPM_COL
    .Row = VBFlexGridRow
    .Col = VBFlexGridCol
End If
.RowSel = VBFlexGridRowSel
.ColSel = VBFlexGridColSel
.TopRow = VBFlexGridTopRow
.LeftCol = VBFlexGridLeftCol
Select Case PropSelectionMode
    Case FlexSelectionModeFree, FlexSelectionModeFreeByRow, FlexSelectionModeFreeByColumn
        If VBFlexGridCaptureRow > (PropFixedRows - 1) Or PropAllowBigSelection = False Then
            If HTI.MouseRow > ((PropFixedRows + PropFrozenRows) - 1) And Y >= 0 Then
                .RowSel = HTI.MouseRow
            Else
                If .RowSel > (PropFixedRows + PropFrozenRows) Then
                    HTI.PT.Y = Y
                    For i = 0 To ((PropFixedRows + PropFrozenRows) - 1)
                        HTI.PT.Y = HTI.PT.Y - GetRowHeight(i)
                    Next i
                    For i = (.RowSel - 1) To PropFixedRows Step -1
                        HTI.PT.Y = HTI.PT.Y + GetRowHeight(i)
                        If HTI.PT.Y >= 0 Then Exit For
                    Next i
                    If i > (PropFixedRows - 1) Then .RowSel = i Else .RowSel = PropFixedRows
                ElseIf HTI.MouseRow > (PropFixedRows - 1) Then
                    .RowSel = HTI.MouseRow
                ElseIf .RowSel > PropFixedRows Then
                    .RowSel = PropFixedRows
                End If
            End If
            If .TopRow > .RowSel Then
                If .RowSel >= (PropFixedRows + PropFrozenRows) Then .TopRow = .RowSel Else .TopRow = PropFixedRows + PropFrozenRows
            Else
                RowsPerPage = GetRowsPerPage(.TopRow)
                If .RowSel > (.TopRow + RowsPerPage - 1) Then
                    .TopRow = .RowSel - GetRowsPerPageRev(.RowSel) + 1
                End If
            End If
            If PropAllowSelection = False Then .Row = .RowSel
        ElseIf PropSelectionMode <> FlexSelectionModeFreeByRow Then
            .RowSel = (PropRows - 1)
        End If
        If VBFlexGridCaptureCol > (PropFixedCols - 1) Or PropAllowBigSelection = False Then
            If HTI.MouseCol > ((PropFixedCols + PropFrozenCols) - 1) And X >= 0 Then
                .ColSel = HTI.MouseCol
            Else
                If .ColSel > (PropFixedCols + PropFrozenCols) Then
                    HTI.PT.X = X
                    For i = 0 To ((PropFixedCols + PropFrozenCols) - 1)
                        HTI.PT.X = HTI.PT.X - GetColWidth(i)
                    Next i
                    For i = (.ColSel - 1) To PropFixedCols Step -1
                        HTI.PT.X = HTI.PT.X + GetColWidth(i)
                        If HTI.PT.X >= 0 Then Exit For
                    Next i
                    If i > (PropFixedCols - 1) Then .ColSel = i Else .ColSel = PropFixedCols
                ElseIf HTI.MouseCol > (PropFixedCols - 1) Then
                    .ColSel = HTI.MouseCol
                ElseIf .ColSel > PropFixedCols Then
                    .ColSel = PropFixedCols
                End If
            End If
            If .LeftCol > .ColSel Then
                If .ColSel >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .ColSel Else .LeftCol = PropFixedCols + PropFrozenCols
            Else
                ColsPerPage = GetColsPerPage(.LeftCol)
                If .ColSel > (.LeftCol + ColsPerPage - 1) Then
                    .LeftCol = .ColSel - GetColsPerPageRev(.ColSel) + 1
                End If
            End If
            If PropAllowSelection = False Then .Col = .ColSel
        ElseIf PropSelectionMode <> FlexSelectionModeFreeByColumn Then
            .ColSel = (PropCols - 1)
        End If
    Case FlexSelectionModeByRow
        If VBFlexGridCaptureRow > (PropFixedRows - 1) Or VBFlexGridCaptureCol > (PropFixedCols - 1) Or PropAllowBigSelection = False Then
            If HTI.MouseRow > ((PropFixedRows + PropFrozenRows) - 1) And Y >= 0 Then
                .RowSel = HTI.MouseRow
            Else
                If .RowSel > (PropFixedRows + PropFrozenRows) Then
                    HTI.PT.Y = Y
                    For i = 0 To ((PropFixedRows + PropFrozenRows) - 1)
                        HTI.PT.Y = HTI.PT.Y - GetRowHeight(i)
                    Next i
                    For i = (.RowSel - 1) To PropFixedRows Step -1
                        HTI.PT.Y = HTI.PT.Y + GetRowHeight(i)
                        If HTI.PT.Y >= 0 Then Exit For
                    Next i
                    If i > (PropFixedRows - 1) Then .RowSel = i Else .RowSel = PropFixedRows
                ElseIf HTI.MouseRow > (PropFixedRows - 1) Then
                    .RowSel = HTI.MouseRow
                ElseIf .RowSel > PropFixedRows Then
                    .RowSel = PropFixedRows
                End If
            End If
            If .TopRow > .RowSel Then
                If .RowSel >= (PropFixedRows + PropFrozenRows) Then .TopRow = .RowSel Else .TopRow = PropFixedRows + PropFrozenRows
            Else
                RowsPerPage = GetRowsPerPage(.TopRow)
                If .RowSel > (.TopRow + RowsPerPage - 1) Then
                    .TopRow = .RowSel - GetRowsPerPageRev(.RowSel) + 1
                End If
            End If
            If PropAllowSelection = False Then .Row = .RowSel
        End If
    Case FlexSelectionModeByColumn
        If VBFlexGridCaptureRow > (PropFixedRows - 1) Or VBFlexGridCaptureCol > (PropFixedCols - 1) Or PropAllowBigSelection = False Then
            If HTI.MouseCol > ((PropFixedCols + PropFrozenCols) - 1) And X >= 0 Then
                .ColSel = HTI.MouseCol
            Else
                If .ColSel > (PropFixedCols + PropFrozenCols) Then
                    HTI.PT.X = X
                    For i = 0 To ((PropFixedCols + PropFrozenCols) - 1)
                        HTI.PT.X = HTI.PT.X - GetColWidth(i)
                    Next i
                    For i = (.ColSel - 1) To PropFixedCols Step -1
                        HTI.PT.X = HTI.PT.X + GetColWidth(i)
                        If HTI.PT.X >= 0 Then Exit For
                    Next i
                    If i > (PropFixedCols - 1) Then .ColSel = i Else .ColSel = PropFixedCols
                ElseIf HTI.MouseCol > (PropFixedCols - 1) Then
                    .ColSel = HTI.MouseCol
                ElseIf .ColSel > PropFixedCols Then
                    .ColSel = PropFixedCols
                End If
            End If
            If .LeftCol > .ColSel Then
                If .ColSel >= (PropFixedCols + PropFrozenCols) Then .LeftCol = .ColSel Else .LeftCol = PropFixedCols + PropFrozenCols
            Else
                ColsPerPage = GetColsPerPage(.LeftCol)
                If .ColSel > (.LeftCol + ColsPerPage - 1) Then
                    .LeftCol = .ColSel - GetColsPerPageRev(.ColSel) + 1
                End If
            End If
            If PropAllowSelection = False Then .Col = .ColSel
        End If
End Select
Call SetRowColParams(RCP)
End With
End Sub

Private Function ProcessFormatRange(ByVal wParam As LongPtr, ByVal lParam As LongPtr) As LongPtr
Static RowOffset As Long, ColOffset As Long
If wParam <> 0 Then
    ProcessFormatRange = VP_YES
    Exit Function
End If
If lParam = 0 Then
    RowOffset = 0
    ColOffset = 0
    ProcessFormatRange = 0
    Exit Function
End If
Dim pFormatRange As TFORMATRANGE
CopyMemory ByVal VarPtr(pFormatRange), ByVal lParam, LenB(pFormatRange)
If pFormatRange.hDCTarget = NULL_PTR Then pFormatRange.hDCTarget = pFormatRange.hDC
If pFormatRange.hDC = NULL_PTR Then
    ProcessFormatRange = 0
    Exit Function
End If
Dim Scale_X As Double, Scale_Y As Double, CXMax As Long, CYMax As Long
Scale_X = GetDeviceCaps(pFormatRange.hDC, LOGPIXELSX) / DPI_X()
Scale_Y = GetDeviceCaps(pFormatRange.hDC, LOGPIXELSY) / DPI_Y()
CXMax = (pFormatRange.RC.Right - pFormatRange.RC.Left) / Scale_X
CYMax = (pFormatRange.RC.Bottom - pFormatRange.RC.Top) / Scale_Y
Dim iRow As Long, iCol As Long, CX As Long, CY As Long, CellRange As TCELLRANGE
For iCol = 0 To ((PropFixedCols + PropFrozenCols) - 1)
    CX = CX + GetColWidth(iCol)
Next iCol
For iRow = 0 To ((PropFixedRows + PropFrozenRows) - 1)
    CY = CY + GetRowHeight(iRow)
Next iRow
CellRange.LeftCol = ((PropFixedCols + PropFrozenCols) + ColOffset)
CellRange.TopRow = ((PropFixedRows + PropFrozenRows) + RowOffset)
For iRow = ((PropFixedRows + PropFrozenRows) + RowOffset) To (PropRows - 1)
    CY = CY + GetRowHeight(iRow)
    If CY > CYMax Then Exit For
Next iRow
If iRow = ((PropFixedRows + PropFrozenRows) + RowOffset) Then iRow = iRow + 1
For iCol = ((PropFixedCols + PropFrozenCols) + ColOffset) To (PropCols - 1)
    CX = CX + GetColWidth(iCol)
    If CX > CXMax Then Exit For
Next iCol
If iCol = ((PropFixedCols + PropFrozenCols) + ColOffset) Then iCol = iCol + 1
CellRange.RightCol = iCol - 1
CellRange.BottomRow = iRow - 1
ColOffset = iCol - (PropFixedCols + PropFrozenCols)
If iRow > (PropRows - 1) And iCol > (PropCols - 1) Then ProcessFormatRange = -1 Else ProcessFormatRange = 1
If iCol > (PropCols - 1) Then
    RowOffset = iRow - (PropFixedRows + PropFrozenRows)
    ColOffset = 0
End If
Dim RC As RECT
With RC
.Top = 0
For iRow = 0 To ((PropFixedRows + PropFrozenRows) - 1)
    .Bottom = .Bottom + GetRowHeight(iRow)
Next iRow
For iRow = CellRange.TopRow To CellRange.BottomRow
    .Bottom = .Bottom + GetRowHeight(iRow)
Next iRow
.Left = 0
For iCol = 0 To ((PropFixedCols + PropFrozenCols) - 1)
    .Right = .Right + GetColWidth(iCol)
Next iCol
For iCol = CellRange.LeftCol To CellRange.RightCol
    .Right = .Right + GetColWidth(iCol)
Next iCol
End With
Dim Scaled_Width As Long, Scaled_Height As Long
Scaled_Width = (RC.Right - RC.Left) * Scale_X
Scaled_Height = (RC.Bottom - RC.Top) * Scale_Y
If Scaled_Width > (pFormatRange.RC.Right - pFormatRange.RC.Left) Then Scaled_Width = pFormatRange.RC.Right - pFormatRange.RC.Left
If Scaled_Height > (pFormatRange.RC.Bottom - pFormatRange.RC.Top) Then Scaled_Height = pFormatRange.RC.Bottom - pFormatRange.RC.Top
If PropPictureType <> FlexPictureTypeEnhMetafile Then
    Dim hDCBmp As LongPtr
    Dim hBmp As LongPtr, hBmpOld As LongPtr
    hDCBmp = CreateCompatibleDC(pFormatRange.hDC)
    If hDCBmp <> NULL_PTR Then
        If PropPictureType = FlexPictureTypeColor Then
            hBmp = CreateCompatibleBitmap(pFormatRange.hDC, RC.Right - RC.Left, RC.Bottom - RC.Top)
        ElseIf PropPictureType = FlexPictureTypeMonochrome Then
            hBmp = CreateCompatibleBitmap(hDCBmp, RC.Right - RC.Left, RC.Bottom - RC.Top)
        End If
        If hBmp <> NULL_PTR Then
            hBmpOld = SelectObject(hDCBmp, hBmp)
            Call DrawGrid(hDCBmp, NULL_PTR, True, True, VarPtr(CellRange))
            Dim OldStretchBltMode As Long
            OldStretchBltMode = SetStretchBltMode(pFormatRange.hDC, STRETCH_HALFTONE)
            SetBrushOrgEx pFormatRange.hDC, 0, 0, ByVal NULL_PTR
            If (GetDeviceCaps(pFormatRange.hDC, RASTERCAPS) And RC_STRETCHBLT) = RC_STRETCHBLT Then
                StretchBlt pFormatRange.hDC, pFormatRange.RC.Left, pFormatRange.RC.Top, Scaled_Width, Scaled_Height, hDCBmp, 0, 0, RC.Right - RC.Left, RC.Bottom - RC.Top, vbSrcCopy
                SelectObject hDCBmp, hBmpOld
            Else
                ' hBmp must not be selected into a device context when the application calls GetDIBits.
                SelectObject hDCBmp, hBmpOld
                Dim pBitmapInfo As BITMAPINFO, pBits() As Byte
                pBitmapInfo.BMIHeader.BISize = LenB(pBitmapInfo.BMIHeader)
                If GetDIBits(pFormatRange.hDC, hBmp, 0, 0, NULL_PTR, pBitmapInfo, DIB_RGB_COLORS) <> 0 Then
                    ReDim pBits(0 To ((pBitmapInfo.BMIHeader.BISizeImage \ pBitmapInfo.BMIHeader.BIHeight) - 1), 0 To (pBitmapInfo.BMIHeader.BIHeight - 1)) As Byte
                    If GetDIBits(pFormatRange.hDC, hBmp, 0, pBitmapInfo.BMIHeader.BIHeight, VarPtr(pBits(0, 0)), pBitmapInfo, DIB_RGB_COLORS) > 0 Then StretchDIBits pFormatRange.hDC, pFormatRange.RC.Left, pFormatRange.RC.Top, Scaled_Width, Scaled_Height, 0, 0, RC.Right - RC.Left, RC.Bottom - RC.Top, VarPtr(pBits(0, 0)), pBitmapInfo, DIB_RGB_COLORS, vbSrcCopy
                End If
            End If
            If OldStretchBltMode <> STRETCH_HALFTONE Then SetStretchBltMode pFormatRange.hDC, OldStretchBltMode
            DeleteObject hBmp
        End If
        DeleteDC hDCBmp
    End If
Else
    Dim hDC As LongPtr
    If VBFlexGridHandle <> NULL_PTR Then hDC = GetDC(VBFlexGridHandle)
    If hDC <> NULL_PTR Then
        Dim EnhMetaRect As RECT, EnhMetaDC As LongPtr, hEMF As LongPtr
        EnhMetaRect.Left = (RC.Left * GetDeviceCaps(hDC, HORZSIZE) * 100) / GetDeviceCaps(hDC, HORZRES)
        EnhMetaRect.Top = (RC.Top * GetDeviceCaps(hDC, VERTSIZE) * 100) / GetDeviceCaps(hDC, VERTRES)
        EnhMetaRect.Right = (RC.Right * GetDeviceCaps(hDC, HORZSIZE) * 100) / GetDeviceCaps(hDC, HORZRES)
        EnhMetaRect.Bottom = (RC.Bottom * GetDeviceCaps(hDC, VERTSIZE) * 100) / GetDeviceCaps(hDC, VERTRES)
        EnhMetaDC = CreateEnhMetaFile(hDC, NULL_PTR, EnhMetaRect, NULL_PTR)
        If EnhMetaDC <> NULL_PTR Then
            Call DrawGrid(EnhMetaDC, NULL_PTR, True, True, VarPtr(CellRange))
            hEMF = CloseEnhMetaFile(EnhMetaDC)
        End If
        If hEMF <> NULL_PTR Then
            EnhMetaRect.Left = pFormatRange.RC.Left
            EnhMetaRect.Top = pFormatRange.RC.Top
            EnhMetaRect.Right = pFormatRange.RC.Left + Scaled_Width
            EnhMetaRect.Bottom = pFormatRange.RC.Top + Scaled_Height
            PlayEnhMetaFile pFormatRange.hDC, hEMF, EnhMetaRect
            DeleteEnhMetaFile hEMF
        End If
        ReleaseDC VBFlexGridHandle, hDC
    End If
End If
End Function

Private Function DoDragRowCol(ByVal Row As Long, ByVal Col As Long) As Long
If Row > -1 Then DoDragRowCol = Row Else If Col > -1 Then DoDragRowCol = Col
If VBFlexGridHandle = NULL_PTR Then Exit Function
Dim Button As Integer
Button = GetMouseState()
If (Button And vbLeftButton) = 0 And (Button And vbRightButton) = 0 Then Exit Function
Dim P As POINTAPI, DX As Long, DY As Long, DragRect As RECT, WndRect As RECT, TrackIndex As Long, dwStyle As Long, dwExStyle As Long
GetCursorPos P
ScreenToClient VBFlexGridHandle, P
DX = GetSystemMetrics(SM_CXDRAG)
DY = GetSystemMetrics(SM_CYDRAG)
DragRect.Left = P.X - DX
DragRect.Right = P.X + DX
DragRect.Top = P.Y - DY
DragRect.Bottom = P.Y + DY
GetWindowRect VBFlexGridHandle, WndRect
MapWindowPoints HWND_DESKTOP, VBFlexGridHandle, WndRect, 2
TrackIndex = DoDragRowCol
dwStyle = GetWindowLong(VBFlexGridHandle, GWL_STYLE)
dwExStyle = GetWindowLong(VBFlexGridHandle, GWL_EXSTYLE)
Dim i As Long, CY1 As Long, CY2 As Long, CX1 As Long, CX2 As Long
If Row > -1 Then
    For i = 0 To ((PropFixedRows + PropFrozenRows) - 1)
        CY1 = CY1 + GetRowHeight(i)
    Next i
    If (dwStyle And WS_HSCROLL) = WS_HSCROLL Then CY2 = GetSystemMetrics(SM_CYHSCROLL)
ElseIf Col > -1 Then
    For i = 0 To ((PropFixedCols + PropFrozenCols) - 1)
        CX1 = CX1 + GetColWidth(i)
    Next i
    If (dwStyle And WS_VSCROLL) = WS_VSCROLL Then
        If (dwExStyle And WS_EX_LEFTSCROLLBAR) = WS_EX_LEFTSCROLLBAR Then
            CX1 = CX1 + GetSystemMetrics(SM_CXVSCROLL)
        Else
            CX2 = GetSystemMetrics(SM_CXVSCROLL)
        End If
    End If
End If
SetCapture VBFlexGridHandle
VBFlexGridDoDragRow = -1
VBFlexGridDoDragCol = -1
VBFlexGridDoDragRowCol = True
Const PM_REMOVE As Long = &H1
Const WM_KEYFIRST As Long = &H100, WM_KEYLAST As Long = &H108
Const WM_MOUSEFIRST As Long = &H200, WM_MOUSELAST As Long = &H20E
Const IDC_NODROP As Long = 1, IDC_MOVE As Long = 2
#If VBA7 Then
Const IDT_AUTOSCROLL As LongPtr = 1
#Else
Const IDT_AUTOSCROLL As Long = 1
#End If
Dim Msg As TMSG, Pos As Long, HTI As THITTESTINFO, ButtonUp As Boolean, Dragging As Boolean, NoDrop As Boolean, AutoScroll As Boolean, SplitterRect As RECT, hDC As LongPtr, hBmpOld As LongPtr
Do
    While PeekMessage(Msg, NULL_PTR, 0, 0, PM_REMOVE) <> 0
        Select Case Msg.Message
            Case WM_QUIT
                ' Post the quit message to the outer message loop.
                PostQuitMessage CLng(Msg.wParam)
                Exit Do
            Case WM_TIMER
                If Msg.hWnd = VBFlexGridHandle And Msg.wParam = IDT_AUTOSCROLL Then
                    Pos = GetMessagePos()
                    P.X = Get_X_lParam(Pos)
                    P.Y = Get_Y_lParam(Pos)
                    ScreenToClient VBFlexGridHandle, P
                    LSet HTI.PT = P
                    Call GetHitTestInfo(HTI)
                    If Row > -1 Then
                        If HTI.MouseRow >= PropFixedRows Then
                            TrackIndex = HTI.MouseRow
                        Else
                            TrackIndex = PropFixedRows
                        End If
                    ElseIf Col > -1 Then
                        If HTI.MouseCol >= PropFixedCols Then
                            TrackIndex = HTI.MouseCol
                        Else
                            TrackIndex = PropFixedCols
                        End If
                    End If
                    If NoDrop = False Then
                        If Row > -1 Then
                            If (dwStyle And WS_VSCROLL) = WS_VSCROLL Then
                                If P.Y < ((16 * PixelsPerDIP_Y()) + CY1) Then
                                    SendMessage VBFlexGridHandle, WM_VSCROLL, SB_LINEUP, ByVal 0&
                                    AutoScroll = True
                                ElseIf (UserControl.ScaleHeight - P.Y) < ((16 * PixelsPerDIP_Y()) + CY2) Then
                                    SendMessage VBFlexGridHandle, WM_VSCROLL, SB_LINEDOWN, ByVal 0&
                                    AutoScroll = True
                                Else
                                    AutoScroll = False
                                End If
                            End If
                        ElseIf Col > -1 Then
                            If (dwStyle And WS_HSCROLL) = WS_HSCROLL Then
                                If P.X < ((16 * PixelsPerDIP_X()) + CX1) Then
                                    SendMessage VBFlexGridHandle, WM_HSCROLL, SB_LINELEFT, ByVal 0&
                                    AutoScroll = True
                                ElseIf (UserControl.ScaleWidth - P.X) < ((16 * PixelsPerDIP_X()) + CX2) Then
                                    SendMessage VBFlexGridHandle, WM_HSCROLL, SB_LINERIGHT, ByVal 0&
                                    AutoScroll = True
                                Else
                                    AutoScroll = False
                                End If
                            End If
                        End If
                    Else
                        AutoScroll = False
                    End If
                    If AutoScroll = True Then
                        SetTimer VBFlexGridHandle, IDT_AUTOSCROLL, 50, NULL_PTR
                    Else
                        KillTimer VBFlexGridHandle, IDT_AUTOSCROLL
                    End If
                    Call RedrawGrid
                Else
                    DispatchMessage Msg
                End If
            Case WM_KEYFIRST To WM_KEYLAST
                Select Case Msg.Message
                    Case WM_KEYDOWN
                        If (CLng(Msg.wParam) And &HFF&) = vbKeyEscape Then ReleaseCapture
                End Select
            Case WM_MOUSEFIRST To WM_MOUSELAST
                Select Case Msg.Message
                    Case WM_MOUSEMOVE
                        P.X = Get_X_lParam(Msg.lParam)
                        P.Y = Get_Y_lParam(Msg.lParam)
                        If Dragging = False Then
                            If PtInRect(DragRect, P.X, P.Y) = 0 Then
                                Dragging = True
                                If PtInRect(WndRect, P.X, P.Y) <> 0 Then
                                    SetCursor FlexGetDragCursor(IDC_MOVE)
                                Else
                                    SetCursor FlexGetDragCursor(IDC_NODROP)
                                    NoDrop = True
                                End If
                                VBFlexGridDoDragRow = Row
                                VBFlexGridDoDragCol = Col
                            End If
                        Else
                            LSet HTI.PT = P
                            Call GetHitTestInfo(HTI)
                            If Row > -1 Then
                                If HTI.MouseRow >= PropFixedRows Then
                                    TrackIndex = HTI.MouseRow
                                Else
                                    TrackIndex = PropFixedRows
                                End If
                            ElseIf Col > -1 Then
                                If HTI.MouseCol >= PropFixedCols Then
                                    TrackIndex = HTI.MouseCol
                                Else
                                    TrackIndex = PropFixedCols
                                End If
                            End If
                            If NoDrop = False Then
                                If PtInRect(WndRect, P.X, P.Y) = 0 Then
                                    SetCursor FlexGetDragCursor(IDC_NODROP)
                                    NoDrop = True
                                End If
                            Else
                                If PtInRect(WndRect, P.X, P.Y) <> 0 Then
                                    SetCursor FlexGetDragCursor(IDC_MOVE)
                                    NoDrop = False
                                End If
                            End If
                            If NoDrop = False Then
                                If Row > -1 Then
                                    If (dwStyle And WS_VSCROLL) = WS_VSCROLL Then
                                        If P.Y < ((16 * PixelsPerDIP_Y()) + CY1) Then
                                            SendMessage VBFlexGridHandle, WM_VSCROLL, SB_LINEUP, ByVal 0&
                                            AutoScroll = True
                                        ElseIf (UserControl.ScaleHeight - P.Y) < ((16 * PixelsPerDIP_Y()) + CY2) Then
                                            SendMessage VBFlexGridHandle, WM_VSCROLL, SB_LINEDOWN, ByVal 0&
                                            AutoScroll = True
                                        Else
                                            AutoScroll = False
                                        End If
                                    End If
                                ElseIf Col > -1 Then
                                    If (dwStyle And WS_HSCROLL) = WS_HSCROLL Then
                                        If P.X < ((16 * PixelsPerDIP_X()) + CX1) Then
                                            SendMessage VBFlexGridHandle, WM_HSCROLL, SB_LINELEFT, ByVal 0&
                                            AutoScroll = True
                                        ElseIf (UserControl.ScaleWidth - P.X) < ((16 * PixelsPerDIP_X()) + CX2) Then
                                            SendMessage VBFlexGridHandle, WM_HSCROLL, SB_LINERIGHT, ByVal 0&
                                            AutoScroll = True
                                        Else
                                            AutoScroll = False
                                        End If
                                    End If
                                End If
                            Else
                                AutoScroll = False
                            End If
                            If AutoScroll = True Then
                                SetTimer VBFlexGridHandle, IDT_AUTOSCROLL, 50, NULL_PTR
                            Else
                                KillTimer VBFlexGridHandle, IDT_AUTOSCROLL
                            End If
                        End If
                        Call RedrawGrid
                    Case WM_LBUTTONUP
                        ButtonUp = CBool((Button And vbLeftButton) <> 0)
                        ReleaseCapture
                    Case WM_RBUTTONUP
                        ButtonUp = CBool((Button And vbRightButton) <> 0)
                        ReleaseCapture
                    Case WM_MOUSEWHEEL, WM_MOUSEHWHEEL
                    Case Else
                        ReleaseCapture
                End Select
            Case UM_CAPTURECHANGED
                Exit Do
            Case WM_PAINT
                DispatchMessage Msg
                If Msg.hWnd = VBFlexGridHandle And Msg.wParam = 0 Then
                    If Dragging = True And NoDrop = False Then
                        P.X = 0
                        P.Y = 0
                        If Row > -1 Then
                            If TrackIndex >= (PropFixedRows + PropFrozenRows) Then
                                For i = 0 To ((PropFixedRows + PropFrozenRows) - 1)
                                    P.Y = P.Y + GetRowHeight(i)
                                Next i
                                For i = VBFlexGridTopRow To (TrackIndex - 1)
                                    P.Y = P.Y + GetRowHeight(i)
                                Next i
                            Else
                                For i = 0 To (PropFixedRows - 1)
                                    P.Y = P.Y + GetRowHeight(i)
                                Next i
                                For i = PropFixedRows To (TrackIndex - 1)
                                    P.Y = P.Y + GetRowHeight(i)
                                Next i
                            End If
                        ElseIf Col > -1 Then
                            If TrackIndex >= (PropFixedCols + PropFrozenCols) Then
                                For i = 0 To ((PropFixedCols + PropFrozenCols) - 1)
                                    P.X = P.X + GetColWidth(i)
                                Next i
                                For i = VBFlexGridLeftCol To (TrackIndex - 1)
                                    P.X = P.X + GetColWidth(i)
                                Next i
                            Else
                                For i = 0 To (PropFixedCols - 1)
                                    P.X = P.X + GetColWidth(i)
                                Next i
                                For i = PropFixedCols To (TrackIndex - 1)
                                    P.X = P.X + GetColWidth(i)
                                Next i
                            End If
                        End If
                        LSet SplitterRect = VBFlexGridClientRect
                        With SplitterRect
                        If Row > -1 Then
                            .Top = P.Y - 1
                            .Bottom = P.Y + 1
                        ElseIf Col > -1 Then
                            .Left = P.X - 1
                            .Right = P.X + 1
                        End If
                        End With
                        hDC = GetDC(VBFlexGridHandle)
                        If hDC <> NULL_PTR Then
                            hBmpOld = SelectObject(hDC, FlexGetSplitterBrush())
                            With SplitterRect
                            PatBlt hDC, .Left, .Top, .Right - .Left, .Bottom - .Top, vbPatInvert
                            End With
                            SelectObject hDC, hBmpOld
                            ReleaseDC VBFlexGridHandle, hDC
                            hDC = NULL_PTR
                        End If
                    End If
                End If
            Case Else
                DispatchMessage Msg
        End Select
    Wend
    WaitMessage
Loop
If AutoScroll = True Then KillTimer VBFlexGridHandle, IDT_AUTOSCROLL
If ButtonUp = True And Dragging = True And NoDrop = False Then
    DoDragRowCol = TrackIndex
    If Row > -1 Then
        If VBFlexGridSelectedRows > 0 Then
            Erase VBFlexGridSelectedRowIndices()
            VBFlexGridSelectedRows = 0
        End If
    End If
End If
VBFlexGridDoDragRow = -1
VBFlexGridDoDragCol = -1
VBFlexGridDoDragRowCol = False
Call RedrawGrid
End Function

Private Sub StartIncrementalSearch(ByVal CharCode As Long)
If PropRows < 1 Or PropCols < 1 Then Exit Sub
If VBFlexGridIncrementalSearch.CancellationPending = True Then Exit Sub
Select Case CharCode
    Case 8 ' Backspace
        If VBFlexGridIncrementalSearch.SearchString = vbNullString Then Exit Sub
    Case 10 ' Linefeed
    Case 13, 27 ' Carriage return, Escape
        If Not VBFlexGridIncrementalSearch.SearchString = vbNullString Then Call CancelIncrementalSearch
        Exit Sub
    Case 0 To 31 ' Non-printable
        Exit Sub
    Case 32 ' Space
        If VBFlexGridIncrementalSearch.SearchString = vbNullString Then Exit Sub
End Select
If TimerIncrementalSearch.Enabled = True Then
    TimerIncrementalSearch.Enabled = False
    TimerIncrementalSearch.Interval = 0
End If
If VBFlexGridRow > -1 And VBFlexGridCol > -1 Then
    With VBFlexGridIncrementalSearch
    Dim Row As Long, Col As Long, Cancel As Boolean
    Row = VBFlexGridRow
    Col = VBFlexGridCol
    If PropSelectionMode <> FlexSelectionModeByColumn Then
        If Row < PropFixedRows Then Row = PropFixedRows
    Else
        If Col < PropFixedCols Then Col = PropFixedCols
    End If
    If .SearchString = vbNullString Then
        .CaseSensitive = False
        .NoWrap = False
        If PropSelectionMode <> FlexSelectionModeByColumn Then
            .Direction = FlexFindDirectionDown
        Else
            .Direction = FlexFindDirectionRight
        End If
        RaiseEvent BeginIncrementalSearch(Row, Col, .CaseSensitive, .NoWrap, .Direction, Cancel)
        Select Case PropSelectionMode
            Case FlexSelectionModeFree, FlexSelectionModeFreeByRow, FlexSelectionModeFreeByColumn
                Select Case .Direction
                    Case FlexFindDirectionDown, FlexFindDirectionUp, FlexFindDirectionRight, FlexFindDirectionLeft
                    Case Else
                        .Direction = FlexFindDirectionDown
                End Select
            Case FlexSelectionModeByRow
                Select Case .Direction
                    Case FlexFindDirectionDown, FlexFindDirectionUp
                    Case FlexFindDirectionRight
                        .Direction = FlexFindDirectionDown
                    Case FlexFindDirectionLeft
                        .Direction = FlexFindDirectionUp
                    Case Else
                        .Direction = FlexFindDirectionDown
                End Select
            Case FlexSelectionModeByColumn
                Select Case .Direction
                    Case FlexFindDirectionRight, FlexFindDirectionLeft
                    Case FlexFindDirectionDown
                        .Direction = FlexFindDirectionRight
                    Case FlexFindDirectionUp
                        .Direction = FlexFindDirectionLeft
                    Case Else
                        .Direction = FlexFindDirectionRight
                End Select
        End Select
    End If
    If Cancel = False Then
        Dim NewSearchString As String
        If CharCode = 8 Then ' Backspace
            NewSearchString = Left$(.SearchString, Len(.SearchString) - 1)
        Else
            NewSearchString = .SearchString & ChrW(CharCode)
        End If
        If Not NewSearchString = vbNullString Then
            Dim FoundIndex As Long
            FoundIndex = -1
            If (Row >= 0 And Row <= (PropRows - 1)) And (Col >= 0 And Col <= (PropCols - 1)) Then
                Select Case .Direction
                    Case FlexFindDirectionDown, FlexFindDirectionUp
                        If Row < PropFixedRows Then Row = PropFixedRows
                    Case FlexFindDirectionRight, FlexFindDirectionLeft
                        If Col < PropFixedCols Then Col = PropFixedCols
                End Select
                FoundIndex = Me.FindItem(NewSearchString, Row, Col, FlexFindMatchStartsWith, .CaseSensitive, True, Not .NoWrap, .Direction, True)
            End If
            Select Case .Direction
                Case FlexFindDirectionDown, FlexFindDirectionUp
                    Row = FoundIndex
                Case FlexFindDirectionRight, FlexFindDirectionLeft
                    Col = FoundIndex
            End Select
            If (Row >= 0 And Row <= (PropRows - 1)) And (Col >= 0 And Col <= (PropCols - 1)) Then
                .SearchString = NewSearchString
                .Row = Row
                .Col = Col
                Dim RCP As TROWCOLPARAMS
                RCP.Mask = RCPM_TOPROW Or RCPM_LEFTCOL
                RCP.Flags = RCPF_FORCEREDRAW
                RCP.Message = WM_CHAR
                If PropSelectionMode <> FlexSelectionModeByColumn Then
                    RCP.Mask = RCP.Mask Or RCPM_ROW Or RCPM_ROWSEL
                    RCP.Row = .Row
                    RCP.RowSel = .Row
                End If
                If PropSelectionMode <> FlexSelectionModeByRow Then
                    RCP.Mask = RCP.Mask Or RCPM_COL Or RCPM_COLSEL
                    RCP.Col = .Col
                    RCP.ColSel = .Col
                End If
                RCP.TopRow = VBFlexGridTopRow
                RCP.LeftCol = VBFlexGridLeftCol
                If RCP.TopRow > .Row Then
                    If .Row >= (PropFixedRows + PropFrozenRows) Then RCP.TopRow = .Row
                ElseIf .Row > (RCP.TopRow + GetRowsPerPage(RCP.TopRow) - 1) Then
                    RCP.TopRow = .Row - GetRowsPerPageRev(.Row) + 1
                End If
                If RCP.LeftCol > .Col Then
                    If .Col >= (PropFixedCols + PropFrozenCols) Then RCP.LeftCol = .Col
                ElseIf .Col > (RCP.LeftCol + GetColsPerPage(RCP.LeftCol) - 1) Then
                    RCP.LeftCol = .Col - GetColsPerPageRev(.Col) + 1
                End If
                Call SetRowColParams(RCP)
            ElseIf .SearchString = vbNullString Then
                Cancel = True
            End If
            .NoLostFocus = True
            RaiseEvent IncrementalSearch(Row, Col, CharCode, .CaseSensitive, .NoWrap, .Direction, FoundIndex)
            .NoLostFocus = False
            If Cancel = True Then
                ' Fire end event immediately with row/col of -1 as an alias that the incremental search could not begin at all.
                RaiseEvent EndIncrementalSearch(-1, -1)
                Exit Sub
            End If
        Else
            Call CancelIncrementalSearch
            Exit Sub
        End If
    ElseIf PropAllowUserEditing = True Then
        If CreateEdit(FlexEditReasonKeyPress) = True Then
            If VBFlexGridEditHandle <> NULL_PTR Then PostMessage VBFlexGridEditHandle, WM_CHAR, CharCode, ByVal 0&
        End If
    End If
    End With
End If
If Not VBFlexGridIncrementalSearch.SearchString = vbNullString Then
    TimerIncrementalSearch.Interval = GetIncrementalSearchTime()
    TimerIncrementalSearch.Enabled = True
End If
End Sub

Private Sub CancelIncrementalSearch(Optional ByVal NoRedraw As Boolean)
If TimerIncrementalSearch.Enabled = True Then
    TimerIncrementalSearch.Enabled = False
    TimerIncrementalSearch.Interval = 0
End If
With VBFlexGridIncrementalSearch
.SearchString = vbNullString
If .Row > -1 And .Col > -1 Then
    Dim Row As Long, Col As Long
    Row = .Row: .Row = -1
    Col = .Col: .Col = -1
    If NoRedraw = False Then Call RedrawGrid
    If VBFlexGridHandle <> NULL_PTR Then
        .CancellationPending = True
        PostMessage VBFlexGridHandle, UM_ENDINCREMENTALSEARCH, Row, ByVal Col
    End If
End If
End With
End Sub

Private Sub DrawIncrementalSearch(ByVal hDC As LongPtr, ByRef Text As String, ByRef TextRect As RECT, ByVal DrawFlags As Long, Optional ByRef SearchOffset As Long)
If hDC = NULL_PTR Then Exit Sub
Dim RCInvert As RECT, RCInvertText As RECT, InvertText As String, InvertResult As Long, InvertOffset As Long
LSet RCInvert = TextRect
LSet RCInvertText = TextRect
InvertText = Text
If Not (DrawFlags And DT_SINGLELINE) = DT_SINGLELINE Then
    Dim pDrawTextParams As DRAWTEXTPARAMS, RC As RECT
    pDrawTextParams.cbSize = LenB(pDrawTextParams)
    SetRect RC, TextRect.Left, TextRect.Top, TextRect.Right, TextRect.Top
    DrawTextEx hDC, StrPtr(InvertText), -1, RC, DrawFlags, pDrawTextParams
    With pDrawTextParams
    If .uiLengthDrawn < Len(InvertText) Then
        If (DrawFlags And DT_WORDBREAK) = DT_WORDBREAK Then
            Select Case Mid$(InvertText, .uiLengthDrawn, 1)
                Case " ", vbCr, vbLf
                    .uiLengthDrawn = .uiLengthDrawn - 1
            End Select
        Else
            Select Case Mid$(InvertText, .uiLengthDrawn, 1)
                Case vbCr, vbLf
                    .uiLengthDrawn = .uiLengthDrawn - 1
            End Select
        End If
        InvertText = Left$(InvertText, .uiLengthDrawn)
    End If
    End With
End If
Dim Pos As Long, Compare As VbCompareMethod
If VBFlexGridIncrementalSearch.CaseSensitive = False Then Compare = vbTextCompare Else Compare = vbBinaryCompare
For Pos = 0 To (Len(InvertText) - 1)
    If (Pos + SearchOffset) < Len(VBFlexGridIncrementalSearch.SearchString) Then
        If StrComp(Mid$(InvertText, Pos + 1, 1), Mid$(VBFlexGridIncrementalSearch.SearchString, Pos + SearchOffset + 1, 1), Compare) <> 0 Then Exit For
    Else
        Exit For
    End If
Next Pos
If Not InvertText = vbNullString Then
    InvertResult = DrawText(hDC, StrPtr(Left$(InvertText, Pos)), -1, RCInvert, DrawFlags Or DT_CALCRECT)
    DrawText hDC, StrPtr(InvertText), -1, RCInvertText, DrawFlags Or DT_CALCRECT
    If (DrawFlags And DT_CENTER) = DT_CENTER Then
        InvertOffset = (((TextRect.Right - TextRect.Left) - (RCInvertText.Right - RCInvertText.Left)) \ 2)
        RCInvert.Left = RCInvert.Left + InvertOffset
        RCInvert.Right = RCInvert.Right + InvertOffset
    ElseIf (DrawFlags And DT_RIGHT) = DT_RIGHT Then
        InvertOffset = ((TextRect.Right - TextRect.Left) - (RCInvertText.Right - RCInvertText.Left))
        RCInvert.Left = RCInvert.Left + InvertOffset
        RCInvert.Right = RCInvert.Right + InvertOffset
    End If
    If (DrawFlags And DT_VCENTER) = DT_VCENTER Or (DrawFlags And DT_BOTTOM) = DT_BOTTOM Then
        InvertOffset = ((TextRect.Bottom - TextRect.Top) - InvertResult)
        If InvertOffset > 0 Then RCInvert.Top = RCInvert.Top + InvertOffset
    End If
Else
    Dim TM As TEXTMETRIC
    If GetTextMetrics(hDC, TM) <> 0 Then SetRect RCInvert, TextRect.Left, TextRect.Top, TextRect.Right, TextRect.Top + TM.TMHeight
End If
If Not (DrawFlags And DT_SINGLELINE) = DT_SINGLELINE Then
    If Mid$(VBFlexGridIncrementalSearch.SearchString, Pos + SearchOffset + 1, 1) = Mid$(Text, Len(InvertText) + 1, 1) Then
        Text = Mid$(Text, Len(InvertText) + 2)
        SearchOffset = SearchOffset + Len(InvertText) + 1
    Else
        Text = vbNullString
        SearchOffset = 0
    End If
Else
    Text = vbNullString
    SearchOffset = 0
End If
With RCInvert
If .Left < TextRect.Left Then .Left = TextRect.Left
If .Top < TextRect.Top Then .Top = TextRect.Top
If .Right > TextRect.Right Then .Right = TextRect.Right
If .Bottom > TextRect.Bottom Then .Bottom = TextRect.Bottom
If .Right >= .Left And .Bottom >= .Top Then
    InvertRect hDC, RCInvert
    If Not Text = vbNullString Then
        TextRect.Top = TextRect.Top + (.Bottom - .Top)
        If TextRect.Bottom >= TextRect.Top Then Call DrawIncrementalSearch(hDC, Text, TextRect, DrawFlags, SearchOffset)
    End If
End If
End With
End Sub

Private Sub StartReaderMode(ByVal wParam As LongPtr, ByVal lParam As LongPtr)
If VBFlexGridHandle = NULL_PTR Then Exit Sub
Dim dwStyle As Long, SCI(0 To 1) As SCROLLINFO, ScrollBars As Integer
dwStyle = GetWindowLong(VBFlexGridHandle, GWL_STYLE)
SCI(0).cbSize = LenB(SCI(0))
SCI(0).fMask = SIF_RANGE
LSet SCI(1) = SCI(0)
If (dwStyle And WS_HSCROLL) = WS_HSCROLL And (dwStyle And WS_VSCROLL) = WS_VSCROLL Then
    GetScrollInfo VBFlexGridHandle, SB_HORZ, SCI(0)
    GetScrollInfo VBFlexGridHandle, SB_VERT, SCI(1)
    If SCI(0).nMax > SCI(0).nMin Then
        If SCI(1).nMax > SCI(1).nMin Then
            ScrollBars = vbBoth
        Else
            ScrollBars = vbHorizontal
        End If
    Else
        If SCI(1).nMax > SCI(1).nMin Then
            ScrollBars = vbVertical
        Else
            ScrollBars = vbSBNone
        End If
    End If
ElseIf Not (dwStyle And WS_HSCROLL) = WS_HSCROLL And (dwStyle And WS_VSCROLL) = WS_VSCROLL Then
    GetScrollInfo VBFlexGridHandle, SB_VERT, SCI(1)
    If SCI(1).nMax > SCI(1).nMin Then
        ScrollBars = vbVertical
    Else
        ScrollBars = vbSBNone
    End If
ElseIf (dwStyle And WS_HSCROLL) = WS_HSCROLL And Not (dwStyle And WS_VSCROLL) = WS_VSCROLL Then
    GetScrollInfo VBFlexGridHandle, SB_HORZ, SCI(0)
    If SCI(0).nMax > SCI(0).nMin Then
        ScrollBars = vbHorizontal
    Else
        ScrollBars = vbSBNone
    End If
Else
    ScrollBars = vbSBNone
End If
Call FlexDoReaderMode(VBFlexGridHandle, ScrollBars, wParam, lParam)
End Sub

Private Function MergeCompareFunction(ByVal Row1 As Long, ByVal Col1 As Long, ByVal Row2 As Long, ByVal Col2 As Long) As Boolean
Dim Text1 As String, Text2 As String
Call GetCellText(Row1, Col1, Text1)
Call GetCellText(Row2, Col2, Text2)
If Text1 = vbNullString Or Text2 = vbNullString Then Exit Function
If StrComp(Text1, Text2) = 0 Then MergeCompareFunction = True
End Function

Private Sub DrawDividerDragSplitter(Optional ByVal hRgn As LongPtr)
If VBFlexGridHandle = NULL_PTR Or VBFlexGridCaptureDividerDrag = False Or FlexGetSplitterBrush() = NULL_PTR Then Exit Sub
Dim hDC As LongPtr, hBmpOld As LongPtr
hDC = GetDC(VBFlexGridHandle)
If hDC <> NULL_PTR Then
    hBmpOld = SelectObject(hDC, FlexGetSplitterBrush())
    If hRgn <> NULL_PTR Then ExtSelectClipRgn hDC, hRgn, RGN_COPY
    With VBFlexGridDividerDragSplitterRect
    PatBlt hDC, .Left, .Top, .Right - .Left, .Bottom - .Top, vbPatInvert
    End With
    If hRgn <> NULL_PTR Then ExtSelectClipRgn hDC, NULL_PTR, RGN_COPY
    SelectObject hDC, hBmpOld
    ReleaseDC VBFlexGridHandle, hDC
End If
End Sub

Private Sub SetDividerDragSplitterRect(ByVal X As Long, ByVal Y As Long)
If VBFlexGridHandle = NULL_PTR Or VBFlexGridCaptureDividerDrag = False Then Exit Sub
LSet VBFlexGridDividerDragSplitterRect = VBFlexGridClientRect
With VBFlexGridDividerDragSplitterRect
Select Case VBFlexGridCaptureHitResult
    Case FlexHitResultDividerRowTop, FlexHitResultDividerRowBottom, FlexHitResultDividerFrozenRowTop, FlexHitResultDividerFrozenRowBottom
        .Top = Y - 1
        .Bottom = Y + 1
    Case FlexHitResultDividerColumnLeft, FlexHitResultDividerColumnRight, FlexHitResultDividerFrozenColumnLeft, FlexHitResultDividerFrozenColumnRight
        .Left = X - 1
        .Right = X + 1
End Select
End With
End Sub

Private Sub GetSortArrowMetrics(ByVal hDC As LongPtr, ByRef SortArrowMetrics As TSORTARROWMETRICS)
If hDC = NULL_PTR Then Exit Sub
With SortArrowMetrics
Dim TM As TEXTMETRIC
If GetTextMetrics(hDC, TM) <> 0 Then
    .CalcSize.CX = TM.TMAveCharWidth
    If .CalcSize.CX < 3 Then .CalcSize.CX = 3
    If .CalcSize.CX Mod 2 Then .CalcSize.CX = .CalcSize.CX + 1
    .CalcSize.CY = .CalcSize.CX \ 2
    .DrawSize.CX = .CalcSize.CX + 1
    .DrawSize.CY = .CalcSize.CY + 1
    .ClientSize.CX = .DrawSize.CX + VBFlexGridPixelMetrics.TextPadding.CX
    .ClientSize.CY = TM.TMHeight
Else
    .CalcSize.CX = 0
    .CalcSize.CY = 0
    .DrawSize.CX = 0
    .DrawSize.CY = 0
    .ClientSize.CX = 0
    .ClientSize.CY = 0
End If
End With
End Sub

Private Sub DrawSortArrow(ByVal hDC As LongPtr, ByVal Color As Long, ByRef P() As POINTAPI, ByRef ClipRgn As RECT)
If hDC = NULL_PTR Then Exit Sub
Dim hRgn As LongPtr
hRgn = CreateRectRgn(0, 0, 0, 0)
If hRgn <> NULL_PTR Then
    If GetClipRgn(hDC, hRgn) = 0 Then
        DeleteObject hRgn
        hRgn = NULL_PTR
    End If
End If
IntersectClipRect hDC, ClipRgn.Left, ClipRgn.Top, ClipRgn.Right, ClipRgn.Bottom
Dim Brush As LongPtr, OldBrush As LongPtr
Brush = CreateSolidBrush(Color)
If Brush <> NULL_PTR Then OldBrush = SelectObject(hDC, Brush)
Dim hPen As LongPtr, hPenOld As LongPtr
hPen = CreatePen(PS_SOLID, 0, Color)
If hPen <> NULL_PTR Then hPenOld = SelectObject(hDC, hPen)
Polygon hDC, P(0), 3
If hPenOld <> NULL_PTR Then
    SelectObject hDC, hPenOld
    hPenOld = NULL_PTR
End If
If hPen <> NULL_PTR Then
    DeleteObject hPen
    hPen = NULL_PTR
End If
If OldBrush <> NULL_PTR Then
    SelectObject hDC, OldBrush
    OldBrush = NULL_PTR
End If
If Brush <> NULL_PTR Then
    DeleteObject Brush
    Brush = NULL_PTR
End If
If hRgn <> NULL_PTR Then
    ExtSelectClipRgn hDC, hRgn, RGN_COPY
    DeleteObject hRgn
    hRgn = NULL_PTR
Else
    ExtSelectClipRgn hDC, NULL_PTR, RGN_COPY
End If
End Sub

Private Sub DrawCellCheckBox(ByVal hDC As LongPtr, ByRef RC As RECT, ByRef ClipRect As RECT, ByRef Text As String, ByVal iRow As Long, ByVal iCol As Long, ByVal Checked As Integer)
If hDC = NULL_PTR Then Exit Sub
Select Case Checked
    Case FlexTextAsCheckBox, FlexDisabledTextAsCheckBox
        If Not Text = vbNullString Then
            On Error Resume Next
            If CBool(Text) = False Then
                If Checked = FlexTextAsCheckBox Then Checked = FlexUnchecked Else Checked = FlexDisabledUnchecked
            Else
                If Checked = FlexTextAsCheckBox Then Checked = FlexChecked Else Checked = FlexDisabledChecked
            End If
            On Error GoTo 0
        Else
            If Checked = FlexTextAsCheckBox Then Checked = FlexGrayed Else Checked = FlexDisabledGrayed
        End If
End Select
Dim hRgnOld As LongPtr
hRgnOld = CreateRectRgn(0, 0, 0, 0)
If hRgnOld <> NULL_PTR Then
    If GetClipRgn(hDC, hRgnOld) = 0 Then
        DeleteObject hRgnOld
        hRgnOld = NULL_PTR
    End If
End If
IntersectClipRect hDC, ClipRect.Left, ClipRect.Top, ClipRect.Right, ClipRect.Bottom
Dim Handled As Boolean
If VBFlexGridCheckBoxDrawMode <> FlexCheckBoxDrawModeNormal Then
    Dim Cancel As Boolean, ItemState As Long, RCItem As RECT, P As POINTAPI
    Select Case Checked
        Case FlexChecked, FlexDisabledChecked
            ItemState = ItemState Or ODS_CHECKED
        Case FlexGrayed, FlexDisabledGrayed
            ItemState = ItemState Or ODS_GRAYED
    End Select
    Select Case Checked
        Case FlexUnchecked, FlexChecked, FlexGrayed
            If VBFlexGridHotRow = iRow And VBFlexGridHotCol = iCol And VBFlexGridHotHitResult = FlexHitResultCheckBox Then ItemState = ItemState Or ODS_HOTLIGHT
        Case FlexDisabledUnchecked, FlexDisabledChecked, FlexDisabledGrayed
            ItemState = ItemState Or ODS_DISABLED
    End Select
    RCItem.Left = 0
    RCItem.Top = 0
    RCItem.Right = RC.Right - RC.Left
    RCItem.Bottom = RC.Bottom - RC.Top
    SetViewportOrgEx hDC, RC.Left, RC.Top, P
    #If Win64 Then
    Dim hDC32 As Long
    CopyMemory ByVal VarPtr(hDC32), ByVal VarPtr(hDC), 4
    RaiseEvent CheckBoxOwnerDraw(iRow, iCol, Cancel, ItemState, hDC32, RCItem.Left, RCItem.Top, RCItem.Right, RCItem.Bottom)
    #Else
    RaiseEvent CheckBoxOwnerDraw(iRow, iCol, Cancel, ItemState, hDC, RCItem.Left, RCItem.Top, RCItem.Right, RCItem.Bottom)
    #End If
    SetViewportOrgEx hDC, P.X, P.Y, P
    Handled = Not Cancel
End If
If Handled = False Then
    Dim Theme As LongPtr
    
    #If ImplementThemedControls = True Then
    
    If VBFlexGridHandle <> NULL_PTR Then
        If VBFlexGridEnabledVisualStyles = True And PropVisualStyles = True Then Theme = OpenThemeData(VBFlexGridHandle, StrPtr("Button"))
        If Theme <> NULL_PTR Then
            Dim CheckState As Long
            Select Case Checked
                Case FlexUnchecked
                    If VBFlexGridHotRow = iRow And VBFlexGridHotCol = iCol And VBFlexGridHotHitResult = FlexHitResultCheckBox Then
                        CheckState = CBS_UNCHECKEDHOT
                    Else
                        CheckState = CBS_UNCHECKEDNORMAL
                    End If
                Case FlexChecked
                    If VBFlexGridHotRow = iRow And VBFlexGridHotCol = iCol And VBFlexGridHotHitResult = FlexHitResultCheckBox Then
                        CheckState = CBS_CHECKEDHOT
                    Else
                        CheckState = CBS_CHECKEDNORMAL
                    End If
                Case FlexGrayed
                    If VBFlexGridHotRow = iRow And VBFlexGridHotCol = iCol And VBFlexGridHotHitResult = FlexHitResultCheckBox Then
                        CheckState = CBS_MIXEDHOT
                    Else
                        CheckState = CBS_MIXEDNORMAL
                    End If
                Case FlexDisabledUnchecked
                    CheckState = CBS_UNCHECKEDDISABLED
                Case FlexDisabledChecked
                    CheckState = CBS_CHECKEDDISABLED
                Case FlexDisabledGrayed
                    CheckState = CBS_MIXEDDISABLED
            End Select
            If IsThemeBackgroundPartiallyTransparent(Theme, BP_CHECKBOX, CheckState) <> 0 Then DrawThemeParentBackground VBFlexGridHandle, hDC, RC
            DrawThemeBackground Theme, hDC, BP_CHECKBOX, CheckState, RC, ByVal NULL_PTR
            CloseThemeData Theme
        End If
    End If
    
    #End If
    
    If Theme = NULL_PTR Then
        Dim Flags As Long
        Flags = DFCS_BUTTONCHECK Or DFCS_FLAT
        Select Case Checked
            Case FlexChecked, FlexDisabledChecked
                Flags = Flags Or DFCS_CHECKED
        End Select
        Select Case Checked
            Case FlexUnchecked, FlexChecked, FlexGrayed
                If VBFlexGridHotRow = iRow And VBFlexGridHotCol = iCol And VBFlexGridHotHitResult = FlexHitResultCheckBox Then Flags = Flags Or DFCS_HOT
            Case FlexDisabledUnchecked, FlexDisabledChecked, FlexDisabledGrayed
                Flags = Flags Or DFCS_INACTIVE
        End Select
        DrawFrameControl hDC, RC, DFC_BUTTON, Flags
        Select Case Checked
            Case FlexGrayed, FlexDisabledGrayed
                ' DrawFrameControl does not support indeterminate checkboxes.
                ' We fill a rectangle inside the checkbox like IE10 does.
                Dim Padding As Long, Brush As LongPtr
                Padding = (RC.Right - RC.Left) * 4 / 13
                RC.Left = RC.Left + Padding
                RC.Top = RC.Top + Padding
                RC.Right = RC.Right - Padding
                RC.Bottom = RC.Bottom - Padding
                If Not (Flags And DFCS_INACTIVE) = DFCS_INACTIVE Then
                    If Not (Flags And DFCS_HOT) = DFCS_HOT Then
                        Brush = GetSysColorBrush(COLOR_WINDOWTEXT)
                    Else
                        Brush = GetSysColorBrush(COLOR_HOTLIGHT)
                    End If
                Else
                    Brush = GetSysColorBrush(COLOR_GRAYTEXT)
                End If
                FillRect hDC, RC, Brush
        End Select
    End If
End If
If hRgnOld <> NULL_PTR Then
    ExtSelectClipRgn hDC, hRgnOld, RGN_COPY
    DeleteObject hRgnOld
    hRgnOld = NULL_PTR
Else
    ExtSelectClipRgn hDC, NULL_PTR, RGN_COPY
End If
End Sub

Private Sub SetCellCheck(ByVal iRow As Long, ByVal iCol As Long, ByVal Reason As FlexCellCheckReasonConstants)
If PropRows < 1 Or PropCols < 1 Then Exit Sub
Dim Checked As Integer
Checked = GetCellChecked(iRow, iCol)
If Checked > -1 Then
    Select Case Checked
        Case FlexUnchecked, FlexChecked, FlexGrayed, FlexTextAsCheckBox
            Dim Cancel As Boolean
            RaiseEvent CellBeforeCheck(iRow, iCol, Reason, Cancel)
            If Cancel = False Then
                Select Case Checked
                    Case FlexUnchecked
                        Call SetCellChecked(iRow, iCol, FlexChecked)
                        Call RedrawGrid
                    Case FlexChecked, FlexGrayed
                        Call SetCellChecked(iRow, iCol, FlexUnchecked)
                        Call RedrawGrid
                End Select
                RaiseEvent CellCheck(iRow, iCol)
            End If
    End Select
End If
End Sub

Private Sub DrawCellFlooding(ByVal hDC As LongPtr, ByRef CellRect As RECT, ByVal Percent As Integer, ByVal Color As Long)
If hDC = NULL_PTR Then Exit Sub
Dim RC As RECT, OldColor As Long
RC.Top = CellRect.Top
RC.Bottom = CellRect.Bottom
OldColor = SetBkColor(hDC, Color)
If Percent > 0 Then
    RC.Left = CellRect.Left
    RC.Right = CellRect.Left + ((CellRect.Right - CellRect.Left) * (Percent / 100#))
    ExtTextOut hDC, 0, 0, ETO_OPAQUE, RC, NULL_PTR, 0, NULL_PTR
ElseIf Percent < 0 Then
    RC.Left = CellRect.Right - ((CellRect.Right - CellRect.Left) * (-Percent / 100#))
    RC.Right = CellRect.Right
    ExtTextOut hDC, 0, 0, ETO_OPAQUE, RC, NULL_PTR, 0, NULL_PTR
End If
SetBkColor hDC, OldColor
End Sub

Private Function GetClipSeparatorCol() As String
If PropClipSeparators = vbNullString Then
    GetClipSeparatorCol = VBFlexGridClipSeparatorCol
Else
    GetClipSeparatorCol = Left$(PropClipSeparators, 1)
End If
End Function

Private Function GetClipSeparatorRow() As String
If PropClipSeparators = vbNullString Then
    GetClipSeparatorRow = VBFlexGridClipSeparatorRow
Else
    GetClipSeparatorRow = Right$(PropClipSeparators, 1)
End If
End Function

Private Sub SetVisualStylesToolTip()
If VBFlexGridHandle <> NULL_PTR Then
    If VBFlexGridToolTipHandle <> NULL_PTR And VBFlexGridEnabledVisualStyles = True Then
        If PropVisualStyles = True Then
            ActivateVisualStyles VBFlexGridToolTipHandle
        Else
            RemoveVisualStyles VBFlexGridToolTipHandle
        End If
    End If
End If
End Sub

Private Sub SetVisualStylesScrollTip()
If VBFlexGridHandle <> NULL_PTR Then
    If VBFlexGridScrollTipHandle <> NULL_PTR And VBFlexGridEnabledVisualStyles = True Then
        If PropVisualStyles = True Then
            ActivateVisualStyles VBFlexGridScrollTipHandle
        Else
            RemoveVisualStyles VBFlexGridScrollTipHandle
        End If
    End If
End If
End Sub

Private Sub SetIMEMode(ByVal hWnd As LongPtr, ByVal hIMCOrig As LongPtr, ByVal Value As FlexIMEModeConstants)
Const IME_CMODE_ALPHANUMERIC As Long = &H0, IME_CMODE_NATIVE As Long = &H1, IME_CMODE_KATAKANA As Long = &H2, IME_CMODE_FULLSHAPE As Long = &H8
Dim hKL As LongPtr
hKL = GetKeyboardLayout(0)
If ImmIsIME(hKL) = NULL_PTR Or hIMCOrig = NULL_PTR Then Exit Sub
Dim hIMC As LongPtr
hIMC = ImmGetContext(hWnd)
If Value = FlexIMEModeDisable Then
    If hIMC <> NULL_PTR Then
        ImmReleaseContext hWnd, hIMC
        ImmAssociateContext hWnd, NULL_PTR
    End If
Else
    If hIMC = NULL_PTR Then
        ImmAssociateContext hWnd, hIMCOrig
        hIMC = ImmGetContext(hWnd)
    End If
    If hIMC <> NULL_PTR And Value <> FlexIMEModeNoControl Then
        Dim dwConversion As Long, dwSentence As Long
        ImmGetConversionStatus hIMC, VarPtr(dwConversion), VarPtr(dwSentence)
        Select Case Value
            Case FlexIMEModeOn
                ImmSetOpenStatus hIMC, 1
            Case FlexIMEModeOff
                ImmSetOpenStatus hIMC, 0
            Case FlexIMEModeHiragana
                ImmSetOpenStatus hIMC, 1
                If Not (dwConversion And IME_CMODE_NATIVE) = IME_CMODE_NATIVE Then dwConversion = dwConversion Or IME_CMODE_NATIVE
                If Not (dwConversion And IME_CMODE_FULLSHAPE) = IME_CMODE_FULLSHAPE Then dwConversion = dwConversion Or IME_CMODE_FULLSHAPE
                If (dwConversion And IME_CMODE_KATAKANA) = IME_CMODE_KATAKANA Then dwConversion = dwConversion And Not IME_CMODE_KATAKANA
            Case FlexIMEModeKatakana
                ImmSetOpenStatus hIMC, 1
                If Not (dwConversion And IME_CMODE_NATIVE) = IME_CMODE_NATIVE Then dwConversion = dwConversion Or IME_CMODE_NATIVE
                If Not (dwConversion And IME_CMODE_KATAKANA) = IME_CMODE_KATAKANA Then dwConversion = dwConversion Or IME_CMODE_KATAKANA
                If Not (dwConversion And IME_CMODE_FULLSHAPE) = IME_CMODE_FULLSHAPE Then dwConversion = dwConversion Or IME_CMODE_FULLSHAPE
            Case FlexIMEModeKatakanaHalf
                ImmSetOpenStatus hIMC, 1
                If Not (dwConversion And IME_CMODE_NATIVE) = IME_CMODE_NATIVE Then dwConversion = dwConversion Or IME_CMODE_NATIVE
                If Not (dwConversion And IME_CMODE_KATAKANA) = IME_CMODE_KATAKANA Then dwConversion = dwConversion Or IME_CMODE_KATAKANA
                If (dwConversion And IME_CMODE_FULLSHAPE) = IME_CMODE_FULLSHAPE Then dwConversion = dwConversion And Not IME_CMODE_FULLSHAPE
            Case FlexIMEModeAlphaFull
                ImmSetOpenStatus hIMC, 1
                If Not (dwConversion And IME_CMODE_FULLSHAPE) = IME_CMODE_FULLSHAPE Then dwConversion = dwConversion Or IME_CMODE_FULLSHAPE
                If (dwConversion And IME_CMODE_NATIVE) = IME_CMODE_NATIVE Then dwConversion = dwConversion And Not IME_CMODE_NATIVE
                If (dwConversion And IME_CMODE_KATAKANA) = IME_CMODE_KATAKANA Then dwConversion = dwConversion And Not IME_CMODE_KATAKANA
            Case FlexIMEModeAlpha
                ImmSetOpenStatus hIMC, 1
                If Not (dwConversion And IME_CMODE_ALPHANUMERIC) = IME_CMODE_ALPHANUMERIC Then dwConversion = dwConversion Or IME_CMODE_ALPHANUMERIC
                If (dwConversion And IME_CMODE_NATIVE) = IME_CMODE_NATIVE Then dwConversion = dwConversion And Not IME_CMODE_NATIVE
                If (dwConversion And IME_CMODE_KATAKANA) = IME_CMODE_KATAKANA Then dwConversion = dwConversion And Not IME_CMODE_KATAKANA
                If (dwConversion And IME_CMODE_FULLSHAPE) = IME_CMODE_FULLSHAPE Then dwConversion = dwConversion And Not IME_CMODE_FULLSHAPE
            Case FlexIMEModeHangulFull
                ImmSetOpenStatus hIMC, 1
                If Not (dwConversion And IME_CMODE_NATIVE) = IME_CMODE_NATIVE Then dwConversion = dwConversion Or IME_CMODE_NATIVE
                If Not (dwConversion And IME_CMODE_FULLSHAPE) = IME_CMODE_FULLSHAPE Then dwConversion = dwConversion Or IME_CMODE_FULLSHAPE
            Case FlexIMEModeHangul
                ImmSetOpenStatus hIMC, 1
                If Not (dwConversion And IME_CMODE_NATIVE) = IME_CMODE_NATIVE Then dwConversion = dwConversion Or IME_CMODE_NATIVE
                If (dwConversion And IME_CMODE_FULLSHAPE) = IME_CMODE_FULLSHAPE Then dwConversion = dwConversion And Not IME_CMODE_FULLSHAPE
        End Select
        ImmSetConversionStatus hIMC, dwConversion, dwSentence
        ImmReleaseContext hWnd, hIMC
    End If
End If
End Sub

Private Sub UpdateToolTipRect()
If VBFlexGridHandle <> NULL_PTR And VBFlexGridToolTipHandle <> NULL_PTR Then
    Dim TI As TOOLINFO
    With TI
    .cbSize = LenB(TI)
    .hWnd = VBFlexGridHandle
    .uId = 0
    LSet .RC = VBFlexGridClientRect
    SendMessage VBFlexGridToolTipHandle, TTM_NEWTOOLRECT, 0, ByVal VarPtr(TI)
    End With
End If
End Sub

Private Sub UpdateToolTipFont(ByVal iRow As Long, ByVal iCol As Long, ByVal InfoTip As Boolean)
If VBFlexGridHandle <> NULL_PTR And VBFlexGridToolTipHandle <> NULL_PTR Then
    If iRow > -1 And iCol > -1 And InfoTip = False Then
        Dim OldFontHandle As LongPtr
        OldFontHandle = VBFlexGridFontToolTipHandle
        Dim CellFmtg As TCELLFMTG
        Call GetCellFmtg(iRow, iCol, CFM_FONT, CellFmtg)
        With CellFmtg
        If .FontName = vbNullString Then
            If iRow > (PropFixedRows - 1) And iCol > (PropFixedCols - 1) Then
                VBFlexGridFontToolTipHandle = CloneGDIFont(VBFlexGridFontHandle)
            Else
                If VBFlexGridFontFixedHandle = NULL_PTR Then
                    VBFlexGridFontToolTipHandle = CloneGDIFont(VBFlexGridFontHandle)
                Else
                    VBFlexGridFontToolTipHandle = CloneGDIFont(VBFlexGridFontFixedHandle)
                End If
            End If
        Else
            Dim TempFont As StdFont
            Set TempFont = New StdFont
            TempFont.Name = .FontName
            TempFont.Size = .FontSize
            TempFont.Bold = CBool((.FontStyle And FS_BOLD) = FS_BOLD)
            TempFont.Italic = CBool((.FontStyle And FS_ITALIC) = FS_ITALIC)
            TempFont.Strikethrough = CBool((.FontStyle And FS_STRIKEOUT) = FS_STRIKEOUT)
            TempFont.Underline = CBool((.FontStyle And FS_UNDERLINE) = FS_UNDERLINE)
            TempFont.Charset = .FontCharset
            VBFlexGridFontToolTipHandle = CreateGDIFontFromOLEFont(TempFont, PropFontQuality)
            Set TempFont = Nothing
        End If
        End With
        SendMessage VBFlexGridToolTipHandle, WM_SETFONT, VBFlexGridFontToolTipHandle, ByVal 0&
        If OldFontHandle <> NULL_PTR Then DeleteObject OldFontHandle
    Else
        SendMessage VBFlexGridToolTipHandle, WM_SETFONT, 0, ByVal 0&
    End If
End If
End Sub

Private Sub CheckToolTipRowCol(ByVal X As Long, ByVal Y As Long)
If VBFlexGridHandle <> NULL_PTR And VBFlexGridToolTipHandle <> NULL_PTR Then
    Dim HTI As THITTESTINFO
    With HTI
    .PT.X = X
    .PT.Y = Y
    Call GetHitTestInfo(HTI)
    If .HitResult <> FlexHitResultNoWhere Then
        If VBFlexGridToolTipRow <> .HitRow Or VBFlexGridToolTipCol <> .HitCol Then
            VBFlexGridToolTipRow = .HitRow
            VBFlexGridToolTipCol = .HitCol
            VBFlexGridToolTipHitResult = .HitResult
            SendMessage VBFlexGridToolTipHandle, TTM_POP, 0, ByVal 0&
        ElseIf VBFlexGridToolTipHitResult <> .HitResult Then
            VBFlexGridToolTipHitResult = .HitResult
            SendMessage VBFlexGridToolTipHandle, TTM_POP, 0, ByVal 0&
        End If
    Else
        VBFlexGridToolTipRow = -1
        VBFlexGridToolTipCol = -1
        VBFlexGridToolTipHitResult = FlexHitResultNoWhere
        SendMessage VBFlexGridToolTipHandle, TTM_POP, 0, ByVal 0&
    End If
    End With
End If
End Sub

Private Sub UpdateScrollTip(ByVal wBar As Long, ByVal TrackPos As Long, ByVal X As Long, ByVal Y As Long)
If VBFlexGridHandle <> NULL_PTR And VBFlexGridScrollTipHandle <> NULL_PTR Then
    Dim TI As TOOLINFO
    With TI
    .cbSize = LenB(TI)
    .hWnd = VBFlexGridHandle
    .uId = 0
    End With
    If wBar = SB_HORZ Then
        RaiseEvent ScrollTip(-1, (PropFixedCols + PropFrozenCols) + TrackPos)
    ElseIf wBar = SB_VERT Then
        RaiseEvent ScrollTip((PropFixedRows + PropFrozenRows) + TrackPos, -1)
    End If
    If VBFlexGridScrollTipTrack = False Or PropScrollTipFollowThumb = True Then
        Dim RC As RECT
        GetWindowRect VBFlexGridHandle, RC
        If wBar = SB_HORZ Then
            SendMessage VBFlexGridScrollTipHandle, TTM_TRACKPOSITION, 0, ByVal MakeDWord(X, RC.Bottom)
        ElseIf wBar = SB_VERT Then
            SendMessage VBFlexGridScrollTipHandle, TTM_TRACKPOSITION, 0, ByVal MakeDWord(RC.Right, Y)
        End If
    End If
    If VBFlexGridScrollTipTrack = False Then
        SendMessage VBFlexGridScrollTipHandle, TTM_TRACKACTIVATE, 1, ByVal VarPtr(TI)
        VBFlexGridScrollTipTrack = True
    End If
End If
End Sub

Private Sub CancelScrollTip()
If VBFlexGridHandle <> NULL_PTR And VBFlexGridScrollTipHandle <> NULL_PTR Then
    If VBFlexGridScrollTipTrack = True Then
        Dim TI As TOOLINFO
        With TI
        .cbSize = LenB(TI)
        .hWnd = VBFlexGridHandle
        .uId = 0
        .lpszText = NULL_PTR
        End With
        SendMessage VBFlexGridScrollTipHandle, TTM_TRACKACTIVATE, 0, ByVal VarPtr(TI)
        SendMessage VBFlexGridScrollTipHandle, TTM_UPDATETIPTEXT, 0, ByVal VarPtr(TI)
        VBFlexGridScrollTipTrack = False
    End If
End If
End Sub

Private Sub UpdateEditRect()
If PropRows < 1 Or PropCols < 1 Then Exit Sub
If VBFlexGridHandle <> NULL_PTR And VBFlexGridEditHandle <> NULL_PTR Then
    If VBFlexGridEditMergedRange.TopRow < (PropFixedRows + PropFrozenRows) And VBFlexGridEditMergedRange.LeftCol < (PropFixedCols + PropFrozenCols) Then
        ' Void
    Else
        With VBFlexGridEditMergedRange
        Dim RC As RECT, i As Long
        If .BottomRow >= VBFlexGridTopRow Then
            For i = 0 To ((PropFixedRows + PropFrozenRows) - 1)
                RC.Top = RC.Bottom
                RC.Bottom = RC.Bottom + GetRowHeight(i)
            Next i
            For i = VBFlexGridTopRow To .TopRow
                RC.Top = RC.Bottom
                RC.Bottom = RC.Bottom + GetRowHeight(i)
            Next i
            If .TopRow < VBFlexGridTopRow Then RC.Top = RC.Bottom
            For i = (.TopRow + 1) To .BottomRow
                If i >= VBFlexGridTopRow Then RC.Bottom = RC.Bottom + GetRowHeight(i)
            Next i
        ElseIf .BottomRow < (PropFixedRows + PropFrozenRows) Then
            For i = 0 To .TopRow
                RC.Top = RC.Bottom
                RC.Bottom = RC.Bottom + GetRowHeight(i)
            Next i
            For i = (.TopRow + 1) To .BottomRow
                RC.Bottom = RC.Bottom + GetRowHeight(i)
            Next i
        Else
            For i = .TopRow To .BottomRow
                RC.Bottom = RC.Top
                RC.Top = RC.Top - GetRowHeight(i)
            Next i
        End If
        If .RightCol >= VBFlexGridLeftCol Then
            For i = 0 To ((PropFixedCols + PropFrozenCols) - 1)
                RC.Left = RC.Right
                RC.Right = RC.Right + GetColWidth(i)
            Next i
            For i = VBFlexGridLeftCol To .LeftCol
                RC.Left = RC.Right
                RC.Right = RC.Right + GetColWidth(i)
            Next i
            If .LeftCol < VBFlexGridLeftCol Then RC.Left = RC.Right
            For i = (.LeftCol + 1) To .RightCol
                If i >= VBFlexGridLeftCol Then RC.Right = RC.Right + GetColWidth(i)
            Next i
        ElseIf .RightCol < (PropFixedCols + PropFrozenCols) Then
            For i = 0 To .LeftCol
                RC.Left = RC.Right
                RC.Right = RC.Right + GetColWidth(i)
            Next i
            For i = (.LeftCol + 1) To .RightCol
                RC.Right = RC.Right + GetColWidth(i)
            Next i
        Else
            For i = .LeftCol To .RightCol
                RC.Right = RC.Left
                RC.Left = RC.Left - GetColWidth(i)
            Next i
        End If
        End With
        Dim EditRect As RECT
        With EditRect
        .Left = RC.Left + VBFlexGridEditGridLineOffsets.LeftTop.CX
        .Top = RC.Top + VBFlexGridEditGridLineOffsets.LeftTop.CY
        .Right = RC.Right - VBFlexGridEditGridLineOffsets.RightBottom.CX
        .Bottom = RC.Bottom - VBFlexGridEditGridLineOffsets.RightBottom.CY
        End With
        If VBFlexGridComboButtonHandle = NULL_PTR Then
            SetWindowPos VBFlexGridEditHandle, NULL_PTR, EditRect.Left, EditRect.Top, (EditRect.Right - EditRect.Left), (EditRect.Bottom - EditRect.Top), SWP_NOOWNERZORDER Or SWP_NOZORDER
        Else
            Dim ComboButtonWidth As Long, ComboButtonAlignment As FlexLeftRightAlignmentConstants
            ComboButtonWidth = GetComboButtonWidth(VBFlexGridEditRow, VBFlexGridEditCol, FlexComboCueNone)
            If VBFlexGridColsInfo(VBFlexGridEditCol).ComboButtonAlignment = -1 Then
                ComboButtonAlignment = VBFlexGridComboButtonAlignment
            Else
                ComboButtonAlignment = VBFlexGridColsInfo(VBFlexGridEditCol).ComboButtonAlignment
            End If
            If ComboButtonAlignment = FlexLeftRightAlignmentRight Then
                EditRect.Right = EditRect.Right - ComboButtonWidth
                If EditRect.Right < EditRect.Left Then EditRect.Right = EditRect.Left
            ElseIf ComboButtonAlignment = FlexLeftRightAlignmentLeft Then
                EditRect.Left = EditRect.Left + ComboButtonWidth
                If EditRect.Left > EditRect.Right Then EditRect.Left = EditRect.Right
            End If
            If (((RC.Right - RC.Left) - (VBFlexGridEditGridLineOffsets.LeftTop.CX + VBFlexGridEditGridLineOffsets.RightBottom.CX)) - ComboButtonWidth) < 0 Then ComboButtonWidth = ((RC.Right - RC.Left) - (VBFlexGridEditGridLineOffsets.LeftTop.CX + VBFlexGridEditGridLineOffsets.RightBottom.CX))
            SetWindowPos VBFlexGridEditHandle, NULL_PTR, EditRect.Left, EditRect.Top, (EditRect.Right - EditRect.Left), (EditRect.Bottom - EditRect.Top), SWP_NOOWNERZORDER Or SWP_NOZORDER
            If ComboButtonAlignment = FlexLeftRightAlignmentRight Then
                SetWindowPos VBFlexGridComboButtonHandle, NULL_PTR, EditRect.Right, EditRect.Top, ComboButtonWidth, (EditRect.Bottom - EditRect.Top), SWP_NOOWNERZORDER Or SWP_NOZORDER Or SWP_NOCOPYBITS
            ElseIf ComboButtonAlignment = FlexLeftRightAlignmentLeft Then
                SetWindowPos VBFlexGridComboButtonHandle, NULL_PTR, EditRect.Left - ComboButtonWidth, EditRect.Top, ComboButtonWidth, (EditRect.Bottom - EditRect.Top), SWP_NOOWNERZORDER Or SWP_NOZORDER Or SWP_NOCOPYBITS
            End If
            Dim WndRect(0 To 1) As RECT
            Dim hMonitor As LongPtr, MI As MONITORINFO
            If VBFlexGridComboListHandle <> NULL_PTR Then
                LSet VBFlexGridComboBoxRect = RC
                LSet WndRect(0) = VBFlexGridComboBoxRect
                MapWindowPoints VBFlexGridHandle, HWND_DESKTOP, WndRect(0), 2
                GetWindowRect VBFlexGridComboListHandle, WndRect(1)
                hMonitor = MonitorFromWindow(VBFlexGridEditHandle, MONITOR_DEFAULTTOPRIMARY)
                MI.cbSize = LenB(MI)
                GetMonitorInfo hMonitor, MI
                If (WndRect(0).Bottom + (WndRect(1).Bottom - WndRect(1).Top)) > MI.RCMonitor.Bottom Then
                    SetWindowPos VBFlexGridComboListHandle, NULL_PTR, WndRect(0).Left, WndRect(0).Top - (WndRect(1).Bottom - WndRect(1).Top), 0, 0, SWP_NOSIZE Or SWP_NOOWNERZORDER Or SWP_NOZORDER Or SWP_NOACTIVATE
                Else
                    SetWindowPos VBFlexGridComboListHandle, NULL_PTR, WndRect(0).Left, WndRect(0).Bottom, 0, 0, SWP_NOSIZE Or SWP_NOOWNERZORDER Or SWP_NOZORDER Or SWP_NOACTIVATE
                End If
            ElseIf VBFlexGridComboCalendarHandle <> NULL_PTR Then
                LSet VBFlexGridComboBoxRect = RC
                LSet WndRect(0) = VBFlexGridComboBoxRect
                MapWindowPoints VBFlexGridHandle, HWND_DESKTOP, WndRect(0), 2
                GetWindowRect VBFlexGridComboCalendarHandle, WndRect(1)
                hMonitor = MonitorFromWindow(VBFlexGridEditHandle, MONITOR_DEFAULTTOPRIMARY)
                MI.cbSize = LenB(MI)
                GetMonitorInfo hMonitor, MI
                If ComboButtonAlignment = FlexLeftRightAlignmentRight Then
                    If (WndRect(0).Bottom + (WndRect(1).Bottom - WndRect(1).Top)) > MI.RCMonitor.Bottom Then
                        SetWindowPos VBFlexGridComboCalendarHandle, NULL_PTR, WndRect(0).Left, WndRect(0).Top - (WndRect(1).Bottom - WndRect(1).Top), 0, 0, SWP_NOSIZE Or SWP_NOOWNERZORDER Or SWP_NOZORDER Or SWP_NOACTIVATE
                    Else
                        SetWindowPos VBFlexGridComboCalendarHandle, NULL_PTR, WndRect(0).Left, WndRect(0).Bottom, 0, 0, SWP_NOSIZE Or SWP_NOOWNERZORDER Or SWP_NOZORDER Or SWP_NOACTIVATE
                    End If
                ElseIf ComboButtonAlignment = FlexLeftRightAlignmentLeft Then
                    If (WndRect(0).Bottom + (WndRect(1).Bottom - WndRect(1).Top)) > MI.RCMonitor.Bottom Then
                        SetWindowPos VBFlexGridComboCalendarHandle, NULL_PTR, WndRect(0).Right - (WndRect(1).Right - WndRect(1).Left), WndRect(0).Top - (WndRect(1).Bottom - WndRect(1).Top), 0, 0, SWP_NOSIZE Or SWP_NOOWNERZORDER Or SWP_NOZORDER Or SWP_NOACTIVATE
                    Else
                        SetWindowPos VBFlexGridComboCalendarHandle, NULL_PTR, WndRect(0).Right - (WndRect(1).Right - WndRect(1).Left), WndRect(0).Bottom, 0, 0, SWP_NOSIZE Or SWP_NOOWNERZORDER Or SWP_NOZORDER Or SWP_NOACTIVATE
                    End If
                End If
            End If
        End If
        If VBFlexGridEditRectChangedFrozen = False Then VBFlexGridEditRectChanged = True
    End If
End If
End Sub

Private Function ValidateEditOnMouseActivateMsg(ByVal lParam As LongPtr, ByRef RetVal As LongPtr) As Boolean
If VBFlexGridHandle <> NULL_PTR And VBFlexGridEditHandle <> NULL_PTR Then
    Select Case HiWord(CLng(lParam))
        Case WM_LBUTTONDOWN
            If VBFlexGridComboButtonHandle <> NULL_PTR Then
                If IsWindowEnabled(VBFlexGridComboButtonHandle) = 0 Then
                    ' If the combo button window is disabled the mouse message will go trough it and could trigger ending of the editing.
                    ' To avoid this a check is needed and return MA_ACTIVATEANDEAT, if necessary.
                    Dim Pos As Long, P As POINTAPI, XY As Currency
                    Pos = GetMessagePos()
                    P.X = Get_X_lParam(Pos)
                    P.Y = Get_Y_lParam(Pos)
                    ScreenToClient VBFlexGridHandle, P
                    CopyMemory ByVal VarPtr(XY), ByVal VarPtr(P), 8
                    If ChildWindowFromPoint(VBFlexGridHandle, XY) = VBFlexGridComboButtonHandle Then
                        RetVal = MA_ACTIVATEANDEAT
                        ValidateEditOnMouseActivateMsg = True
                        Exit Function
                    End If
                End If
            End If
            If LoWord(CLng(lParam)) = HTCLIENT And VBFlexGridEditTextChanged = True Then
                Dim Cancel As Boolean
                VBFlexGridEditOnValidate = True
                RaiseEvent ValidateEdit(Cancel)
                VBFlexGridEditOnValidate = False
                If VBFlexGridEditHandle <> NULL_PTR Then
                    If Cancel = True Then
                        ' Edit control remains active and will not be destroyed.
                        RetVal = MA_ACTIVATEANDEAT
                        ValidateEditOnMouseActivateMsg = True
                        Exit Function
                    Else
                        VBFlexGridEditAlreadyValidated = True
                    End If
                End If
            End If
    End Select
End If
End Function

Private Sub ComboShowDropDown(ByVal Value As Boolean, ByVal Reason As FlexComboDropDownReasonConstants)
If VBFlexGridEditHandle <> NULL_PTR And VBFlexGridComboButtonHandle <> NULL_PTR And (VBFlexGridComboListHandle <> NULL_PTR Or VBFlexGridComboCalendarHandle <> NULL_PTR) Then
    Dim dwLong As Long
    dwLong = GetWindowLong(VBFlexGridComboButtonHandle, GWL_USERDATA)
    If Value = True Then
        If Not (dwLong And ODS_SELECTED) = ODS_SELECTED And Not (dwLong And ODS_DISABLED) = ODS_DISABLED Then
            Dim Cancel As Boolean
            RaiseEvent ComboBeforeDropDown(Reason, Cancel)
            If Cancel = False Then
                If GetCursor() = NULL_PTR Then
                    ' The mouse cursor can be hidden when showing the drop-down list upon a change event.
                    ' Reason is that the edit control hides the cursor and a following mouse move will show it again.
                    ' However, the drop-down list will set a mouse capture and thus the cursor keeps hidden.
                    ' Solution is to refresh the cursor by sending a WM_SETCURSOR.
                    Call RefreshMousePointer(VBFlexGridEditHandle)
                End If
                RaiseEvent ComboDropDown
                SetWindowLong VBFlexGridComboButtonHandle, GWL_USERDATA, dwLong Or ODS_SELECTED
                InvalidateRect VBFlexGridComboButtonHandle, ByVal NULL_PTR, 0
                Dim WndRect(0 To 1) As RECT
                Dim hMonitor As LongPtr, MI As MONITORINFO
                If VBFlexGridComboListHandle <> NULL_PTR Then
                    If IsWindowVisible(VBFlexGridComboListHandle) = 0 Then
                        LSet WndRect(0) = VBFlexGridComboBoxRect
                        MapWindowPoints VBFlexGridHandle, HWND_DESKTOP, WndRect(0), 2
                        GetWindowRect VBFlexGridComboListHandle, WndRect(1)
                        hMonitor = MonitorFromWindow(VBFlexGridEditHandle, MONITOR_DEFAULTTOPRIMARY)
                        MI.cbSize = LenB(MI)
                        GetMonitorInfo hMonitor, MI
                        If (WndRect(0).Bottom + (WndRect(1).Bottom - WndRect(1).Top)) > MI.RCMonitor.Bottom Then
                            SetWindowPos VBFlexGridComboListHandle, NULL_PTR, WndRect(0).Left, WndRect(0).Top - (WndRect(1).Bottom - WndRect(1).Top), 0, 0, SWP_NOSIZE Or SWP_NOOWNERZORDER Or SWP_NOZORDER Or SWP_NOACTIVATE Or SWP_SHOWWINDOW
                        Else
                            SetWindowPos VBFlexGridComboListHandle, NULL_PTR, WndRect(0).Left, WndRect(0).Bottom, 0, 0, SWP_NOSIZE Or SWP_NOOWNERZORDER Or SWP_NOZORDER Or SWP_NOACTIVATE Or SWP_SHOWWINDOW
                        End If
                    End If
                    SetCapture VBFlexGridComboListHandle
                ElseIf VBFlexGridComboCalendarHandle <> NULL_PTR Then
                    VBFlexGridEditNoLostFocus = True
                    If IsWindowVisible(VBFlexGridComboCalendarHandle) = 0 Then
                        LSet WndRect(0) = VBFlexGridComboBoxRect
                        MapWindowPoints VBFlexGridHandle, HWND_DESKTOP, WndRect(0), 2
                        GetWindowRect VBFlexGridComboCalendarHandle, WndRect(1)
                        hMonitor = MonitorFromWindow(VBFlexGridEditHandle, MONITOR_DEFAULTTOPRIMARY)
                        MI.cbSize = LenB(MI)
                        GetMonitorInfo hMonitor, MI
                        Dim ComboButtonAlignment As FlexLeftRightAlignmentConstants
                        If VBFlexGridColsInfo(VBFlexGridEditCol).ComboButtonAlignment = -1 Then
                            ComboButtonAlignment = VBFlexGridComboButtonAlignment
                        Else
                            ComboButtonAlignment = VBFlexGridColsInfo(VBFlexGridEditCol).ComboButtonAlignment
                        End If
                        If ComboButtonAlignment = FlexLeftRightAlignmentRight Then
                            If (WndRect(0).Bottom + (WndRect(1).Bottom - WndRect(1).Top)) > MI.RCMonitor.Bottom Then
                                SetWindowPos VBFlexGridComboCalendarHandle, NULL_PTR, WndRect(0).Left, WndRect(0).Top - (WndRect(1).Bottom - WndRect(1).Top), 0, 0, SWP_NOSIZE Or SWP_NOOWNERZORDER Or SWP_NOZORDER Or SWP_SHOWWINDOW
                            Else
                                SetWindowPos VBFlexGridComboCalendarHandle, NULL_PTR, WndRect(0).Left, WndRect(0).Bottom, 0, 0, SWP_NOSIZE Or SWP_NOOWNERZORDER Or SWP_NOZORDER Or SWP_SHOWWINDOW
                            End If
                        ElseIf ComboButtonAlignment = FlexLeftRightAlignmentLeft Then
                            If (WndRect(0).Bottom + (WndRect(1).Bottom - WndRect(1).Top)) > MI.RCMonitor.Bottom Then
                                SetWindowPos VBFlexGridComboCalendarHandle, NULL_PTR, WndRect(0).Right - (WndRect(1).Right - WndRect(1).Left), WndRect(0).Top - (WndRect(1).Bottom - WndRect(1).Top), 0, 0, SWP_NOSIZE Or SWP_NOOWNERZORDER Or SWP_NOZORDER Or SWP_SHOWWINDOW
                            Else
                                SetWindowPos VBFlexGridComboCalendarHandle, NULL_PTR, WndRect(0).Right - (WndRect(1).Right - WndRect(1).Left), WndRect(0).Bottom, 0, 0, SWP_NOSIZE Or SWP_NOOWNERZORDER Or SWP_NOZORDER Or SWP_SHOWWINDOW
                            End If
                        End If
                    End If
                    ' SetCapture is not applicable as the calendar control needs to have the focus.
                End If
            End If
        End If
    Else
        If (dwLong And ODS_SELECTED) = ODS_SELECTED Then
            SetWindowLong VBFlexGridComboButtonHandle, GWL_USERDATA, dwLong And Not ODS_SELECTED
            InvalidateRect VBFlexGridComboButtonHandle, ByVal NULL_PTR, 0
            If VBFlexGridComboListHandle <> NULL_PTR Then
                If GetCapture() = VBFlexGridComboListHandle Then ReleaseCapture
                If IsWindowVisible(VBFlexGridComboListHandle) <> 0 Then ShowWindow VBFlexGridComboListHandle, SW_HIDE
            ElseIf VBFlexGridComboCalendarHandle <> NULL_PTR Then
                SetFocusAPI VBFlexGridEditHandle
                If IsWindowVisible(VBFlexGridComboCalendarHandle) <> 0 Then ShowWindow VBFlexGridComboCalendarHandle, SW_HIDE
                VBFlexGridEditNoLostFocus = False
            End If
            RaiseEvent ComboCloseUp
        End If
    End If
End If
End Sub

Private Sub ComboButtonPerformClick()
Static InProc As Boolean
If InProc = True Then Exit Sub
If VBFlexGridEditHandle <> NULL_PTR And VBFlexGridComboButtonHandle <> NULL_PTR And VBFlexGridComboListHandle = NULL_PTR And VBFlexGridComboCalendarHandle = NULL_PTR Then
    InProc = True
    Dim dwLong As Long
    dwLong = GetWindowLong(VBFlexGridComboButtonHandle, GWL_USERDATA)
    If Not (dwLong And ODS_DISABLED) = ODS_DISABLED Then
        If Not (dwLong And ODS_SELECTED) = ODS_SELECTED Then
            SetWindowLong VBFlexGridComboButtonHandle, GWL_USERDATA, dwLong Or ODS_SELECTED
            InvalidateRect VBFlexGridComboButtonHandle, ByVal NULL_PTR, 0
            UpdateWindow VBFlexGridComboButtonHandle
        End If
        VBFlexGridEditNoLostFocus = True
        RaiseEvent ComboButtonClick
        If VBFlexGridEditHandle <> NULL_PTR Then
            If VBFlexGridComboButtonHandle <> NULL_PTR Then
                Call ComboButtonSetState(ODS_SELECTED, False, True)
                ' Remove any left mouse button down or double-click messages so that we can get a toggle effect on the combo button.
                Dim Msg As TMSG
                Const PM_REMOVE As Long = &H1
                While PeekMessage(Msg, VBFlexGridComboButtonHandle, WM_LBUTTONDOWN, WM_LBUTTONDOWN, PM_REMOVE) <> 0 Or PeekMessage(Msg, VBFlexGridComboButtonHandle, WM_LBUTTONDBLCLK, WM_LBUTTONDBLCLK, PM_REMOVE) <> 0: Wend
            End If
            SetFocusAPI VBFlexGridEditHandle
            VBFlexGridEditNoLostFocus = False
        Else
            VBFlexGridEditNoLostFocus = False
            SetFocusAPI UserControl.hWnd
        End If
    End If
    InProc = False
End If
End Sub

Private Sub ComboButtonDraw(ByVal iRow As Long, ByVal iCol As Long, ByRef DIS As DRAWITEMSTRUCT)
Dim Handled As Boolean
#If Win64 Then
Dim hDC32 As Long
#End If
If VBFlexGridComboButtonDrawMode <> FlexComboButtonDrawModeNormal Then
    Dim Cancel As Boolean
    #If Win64 Then
    CopyMemory ByVal VarPtr(hDC32), ByVal VarPtr(DIS.hDC), 4
    RaiseEvent ComboButtonOwnerDraw(iRow, iCol, Cancel, DIS.CtlType, DIS.ItemAction, DIS.ItemState, hDC32, DIS.RCItem.Left, DIS.RCItem.Top, DIS.RCItem.Right, DIS.RCItem.Bottom)
    #Else
    RaiseEvent ComboButtonOwnerDraw(iRow, iCol, Cancel, DIS.CtlType, DIS.ItemAction, DIS.ItemState, DIS.hDC, DIS.RCItem.Left, DIS.RCItem.Top, DIS.RCItem.Right, DIS.RCItem.Bottom)
    #End If
    Handled = Not Cancel
End If
If Handled = False Then
    Dim Theme As LongPtr, ContentRect As RECT, OldTextColor As Long
    
    #If ImplementThemedControls = True Then
    
    Dim ThemeDropDown As Boolean
    If VBFlexGridEnabledVisualStyles = True And PropVisualStyles = True Then
        If DIS.CtlType = ODT_STATIC Then
            If VBFlexGridComboListHandle <> NULL_PTR Or VBFlexGridComboCalendarHandle <> NULL_PTR Then
                Theme = OpenThemeData(VBFlexGridHandle, StrPtr("ComboBox"))
                ThemeDropDown = True
            Else
                Theme = OpenThemeData(VBFlexGridHandle, StrPtr("Button"))
            End If
        Else
            If DIS.CtlType = ODT_COMBOBOX Then
                Theme = OpenThemeData(VBFlexGridHandle, StrPtr("ComboBox"))
                ThemeDropDown = True
            ElseIf DIS.CtlType = ODT_BUTTON Then
                Theme = OpenThemeData(VBFlexGridHandle, StrPtr("Button"))
            End If
        End If
    End If
    If Theme <> NULL_PTR Then
        If ThemeDropDown = True Then
            Dim ComboBoxPart As Long, ComboBoxState As Long
            ComboBoxPart = CP_DROPDOWNBUTTON
            If Not (DIS.ItemState And ODS_DISABLED) = ODS_DISABLED Then
                If Not (DIS.ItemState And ODS_SELECTED) = ODS_SELECTED Then
                    If Not (DIS.ItemState And ODS_HOTLIGHT) = ODS_HOTLIGHT Then
                        ComboBoxState = CBXS_NORMAL
                    Else
                        ComboBoxState = CBXS_HOT
                    End If
                Else
                    ComboBoxState = CBXS_PRESSED
                End If
            Else
                ComboBoxState = CBXS_DISABLED
            End If
            If IsThemeBackgroundPartiallyTransparent(Theme, ComboBoxPart, ComboBoxState) <> 0 Then DrawThemeParentBackground DIS.hWndItem, DIS.hDC, DIS.RCItem
            DrawThemeBackground Theme, DIS.hDC, ComboBoxPart, ComboBoxState, DIS.RCItem, DIS.RCItem
        Else
            Dim ButtonPart As Long, ButtonState As Long
            ButtonPart = BP_PUSHBUTTON
            If Not (DIS.ItemState And ODS_DISABLED) = ODS_DISABLED Then
                If Not (DIS.ItemState And ODS_SELECTED) = ODS_SELECTED Then
                    If Not (DIS.ItemState And ODS_HOTLIGHT) = ODS_HOTLIGHT Then
                        ButtonState = PBS_NORMAL
                    Else
                        ButtonState = PBS_HOT
                    End If
                Else
                    ButtonState = PBS_PRESSED
                End If
            Else
                ButtonState = PBS_DISABLED
            End If
            If IsThemeBackgroundPartiallyTransparent(Theme, ButtonPart, ButtonState) <> 0 Then DrawThemeParentBackground DIS.hWndItem, DIS.hDC, DIS.RCItem
            DrawThemeBackground Theme, DIS.hDC, ButtonPart, ButtonState, DIS.RCItem, DIS.RCItem
            GetThemeBackgroundContentRect Theme, DIS.hDC, ButtonPart, ButtonState, DIS.RCItem, ContentRect
            #If Win64 Then
            CopyMemory ByVal VarPtr(hDC32), ByVal VarPtr(DIS.hDC), 4
            RaiseEvent ComboButtonCustomDraw(iRow, iCol, Handled, DIS.CtlType, DIS.ItemAction, DIS.ItemState, hDC32, DIS.RCItem.Left, DIS.RCItem.Top, DIS.RCItem.Right, DIS.RCItem.Bottom, ContentRect.Left, ContentRect.Top, ContentRect.Right, ContentRect.Bottom)
            #Else
            RaiseEvent ComboButtonCustomDraw(iRow, iCol, Handled, DIS.CtlType, DIS.ItemAction, DIS.ItemState, DIS.hDC, DIS.RCItem.Left, DIS.RCItem.Top, DIS.RCItem.Right, DIS.RCItem.Bottom, ContentRect.Left, ContentRect.Top, ContentRect.Right, ContentRect.Bottom)
            #End If
            If Handled = False Then
                If VBFlexGridColsInfo(iCol).ComboButtonPicture Is Nothing Then
                    If VBFlexGridComboButtonPicture Is Nothing Then
                        If Not (DIS.ItemState And ODS_DISABLED) = ODS_DISABLED Then
                            OldTextColor = SetTextColor(DIS.hDC, GetSysColor(COLOR_BTNTEXT))
                        Else
                            OldTextColor = SetTextColor(DIS.hDC, GetSysColor(COLOR_GRAYTEXT))
                        End If
                        Call ComboButtonDrawEllipsis(DIS.hDC, ContentRect)
                        SetTextColor DIS.hDC, OldTextColor
                    Else
                        Call ComboButtonDrawPicture(DIS.hDC, ContentRect, DIS.ItemState, VBFlexGridComboButtonPicture, VBFlexGridComboButtonPictureRenderFlag)
                    End If
                Else
                    Call ComboButtonDrawPicture(DIS.hDC, ContentRect, DIS.ItemState, VBFlexGridColsInfo(iCol).ComboButtonPicture, VBFlexGridColsInfo(iCol).ComboButtonPictureRenderFlag)
                End If
            End If
        End If
        CloseThemeData Theme
    End If
    
    #End If
    
    If Theme = NULL_PTR Then
        Dim CtlType As Long, Flags As Long
        If DIS.CtlType = ODT_STATIC Then
            If VBFlexGridComboListHandle <> NULL_PTR Or VBFlexGridComboCalendarHandle <> NULL_PTR Then
                CtlType = DFC_SCROLL
                Flags = DFCS_SCROLLCOMBOBOX
            Else
                CtlType = DFC_BUTTON
                Flags = DFCS_BUTTONPUSH Or DFCS_ADJUSTRECT
            End If
        Else
            If DIS.CtlType = ODT_COMBOBOX Then
                CtlType = DFC_SCROLL
                Flags = DFCS_SCROLLCOMBOBOX
            ElseIf DIS.CtlType = ODT_BUTTON Then
                CtlType = DFC_BUTTON
                Flags = DFCS_BUTTONPUSH Or DFCS_ADJUSTRECT
            End If
        End If
        If (DIS.ItemState And ODS_SELECTED) = ODS_SELECTED Then Flags = Flags Or DFCS_PUSHED Or DFCS_FLAT
        If (DIS.ItemState And ODS_DISABLED) = ODS_DISABLED Then Flags = Flags Or DFCS_INACTIVE
        If (DIS.ItemState And ODS_HOTLIGHT) = ODS_HOTLIGHT Then Flags = Flags Or DFCS_HOT
        LSet ContentRect = DIS.RCItem
        DrawFrameControl DIS.hDC, ContentRect, CtlType, Flags
        If CtlType = DFC_BUTTON Then
            #If Win64 Then
            CopyMemory ByVal VarPtr(hDC32), ByVal VarPtr(DIS.hDC), 4
            RaiseEvent ComboButtonCustomDraw(iRow, iCol, Handled, DIS.CtlType, DIS.ItemAction, DIS.ItemState, hDC32, DIS.RCItem.Left, DIS.RCItem.Top, DIS.RCItem.Right, DIS.RCItem.Bottom, ContentRect.Left, ContentRect.Top, ContentRect.Right, ContentRect.Bottom)
            #Else
            RaiseEvent ComboButtonCustomDraw(iRow, iCol, Handled, DIS.CtlType, DIS.ItemAction, DIS.ItemState, DIS.hDC, DIS.RCItem.Left, DIS.RCItem.Top, DIS.RCItem.Right, DIS.RCItem.Bottom, ContentRect.Left, ContentRect.Top, ContentRect.Right, ContentRect.Bottom)
            #End If
            If Handled = False Then
                If VBFlexGridColsInfo(iCol).ComboButtonPicture Is Nothing Then
                    If VBFlexGridComboButtonPicture Is Nothing Then
                        If Not (Flags And DFCS_INACTIVE) = DFCS_INACTIVE Then
                            If Not (Flags And DFCS_HOT) = DFCS_HOT Then
                                OldTextColor = SetTextColor(DIS.hDC, GetSysColor(COLOR_BTNTEXT))
                            Else
                                OldTextColor = SetTextColor(DIS.hDC, GetSysColor(COLOR_HOTLIGHT))
                            End If
                        Else
                            OldTextColor = SetTextColor(DIS.hDC, GetSysColor(COLOR_GRAYTEXT))
                        End If
                        Call ComboButtonDrawEllipsis(DIS.hDC, ContentRect)
                        SetTextColor DIS.hDC, OldTextColor
                    Else
                        Call ComboButtonDrawPicture(DIS.hDC, ContentRect, DIS.ItemState, VBFlexGridComboButtonPicture, VBFlexGridComboButtonPictureRenderFlag)
                    End If
                Else
                    Call ComboButtonDrawPicture(DIS.hDC, ContentRect, DIS.ItemState, VBFlexGridColsInfo(iCol).ComboButtonPicture, VBFlexGridColsInfo(iCol).ComboButtonPictureRenderFlag)
                End If
            End If
        End If
    End If
End If
End Sub

Private Sub ComboButtonDrawEllipsis(ByVal hDC As LongPtr, ByRef ContentRect As RECT)
If hDC = NULL_PTR Then Exit Sub
Dim OldBkMode As Long, OldTextAlign As Long, hFontOld As LongPtr
Dim X As Long, Y As Long, Size As SIZEAPI, Result As Long, DX(0 To 2) As Long
OldBkMode = SetBkMode(hDC, 1)
OldTextAlign = SetTextAlign(hDC, TA_CENTER Or TA_BASELINE)
hFontOld = SelectObject(hDC, GetStockObject(SYSTEM_FONT))
With ContentRect
X = .Left + ((.Right - .Left) \ 2)
Y = .Bottom
GetTextExtentPoint32 hDC, ByVal StrPtr("."), 1, Size
Result = (((.Bottom - .Top) - (Size.CY \ 2)) \ 2)
If Result > 0 Then Y = Y - Result
End With
' The system font is not scaled on higher DPI's.
' For better appearance the dots will be shorten always by 1 unit and then scaled, if necessary.
DX(0) = (Size.CX - 1) * PixelsPerDIP_X()
DX(1) = DX(0)
DX(2) = DX(0)
ExtTextOut hDC, X, Y, ETO_CLIPPED, ContentRect, StrPtr("..."), 3, VarPtr(DX(0))
SetBkMode hDC, OldBkMode
SetTextAlign hDC, OldTextAlign
If hFontOld <> NULL_PTR Then SelectObject hDC, hFontOld
End Sub

Private Sub ComboButtonDrawPicture(ByVal hDC As LongPtr, ByRef ContentRect As RECT, ByVal ItemState As Long, ByVal Picture As IPictureDisp, ByRef RenderFlag As Integer)
If hDC = NULL_PTR Then Exit Sub
If Picture Is Nothing Then Exit Sub
If Picture.Handle <> NULL_PTR Then
    Dim hRgnOld As LongPtr
    hRgnOld = CreateRectRgn(0, 0, 0, 0)
    If hRgnOld <> NULL_PTR Then
        If GetClipRgn(hDC, hRgnOld) = 0 Then
            DeleteObject hRgnOld
            hRgnOld = NULL_PTR
        End If
    End If
    IntersectClipRect hDC, ContentRect.Left, ContentRect.Top, ContentRect.Right, ContentRect.Bottom
    Dim CX As Long, CY As Long, X As Long, Y As Long
    CX = CHimetricToPixel_X(Picture.Width)
    CY = CHimetricToPixel_Y(Picture.Height)
    X = ContentRect.Left + ((ContentRect.Right - ContentRect.Left - CX) \ 2)
    Y = ContentRect.Top + ((ContentRect.Bottom - ContentRect.Top - CY) \ 2)
    If Not (ItemState And ODS_DISABLED) = ODS_DISABLED Then
        Call RenderPicture(Picture, hDC, X, Y, CX, CY, RenderFlag)
    Else
        If Picture.Type = vbPicTypeIcon Then
            DrawState hDC, NULL_PTR, NULL_PTR, Picture.Handle, 0, X, Y, CX, CY, DST_ICON Or DSS_DISABLED
        Else
            Dim hImage As LongPtr
            hImage = BitmapHandleFromPicture(Picture, vbWhite)
            ' The DrawState API with DSS_DISABLED will draw white as transparent.
            ' This will ensure GIF bitmaps or metafiles are better drawn.
            DrawState hDC, NULL_PTR, NULL_PTR, hImage, 0, X, Y, CX, CY, DST_BITMAP Or DSS_DISABLED
            DeleteObject hImage
        End If
    End If
    If hRgnOld <> NULL_PTR Then
        ExtSelectClipRgn hDC, hRgnOld, RGN_COPY
        DeleteObject hRgnOld
        hRgnOld = NULL_PTR
    Else
        ExtSelectClipRgn hDC, NULL_PTR, RGN_COPY
    End If
End If
End Sub

Private Function ComboButtonGetState(ByVal dwState As Long) As Boolean
If VBFlexGridEditHandle <> NULL_PTR And VBFlexGridComboButtonHandle <> NULL_PTR Then ComboButtonGetState = CBool((GetWindowLong(VBFlexGridComboButtonHandle, GWL_USERDATA) And dwState) = dwState)
End Function

Private Sub ComboButtonSetState(ByVal dwState As Long, ByVal Value As Boolean, Optional ByVal UpdateNow As Boolean)
If VBFlexGridEditHandle <> NULL_PTR And VBFlexGridComboButtonHandle <> NULL_PTR Then
    Dim dwLong As Long
    dwLong = GetWindowLong(VBFlexGridComboButtonHandle, GWL_USERDATA)
    If Value = True Then
        If Not (dwLong And dwState) = dwState Then
            SetWindowLong VBFlexGridComboButtonHandle, GWL_USERDATA, dwLong Or dwState
            InvalidateRect VBFlexGridComboButtonHandle, ByVal NULL_PTR, 0
            If UpdateNow = True Then UpdateWindow VBFlexGridComboButtonHandle
        End If
    Else
        If (dwLong And dwState) = dwState Then
            SetWindowLong VBFlexGridComboButtonHandle, GWL_USERDATA, dwLong And Not dwState
            InvalidateRect VBFlexGridComboButtonHandle, ByVal NULL_PTR, 0
            If UpdateNow = True Then UpdateWindow VBFlexGridComboButtonHandle
        End If
    End If
End If
End Sub

Private Function ComboListSelFromPt(ByVal X As Long, ByVal Y As Long, ByVal AutoScroll As Boolean) As Long
ComboListSelFromPt = LB_ERR
If VBFlexGridComboListHandle <> NULL_PTR Then
    Dim P As POINTAPI, XY As Currency, Index As Long
    P.X = X
    P.Y = Y
    ClientToScreen VBFlexGridComboListHandle, P
    CopyMemory ByVal VarPtr(XY), ByVal VarPtr(P), 8
    Index = LBItemFromPt(VBFlexGridComboListHandle, XY, IIf(AutoScroll = True, 1, 0))
    If Not Index = LB_ERR Then
        If SendMessage(VBFlexGridComboListHandle, LB_GETCOUNT, 0, ByVal 0&) > 0 Then
            If Index <> SendMessage(VBFlexGridComboListHandle, LB_GETCURSEL, 0, ByVal 0&) Then SendMessage VBFlexGridComboListHandle, LB_SETCURSEL, Index, ByVal 0&
        Else
            SendMessage VBFlexGridComboListHandle, LB_SETCURSEL, -1, ByVal 0&
        End If
    End If
    ComboListSelFromPt = Index
End If
End Function

Private Sub ComboListCommitSel()
If VBFlexGridEditHandle <> NULL_PTR And VBFlexGridComboListHandle <> NULL_PTR Then
    Dim Index As Long, Length As Long
    Index = CLng(SendMessage(VBFlexGridComboListHandle, LB_GETCURSEL, 0, ByVal 0&))
    Length = CLng(SendMessage(VBFlexGridComboListHandle, LB_GETTEXTLEN, Index, ByVal 0&))
    If Not Length = LB_ERR Then
        Dim Text As String
        Text = String(Length, vbNullChar)
        SendMessage VBFlexGridComboListHandle, LB_GETTEXT, Index, ByVal StrPtr(Text)
        Me.EditText = Text
        SendMessage VBFlexGridEditHandle, EM_SETSEL, 0, ByVal -1&
    End If
End If
End Sub

Private Sub ComboCalendarCommitSel()
If VBFlexGridEditHandle <> NULL_PTR And VBFlexGridComboCalendarHandle <> NULL_PTR Then
    Me.EditText = Me.ComboCalendarValue
    SendMessage VBFlexGridEditHandle, EM_SETSEL, 0, ByVal -1&
End If
End Sub

Private Sub ComboCalendarCommitST(ByRef ST As SYSTEMTIME)
If VBFlexGridEditHandle <> NULL_PTR And VBFlexGridComboCalendarHandle <> NULL_PTR Then
    Me.EditText = DateSerial(ST.wYear, ST.wMonth, ST.wDay)
    SendMessage VBFlexGridEditHandle, EM_SETSEL, 0, ByVal -1&
End If
End Sub

Private Sub ComboCuePerformClick(ByVal Reason As FlexEditReasonConstants, Optional ByVal Row As Long = -1, Optional ByVal Col As Long = -1)
Static InProc As Boolean
If VBFlexGridHandle = NULL_PTR Or InProc = True Then Exit Sub
If Row = -1 Then Row = VBFlexGridRow
If Col = -1 Then Col = VBFlexGridCol
If (Row < 0 Or Row > (PropRows - 1)) Or (Col < 0 Or Col > (PropCols - 1)) Then Exit Sub
If VBFlexGridEditHandle = NULL_PTR And VBFlexGridComboButtonHandle = NULL_PTR And VBFlexGridComboListHandle = NULL_PTR And VBFlexGridComboCalendarHandle = NULL_PTR Then
    InProc = True
    VBFlexGridComboCueClickRow = Row
    VBFlexGridComboCueClickCol = Col
    Call RedrawGrid(True)
    RaiseEvent ComboCueClick(Row, Col, Reason)
    Dim P As POINTAPI, XY As Currency
    GetCursorPos P
    CopyMemory ByVal VarPtr(XY), ByVal VarPtr(P), 8
    If WindowFromPoint(XY) = VBFlexGridHandle Then
        Dim HTI As THITTESTINFO
        ScreenToClient VBFlexGridHandle, P
        HTI.PT.X = P.X
        HTI.PT.Y = P.Y
        Call GetHitTestInfo(HTI)
        If HTI.HitRow = Row And HTI.HitCol = Col And HTI.HitResult = FlexHitResultComboCue Then
            ' Remove any left mouse button down or double-click messages so that we can get a toggle effect on the combo cue.
            Dim Msg As TMSG
            Const PM_REMOVE As Long = &H1
            While PeekMessage(Msg, VBFlexGridHandle, WM_LBUTTONDOWN, WM_LBUTTONDOWN, PM_REMOVE) <> 0 Or PeekMessage(Msg, VBFlexGridHandle, WM_LBUTTONDBLCLK, WM_LBUTTONDBLCLK, PM_REMOVE) <> 0: Wend
        End If
    End If
    VBFlexGridComboCueClickRow = -1
    VBFlexGridComboCueClickCol = -1
    Call RedrawGrid(True)
    InProc = False
End If
End Sub

Private Sub InplaceMergeSort(ByVal Left As Long, ByVal Middle As Long, ByVal Right As Long, ByVal Col As Long, ByRef Data() As TCOLS, ByVal Sort As FlexSortConstants)
Dim Blank As TCOLS, Length As Long, Temp() As TCOLS, Cmp As Long, Dst As Long
Dim i As Long, j As Long
Dim Dbl1 As Double, Dbl2 As Double
Length = LenB(Blank)
ReDim Temp(0 To (Middle - Left)) As TCOLS
j = 0
For i = Left To Middle
    CopyMemory ByVal VarPtr(Temp(j)), ByVal VarPtr(Data(i)), Length
    j = j + 1
Next i
j = 0
Dst = Left
Do While i <= Right And j <= UBound(Temp)
    Cmp = 0
    Select Case Sort
        Case FlexSortGenericAscending, FlexSortGenericDescending
            ' Sort strings and numbers only. (dates will be sorted as strings)
            If Not IsNumeric(Data(i).Cols(Col).Text) Or Not IsNumeric(Temp(j).Cols(Col).Text) Then
                If Data(i).Cols(Col).Text < Temp(j).Cols(Col).Text Then
                    Cmp = -1
                ElseIf Data(i).Cols(Col).Text > Temp(j).Cols(Col).Text Then
                    Cmp = 1
                End If
            Else
                Dbl1 = Empty: Dbl2 = Empty
                On Error Resume Next
                Dbl1 = CDbl(Data(i).Cols(Col).Text)
                Dbl2 = CDbl(Temp(j).Cols(Col).Text)
                On Error GoTo 0
                Cmp = Sgn(Dbl1 - Dbl2)
            End If
            If Sort = FlexSortGenericDescending Then Cmp = -Cmp
        Case FlexSortNumericAscending, FlexSortNumericDescending
            Dbl1 = Empty: Dbl2 = Empty
            On Error Resume Next
            Dbl1 = CDbl(Data(i).Cols(Col).Text)
            Dbl2 = CDbl(Temp(j).Cols(Col).Text)
            On Error GoTo 0
            Cmp = Sgn(Dbl1 - Dbl2)
            If Sort = FlexSortNumericDescending Then Cmp = -Cmp
        Case FlexSortStringNoCaseAscending, FlexSortStringNoCaseDescending
            Cmp = lstrcmpi(StrPtr(Data(i).Cols(Col).Text), StrPtr(Temp(j).Cols(Col).Text))
            If Sort = FlexSortStringNoCaseDescending Then Cmp = -Cmp
        Case FlexSortStringAscending, FlexSortStringDescending
            Cmp = lstrcmp(StrPtr(Data(i).Cols(Col).Text), StrPtr(Temp(j).Cols(Col).Text))
            If Sort = FlexSortStringDescending Then Cmp = -Cmp
        Case FlexSortCurrencyAscending, FlexSortCurrencyDescending
            Dim Cur1 As Currency, Cur2 As Currency
            Cur1 = Empty: Cur2 = Empty
            On Error Resume Next
            Cur1 = CCur(Data(i).Cols(Col).Text)
            Cur2 = CCur(Temp(j).Cols(Col).Text)
            On Error GoTo 0
            Cmp = Sgn(Cur1 - Cur2)
            If Sort = FlexSortCurrencyDescending Then Cmp = -Cmp
        Case FlexSortDateAscending, FlexSortDateDescending
            Dim Date1 As Date, Date2 As Date
            Date1 = Empty: Date2 = Empty
            On Error Resume Next
            Date1 = CDate(Data(i).Cols(Col).Text)
            Date2 = CDate(Temp(j).Cols(Col).Text)
            On Error GoTo 0
            Cmp = Sgn(Date1 - Date2)
            If Sort = FlexSortDateDescending Then Cmp = -Cmp
        Case FlexSortCustomText
            RaiseEvent CompareText(Data(i).Cols(Col).Text, Temp(j).Cols(Col).Text, Col, Cmp)
    End Select
    If Cmp < 0 Then
        CopyMemory ByVal VarPtr(Data(Dst)), ByVal VarPtr(Data(i)), Length
        i = i + 1
    Else
        CopyMemory ByVal VarPtr(Data(Dst)), ByVal VarPtr(Temp(j)), Length
        ZeroMemory ByVal VarPtr(Temp(j)), Length
        j = j + 1
    End If
    Dst = Dst + 1
Loop
Do While j <= UBound(Temp)
    CopyMemory ByVal VarPtr(Data(Dst)), ByVal VarPtr(Temp(j)), Length
    ZeroMemory ByVal VarPtr(Temp(j)), Length
    Dst = Dst + 1
    j = j + 1
Loop
End Sub

Private Sub MergeSortRec(ByVal Left As Long, ByVal Right As Long, ByVal Col As Long, ByRef Data() As TCOLS, ByVal Sort As FlexSortConstants)
Dim Middle As Long
Middle = (Left + Right) \ 2
If Left < Right Then
    Call MergeSortRec(Left, Middle, Col, Data(), Sort)
    Call MergeSortRec(Middle + 1, Right, Col, Data(), Sort)
    Call InplaceMergeSort(Left, Middle, Right, Col, Data(), Sort)
End If
End Sub

Private Sub InplaceTextDisplayMergeSort(ByVal Left As Long, ByVal Middle As Long, ByVal Right As Long, ByVal Col As Long, ByRef Data() As TINDIRECTMERGESORTDATA, ByVal Sort As FlexSortConstants)
Dim Blank As TINDIRECTMERGESORTDATA, Length As Long, Temp() As TINDIRECTMERGESORTDATA, Cmp As Long, Dst As Long
Dim i As Long, j As Long
Dim Dbl1 As Double, Dbl2 As Double
Length = LenB(Blank)
ReDim Temp(0 To (Middle - Left)) As TINDIRECTMERGESORTDATA
j = 0
For i = Left To Middle
    CopyMemory ByVal VarPtr(Temp(j)), ByVal VarPtr(Data(i)), Length
    j = j + 1
Next i
j = 0
Dst = Left
Do While i <= Right And j <= UBound(Temp)
    Cmp = 0
    Select Case Sort
        Case FlexSortGenericAscending, FlexSortGenericDescending
            ' Sort strings and numbers only. (dates will be sorted as strings)
            If Not IsNumeric(Data(i).TextDisplay) Or Not IsNumeric(Temp(j).TextDisplay) Then
                If Data(i).TextDisplay < Temp(j).TextDisplay Then
                    Cmp = -1
                ElseIf Data(i).TextDisplay > Temp(j).TextDisplay Then
                    Cmp = 1
                End If
            Else
                Dbl1 = Empty: Dbl2 = Empty
                On Error Resume Next
                Dbl1 = CDbl(Data(i).TextDisplay)
                Dbl2 = CDbl(Temp(j).TextDisplay)
                On Error GoTo 0
                Cmp = Sgn(Dbl1 - Dbl2)
            End If
            If Sort = FlexSortGenericDescending Then Cmp = -Cmp
        Case FlexSortNumericAscending, FlexSortNumericDescending
            Dbl1 = Empty: Dbl2 = Empty
            On Error Resume Next
            Dbl1 = CDbl(Data(i).TextDisplay)
            Dbl2 = CDbl(Temp(j).TextDisplay)
            On Error GoTo 0
            Cmp = Sgn(Dbl1 - Dbl2)
            If Sort = FlexSortNumericDescending Then Cmp = -Cmp
        Case FlexSortStringNoCaseAscending, FlexSortStringNoCaseDescending
            Cmp = lstrcmpi(StrPtr(Data(i).TextDisplay), StrPtr(Temp(j).TextDisplay))
            If Sort = FlexSortStringNoCaseDescending Then Cmp = -Cmp
        Case FlexSortStringAscending, FlexSortStringDescending
            Cmp = lstrcmp(StrPtr(Data(i).TextDisplay), StrPtr(Temp(j).TextDisplay))
            If Sort = FlexSortStringDescending Then Cmp = -Cmp
        Case FlexSortCurrencyAscending, FlexSortCurrencyDescending
            Dim Cur1 As Currency, Cur2 As Currency
            Cur1 = Empty: Cur2 = Empty
            On Error Resume Next
            Cur1 = CCur(Data(i).TextDisplay)
            Cur2 = CCur(Temp(j).TextDisplay)
            On Error GoTo 0
            Cmp = Sgn(Cur1 - Cur2)
            If Sort = FlexSortCurrencyDescending Then Cmp = -Cmp
        Case FlexSortDateAscending, FlexSortDateDescending
            Dim Date1 As Date, Date2 As Date
            Date1 = Empty: Date2 = Empty
            On Error Resume Next
            Date1 = CDate(Data(i).TextDisplay)
            Date2 = CDate(Temp(j).TextDisplay)
            On Error GoTo 0
            Cmp = Sgn(Date1 - Date2)
            If Sort = FlexSortDateDescending Then Cmp = -Cmp
        Case FlexSortCustomText
            RaiseEvent CompareText(Data(i).TextDisplay, Temp(j).TextDisplay, Col, Cmp)
    End Select
    If Cmp < 0 Then
        CopyMemory ByVal VarPtr(Data(Dst)), ByVal VarPtr(Data(i)), Length
        i = i + 1
    Else
        CopyMemory ByVal VarPtr(Data(Dst)), ByVal VarPtr(Temp(j)), Length
        ZeroMemory ByVal VarPtr(Temp(j)), Length
        j = j + 1
    End If
    Dst = Dst + 1
Loop
Do While j <= UBound(Temp)
    CopyMemory ByVal VarPtr(Data(Dst)), ByVal VarPtr(Temp(j)), Length
    ZeroMemory ByVal VarPtr(Temp(j)), Length
    Dst = Dst + 1
    j = j + 1
Loop
End Sub

Private Sub TextDisplayMergeSortRec(ByVal Left As Long, ByVal Right As Long, ByVal Col As Long, ByRef Data() As TINDIRECTMERGESORTDATA, ByVal Sort As FlexSortConstants)
Dim Middle As Long
Middle = (Left + Right) \ 2
If Left < Right Then
    Call TextDisplayMergeSortRec(Left, Middle, Col, Data(), Sort)
    Call TextDisplayMergeSortRec(Middle + 1, Right, Col, Data(), Sort)
    Call InplaceTextDisplayMergeSort(Left, Middle, Right, Col, Data(), Sort)
End If
End Sub

Private Sub InplaceCustomMergeSort(ByVal Left As Long, ByVal Middle As Long, ByVal Right As Long, ByVal Col As Long, ByRef Data() As TINDIRECTMERGESORTDATA)
Dim Blank As TINDIRECTMERGESORTDATA, Length As Long, Temp() As TINDIRECTMERGESORTDATA, Cmp As Long, Dst As Long
Dim i As Long, j As Long
Length = LenB(Blank)
ReDim Temp(0 To (Middle - Left)) As TINDIRECTMERGESORTDATA
j = 0
For i = Left To Middle
    CopyMemory ByVal VarPtr(Temp(j)), ByVal VarPtr(Data(i)), Length
    j = j + 1
Next i
j = 0
Dst = Left
Do While i <= Right And j <= UBound(Temp)
    Cmp = 0
    RaiseEvent Compare(Data(i).Row, Temp(j).Row, Col, Cmp)
    If Cmp < 0 Then
        CopyMemory ByVal VarPtr(Data(Dst)), ByVal VarPtr(Data(i)), Length
        i = i + 1
    Else
        CopyMemory ByVal VarPtr(Data(Dst)), ByVal VarPtr(Temp(j)), Length
        ZeroMemory ByVal VarPtr(Temp(j)), Length
        j = j + 1
    End If
    Dst = Dst + 1
Loop
Do While j <= UBound(Temp)
    CopyMemory ByVal VarPtr(Data(Dst)), ByVal VarPtr(Temp(j)), Length
    ZeroMemory ByVal VarPtr(Temp(j)), Length
    Dst = Dst + 1
    j = j + 1
Loop
End Sub

Private Sub CustomMergeSortRec(ByVal Left As Long, ByVal Right As Long, ByVal Col As Long, ByRef Data() As TINDIRECTMERGESORTDATA)
Dim Middle As Long
Middle = (Left + Right) \ 2
If Left < Right Then
    Call CustomMergeSortRec(Left, Middle, Col, Data())
    Call CustomMergeSortRec(Middle + 1, Right, Col, Data())
    Call InplaceCustomMergeSort(Left, Middle, Right, Col, Data())
End If
End Sub

Private Sub BubbleSortIter(ByVal First As Long, ByVal Last As Long, ByVal Col As Long, ByRef Data() As TCOLS)
Dim Swap As TCOLS, Length As Long, Cmp As Long
Length = LenB(Swap)
Dim i As Long, j As Long, iCol As Long
Do While Last > First
    i = First
    For j = First To Last - 1
        Cmp = 0
        RaiseEvent Compare(j, j + 1, Col, Cmp)
        If Cmp > 0 Then
            CopyMemory ByVal VarPtr(Swap), ByVal VarPtr(Data(j + 1)), Length
            CopyMemory ByVal VarPtr(Data(j + 1)), ByVal VarPtr(Data(j)), Length
            CopyMemory ByVal VarPtr(Data(j)), ByVal VarPtr(Swap), Length
            ZeroMemory ByVal VarPtr(Swap), Length
            i = j
        End If
    Next j
    Last = i
Loop
End Sub

Private Function PtInRect(ByRef lpRect As RECT, ByVal X As Long, ByVal Y As Long) As Long
' Avoid API declare since x64 calling convention aligns 8 bytes per argument.
' So the handling of a ByVal PT being split into two 4-byte arguments will crash.
PtInRect = 0
If X >= lpRect.Left And X < lpRect.Right And Y >= lpRect.Top And Y < lpRect.Bottom Then PtInRect = 1
End Function

#If ImplementPreTranslateMsg = True Then

Private Function PreTranslateMsg(ByVal lParam As LongPtr) As LongPtr
PreTranslateMsg = 0
If lParam <> NULL_PTR Then
    Dim Msg As TMSG, Handled As Boolean, RetVal As Long
    CopyMemory Msg, ByVal lParam, LenB(Msg)
    IOleInPlaceActiveObjectVB_TranslateAccelerator Handled, RetVal, Msg.hWnd, Msg.Message, Msg.wParam, Msg.lParam, GetShiftStateFromMsg()
    If Handled = True Then
        PreTranslateMsg = 1
    ElseIf PropWantReturn = True Then
        If Msg.Message = WM_KEYDOWN Or Msg.Message = WM_KEYUP Then
            If (CLng(Msg.wParam) And &HFF&) = vbKeyReturn Then
                SendMessage Msg.hWnd, Msg.Message, Msg.wParam, ByVal Msg.lParam
                PreTranslateMsg = 1
            End If
        End If
    End If
End If
End Function

#End If

Friend Sub FReaderModeScroll(ByVal DX As Long, ByVal DY As Long)
If VBFlexGridHandle = NULL_PTR Then Exit Sub
If DX > 0 Then
    If VBFlexGridReaderModeScroll.CX < 0 Then VBFlexGridReaderModeScroll.CX = 0
ElseIf DX < 0 Then
    If VBFlexGridReaderModeScroll.CX > 0 Then VBFlexGridReaderModeScroll.CX = 0
End If
VBFlexGridReaderModeScroll.CX = VBFlexGridReaderModeScroll.CX + DX
If DY > 0 Then
    If VBFlexGridReaderModeScroll.CY < 0 Then VBFlexGridReaderModeScroll.CY = 0
ElseIf DY < 0 Then
    If VBFlexGridReaderModeScroll.CY > 0 Then VBFlexGridReaderModeScroll.CY = 0
End If
VBFlexGridReaderModeScroll.CY = VBFlexGridReaderModeScroll.CY + DY
If VBFlexGridReaderModeScroll.CX > 0 Then
    While VBFlexGridReaderModeScroll.CX >= GetColWidth(VBFlexGridLeftCol)
        SendMessage VBFlexGridHandle, WM_HSCROLL, MakeDWord(SB_LINERIGHT, 0), ByVal 0&
        VBFlexGridReaderModeScroll.CX = VBFlexGridReaderModeScroll.CX - GetColWidth(VBFlexGridLeftCol)
    Wend
ElseIf VBFlexGridReaderModeScroll.CX < 0 Then
    While VBFlexGridReaderModeScroll.CX <= -GetColWidth(VBFlexGridLeftCol)
        SendMessage VBFlexGridHandle, WM_HSCROLL, MakeDWord(SB_LINELEFT, 0), ByVal 0&
        VBFlexGridReaderModeScroll.CX = VBFlexGridReaderModeScroll.CX + GetColWidth(VBFlexGridLeftCol)
    Wend
End If
If VBFlexGridReaderModeScroll.CY > 0 Then
    While VBFlexGridReaderModeScroll.CY >= GetRowHeight(VBFlexGridTopRow)
        SendMessage VBFlexGridHandle, WM_VSCROLL, MakeDWord(SB_LINEDOWN, 0), ByVal 0&
        VBFlexGridReaderModeScroll.CY = VBFlexGridReaderModeScroll.CY - GetRowHeight(VBFlexGridTopRow)
    Wend
ElseIf VBFlexGridReaderModeScroll.CY < 0 Then
    While VBFlexGridReaderModeScroll.CY <= -GetRowHeight(VBFlexGridTopRow)
        SendMessage VBFlexGridHandle, WM_VSCROLL, MakeDWord(SB_LINEUP, 0), ByVal 0&
        VBFlexGridReaderModeScroll.CY = VBFlexGridReaderModeScroll.CY + GetRowHeight(VBFlexGridTopRow)
    Wend
End If
End Sub

#If VBA7 Then
Friend Function FSubclass_Message(ByVal hWnd As LongPtr, ByVal wMsg As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr, ByVal dwRefData As LongPtr) As LongPtr
#Else
Friend Function FSubclass_Message(ByVal hWnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByVal lParam As Long, ByVal dwRefData As Long) As Long
#End If
Select Case dwRefData
    Case 1
        FSubclass_Message = WindowProcControl(hWnd, wMsg, wParam, lParam)
    Case 2
        FSubclass_Message = WindowProcEdit(hWnd, wMsg, wParam, lParam)
    Case 3
        FSubclass_Message = WindowProcComboButton(hWnd, wMsg, wParam, lParam)
    Case 4
        FSubclass_Message = WindowProcComboList(hWnd, wMsg, wParam, lParam)
    Case 5
        FSubclass_Message = WindowProcComboCalendar(hWnd, wMsg, wParam, lParam)
    Case 6
        FSubclass_Message = WindowProcUserControl(hWnd, wMsg, wParam, lParam)
End Select
End Function

Private Function WindowProcControl(ByVal hWnd As LongPtr, ByVal wMsg As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr) As LongPtr
Dim Pos As Long, Cancel As Boolean
Select Case wMsg
    Case WM_SETFOCUS
        If wParam <> UserControl.hWnd Then SetFocusAPI UserControl.hWnd: Exit Function
        If VBFlexGridEditHandle <> NULL_PTR Then SetFocusAPI VBFlexGridEditHandle: Exit Function
        
        #If ImplementPreTranslateMsg = True Then
        
        If UsePreTranslateMsg = False Then Call ActivateIPAO(Me) Else Call FlexPreTranslateMsgActivate(hWnd)
        
        #Else
        
        Call ActivateIPAO(Me)
        
        #End If
        
    Case WM_KILLFOCUS
        
        #If ImplementPreTranslateMsg = True Then
        
        If UsePreTranslateMsg = False Then Call DeActivateIPAO Else Call FlexPreTranslateMsgDeActivate
        
        #Else
        
        Call DeActivateIPAO
        
        #End If
        
    Case WM_GETFONT
        WindowProcControl = VBFlexGridFontHandle
        Exit Function
    Case WM_SETREDRAW
        VBFlexGridNoRedraw = CBool(wParam = 0)
        WindowProcControl = 0
        Exit Function
    Case WM_SIZE
        If VBFlexGridDoubleBufferDC <> NULL_PTR Then
            If VBFlexGridDoubleBufferBmpOld <> NULL_PTR Then
                SelectObject VBFlexGridDoubleBufferDC, VBFlexGridDoubleBufferBmpOld
                VBFlexGridDoubleBufferBmpOld = NULL_PTR
            End If
            If VBFlexGridDoubleBufferBmp <> NULL_PTR Then
                DeleteObject VBFlexGridDoubleBufferBmp
                VBFlexGridDoubleBufferBmp = NULL_PTR
            End If
            DeleteDC VBFlexGridDoubleBufferDC
            VBFlexGridDoubleBufferDC = NULL_PTR
        End If
        GetClientRect hWnd, VBFlexGridClientRect
        Dim RCP1 As TROWCOLPARAMS
        With RCP1
        .Mask = RCPM_TOPROW Or RCPM_LEFTCOL
        .Flags = RCPF_CHECKTOPROW Or RCPF_CHECKLEFTCOL Or RCPF_FORCETOPROWMASK Or RCPF_FORCELEFTCOLMASK Or RCPF_SETSCROLLBARS
        .Message = WM_SIZE
        .TopRow = VBFlexGridTopRow
        .LeftCol = VBFlexGridLeftCol
        Call SetRowColParams(RCP1)
        End With
        If PropShowInfoTips = True Or PropShowLabelTips = True Then Call UpdateToolTipRect
    Case WM_HSCROLL, WM_VSCROLL
        Dim dwStyle As Long
        dwStyle = GetWindowLong(hWnd, GWL_STYLE)
        If lParam = 0 And ((wMsg = WM_HSCROLL And (dwStyle And WS_HSCROLL) = WS_HSCROLL) Or (wMsg = WM_VSCROLL And (dwStyle And WS_VSCROLL) = WS_VSCROLL)) Then
            Dim SCI As SCROLLINFO, wBar As Long, PrevPos As Long
            SCI.cbSize = LenB(SCI)
            SCI.fMask = SIF_ALL
            If wMsg = WM_HSCROLL Then
                wBar = SB_HORZ
            ElseIf wMsg = WM_VSCROLL Then
                wBar = SB_VERT
            End If
            GetScrollInfo hWnd, wBar, SCI
            PrevPos = SCI.nPos
            Select Case LoWord(CLng(wParam))
                Case SB_LINELEFT, SB_LINEUP
                    If wMsg = WM_HSCROLL Then
                        SCI.nPos = VBFlexGridLeftCol
                        Call MovePreviousCol(SCI.nPos)
                        If SCI.nPos < VBFlexGridLeftCol Then
                            SCI.nPos = SCI.nPos - (PropFixedCols + PropFrozenCols)
                        Else
                            SCI.nPos = SCI.nMin
                        End If
                    ElseIf wMsg = WM_VSCROLL Then
                        SCI.nPos = VBFlexGridTopRow
                        Call MovePreviousRow(SCI.nPos)
                        If SCI.nPos < VBFlexGridTopRow Then
                            SCI.nPos = SCI.nPos - (PropFixedRows + PropFrozenRows)
                        Else
                            SCI.nPos = SCI.nMin
                        End If
                    End If
                Case SB_LINERIGHT, SB_LINEDOWN
                    If wMsg = WM_HSCROLL Then
                        SCI.nPos = VBFlexGridLeftCol
                        Call MoveNextCol(SCI.nPos)
                        If SCI.nPos > VBFlexGridLeftCol Then
                            SCI.nPos = SCI.nPos - (PropFixedCols + PropFrozenCols)
                        Else
                            SCI.nPos = SCI.nMax
                        End If
                    ElseIf wMsg = WM_VSCROLL Then
                        SCI.nPos = VBFlexGridTopRow
                        Call MoveNextRow(SCI.nPos)
                        If SCI.nPos > VBFlexGridTopRow Then
                            SCI.nPos = SCI.nPos - (PropFixedRows + PropFrozenRows)
                        Else
                            SCI.nPos = SCI.nMax
                        End If
                    End If
                Case SB_PAGELEFT, SB_PAGEUP
                    If wBar = SB_HORZ Then
                        SCI.nPos = SCI.nPos - GetColsPerPageRev(VBFlexGridLeftCol)
                    ElseIf wBar = SB_VERT Then
                        SCI.nPos = SCI.nPos - GetRowsPerPageRev(VBFlexGridTopRow)
                    End If
                Case SB_PAGERIGHT, SB_PAGEDOWN
                    If wBar = SB_HORZ Then
                        SCI.nPos = SCI.nPos + GetColsPerPage(VBFlexGridLeftCol)
                    ElseIf wBar = SB_VERT Then
                        SCI.nPos = SCI.nPos + GetRowsPerPage(VBFlexGridTopRow)
                    End If
                Case SB_THUMBPOSITION
                    SCI.nPos = SCI.nTrackPos
                Case SB_THUMBTRACK
                    If PropScrollTrack = True Then SCI.nPos = SCI.nTrackPos
                Case SB_TOP
                    SCI.nPos = SCI.nMin
                Case SB_BOTTOM
                    SCI.nPos = SCI.nMax
            End Select
            If SCI.nPos > SCI.nMax Then
                SCI.nPos = SCI.nMax
            ElseIf SCI.nPos < SCI.nMin Then
                SCI.nPos = SCI.nMin
            End If
            If PrevPos <> SCI.nPos Then
                SCI.fMask = SIF_POS
                SetScrollInfo hWnd, wBar, SCI, 1
                If wMsg = WM_HSCROLL Then
                    VBFlexGridLeftCol = (PropFixedCols + PropFrozenCols) + SCI.nPos
                ElseIf wMsg = WM_VSCROLL Then
                    VBFlexGridTopRow = (PropFixedRows + PropFrozenRows) + SCI.nPos
                End If
                Call RedrawGrid
                If PropShowInfoTips = True Or PropShowLabelTips = True Then
                    Pos = GetMessagePos()
                    Call CheckToolTipRowCol(Get_X_lParam(Pos), Get_Y_lParam(Pos))
                End If
                If VBFlexGridEditRow > -1 And VBFlexGridEditCol > -1 Then Call UpdateEditRect
                RaiseEvent Scroll
            End If
            If PropShowScrollTips = True Then
                Select Case LoWord(CLng(wParam))
                    Case SB_THUMBPOSITION
                        Call CancelScrollTip
                    Case SB_THUMBTRACK
                        Pos = GetMessagePos()
                        Call UpdateScrollTip(wBar, SCI.nTrackPos, Get_X_lParam(Pos), Get_Y_lParam(Pos))
                End Select
            End If
            WindowProcControl = 0
            Exit Function
        End If
    Case WM_PAINT
        If wParam = 0 Then
            Dim PS As PAINTSTRUCT, hDC As LongPtr, hRgn As LongPtr
            hDC = BeginPaint(hWnd, PS)
            With PS
            If PropDoubleBuffer = True Then
                If VBFlexGridDoubleBufferDC = NULL_PTR Then
                    VBFlexGridDoubleBufferDC = CreateCompatibleDC(hDC)
                    If VBFlexGridDoubleBufferDC <> NULL_PTR Then
                        VBFlexGridDoubleBufferBmp = CreateCompatibleBitmap(hDC, VBFlexGridClientRect.Right - VBFlexGridClientRect.Left, VBFlexGridClientRect.Bottom - VBFlexGridClientRect.Top)
                        If VBFlexGridDoubleBufferBmp <> NULL_PTR Then VBFlexGridDoubleBufferBmpOld = SelectObject(VBFlexGridDoubleBufferDC, VBFlexGridDoubleBufferBmp)
                    End If
                End If
                If VBFlexGridDoubleBufferDC <> NULL_PTR And VBFlexGridDoubleBufferBmp <> NULL_PTR Then
                    If .fErase <> 0 Then
                        If VBFlexGridBackColorBkgBrush <> NULL_PTR Then FillRect VBFlexGridDoubleBufferDC, VBFlexGridClientRect, VBFlexGridBackColorBkgBrush
                        Call DrawGrid(VBFlexGridDoubleBufferDC, NULL_PTR, True)
                    Else
                        Call DrawGrid(VBFlexGridDoubleBufferDC, hRgn, False)
                        If hRgn <> NULL_PTR Then ExtSelectClipRgn hDC, hRgn, RGN_COPY
                    End If
                    With PS.RCPaint
                    BitBlt hDC, .Left, .Top, .Right - .Left, .Bottom - .Top, VBFlexGridDoubleBufferDC, .Left, .Top, vbSrcCopy
                    End With
                    If hRgn <> NULL_PTR Then
                        ExtSelectClipRgn hDC, NULL_PTR, RGN_COPY
                        DeleteObject hRgn
                    End If
                End If
            Else
                If .fErase <> 0 Then
                    Call DrawGrid(hDC, hRgn, False)
                    If hRgn <> NULL_PTR Then
                        ExtSelectClipRgn hDC, hRgn, RGN_DIFF
                        If VBFlexGridBackColorBkgBrush <> NULL_PTR Then FillRect hDC, VBFlexGridClientRect, VBFlexGridBackColorBkgBrush
                    End If
                Else
                    Call DrawGrid(hDC, NULL_PTR, True)
                End If
                If hRgn <> NULL_PTR Then
                    ExtSelectClipRgn hDC, NULL_PTR, RGN_COPY
                    DeleteObject hRgn
                End If
            End If
            End With
            EndPaint hWnd, PS
            If VBFlexGridDividerDragDirty = True Then
                With PS.RCPaint
                hRgn = CreateRectRgn(.Left, .Top, .Right, .Bottom)
                End With
                Call DrawDividerDragSplitter(hRgn)
                If hRgn <> NULL_PTR Then DeleteObject hRgn
            End If
        Else
            Dim hDCBmp As LongPtr, hBmp As LongPtr, hBmpOld As LongPtr
            hDCBmp = CreateCompatibleDC(wParam)
            If hDCBmp <> NULL_PTR Then
                hBmp = CreateCompatibleBitmap(wParam, VBFlexGridClientRect.Right - VBFlexGridClientRect.Left, VBFlexGridClientRect.Bottom - VBFlexGridClientRect.Top)
                If hBmp <> NULL_PTR Then
                    hBmpOld = SelectObject(hDCBmp, hBmp)
                    If SendMessage(hWnd, WM_ERASEBKGND, hDCBmp, ByVal 0&) = 0 Then
                        If VBFlexGridBackColorBkgBrush <> NULL_PTR Then FillRect hDCBmp, VBFlexGridClientRect, VBFlexGridBackColorBkgBrush
                    End If
                    Call DrawGrid(hDCBmp, NULL_PTR, True)
                    BitBlt wParam, 0, 0, VBFlexGridClientRect.Right - VBFlexGridClientRect.Left, VBFlexGridClientRect.Bottom - VBFlexGridClientRect.Top, hDCBmp, 0, 0, vbSrcCopy
                    SelectObject hDCBmp, hBmpOld
                    DeleteObject hBmp
                End If
                DeleteDC hDCBmp
            End If
        End If
        WindowProcControl = 0
        Exit Function
    Case WM_PRINTCLIENT
        WindowProcControl = WindowProcControl(hWnd, WM_PAINT, wParam, ByVal 0&)
        Exit Function
    Case WM_MOUSEACTIVATE
        If VBFlexGridEditRow > -1 And VBFlexGridEditCol > -1 Then
            If ValidateEditOnMouseActivateMsg(lParam, WindowProcControl) = True Then
                ' In case the edit window is still active due to failed validation then this ensures that the focus is properly set when clicked from outside.
                If VBFlexGridEditHandle <> NULL_PTR Then
                    If GetFocus() <> VBFlexGridEditHandle Then SetFocusAPI UserControl.hWnd
                End If
                Exit Function
            End If
        End If
    Case WM_SETCURSOR
        If LoWord(CLng(lParam)) = HTCLIENT Then
            Dim HTI1 As THITTESTINFO
            With HTI1
            Pos = GetMessagePos()
            .PT.X = Get_X_lParam(Pos)
            .PT.Y = Get_Y_lParam(Pos)
            ScreenToClient hWnd, .PT
            Call GetHitTestInfo(HTI1)
            Select Case .HitResult
                Case FlexHitResultDividerRowTop, FlexHitResultDividerRowBottom, FlexHitResultDividerFrozenRowTop, FlexHitResultDividerFrozenRowBottom
                    SetCursor LoadCursor(NULL_PTR, MousePointerID(vbSizeNS))
                    WindowProcControl = 1
                    Exit Function
                Case FlexHitResultDividerColumnLeft, FlexHitResultDividerColumnRight, FlexHitResultDividerFrozenColumnLeft, FlexHitResultDividerFrozenColumnRight
                    SetCursor LoadCursor(NULL_PTR, MousePointerID(vbSizeWE))
                    WindowProcControl = 1
                    Exit Function
            End Select
            End With
            If MousePointerID(PropMousePointer) <> 0 Then
                SetCursor LoadCursor(NULL_PTR, MousePointerID(PropMousePointer))
                WindowProcControl = 1
                Exit Function
            ElseIf PropMousePointer = 99 Then
                If Not PropMouseIcon Is Nothing Then
                    SetCursor PropMouseIcon.Handle
                    WindowProcControl = 1
                    Exit Function
                End If
            End If
        End If
    Case WM_SETTINGCHANGE
        SystemParametersInfo SPI_GETWHEELSCROLLLINES, 0, VarPtr(VBFlexGridWheelScrollLines), 0
        If SystemParametersInfo(SPI_GETFOCUSBORDERWIDTH, 0, VarPtr(VBFlexGridFocusBorder.CX), 0) = 0 Then VBFlexGridFocusBorder.CX = 1
        If SystemParametersInfo(SPI_GETFOCUSBORDERHEIGHT, 0, VarPtr(VBFlexGridFocusBorder.CY), 0) = 0 Then VBFlexGridFocusBorder.CY = 1
        If VBFlexGridFocusRectPen <> NULL_PTR Then
            DeleteObject VBFlexGridFocusRectPen
            VBFlexGridFocusRectPen = NULL_PTR
        End If
        If PropFocusRect = FlexFocusRectFlat Then VBFlexGridFocusRectPen = CreatePen(PS_INSIDEFRAME, GetFocusRectWidth(), WinColor(PropBackColorSel))
    Case WM_STYLECHANGED
        If wParam = GWL_EXSTYLE Then
            Dim dwStyleNew As Long
            CopyMemory dwStyleNew, ByVal UnsignedAdd(lParam, 4), 4
            VBFlexGridRTLLayout = CBool((dwStyleNew And WS_EX_LAYOUTRTL) = WS_EX_LAYOUTRTL)
            VBFlexGridRTLReading = CBool((dwStyleNew And WS_EX_RTLREADING) = WS_EX_RTLREADING)
            If VBFlexGridDoubleBufferDC <> NULL_PTR Then SetLayout VBFlexGridDoubleBufferDC, IIf(VBFlexGridRTLLayout, LAYOUT_RTL, 0)
        End If
    Case WM_MOUSEWHEEL
        If VBFlexGridWheelScrollLines > 0 Then
            Static WheelDelta As Long, LastWheelDelta As Long
            Dim CurrWheelDelta As Long
            CurrWheelDelta = Get_Wheel_Delta_wParam(wParam)
            If Sgn(CurrWheelDelta) <> Sgn(LastWheelDelta) Then WheelDelta = 0
            WheelDelta = WheelDelta + CurrWheelDelta
            If Abs(WheelDelta) >= 120 Then
                Dim WheelDeltaPerLine As Long
                WheelDeltaPerLine = (WheelDelta \ VBFlexGridWheelScrollLines)
                If Sgn(WheelDelta) = -1 Then
                    While WheelDelta <= WheelDeltaPerLine
                        SendMessage hWnd, WM_VSCROLL, MakeDWord(SB_LINEDOWN, 0), ByVal 0&
                        WheelDelta = WheelDelta - WheelDeltaPerLine
                    Wend
                Else
                    While WheelDelta >= WheelDeltaPerLine
                        SendMessage hWnd, WM_VSCROLL, MakeDWord(SB_LINEUP, 0), ByVal 0&
                        WheelDelta = WheelDelta - WheelDeltaPerLine
                    Wend
                End If
                WheelDelta = 0
            End If
            LastWheelDelta = CurrWheelDelta
            WindowProcControl = 0
            Exit Function
        End If
    Case WM_MOUSEHWHEEL
        Static HWheelDelta As Long, LastHWheelDelta As Long
        Dim CurrHWheelDelta As Long
        CurrHWheelDelta = Get_Wheel_Delta_wParam(wParam)
        If Sgn(CurrHWheelDelta) <> Sgn(LastHWheelDelta) Then HWheelDelta = 0
        HWheelDelta = HWheelDelta + CurrHWheelDelta
        If Abs(HWheelDelta) >= 120 Then
            If Sgn(HWheelDelta) = -1 Then
                SendMessage hWnd, WM_HSCROLL, MakeDWord(SB_LINELEFT, 0), ByVal 0&
            Else
                SendMessage hWnd, WM_HSCROLL, MakeDWord(SB_LINERIGHT, 0), ByVal 0&
            End If
            HWheelDelta = 0
        End If
        LastHWheelDelta = CurrHWheelDelta
        WindowProcControl = 0
        Exit Function
    Case WM_KEYDOWN, WM_KEYUP, WM_SYSKEYDOWN, WM_SYSKEYUP
        Dim KeyCode As Integer
        KeyCode = CLng(wParam) And &HFF&
        If wMsg = WM_KEYDOWN Or wMsg = WM_KEYUP Then
            If wMsg = WM_KEYDOWN Then
                RaiseEvent KeyDown(KeyCode, GetShiftStateFromMsg())
                If PropAllowUserEditing = True Then
                    Select Case KeyCode
                        Case vbKeyF2
                            If CreateEdit(FlexEditReasonF2) = True Then Exit Function
                        Case vbKeySpace
                            If VBFlexGridIncrementalSearch.SearchString = vbNullString Then
                                If GetShiftStateFromMsg() = 0 Then
                                    If VBFlexGridRow > -1 And VBFlexGridCol > -1 Then
                                        If GetCellChecked(VBFlexGridRow, VBFlexGridCol) > -1 Then
                                            Call SetCellCheck(VBFlexGridRow, VBFlexGridCol, FlexCellCheckReasonKeyboard)
                                        ElseIf CreateEdit(FlexEditReasonSpace) = True Then
                                            Exit Function
                                        End If
                                    Else
                                        If CreateEdit(FlexEditReasonSpace) = True Then Exit Function
                                    End If
                                End If
                            End If
                        Case vbKeyBack
                            If VBFlexGridIncrementalSearch.SearchString = vbNullString Then
                                If GetShiftStateFromMsg() = 0 Then
                                    If CreateEdit(FlexEditReasonBackSpace) = True Then Exit Function
                                End If
                            End If
                        Case vbKeyReturn
                            If PropDirectionAfterReturn = FlexDirectionAfterReturnEdit Then
                                If VBFlexGridIncrementalSearch.SearchString = vbNullString Then
                                    If GetShiftStateFromMsg() = 0 Then
                                        If CreateEdit(FlexEditReasonReturn) = True Then Exit Function
                                    End If
                                End If
                            End If
                        Case vbKeyF4
                            If VBFlexGridRow > -1 And VBFlexGridCol > -1 Then
                                Select Case GetComboCueActive(VBFlexGridRow, VBFlexGridCol)
                                    Case FlexComboCueDropDown, FlexComboCueButton
                                        If CreateEdit(FlexEditReasonComboCueF4) = True Then
                                            Exit Function
                                        ElseIf PropAlwaysAllowComboCues = True Then
                                            Call ComboCuePerformClick(FlexEditReasonComboCueF4)
                                        End If
                                End Select
                            End If
                    End Select
                Else
                    Select Case KeyCode
                        Case vbKeySpace
                            If VBFlexGridIncrementalSearch.SearchString = vbNullString Then
                                If GetShiftStateFromMsg() = 0 Then
                                    If VBFlexGridRow > -1 And VBFlexGridCol > -1 Then
                                        If GetCellChecked(VBFlexGridRow, VBFlexGridCol) > -1 Then Call SetCellCheck(VBFlexGridRow, VBFlexGridCol, FlexCellCheckReasonKeyboard)
                                    End If
                                End If
                            End If
                        Case vbKeyF4
                            If PropAlwaysAllowComboCues = True Then
                                If VBFlexGridRow > -1 And VBFlexGridCol > -1 Then
                                    Select Case GetComboCueActive(VBFlexGridRow, VBFlexGridCol)
                                        Case FlexComboCueDropDown, FlexComboCueButton
                                            Call ComboCuePerformClick(FlexEditReasonComboCueF4)
                                    End Select
                                End If
                            End If
                    End Select
                End If
                If PropAutoClipboard = True Then
                    If VBFlexGridRow > -1 And VBFlexGridCol > -1 Then
                        If PropAllowUserEditing = False Then
                            If GetShiftStateFromMsg() = vbCtrlMask And (KeyCode = vbKeyC Or KeyCode = vbKeyInsert) Then Me.Copy
                        Else
                            Select Case GetShiftStateFromMsg()
                                Case vbShiftMask
                                    Select Case KeyCode
                                        Case vbKeyDelete
                                            Me.Cut
                                        Case vbKeyInsert
                                            Me.Paste
                                    End Select
                                Case vbCtrlMask
                                    Select Case KeyCode
                                        Case vbKeyC, vbKeyInsert
                                            Me.Copy
                                        Case vbKeyX
                                            Me.Cut
                                        Case vbKeyV
                                            Me.Paste
                                        Case vbKeyDelete
                                            Me.Delete
                                    End Select
                                Case Else
                                    Select Case KeyCode
                                        Case vbKeyDelete
                                            Me.Delete
                                    End Select
                            End Select
                        End If
                    End If
                End If
            ElseIf wMsg = WM_KEYUP Then
                RaiseEvent KeyUp(KeyCode, GetShiftStateFromMsg())
            End If
            Dim Msg As TMSG
            Const PM_NOREMOVE As Long = &H0
            If PeekMessage(Msg, hWnd, WM_CHAR, WM_CHAR, PM_NOREMOVE) <> 0 Then VBFlexGridCharCodeCache = CLng(Msg.wParam)
            If wMsg = WM_KEYDOWN Then Call ProcessKeyDown(KeyCode, GetShiftStateFromMsg())
        ElseIf wMsg = WM_SYSKEYDOWN Then
            RaiseEvent KeyDown(KeyCode, GetShiftStateFromMsg())
            If PropAllowUserEditing = True Then
                If KeyCode = vbKeyUp Or KeyCode = vbKeyDown Then
                    If VBFlexGridRow > -1 And VBFlexGridCol > -1 Then
                        Select Case GetComboCueActive(VBFlexGridRow, VBFlexGridCol)
                            Case FlexComboCueDropDown
                                If CreateEdit(FlexEditReasonComboCueAltUpDown) = True Then
                                    Exit Function
                                ElseIf PropAlwaysAllowComboCues = True Then
                                    Call ComboCuePerformClick(FlexEditReasonComboCueAltUpDown)
                                End If
                        End Select
                    End If
                End If
            ElseIf PropAlwaysAllowComboCues = True Then
                If KeyCode = vbKeyUp Or KeyCode = vbKeyDown Then
                    If VBFlexGridRow > -1 And VBFlexGridCol > -1 Then
                        Select Case GetComboCueActive(VBFlexGridRow, VBFlexGridCol)
                            Case FlexComboCueDropDown
                                Call ComboCuePerformClick(FlexEditReasonComboCueAltUpDown)
                        End Select
                    End If
                End If
            End If
        ElseIf wMsg = WM_SYSKEYUP Then
            RaiseEvent KeyUp(KeyCode, GetShiftStateFromMsg())
        End If
        wParam = KeyCode
    Case WM_CHAR
        Dim KeyChar As Integer
        If VBFlexGridCharCodeCache <> 0 Then
            KeyChar = CUIntToInt(VBFlexGridCharCodeCache And &HFFFF&)
            VBFlexGridCharCodeCache = 0
        Else
            KeyChar = CUIntToInt(CLng(wParam) And &HFFFF&)
        End If
        RaiseEvent KeyPress(KeyChar)
        wParam = CIntToUInt(KeyChar)
        If PropAllowIncrementalSearch = False Then
            If PropAllowUserEditing = True Then
                If wParam >= 33 Then ' 0 to 31 are non-printable and 32 is space char
                    If CreateEdit(FlexEditReasonKeyPress) = True Then
                        If VBFlexGridEditHandle <> NULL_PTR Then PostMessage VBFlexGridEditHandle, wMsg, wParam, ByVal 0&
                        Exit Function
                    End If
                End If
            End If
        End If
        If PropAllowIncrementalSearch = True Then Call StartIncrementalSearch(CLng(wParam))
    Case WM_UNICHAR
        If wParam = UNICODE_NOCHAR Then
            WindowProcControl = 1
        Else
            Dim UTF16 As String
            UTF16 = UTF32CodePoint_To_UTF16(CLng(wParam))
            If Len(UTF16) = 1 Then
                SendMessage hWnd, WM_CHAR, CIntToUInt(AscW(UTF16)), ByVal lParam
            ElseIf Len(UTF16) = 2 Then
                SendMessage hWnd, WM_CHAR, CIntToUInt(AscW(Left$(UTF16, 1))), ByVal lParam
                SendMessage hWnd, WM_CHAR, CIntToUInt(AscW(Right$(UTF16, 1))), ByVal lParam
            End If
            WindowProcControl = 0
        End If
        Exit Function
    Case WM_INPUTLANGCHANGE
        Call SetIMEMode(hWnd, VBFlexGridIMCHandle, PropIMEMode)
    Case WM_IME_SETCONTEXT
        If wParam <> 0 Then Call SetIMEMode(hWnd, VBFlexGridIMCHandle, PropIMEMode)
    Case WM_IME_CHAR
        SendMessage hWnd, WM_CHAR, wParam, ByVal lParam
        Exit Function
    Case WM_DROPFILES
        If wParam <> NULL_PTR Then
            Dim FileCount As Long
            FileCount = DragQueryFile(wParam, -1, NULL_PTR, 0)
            If FileCount > 0 Then
                Dim FileList() As String, iFile As Long, FileBuffer As String, P As POINTAPI
                ReDim FileList(0 To (FileCount - 1)) As String
                For iFile = 0 To (FileCount - 1)
                    FileBuffer = String(DragQueryFile(wParam, iFile, NULL_PTR, 0), vbNullChar)
                    DragQueryFile wParam, iFile, StrPtr(FileBuffer), Len(FileBuffer) + 1
                    FileList(iFile) = FileBuffer
                Next iFile
                DragQueryPoint wParam, P
                RaiseEvent DropFiles(FileList(), UserControl.ScaleX(P.X, vbPixels, vbContainerPosition), UserControl.ScaleY(P.Y, vbPixels, vbContainerPosition))
            End If
            DragFinish wParam
        End If
        WindowProcControl = 0
        Exit Function
    Case WM_LBUTTONDOWN, WM_MBUTTONDOWN, WM_RBUTTONDOWN
        Dim HTI2 As THITTESTINFO
        With HTI2
        .PT.X = Get_X_lParam(lParam)
        .PT.Y = Get_Y_lParam(lParam)
        Call GetHitTestInfo(HTI2)
        Select Case wMsg
            Case WM_LBUTTONDOWN
                RaiseEvent BeforeMouseDown(vbLeftButton, GetShiftStateFromParam(wParam), UserControl.ScaleX(.PT.X, vbPixels, vbTwips), UserControl.ScaleY(.PT.Y, vbPixels, vbTwips), Cancel)
                If Cancel = False Then
                    SetCapture hWnd
                    If GetFocus() <> hWnd Then SetFocusAPI UserControl.hWnd
                    Cancel = ProcessLButtonDown(GetShiftStateFromParam(wParam), HTI2)
                End If
            Case WM_MBUTTONDOWN
                RaiseEvent BeforeMouseDown(vbMiddleButton, GetShiftStateFromParam(wParam), UserControl.ScaleX(.PT.X, vbPixels, vbTwips), UserControl.ScaleY(.PT.Y, vbPixels, vbTwips), Cancel)
            Case WM_RBUTTONDOWN
                RaiseEvent BeforeMouseDown(vbRightButton, GetShiftStateFromParam(wParam), UserControl.ScaleX(.PT.X, vbPixels, vbTwips), UserControl.ScaleY(.PT.Y, vbPixels, vbTwips), Cancel)
        End Select
        End With
        If Cancel = True Then
            VBFlexGridCellClickRow = -1
            VBFlexGridCellClickCol = -1
            WindowProcControl = 0
            Exit Function
        Else
            With HTI2
            If .HitResult = FlexHitResultCell Then
                VBFlexGridCellClickRow = .HitRow
                VBFlexGridCellClickCol = .HitCol
            Else
                VBFlexGridCellClickRow = -1
                VBFlexGridCellClickCol = -1
                If wMsg = WM_LBUTTONDOWN Then
                    If .HitResult = FlexHitResultComboCue Then
                        If PropAllowUserEditing = True Then
                            Select Case PropSelectionMode
                                Case FlexSelectionModeByRow
                                    If CreateEdit(FlexEditReasonComboCueClick, .HitRow) = False And PropAlwaysAllowComboCues = True Then Call ComboCuePerformClick(FlexEditReasonComboCueClick, .HitRow)
                                Case FlexSelectionModeByColumn
                                    If CreateEdit(FlexEditReasonComboCueClick, , .HitCol) = False And PropAlwaysAllowComboCues = True Then Call ComboCuePerformClick(FlexEditReasonComboCueClick, , .HitCol)
                                Case Else
                                    If CreateEdit(FlexEditReasonComboCueClick, .HitRow, .HitCol) = False And PropAlwaysAllowComboCues = True Then Call ComboCuePerformClick(FlexEditReasonComboCueClick, .HitRow, .HitCol)
                            End Select
                        ElseIf PropAlwaysAllowComboCues = True Then
                            Select Case PropSelectionMode
                                Case FlexSelectionModeByRow
                                    Call ComboCuePerformClick(FlexEditReasonComboCueClick, .HitRow)
                                Case FlexSelectionModeByColumn
                                    Call ComboCuePerformClick(FlexEditReasonComboCueClick, , .HitCol)
                                Case Else
                                    Call ComboCuePerformClick(FlexEditReasonComboCueClick, .HitRow, .HitCol)
                            End Select
                        End If
                    ElseIf .HitResult = FlexHitResultCheckBox Then
                        Call SetCellCheck(.HitRow, .HitCol, FlexCellCheckReasonMouse)
                    End If
                End If
            End If
            End With
            If PropAllowReaderMode = True Then
                If wMsg = WM_MBUTTONDOWN Then
                    If PropRows > 0 And PropCols > 0 And PropScrollBars <> vbSBNone Then
                        If VBFlexGridReaderModeAnchorRegistered = False Then
                            Call FlexReaderModeAnchorRegisterClass
                            VBFlexGridReaderModeAnchorRegistered = True
                        End If
                        VBFlexGridReaderModeScroll.CX = 0
                        VBFlexGridReaderModeScroll.CY = 0
                        Call StartReaderMode(wParam, lParam)
                    End If
                End If
            End If
        End If
    Case WM_MOUSEMOVE
        Call ProcessMouseMove(GetMouseStateFromParam(wParam), Get_X_lParam(lParam), Get_Y_lParam(lParam))
        If PropMouseTrack = True Then
            Dim HTI3 As THITTESTINFO
            With HTI3
            .PT.X = Get_X_lParam(lParam)
            .PT.Y = Get_Y_lParam(lParam)
            Call GetHitTestInfo(HTI3)
            If .HitRow > -1 And .HitCol > -1 Then
                If VBFlexGridHotRow <> .HitRow Or VBFlexGridHotCol <> .HitCol Or VBFlexGridHotHitResult <> .HitResult Then
                    VBFlexGridHotRow = .HitRow
                    VBFlexGridHotCol = .HitCol
                    VBFlexGridHotHitResult = .HitResult
                    Call RedrawGrid
                End If
            Else
                If VBFlexGridHotRow > -1 And VBFlexGridHotCol > -1 Then
                    VBFlexGridHotRow = -1
                    VBFlexGridHotCol = -1
                    VBFlexGridHotHitResult = FlexHitResultNoWhere
                    Call RedrawGrid
                End If
            End If
            End With
        End If
    Case WM_MOUSELEAVE
        If VBFlexGridHotRow > -1 And VBFlexGridHotCol > -1 Then
            VBFlexGridHotRow = -1
            VBFlexGridHotCol = -1
            VBFlexGridHotHitResult = FlexHitResultNoWhere
            Call RedrawGrid
        End If
    Case WM_LBUTTONUP
        Call ProcessLButtonUp(GetShiftStateFromParam(wParam), Get_X_lParam(lParam), Get_Y_lParam(lParam))
        ReleaseCapture
    Case WM_CANCELMODE
        If PropAllowIncrementalSearch = True Then
            If Not VBFlexGridIncrementalSearch.SearchString = vbNullString Then Call CancelIncrementalSearch
        End If
    Case WM_CAPTURECHANGED
        If VBFlexGridDoDragRowCol = True Then PostMessage hWnd, UM_CAPTURECHANGED, wParam, ByVal lParam
        VBFlexGridCapturePoint.X = 0
        VBFlexGridCapturePoint.Y = 0
        VBFlexGridCaptureRow = -1
        VBFlexGridCaptureCol = -1
        VBFlexGridCaptureHitResult = FlexHitResultNoWhere
        VBFlexGridCaptureDividerRow = -1
        VBFlexGridCaptureDividerCol = -1
        VBFlexGridCaptureDividerDrag = False
        VBFlexGridCaptureDividerMoved = False
        VBFlexGridMouseMoveRow = -1
        VBFlexGridMouseMoveCol = -1
        VBFlexGridMouseMoveChanged = False
        If VBFlexGridDividerDragDirty = True Then
            ClipCursor ByVal NULL_PTR
            SetRect VBFlexGridDividerDragSplitterRect, 0, 0, 0, 0
            VBFlexGridDividerDragOffset.X = 0
            VBFlexGridDividerDragOffset.Y = 0
            VBFlexGridDividerDragDirty = False
            Call RedrawGrid
        End If
        If VBFlexGridExpandSelectedRows = True Then
            Dim RCP2 As TROWCOLPARAMS
            RCP2.Message = WM_CAPTURECHANGED
            Call SetRowColParams(RCP2)
        End If
    Case WM_NOTIFY
        Dim NM As NMHDR
        CopyMemory NM, ByVal lParam, LenB(NM)
        If NM.hWndFrom = VBFlexGridToolTipHandle And VBFlexGridToolTipHandle <> NULL_PTR Then
            Static ShowTipRow As Long, ShowTipCol As Long, ShowInfoTip As Boolean, LBLI As TLABELINFO
            Select Case NM.Code
                Case TTN_GETDISPINFO
                    Dim NMTTDI As NMTTDISPINFO
                    CopyMemory NMTTDI, ByVal lParam, LenB(NMTTDI)
                    ShowTipRow = -1
                    ShowTipCol = -1
                    ShowInfoTip = False
                    LBLI.Flags = 0
                    Dim HTI4 As THITTESTINFO
                    With HTI4
                    Pos = GetMessagePos()
                    .PT.X = Get_X_lParam(Pos)
                    .PT.Y = Get_Y_lParam(Pos)
                    ScreenToClient hWnd, .PT
                    Call GetHitTestInfo(HTI4)
                    Dim Text As String
                    If .HitRow > -1 And .HitCol > -1 And .HitResult = FlexHitResultCell Then
                        If PropShowLabelTips = True Then Call GetLabelInfo(.HitRow, .HitCol, LBLI)
                        If (LBLI.Flags And LBLI_VALID) = LBLI_VALID And Not (LBLI.Flags And LBLI_UNFOLDED) = LBLI_UNFOLDED And Not (LBLI.Flags And LBLI_HIDDEN) = LBLI_HIDDEN Then
                            Call GetCellText(.HitRow, .HitCol, Text)
                            Call GetTextDisplay(.HitRow, .HitCol, Text)
                            If (LBLI.DrawFlags And DT_SINGLELINE) = DT_SINGLELINE Then
                                If InStr(Text, vbCr) Then Text = Replace$(Text, vbCr, vbNullString)
                                If InStr(Text, vbLf) Then Text = Replace$(Text, vbLf, vbNullString)
                            End If
                            ShowTipRow = .HitRow
                            ShowTipCol = .HitCol
                            ShowInfoTip = False
                        ElseIf PropShowInfoTips = True Then
                            Call GetCellToolTipText(.HitRow, .HitCol, Text)
                            ShowTipRow = .HitRow
                            ShowTipCol = .HitCol
                            ShowInfoTip = True
                        End If
                    End If
                    End With
                    If Not Text = vbNullString Then
                        Call UpdateToolTipFont(ShowTipRow, ShowTipCol, ShowInfoTip)
                        With NMTTDI
                        If Len(Text) <= 80 Then
                            Text = Left$(Text & vbNullChar, 80)
                            CopyMemory .szText(0), ByVal StrPtr(Text), LenB(Text)
                        Else
                            .lpszText = StrPtr(Text)
                        End If
                        .hInst = NULL_PTR
                        End With
                        CopyMemory ByVal lParam, NMTTDI, LenB(NMTTDI)
                    Else
                        ShowTipRow = -1
                        ShowTipCol = -1
                        ShowInfoTip = False
                    End If
                Case TTN_SHOW
                    If PropShowLabelTips = True And ShowTipRow > -1 And ShowTipCol > -1 And ShowInfoTip = False Then
                        If (LBLI.Flags And LBLI_VALID) = LBLI_VALID Then
                            Dim RC As RECT
                            LSet RC = LBLI.RC
                            MapWindowPoints VBFlexGridHandle, HWND_DESKTOP, RC, 2
                            SendMessage VBFlexGridToolTipHandle, TTM_ADJUSTRECT, 1, ByVal VarPtr(RC)
                            SetWindowPos VBFlexGridToolTipHandle, NULL_PTR, RC.Left, RC.Top, (RC.Right - RC.Left), (RC.Bottom - RC.Top), SWP_NOOWNERZORDER Or SWP_NOZORDER Or SWP_NOACTIVATE
                            WindowProcControl = 1
                            Exit Function
                        End If
                    End If
                Case NM_CUSTOMDRAW
                    Dim NMTTCD As NMTTCUSTOMDRAW
                    CopyMemory NMTTCD, ByVal lParam, LenB(NMTTCD)
                    Select Case NMTTCD.NMCD.dwDrawStage
                        Case CDDS_PREPAINT
                            If PropShowLabelTips = True And ShowInfoTip = False Then
                                If (LBLI.Flags And LBLI_VALID) = LBLI_VALID Then
                                    If (NMTTCD.uDrawFlags And DT_CALCRECT) = DT_CALCRECT Then
                                        NMTTCD.uDrawFlags = LBLI.DrawFlags
                                        If Not (NMTTCD.uDrawFlags And DT_CALCRECT) = DT_CALCRECT Then NMTTCD.uDrawFlags = NMTTCD.uDrawFlags Or DT_CALCRECT
                                    Else
                                        NMTTCD.uDrawFlags = LBLI.DrawFlags
                                        If (NMTTCD.uDrawFlags And DT_CALCRECT) = DT_CALCRECT Then NMTTCD.uDrawFlags = NMTTCD.uDrawFlags And Not DT_CALCRECT
                                    End If
                                    CopyMemory ByVal lParam, NMTTCD, LenB(NMTTCD)
                                    Exit Function
                                End If
                            End If
                    End Select
            End Select
        ElseIf NM.hWndFrom = VBFlexGridComboCalendarHandle And VBFlexGridComboCalendarHandle <> NULL_PTR Then
            Select Case NM.Code
                Case MCN_SELECT
                    Dim NMSC As NMSELCHANGE
                    CopyMemory NMSC, ByVal lParam, LenB(NMSC)
                    Call ComboCalendarCommitST(NMSC.STSelStart)
                    Call ComboShowDropDown(False, FlexComboDropDownReasonMouse)
                    If VBFlexGridEditHandle <> NULL_PTR Then
                        If (GetWindowLong(VBFlexGridEditHandle, GWL_STYLE) And ES_READONLY) <> 0 Then DestroyEdit False, FlexEditCloseModeReturn
                    End If
            End Select
        End If
    Case WM_COMMAND
        If lParam <> 0 Then
            If LoWord(CLng(wParam)) = ID_EDITCHILD And lParam = VBFlexGridEditHandle And VBFlexGridEditHandle <> NULL_PTR Then
                Select Case HiWord(CLng(wParam))
                    Case EN_CHANGE
                        If VBFlexGridEditChangeFrozen = False Then
                            If VBFlexGridComboModeActive = FlexComboModeEditable And VBFlexGridComboListHandle <> NULL_PTR Then
                                Dim Index As Long
                                Index = CLng(SendMessage(VBFlexGridComboListHandle, LB_FINDSTRINGEXACT, -1, ByVal StrPtr(Me.EditText)))
                                If Not Index = LB_ERR Then
                                    SendMessage VBFlexGridComboListHandle, LB_SETCURSEL, Index, ByVal 0&
                                    Call ComboListCommitSel
                                End If
                            End If
                            If VBFlexGridComboCalendarHandle <> NULL_PTR Then
                                Dim DateText As String
                                DateText = Me.EditText
                                If IsDate(DateText) Then
                                    Me.ComboCalendarValue = CDate(DateText)
                                Else
                                    Me.ComboCalendarValue = VBA.Date()
                                End If
                            End If
                            VBFlexGridEditTextChanged = True
                            VBFlexGridEditAlreadyValidated = False
                            RaiseEvent EditChange
                        End If
                End Select
            ElseIf LoWord(CLng(wParam)) = ID_COMBOBUTTONCHILD And lParam = VBFlexGridComboButtonHandle And VBFlexGridComboButtonHandle <> NULL_PTR Then
                Select Case HiWord(CLng(wParam))
                    Case STN_CLICKED, STN_DBLCLK
                        If VBFlexGridComboListHandle <> NULL_PTR Or VBFlexGridComboCalendarHandle <> NULL_PTR Then
                            Call ComboShowDropDown(True, FlexComboDropDownReasonMouse)
                        Else
                            Call ComboButtonPerformClick
                        End If
                    Case STN_ENABLE
                        Call ComboButtonSetState(ODS_DISABLED, False)
                    Case STN_DISABLE
                        Call ComboButtonSetState(ODS_DISABLED, True)
                End Select
            ElseIf LoWord(CLng(wParam)) = 0 And lParam = VBFlexGridComboListHandle And VBFlexGridComboListHandle <> NULL_PTR Then
                Select Case HiWord(CLng(wParam))
                    Case LBN_SELCHANGE
                        Call ComboListCommitSel
                End Select
            End If
        End If
    Case WM_NOTIFYFORMAT
        Const NF_QUERY As Long = 3
        If lParam = NF_QUERY Then
            Const NFR_ANSI As Long = 1
            Const NFR_UNICODE As Long = 2
            WindowProcControl = NFR_UNICODE
            Exit Function
        End If
    Case WM_CTLCOLOREDIT, WM_CTLCOLORSTATIC
        If lParam = VBFlexGridEditHandle And VBFlexGridEditHandle <> NULL_PTR Then
            If VBFlexGridEditBackColorBrush <> NULL_PTR Then
                SetBkColor wParam, WinColor(VBFlexGridEditBackColor)
                SetTextColor wParam, WinColor(VBFlexGridEditForeColor)
                WindowProcControl = VBFlexGridEditBackColorBrush
            Else
                SetBkColor wParam, GetSysColor(COLOR_WINDOW)
                SetTextColor wParam, GetSysColor(COLOR_WINDOWTEXT)
                WindowProcControl = GetSysColorBrush(COLOR_WINDOW)
            End If
            Exit Function
        End If
    Case WM_THEMECHANGED
        VBFlexGridEnabledVisualStyles = EnabledVisualStyles()
    Case WM_DRAWITEM
        Dim DIS As DRAWITEMSTRUCT, Brush As LongPtr
        CopyMemory DIS, ByVal lParam, LenB(DIS)
        If DIS.CtlType = ODT_STATIC And DIS.CtlID = ID_COMBOBUTTONCHILD And DIS.hWndItem = VBFlexGridComboButtonHandle And VBFlexGridComboButtonHandle <> NULL_PTR Then
            DIS.ItemState = GetWindowLong(DIS.hWndItem, GWL_USERDATA)
            If VBFlexGridEditBackColorBrush <> NULL_PTR Then
                Brush = VBFlexGridEditBackColorBrush
            Else
                Brush = GetSysColorBrush(COLOR_WINDOW)
            End If
            FillRect DIS.hDC, DIS.RCItem, Brush
            Call ComboButtonDraw(VBFlexGridEditRow, VBFlexGridEditCol, DIS)
            WindowProcControl = 1
            Exit Function
        ElseIf DIS.CtlType = ODT_LISTBOX And DIS.hWndItem = VBFlexGridComboListHandle And VBFlexGridComboListHandle <> NULL_PTR And DIS.ItemID > -1 Then
            If (DIS.ItemState And ODS_SELECTED) = ODS_SELECTED Then
                Brush = GetSysColorBrush(COLOR_HIGHLIGHT)
            Else
                Brush = GetSysColorBrush(COLOR_WINDOW)
            End If
            FillRect DIS.hDC, DIS.RCItem, Brush
            Dim dwExStyle As Long, TextAlign As Long, OldTextAlign As Long, OldBkMode As Long, OldTextColor As Long
            dwExStyle = GetWindowLong(VBFlexGridComboListHandle, GWL_EXSTYLE)
            If (dwExStyle And WS_EX_RTLREADING) = WS_EX_RTLREADING Then TextAlign = TA_RTLREADING
            If (dwExStyle And WS_EX_RIGHT) = WS_EX_RIGHT Then TextAlign = TextAlign Or TA_RIGHT
            If TextAlign <> 0 Then OldTextAlign = SetTextAlign(DIS.hDC, TextAlign)
            OldBkMode = SetBkMode(DIS.hDC, 1)
            OldTextColor = GetTextColor(DIS.hDC)
            Dim hPen As LongPtr, hPenOld As LongPtr, i As Long, ColumnRect As RECT, LinePoints(0 To 1) As POINTAPI
            If Not (DIS.ItemState And ODS_DISABLED) = ODS_DISABLED And (DIS.ItemState And ODS_SELECTED) = ODS_SELECTED Then
                hPen = CreatePen(PS_SOLID, 0, GetSysColor(COLOR_HIGHLIGHTTEXT))
            Else
                hPen = CreatePen(PS_SOLID, 0, &HC0C0C0)
            End If
            If hPen <> NULL_PTR Then hPenOld = SelectObject(DIS.hDC, hPen)
            LSet ColumnRect = DIS.RCItem
            With VBFlexGridComboMultiColumn
            For i = 0 To (.Items(DIS.ItemID).Count - 1)
                If i = .BoundColumn Then
                    If (DIS.ItemState And ODS_DISABLED) = ODS_DISABLED Then
                        SetTextColor DIS.hDC, GetSysColor(COLOR_GRAYTEXT)
                    ElseIf (DIS.ItemState And ODS_SELECTED) = ODS_SELECTED Then
                        SetTextColor DIS.hDC, GetSysColor(COLOR_HIGHLIGHTTEXT)
                    Else
                        SetTextColor DIS.hDC, GetSysColor(COLOR_WINDOWTEXT)
                    End If
                Else
                    If Not (DIS.ItemState And ODS_DISABLED) = ODS_DISABLED And (DIS.ItemState And ODS_SELECTED) = ODS_SELECTED Then
                        SetTextColor DIS.hDC, GetSysColor(COLOR_HIGHLIGHTTEXT)
                    Else
                        SetTextColor DIS.hDC, &H808080
                    End If
                End If
                If (TextAlign And TA_RIGHT) = 0 Then
                    TextOut DIS.hDC, ColumnRect.Left + 2, ColumnRect.Top, StrPtr(.Items(DIS.ItemID).Column(i)), Len(.Items(DIS.ItemID).Column(i))
                    If i < (.Items(DIS.ItemID).Count - 1) Then
                        ColumnRect.Left = ColumnRect.Left + .MaxWidths(i) + 5
                        LinePoints(0).X = ColumnRect.Left - 1
                        LinePoints(0).Y = ColumnRect.Top
                        LinePoints(1).X = ColumnRect.Left - 1
                        LinePoints(1).Y = ColumnRect.Bottom
                        Polyline DIS.hDC, LinePoints(0), 2
                    End If
                Else
                    TextOut DIS.hDC, ColumnRect.Right - 2, ColumnRect.Top, StrPtr(.Items(DIS.ItemID).Column(i)), Len(.Items(DIS.ItemID).Column(i))
                    If i < (.Items(DIS.ItemID).Count - 1) Then
                        ColumnRect.Right = ColumnRect.Right - .MaxWidths(i) - 5
                        LinePoints(0).X = ColumnRect.Right + 1
                        LinePoints(0).Y = ColumnRect.Top
                        LinePoints(1).X = ColumnRect.Right + 1
                        LinePoints(1).Y = ColumnRect.Bottom
                        Polyline DIS.hDC, LinePoints(0), 2
                    End If
                End If
            Next i
            End With
            If hPenOld <> NULL_PTR Then
                SelectObject hDC, hPenOld
                hPenOld = NULL_PTR
            End If
            If hPen <> NULL_PTR Then
                DeleteObject hPen
                hPen = NULL_PTR
            End If
            SetBkMode DIS.hDC, OldBkMode
            SetTextColor DIS.hDC, OldTextColor
            If TextAlign <> 0 Then SetTextAlign DIS.hDC, OldTextAlign
            If (DIS.ItemState And ODS_FOCUS) = ODS_FOCUS Then
                If Not (DIS.ItemState And ODS_NOFOCUSRECT) = ODS_NOFOCUSRECT Then DrawFocusRect DIS.hDC, DIS.RCItem
            End If
            WindowProcControl = 1
            Exit Function
        End If
    Case WM_TIMER
        Select Case wParam
            Case IDT_MULTISELCHANGE
                KillTimer hWnd, IDT_MULTISELCHANGE
                VBFlexGridMultiSelChangeTimer = False
                If PropAllowMultiSelection = True Then RaiseEvent MultiSelChange
                WindowProcControl = 0
                Exit Function
        End Select
    Case VP_FORMATRANGE
        WindowProcControl = ProcessFormatRange(wParam, lParam)
        Exit Function
    
    #If ImplementPreTranslateMsg = True Then
    
    Case UM_PRETRANSLATEMSG
        WindowProcControl = PreTranslateMsg(lParam)
        Exit Function
    
    #End If
    
    Case UM_ENDINCREMENTALSEARCH
        If VBFlexGridIncrementalSearch.CancellationPending = True Then
            VBFlexGridIncrementalSearch.CancellationPending = False
            RaiseEvent EndIncrementalSearch(CLng(wParam), CLng(lParam))
        End If
End Select
WindowProcControl = DefWindowProc(hWnd, wMsg, wParam, lParam)
Select Case wMsg
    Case WM_SETFOCUS, WM_KILLFOCUS
        VBFlexGridFocused = CBool(wMsg = WM_SETFOCUS)
        If PropAllowIncrementalSearch = True And wMsg = WM_KILLFOCUS Then
            If Not VBFlexGridIncrementalSearch.SearchString = vbNullString And VBFlexGridIncrementalSearch.NoLostFocus = False Then Call CancelIncrementalSearch(True)
        End If
        Call RedrawGrid
    Case WM_LBUTTONDBLCLK, WM_MBUTTONDBLCLK, WM_RBUTTONDBLCLK
        Dim HTI5 As THITTESTINFO
        With HTI5
        Pos = GetMessagePos()
        .PT.X = Get_X_lParam(Pos)
        .PT.Y = Get_Y_lParam(Pos)
        ScreenToClient hWnd, .PT
        Call GetHitTestInfo(HTI5)
        If wMsg = WM_LBUTTONDBLCLK Then
            Select Case .HitResult
                Case FlexHitResultDividerRowTop, FlexHitResultDividerRowBottom, FlexHitResultDividerColumnLeft, FlexHitResultDividerColumnRight
                    RaiseEvent DividerDblClick(.HitRowDivider, .HitColDivider)
                Case FlexHitResultCell
                    RaiseEvent CellDblClick(.HitRow, .HitCol, vbLeftButton)
                Case FlexHitResultCheckBox
                    Call SetCellCheck(.HitRow, .HitCol, FlexCellCheckReasonMouse)
            End Select
        Else
            If .HitResult = FlexHitResultCell Then
                If wMsg = WM_MBUTTONDBLCLK Then
                    RaiseEvent CellDblClick(.HitRow, .HitCol, vbMiddleButton)
                ElseIf wMsg = WM_RBUTTONDBLCLK Then
                    RaiseEvent CellDblClick(.HitRow, .HitCol, vbRightButton)
                End If
            End If
        End If
        RaiseEvent DblClick
        If PropAllowUserEditing = True Then
            If wMsg = WM_LBUTTONDBLCLK Then
                If .HitResult = FlexHitResultCell Then
                    If .HitRow > (PropFixedRows - 1) And .HitCol > (PropFixedCols - 1) Then
                        Select Case PropSelectionMode
                            Case FlexSelectionModeByRow
                                If CreateEdit(FlexEditReasonDblClick, .HitRow) = False And PropAlwaysAllowComboCues = True Then Call ComboCuePerformClick(FlexEditReasonComboCueDblClick, .HitRow)
                            Case FlexSelectionModeByColumn
                                If CreateEdit(FlexEditReasonDblClick, , .HitCol) = False And PropAlwaysAllowComboCues = True Then Call ComboCuePerformClick(FlexEditReasonComboCueDblClick, , .HitCol)
                            Case Else
                                If CreateEdit(FlexEditReasonDblClick, .HitRow, .HitCol) = False And PropAlwaysAllowComboCues = True Then Call ComboCuePerformClick(FlexEditReasonComboCueDblClick, .HitRow, .HitCol)
                        End Select
                    End If
                ElseIf .HitResult = FlexHitResultComboCue Then
                    Select Case PropSelectionMode
                        Case FlexSelectionModeByRow
                            If CreateEdit(FlexEditReasonComboCueDblClick, .HitRow) = False And PropAlwaysAllowComboCues = True Then Call ComboCuePerformClick(FlexEditReasonComboCueDblClick, .HitRow)
                        Case FlexSelectionModeByColumn
                            If CreateEdit(FlexEditReasonComboCueDblClick, , .HitCol) = False And PropAlwaysAllowComboCues = True Then Call ComboCuePerformClick(FlexEditReasonComboCueDblClick, , .HitCol)
                        Case Else
                            If CreateEdit(FlexEditReasonComboCueDblClick, .HitRow, .HitCol) = False And PropAlwaysAllowComboCues = True Then Call ComboCuePerformClick(FlexEditReasonComboCueDblClick, .HitRow, .HitCol)
                    End Select
                End If
            End If
        ElseIf PropAlwaysAllowComboCues = True Then
            If wMsg = WM_LBUTTONDBLCLK Then
                If .HitResult = FlexHitResultComboCue Then
                    Select Case PropSelectionMode
                        Case FlexSelectionModeByRow
                            Call ComboCuePerformClick(FlexEditReasonComboCueDblClick, .HitRow)
                        Case FlexSelectionModeByColumn
                            Call ComboCuePerformClick(FlexEditReasonComboCueDblClick, , .HitCol)
                        Case Else
                            Call ComboCuePerformClick(FlexEditReasonComboCueDblClick, .HitRow, .HitCol)
                    End Select
                End If
            End If
        End If
        End With
    Case WM_LBUTTONDOWN, WM_MBUTTONDOWN, WM_RBUTTONDOWN, WM_MOUSEMOVE, WM_LBUTTONUP, WM_MBUTTONUP, WM_RBUTTONUP
        Dim X As Single
        Dim Y As Single
        X = UserControl.ScaleX(Get_X_lParam(lParam), vbPixels, vbTwips)
        Y = UserControl.ScaleY(Get_Y_lParam(lParam), vbPixels, vbTwips)
        Select Case wMsg
            Case WM_LBUTTONDOWN
                RaiseEvent MouseDown(vbLeftButton, GetShiftStateFromParam(wParam), X, Y)
                VBFlexGridIsClick = True
            Case WM_MBUTTONDOWN
                RaiseEvent MouseDown(vbMiddleButton, GetShiftStateFromParam(wParam), X, Y)
                VBFlexGridIsClick = True
            Case WM_RBUTTONDOWN
                RaiseEvent MouseDown(vbRightButton, GetShiftStateFromParam(wParam), X, Y)
                VBFlexGridIsClick = True
            Case WM_MOUSEMOVE
                If VBFlexGridMouseOver = False And PropMouseTrack = True Then
                    VBFlexGridMouseOver = True
                    RaiseEvent MouseEnter
                    Dim TME As TRACKMOUSEEVENTSTRUCT
                    With TME
                    .cbSize = LenB(TME)
                    .hWndTrack = hWnd
                    .dwFlags = TME_LEAVE
                    End With
                    TrackMouseEvent TME
                End If
                RaiseEvent MouseMove(GetMouseStateFromParam(wParam), GetShiftStateFromParam(wParam), X, Y)
            Case WM_LBUTTONUP, WM_MBUTTONUP, WM_RBUTTONUP
                Dim HTI6 As THITTESTINFO
                With HTI6
                .PT.X = Get_X_lParam(lParam)
                .PT.Y = Get_Y_lParam(lParam)
                Call GetHitTestInfo(HTI6)
                If .HitResult = FlexHitResultCell And VBFlexGridIsClick = True Then
                    If VBFlexGridCellClickRow = .HitRow And VBFlexGridCellClickCol = .HitCol Then
                        Select Case wMsg
                            Case WM_LBUTTONUP
                                RaiseEvent CellClick(.HitRow, .HitCol, vbLeftButton)
                            Case WM_MBUTTONUP
                                RaiseEvent CellClick(.HitRow, .HitCol, vbMiddleButton)
                            Case WM_RBUTTONUP
                                RaiseEvent CellClick(.HitRow, .HitCol, vbRightButton)
                        End Select
                    End If
                End If
                End With
                Select Case wMsg
                    Case WM_LBUTTONUP
                        RaiseEvent MouseUp(vbLeftButton, GetShiftStateFromParam(wParam), X, Y)
                    Case WM_MBUTTONUP
                        RaiseEvent MouseUp(vbMiddleButton, GetShiftStateFromParam(wParam), X, Y)
                    Case WM_RBUTTONUP
                        RaiseEvent MouseUp(vbRightButton, GetShiftStateFromParam(wParam), X, Y)
                End Select
                If VBFlexGridIsClick = True Then
                    VBFlexGridIsClick = False
                    If (X >= 0 And X <= UserControl.Width) And (Y >= 0 And Y <= UserControl.Height) Then RaiseEvent Click
                End If
        End Select
    Case WM_MOUSELEAVE
        If VBFlexGridMouseOver = True Then
            VBFlexGridMouseOver = False
            RaiseEvent MouseLeave
        End If
End Select
End Function

Private Function WindowProcEdit(ByVal hWnd As LongPtr, ByVal wMsg As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr) As LongPtr
Select Case wMsg
    Case WM_SETFOCUS
        
        #If ImplementPreTranslateMsg = True Then
        
        If UsePreTranslateMsg = False Then Call ActivateIPAO(Me) Else Call FlexPreTranslateMsgActivate(hWnd)
        
        #Else
        
        Call ActivateIPAO(Me)
        
        #End If
        
    Case WM_KILLFOCUS
        
        #If ImplementPreTranslateMsg = True Then
        
        If UsePreTranslateMsg = False Then Call DeActivateIPAO Else Call FlexPreTranslateMsgDeActivate
        
        #Else
        
        Call DeActivateIPAO
        
        #End If
        
    Case WM_MOUSEACTIVATE
        ' It is necessary to break the chain and return MA_ACTIVATE for this window.
        ' This enables the parent window - when it receives WM_MOUSEACTIVATE - to destroy this child window.
        WindowProcEdit = MA_ACTIVATE
        Exit Function
    Case WM_MOUSEWHEEL, WM_MOUSEHWHEEL
        If VBFlexGridComboListHandle <> NULL_PTR Then
            If ComboButtonGetState(ODS_SELECTED) = True Then
                SendMessage VBFlexGridComboListHandle, wMsg, wParam, ByVal lParam
                Exit Function
            End If
        End If
    Case WM_KEYDOWN, WM_KEYUP, WM_SYSKEYDOWN, WM_SYSKEYUP
        Dim KeyCode As Integer
        KeyCode = CLng(wParam) And &HFF&
        If wMsg = WM_KEYDOWN Or wMsg = WM_KEYUP Then
            If wMsg = WM_KEYDOWN Then
                If VBFlexGridEditRectChanged = True Then
                    VBFlexGridEditRectChanged = False
                    VBFlexGridEditRectChangedFrozen = True
                    Me.CellEnsureVisible , VBFlexGridEditMergedRange.TopRow, VBFlexGridEditMergedRange.LeftCol
                    VBFlexGridEditRectChangedFrozen = False
                End If
                RaiseEvent EditKeyDown(KeyCode, GetShiftStateFromMsg())
                If VBFlexGridEditHandle <> NULL_PTR Then
                    Select Case KeyCode
                        Case vbKeyEscape
                            If VBFlexGridComboButtonHandle <> NULL_PTR And VBFlexGridComboListHandle <> NULL_PTR Then Call ComboShowDropDown(False, FlexComboDropDownReasonKeyboard)
                            If DestroyEdit(True, FlexEditCloseModeEscape) = True Then Exit Function
                        Case vbKeyF4
                            If VBFlexGridComboButtonHandle <> NULL_PTR Then
                                If VBFlexGridComboListHandle <> NULL_PTR Or VBFlexGridComboCalendarHandle <> NULL_PTR Then
                                    Call ComboShowDropDown(Not ComboButtonGetState(ODS_SELECTED), FlexComboDropDownReasonKeyboard)
                                Else
                                    Call ComboButtonPerformClick
                                End If
                                Exit Function
                            End If
                        Case vbKeyReturn
                            If VBFlexGridComboButtonHandle <> NULL_PTR And VBFlexGridComboListHandle <> NULL_PTR Then
                                If ComboButtonGetState(ODS_SELECTED) = True Then
                                    Call ComboListCommitSel
                                    Call ComboShowDropDown(False, FlexComboDropDownReasonKeyboard)
                                    If DestroyEdit(False, FlexEditCloseModeReturn) = True Then
                                        Select Case PropDirectionAfterReturn
                                            Case FlexDirectionAfterReturnNone, FlexDirectionAfterReturnEdit
                                            Case Else
                                                Select Case GetShiftStateFromMsg()
                                                    Case 0, vbShiftMask
                                                        PostMessage VBFlexGridHandle, wMsg, wParam, ByVal 0&
                                                End Select
                                        End Select
                                    End If
                                    Exit Function
                                End If
                            End If
                            Select Case GetShiftStateFromMsg()
                                Case 0
                                    If DestroyEdit(False, FlexEditCloseModeReturn) = True Then
                                        Select Case PropDirectionAfterReturn
                                            Case FlexDirectionAfterReturnNone, FlexDirectionAfterReturnEdit
                                            Case Else
                                                PostMessage VBFlexGridHandle, wMsg, wParam, ByVal 0&
                                        End Select
                                        Exit Function
                                    End If
                                Case vbShiftMask
                                    PostMessage hWnd, WM_CHAR, 13, ByVal 0& ' Carriage return
                                Case vbCtrlMask
                                    PostMessage hWnd, WM_CHAR, 10, ByVal 0& ' Linefeed
                            End Select
                        Case vbKeyTab
                            If PropTabBehavior <> FlexTabControls Then
                                Select Case GetShiftStateFromMsg()
                                    Case 0
                                        If DestroyEdit(False, FlexEditCloseModeTab) = True Then PostMessage VBFlexGridHandle, wMsg, wParam, ByVal 0&: Exit Function
                                    Case vbShiftMask
                                        If DestroyEdit(False, FlexEditCloseModeShiftTab) = True Then PostMessage VBFlexGridHandle, wMsg, wParam, ByVal 0&: Exit Function
                                End Select
                            End If
                        Case vbKeyUp, vbKeyDown, vbKeyLeft, vbKeyRight, vbKeyPageDown, vbKeyPageUp, vbKeyHome, vbKeyEnd
                            If VBFlexGridComboButtonHandle <> NULL_PTR And VBFlexGridComboListHandle <> NULL_PTR Then
                                If IsWindowVisible(VBFlexGridComboListHandle) <> 0 Then
                                    Select Case KeyCode
                                        Case vbKeyUp, vbKeyDown, vbKeyPageDown, vbKeyPageUp, vbKeyHome, vbKeyEnd
                                            SendMessage VBFlexGridComboListHandle, wMsg, wParam, ByVal lParam
                                            Exit Function
                                    End Select
                                End If
                            End If
                            Dim SelStart As Long, SelEnd As Long
                            SendMessage hWnd, EM_GETSEL, VarPtr(SelStart), ByVal VarPtr(SelEnd)
                            If SelStart = SelEnd Then
                                Dim CloseMode As FlexEditCloseModeConstants
                                CloseMode = -1
                                Select Case KeyCode
                                    Case vbKeyLeft, vbKeyRight, vbKeyPageDown, vbKeyPageUp
                                        Select Case KeyCode
                                            Case vbKeyLeft
                                                If SelEnd = 0 Then CloseMode = FlexEditCloseModeNavigationKey
                                            Case vbKeyRight
                                                If SelEnd = SendMessage(hWnd, WM_GETTEXTLENGTH, 0, ByVal 0&) Then CloseMode = FlexEditCloseModeNavigationKey
                                            Case vbKeyPageDown, vbKeyPageUp
                                                If SelStart = SelEnd Then CloseMode = FlexEditCloseModeNavigationKey
                                        End Select
                                    Case vbKeyUp, vbKeyDown, vbKeyHome, vbKeyEnd
                                        Dim FirstCharPos As Long, LineFromChar As Long
                                        FirstCharPos = CLng(SendMessage(hWnd, EM_LINEINDEX, -1, ByVal 0&))
                                        LineFromChar = CLng(SendMessage(hWnd, EM_LINEFROMCHAR, FirstCharPos, ByVal 0&))
                                        Select Case KeyCode
                                            Case vbKeyUp
                                                If LineFromChar = 0 Then CloseMode = FlexEditCloseModeNavigationKey
                                            Case vbKeyDown
                                                If LineFromChar = (SendMessage(hWnd, EM_GETLINECOUNT, 0, ByVal 0&) - 1) Then CloseMode = FlexEditCloseModeNavigationKey
                                            Case vbKeyHome
                                                If SelEnd = FirstCharPos Then CloseMode = FlexEditCloseModeNavigationKey
                                            Case vbKeyEnd
                                                If SelEnd = (FirstCharPos + SendMessage(hWnd, EM_LINELENGTH, FirstCharPos, ByVal 0&)) Then CloseMode = FlexEditCloseModeNavigationKey
                                        End Select
                                End Select
                                If CloseMode > -1 Then
                                    If DestroyEdit(False, CloseMode) = True Then PostMessage VBFlexGridHandle, wMsg, wParam, ByVal 0&: Exit Function
                                End If
                            End If
                    End Select
                Else
                    Exit Function
                End If
            ElseIf wMsg = WM_KEYUP Then
                RaiseEvent EditKeyUp(KeyCode, GetShiftStateFromMsg())
            End If
            Dim Msg As TMSG
            Const PM_NOREMOVE As Long = &H0
            If PeekMessage(Msg, hWnd, WM_CHAR, WM_CHAR, PM_NOREMOVE) <> 0 Then VBFlexGridCharCodeCache = CLng(Msg.wParam)
        ElseIf wMsg = WM_SYSKEYDOWN Then
            If VBFlexGridEditRectChanged = True Then
                VBFlexGridEditRectChanged = False
                VBFlexGridEditRectChangedFrozen = True
                Me.CellEnsureVisible , VBFlexGridEditMergedRange.TopRow, VBFlexGridEditMergedRange.LeftCol
                VBFlexGridEditRectChangedFrozen = False
            End If
            RaiseEvent EditKeyDown(KeyCode, GetShiftStateFromMsg())
            If VBFlexGridEditHandle <> NULL_PTR Then
                If KeyCode = vbKeyReturn Then
                    PostMessage hWnd, WM_CHAR, vbKeyReturn, ByVal 0&
                ElseIf VBFlexGridComboButtonHandle <> NULL_PTR And (VBFlexGridComboListHandle <> NULL_PTR Or VBFlexGridComboCalendarHandle <> NULL_PTR) Then
                    If KeyCode = vbKeyUp Or KeyCode = vbKeyDown Then Call ComboShowDropDown(Not ComboButtonGetState(ODS_SELECTED), FlexComboDropDownReasonKeyboard)
                End If
            Else
                Exit Function
            End If
        ElseIf wMsg = WM_SYSKEYUP Then
            RaiseEvent EditKeyUp(KeyCode, GetShiftStateFromMsg())
        End If
        wParam = KeyCode
    Case WM_CHAR
        Dim KeyChar As Integer
        If VBFlexGridCharCodeCache <> 0 Then
            KeyChar = CUIntToInt(VBFlexGridCharCodeCache And &HFFFF&)
            VBFlexGridCharCodeCache = 0
        Else
            KeyChar = CUIntToInt(CLng(wParam) And &HFFFF&)
        End If
        RaiseEvent EditKeyPress(KeyChar)
        If (CLng(wParam) And &HFFFF&) <> 0 And KeyChar = 0 Then
            Exit Function
        Else
            wParam = CIntToUInt(KeyChar)
        End If
        If VBFlexGridComboModeActive = FlexComboModeDropDown And VBFlexGridComboListHandle <> NULL_PTR Then
            SendMessage VBFlexGridComboListHandle, wMsg, wParam, ByVal lParam
            Exit Function
        End If
    Case WM_UNICHAR
        If wParam = UNICODE_NOCHAR Then
            WindowProcEdit = 1
        Else
            Dim UTF16 As String
            UTF16 = UTF32CodePoint_To_UTF16(CLng(wParam))
            If Len(UTF16) = 1 Then
                SendMessage hWnd, WM_CHAR, CIntToUInt(AscW(UTF16)), ByVal lParam
            ElseIf Len(UTF16) = 2 Then
                SendMessage hWnd, WM_CHAR, CIntToUInt(AscW(Left$(UTF16, 1))), ByVal lParam
                SendMessage hWnd, WM_CHAR, CIntToUInt(AscW(Right$(UTF16, 1))), ByVal lParam
            End If
            WindowProcEdit = 0
        End If
        Exit Function
    Case WM_INPUTLANGCHANGE
        Call SetIMEMode(hWnd, VBFlexGridIMCHandle, PropIMEMode)
    Case WM_IME_SETCONTEXT
        If wParam <> 0 Then Call SetIMEMode(hWnd, VBFlexGridIMCHandle, PropIMEMode)
    Case WM_IME_CHAR
        SendMessage hWnd, WM_CHAR, wParam, ByVal lParam
        Exit Function
    Case WM_CONTEXTMENU
        If wParam = hWnd Then
            Dim P As POINTAPI, Handled As Boolean
            P.X = Get_X_lParam(lParam)
            P.Y = Get_Y_lParam(lParam)
            If P.X = -1 And P.Y = -1 Then
                ' If the user types SHIFT + F10 then the X and Y coordinates are -1.
                RaiseEvent EditContextMenu(Handled, -1, -1)
            Else
                ScreenToClient VBFlexGridHandle, P
                RaiseEvent EditContextMenu(Handled, UserControl.ScaleX(P.X, vbPixels, vbContainerPosition), UserControl.ScaleY(P.Y, vbPixels, vbContainerPosition))
            End If
            If Handled = True Then Exit Function
        End If
    Case WM_LBUTTONDOWN
        If GetFocus() <> hWnd Then UCNoSetFocusFwd = True: SetFocusAPI UserControl.hWnd: UCNoSetFocusFwd = False
    Case WM_NCCALCSIZE, WM_NCHITTEST, WM_NCPAINT
        Dim RC As RECT
        Select Case wMsg
            Case WM_NCCALCSIZE
                Dim dwStyle As Long, dwExStyle As Long
                dwStyle = GetWindowLong(hWnd, GWL_STYLE)
                dwExStyle = GetWindowLong(hWnd, GWL_EXSTYLE)
                If (dwStyle And WS_BORDER) = WS_BORDER Then dwStyle = dwStyle And Not WS_BORDER
                If (dwStyle And WS_DLGFRAME) = WS_DLGFRAME Then dwStyle = dwStyle And Not WS_DLGFRAME
                If (dwExStyle And WS_EX_STATICEDGE) = WS_EX_STATICEDGE Then dwExStyle = dwExStyle And Not WS_EX_STATICEDGE
                If (dwExStyle And WS_EX_CLIENTEDGE) = WS_EX_CLIENTEDGE Then dwExStyle = dwExStyle And Not WS_EX_CLIENTEDGE
                If (dwExStyle And WS_EX_WINDOWEDGE) = WS_EX_WINDOWEDGE Then dwExStyle = dwExStyle And Not WS_EX_WINDOWEDGE
                SetWindowLong hWnd, GWL_STYLE, dwStyle
                SetWindowLong hWnd, GWL_EXSTYLE, dwExStyle
                WindowProcEdit = FlexDefaultProc(hWnd, wMsg, wParam, lParam)
                ' The NCCALCSIZE_PARAMS struct is not necessary because only the first rectangle is adjusted.
                ' If wParam is 1 or not, the treatment is the same.
                CopyMemory RC, ByVal lParam, LenB(RC)
                RC.Top = RC.Top + (VBFlexGridPixelMetrics.TextPadding.CY - VBFlexGridEditGridLineOffsets.LeftTop.CY)
                RC.Bottom = RC.Bottom - (VBFlexGridPixelMetrics.TextPadding.CY - VBFlexGridEditGridLineOffsets.RightBottom.CY)
                CopyMemory ByVal lParam, RC, LenB(RC)
                WindowProcEdit = 0
                Exit Function
            Case WM_NCHITTEST
                GetWindowRect hWnd, RC
                DefWindowProc hWnd, WM_NCCALCSIZE, 0, ByVal VarPtr(RC)
                If PtInRect(RC, Get_X_lParam(lParam), Get_Y_lParam(lParam)) <> 0 Then
                    WindowProcEdit = HTCLIENT
                Else
                    WindowProcEdit = FlexDefaultProc(hWnd, wMsg, wParam, lParam)
                End If
                Exit Function
            Case WM_NCPAINT
                Dim hDC As LongPtr
                If wParam = 1 Then ' Alias for entire window
                    hDC = GetWindowDC(hWnd)
                Else
                    hDC = GetDCEx(hWnd, wParam, DCX_WINDOW Or DCX_INTERSECTRGN Or DCX_USESTYLE)
                End If
                If hDC <> NULL_PTR Then
                    Dim Brush As LongPtr
                    If VBFlexGridEditBackColorBrush <> NULL_PTR Then
                        Brush = VBFlexGridEditBackColorBrush
                    Else
                        Brush = GetSysColorBrush(COLOR_WINDOW)
                    End If
                    Dim WndRect As RECT
                    GetWindowRect hWnd, WndRect
                    RC.Left = 0
                    RC.Right = (WndRect.Right - WndRect.Left)
                    RC.Top = 0
                    RC.Bottom = RC.Top + (VBFlexGridPixelMetrics.TextPadding.CY - VBFlexGridEditGridLineOffsets.LeftTop.CY)
                    FillRect hDC, RC, Brush
                    RC.Bottom = (WndRect.Bottom - WndRect.Top)
                    RC.Top = RC.Bottom - (VBFlexGridPixelMetrics.TextPadding.CY - VBFlexGridEditGridLineOffsets.RightBottom.CY)
                    FillRect hDC, RC, Brush
                    ReleaseDC hWnd, hDC
                End If
                WindowProcEdit = FlexDefaultProc(hWnd, wMsg, wParam, lParam)
                Exit Function
        End Select
    
    #If ImplementPreTranslateMsg = True Then
    
    Case UM_PRETRANSLATEMSG
        WindowProcEdit = PreTranslateMsg(lParam)
        Exit Function
    
    #End If
    
End Select
WindowProcEdit = FlexDefaultProc(hWnd, wMsg, wParam, lParam)
If wMsg = WM_KILLFOCUS Then
    If VBFlexGridComboButtonHandle <> NULL_PTR And VBFlexGridComboListHandle <> NULL_PTR Then Call ComboShowDropDown(False, -1)
    DestroyEdit False, FlexEditCloseModeLostFocus
End If
End Function

Private Function WindowProcComboButton(ByVal hWnd As LongPtr, ByVal wMsg As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr) As LongPtr
Select Case wMsg
    Case WM_MOUSEACTIVATE
        ' It is necessary to break the chain and return MA_ACTIVATE for this window.
        ' This enables the parent window - when it receives WM_MOUSEACTIVATE - to destroy this child window.
        If ComboButtonGetState(ODS_SELECTED) = False Then
            WindowProcComboButton = MA_ACTIVATE
        Else
            ' This allows the popup window to close without causing a click which would show it again.
            WindowProcComboButton = MA_ACTIVATEANDEAT
        End If
        Exit Function
    Case WM_MOUSEWHEEL, WM_MOUSEHWHEEL
        If VBFlexGridComboListHandle <> NULL_PTR Then
            If ComboButtonGetState(ODS_SELECTED) = True Then
                SendMessage VBFlexGridComboListHandle, wMsg, wParam, ByVal lParam
                Exit Function
            End If
        End If
    Case WM_LBUTTONDOWN
        ' In case the edit window is still active due to failed validation then this ensures that the focus is properly set when clicked from outside.
        If VBFlexGridEditHandle <> NULL_PTR Then
            If GetFocus() <> VBFlexGridEditHandle Then SetFocusAPI UserControl.hWnd
        End If
    Case WM_MOUSEMOVE
        If ComboButtonGetState(ODS_HOTLIGHT) = False Then
            Call ComboButtonSetState(ODS_HOTLIGHT, True)
            Dim TME As TRACKMOUSEEVENTSTRUCT
            With TME
            .cbSize = LenB(TME)
            .hWndTrack = hWnd
            .dwFlags = TME_LEAVE
            End With
            TrackMouseEvent TME
        End If
    Case WM_MOUSELEAVE
        Call ComboButtonSetState(ODS_HOTLIGHT, False)
End Select
WindowProcComboButton = FlexDefaultProc(hWnd, wMsg, wParam, lParam)
End Function

Private Function WindowProcComboList(ByVal hWnd As LongPtr, ByVal wMsg As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr) As LongPtr
Static NonClientMouseOver As Boolean, NonClientCapture As Boolean, LastMouseMoveLParam As LongPtr, CanCommitSel As Boolean
Select Case wMsg
    Case WM_MOUSEACTIVATE
        ' To prevent the popup window from being activated it is necessary to return MA_NOACTIVATE.
        WindowProcComboList = MA_NOACTIVATE
        Exit Function
    Case WM_SHOWWINDOW
        NonClientMouseOver = False
        NonClientCapture = False
        LastMouseMoveLParam = 0
        CanCommitSel = False
    Case WM_MOUSEMOVE
        Select Case SendMessage(hWnd, WM_NCHITTEST, 0, ByVal GetMessagePos())
            Case HTHSCROLL, HTVSCROLL
                ReleaseCapture
        End Select
        If LastMouseMoveLParam <> lParam Or LastMouseMoveLParam = 0 Then
            If CanCommitSel = True Then
                ComboListSelFromPt Get_X_lParam(lParam), Get_Y_lParam(lParam), CBool((GetMouseStateFromParam(wParam) And vbLeftButton) <> 0)
            Else
                If Not ComboListSelFromPt(Get_X_lParam(lParam), Get_Y_lParam(lParam), False) = LB_ERR Then CanCommitSel = True
            End If
            LastMouseMoveLParam = lParam
        End If
    Case WM_NCMOUSEMOVE
        If NonClientMouseOver = False Then
            NonClientMouseOver = True
            Dim TME As TRACKMOUSEEVENTSTRUCT
            With TME
            .cbSize = LenB(TME)
            .hWndTrack = hWnd
            .dwFlags = TME_LEAVE Or TME_NONCLIENT
            End With
            TrackMouseEvent TME
        End If
    Case WM_NCMOUSELEAVE
        NonClientMouseOver = False
        SetCapture hWnd
    Case WM_NCLBUTTONDOWN
        Select Case wParam
            Case HTHSCROLL, HTVSCROLL
                NonClientCapture = True
        End Select
    Case WM_LBUTTONDOWN, WM_LBUTTONDBLCLK
        If Not ComboListSelFromPt(Get_X_lParam(lParam), Get_Y_lParam(lParam), False) = LB_ERR Then
            CanCommitSel = True
        Else
            ReleaseCapture
        End If
        Exit Function ' Prevents the popup window from being focused.
    Case WM_LBUTTONUP
        If CanCommitSel = True Then
            If Not ComboListSelFromPt(Get_X_lParam(lParam), Get_Y_lParam(lParam), False) = LB_ERR Then
                If SendMessage(hWnd, LB_GETCOUNT, 0, ByVal 0&) = 0 Then Exit Function
                Call ComboListCommitSel
                If VBFlexGridComboModeActive = FlexComboModeDropDown Then
                    Call ComboShowDropDown(False, FlexComboDropDownReasonMouse)
                    DestroyEdit False, FlexEditCloseModeReturn
                    Exit Function
                End If
            End If
            ReleaseCapture
        End If
        Exit Function
    Case WM_CAPTURECHANGED
        Select Case SendMessage(hWnd, WM_NCHITTEST, 0, ByVal GetMessagePos())
            Case HTHSCROLL, HTVSCROLL
                If NonClientCapture = True And lParam = 0 Then NonClientCapture = False
            Case Else
                If NonClientCapture = True Then
                    PostMessage hWnd, UM_CAPTURECHANGED, wParam, ByVal lParam
                    NonClientCapture = False
                Else
                    Call ComboShowDropDown(False, FlexComboDropDownReasonMouse)
                End If
        End Select
    Case UM_CAPTURECHANGED
        If lParam = 0 Then SetCapture hWnd
    Case WM_NCCALCSIZE, WM_NCHITTEST, WM_NCPAINT
        If VBFlexGridComboMultiColumn.Header.Count > 0 Then
            Dim RC As RECT
            Select Case wMsg
                Case WM_NCCALCSIZE
                    WindowProcComboList = FlexDefaultProc(hWnd, wMsg, wParam, lParam)
                    ' The NCCALCSIZE_PARAMS struct is not necessary because only the first rectangle is adjusted.
                    ' If wParam is 1 or not, the treatment is the same.
                    CopyMemory RC, ByVal lParam, LenB(RC)
                    RC.Top = RC.Top + CLng(SendMessage(hWnd, LB_GETITEMHEIGHT, 0, ByVal 0&)) + 1
                    CopyMemory ByVal lParam, RC, LenB(RC)
                    WindowProcComboList = 0
                    Exit Function
                Case WM_NCHITTEST
                    GetWindowRect hWnd, RC
                    DefWindowProc hWnd, WM_NCCALCSIZE, 0, ByVal VarPtr(RC)
                    If PtInRect(RC, Get_X_lParam(lParam), Get_Y_lParam(lParam)) <> 0 Then
                        WindowProcComboList = HTCLIENT
                    Else
                        WindowProcComboList = FlexDefaultProc(hWnd, wMsg, wParam, lParam)
                    End If
                    Exit Function
                Case WM_NCPAINT
                    Dim hDC As LongPtr
                    If wParam = 1 Then ' Alias for entire window
                        hDC = GetWindowDC(hWnd)
                    Else
                        hDC = GetDCEx(hWnd, wParam, DCX_WINDOW Or DCX_INTERSECTRGN Or DCX_USESTYLE)
                    End If
                    If hDC <> NULL_PTR Then
                        Dim Brush As LongPtr
                        Brush = GetSysColorBrush(COLOR_BTNFACE)
                        Dim WndRect As RECT
                        GetWindowRect hWnd, WndRect
                        RC.Left = 1
                        RC.Right = (WndRect.Right - WndRect.Left) - 1
                        RC.Top = 1
                        RC.Bottom = 1 + CLng(SendMessage(hWnd, LB_GETITEMHEIGHT, 0, ByVal 0&))
                        FillRect hDC, RC, Brush
                        Dim dwExStyle As Long, TextAlign As Long, OldTextAlign As Long, OldBkMode As Long, OldTextColor As Long
                        dwExStyle = GetWindowLong(hWnd, GWL_EXSTYLE)
                        If (dwExStyle And WS_EX_RTLREADING) = WS_EX_RTLREADING Then TextAlign = TA_RTLREADING
                        If (dwExStyle And WS_EX_RIGHT) = WS_EX_RIGHT Then TextAlign = TextAlign Or TA_RIGHT
                        If TextAlign <> 0 Then OldTextAlign = SetTextAlign(hDC, TextAlign)
                        OldBkMode = SetBkMode(hDC, 1)
                        If IsWindowEnabled(hWnd) <> 0 Then
                            OldTextColor = SetTextColor(hDC, GetSysColor(COLOR_BTNTEXT))
                        Else
                            OldTextColor = SetTextColor(hDC, GetSysColor(COLOR_GRAYTEXT))
                        End If
                        Dim hFontOld As LongPtr, hPen As LongPtr, hPenOld As LongPtr, i As Long, LinePoints(0 To 1) As POINTAPI
                        hFontOld = SelectObject(hDC, SendMessage(hWnd, WM_GETFONT, 0, ByVal 0&))
                        hPen = CreatePen(PS_SOLID, 0, vbBlack)
                        If hPen <> NULL_PTR Then hPenOld = SelectObject(hDC, hPen)
                        LinePoints(0).X = RC.Left
                        LinePoints(0).Y = RC.Bottom
                        LinePoints(1).X = RC.Right
                        LinePoints(1).Y = RC.Bottom
                        Polyline hDC, LinePoints(0), 2
                        With VBFlexGridComboMultiColumn
                        For i = 0 To (.Header.Count - 1)
                            If (TextAlign And TA_RIGHT) = 0 Then
                                TextOut hDC, RC.Left + 2, RC.Top, StrPtr(.Header.Column(i)), Len(.Header.Column(i))
                                If i < (.Header.Count - 1) Then
                                    RC.Left = RC.Left + .MaxWidths(i) + 5
                                    LinePoints(0).X = RC.Left - 1
                                    LinePoints(0).Y = RC.Top
                                    LinePoints(1).X = RC.Left - 1
                                    LinePoints(1).Y = RC.Bottom
                                    Polyline hDC, LinePoints(0), 2
                                End If
                            Else
                                TextOut hDC, RC.Right - 2, RC.Top, StrPtr(.Header.Column(i)), Len(.Header.Column(i))
                                If i < (.Header.Count - 1) Then
                                    RC.Right = RC.Right - .MaxWidths(i) - 5
                                    LinePoints(0).X = RC.Right + 1
                                    LinePoints(0).Y = RC.Top
                                    LinePoints(1).X = RC.Right + 1
                                    LinePoints(1).Y = RC.Bottom
                                    Polyline hDC, LinePoints(0), 2
                                End If
                            End If
                        Next i
                        End With
                        If hPenOld <> NULL_PTR Then
                            SelectObject hDC, hPenOld
                            hPenOld = NULL_PTR
                        End If
                        If hPen <> NULL_PTR Then
                            DeleteObject hPen
                            hPen = NULL_PTR
                        End If
                        If hFontOld <> NULL_PTR Then
                            SelectObject hDC, hFontOld
                            hFontOld = NULL_PTR
                        End If
                        SetBkMode hDC, OldBkMode
                        SetTextColor hDC, OldTextColor
                        If TextAlign <> 0 Then SetTextAlign hDC, OldTextAlign
                        ReleaseDC hWnd, hDC
                    End If
                    WindowProcComboList = FlexDefaultProc(hWnd, wMsg, wParam, lParam)
                    Exit Function
            End Select
        End If
End Select
WindowProcComboList = FlexDefaultProc(hWnd, wMsg, wParam, lParam)
End Function

Private Function WindowProcComboCalendar(ByVal hWnd As LongPtr, ByVal wMsg As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr) As LongPtr
Select Case wMsg
    Case WM_SETFOCUS
        
        #If ImplementPreTranslateMsg = True Then
        
        If UsePreTranslateMsg = False Then Call ActivateIPAO(Me) Else Call FlexPreTranslateMsgActivate(hWnd)
        
        #Else
        
        Call ActivateIPAO(Me)
        
        #End If
        
    Case WM_KILLFOCUS
        
        #If ImplementPreTranslateMsg = True Then
        
        If UsePreTranslateMsg = False Then Call DeActivateIPAO Else Call FlexPreTranslateMsgDeActivate
        
        #Else
        
        Call DeActivateIPAO
        
        #End If
        
    Case WM_KEYDOWN, WM_SYSKEYDOWN
        Dim KeyCode As Integer
        KeyCode = CLng(wParam) And &HFF&
        If wMsg = WM_KEYDOWN Then
            Select Case KeyCode
                Case vbKeyEscape
                    Call ComboShowDropDown(False, FlexComboDropDownReasonKeyboard)
                    If DestroyEdit(True, FlexEditCloseModeEscape) = True Then Exit Function
                Case vbKeyF4
                    Call ComboShowDropDown(Not ComboButtonGetState(ODS_SELECTED), FlexComboDropDownReasonKeyboard)
                Case vbKeyReturn
                    Call ComboCalendarCommitSel
                    Call ComboShowDropDown(False, FlexComboDropDownReasonKeyboard)
                    If DestroyEdit(False, FlexEditCloseModeReturn) = True Then
                        Select Case PropDirectionAfterReturn
                            Case FlexDirectionAfterReturnNone, FlexDirectionAfterReturnEdit
                            Case Else
                                Select Case GetShiftStateFromMsg()
                                    Case 0, vbShiftMask
                                        PostMessage VBFlexGridHandle, wMsg, wParam, ByVal 0&
                                End Select
                        End Select
                    End If
                    Exit Function
                Case vbKeyTab
                    If PropTabBehavior <> FlexTabControls Then
                        Select Case GetShiftStateFromMsg()
                            Case 0
                                If DestroyEdit(False, FlexEditCloseModeTab) = True Then PostMessage VBFlexGridHandle, wMsg, wParam, ByVal 0&: Exit Function
                            Case vbShiftMask
                                If DestroyEdit(False, FlexEditCloseModeShiftTab) = True Then PostMessage VBFlexGridHandle, wMsg, wParam, ByVal 0&: Exit Function
                        End Select
                    End If
            End Select
        ElseIf wMsg = WM_SYSKEYDOWN Then
            If KeyCode = vbKeyUp Or KeyCode = vbKeyDown Then Call ComboShowDropDown(Not ComboButtonGetState(ODS_SELECTED), FlexComboDropDownReasonKeyboard)
        End If
    
    #If ImplementPreTranslateMsg = True Then
    
    Case UM_PRETRANSLATEMSG
        WindowProcComboCalendar = PreTranslateMsg(lParam)
        Exit Function
    
    #End If
    
End Select
WindowProcComboCalendar = FlexDefaultProc(hWnd, wMsg, wParam, lParam)
If wMsg = WM_KILLFOCUS Then Call ComboShowDropDown(False, -1)
End Function

Private Function WindowProcUserControl(ByVal hWnd As LongPtr, ByVal wMsg As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr) As LongPtr
Select Case wMsg
    Case WM_CONTEXTMENU
        If wParam = VBFlexGridHandle Then
            Dim P As POINTAPI
            P.X = Get_X_lParam(lParam)
            P.Y = Get_Y_lParam(lParam)
            If P.X = -1 And P.Y = -1 Then
                ' If the user types SHIFT + F10 then the X and Y coordinates are -1.
                RaiseEvent ContextMenu(-1, -1)
            Else
                ScreenToClient VBFlexGridHandle, P
                RaiseEvent ContextMenu(UserControl.ScaleX(P.X, vbPixels, vbContainerPosition), UserControl.ScaleY(P.Y, vbPixels, vbContainerPosition))
            End If
        End If
End Select
WindowProcUserControl = FlexDefaultProc(hWnd, wMsg, wParam, lParam)
If wMsg = WM_SETFOCUS And UCNoSetFocusFwd = False Then SetFocusAPI VBFlexGridHandle
End Function
